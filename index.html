<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

  <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;">

  <title>Noir搓的小手机</title>
  <style>
    .message p,
    .diary-content {
      user-select: none;
      -webkit-user-select: none;
    }

    .lt-end-session-btn {
      font-size: 1.5rem;
      color: inherit;
      /* 继承父元素的颜色 */
      opacity: 0.6;
      cursor: pointer;
      padding: 0 5px;
      line-height: 1;
      font-weight: bold;
    }

    .lt-end-session-btn:hover {
      opacity: 1;
    }

    /* --- Noir's Refactor: Feed Loader Style --- */
    #feed-loader {
      position: absolute;
      inset: 0;
      background: rgba(244, 248, 255, 0.85);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      color: var(--text-color);
      font-size: 1rem;
      flex-direction: column;
      gap: 10px;
    }

    .loader-spinner {
      width: 24px;
      height: 24px;
      border: 3px solid var(--border-color);
      border-top-color: var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* --- End of Refactor --- */
    /*
        Noir's Mizuiro Theme
        - 哼，看好了，这才是设计。
      */
    /*
          Noir's Mizuiro Theme
          - 哼，看好了，这才是设计。
        */
    :root {
      --phone-width: 375px;
      --phone-height: 812px;
      --user-bg-image: url('');

      /* === Noir's Ultimate Dynamic Theme Engine v2.0 === */
      /* 哼，现在所有的颜色都听从这三个总开关的指挥。*/
      --primary-hue: 35;
      --primary-saturation: 25%;
      --primary-lightness: 80%;

      /* 核心颜色 */
      --primary-color: hsl(var(--primary-hue), var(--primary-saturation), var(--primary-lightness));
      /* 强调色/用户气泡色，现在也是动态的 */
      --accent-color: hsl(var(--primary-hue), calc(var(--primary-saturation) * 1.2), calc(var(--primary-lightness) - 20%));

      /* 哼，看好了，这些就是被我重新接上线的“电灯” */

      /* 文字颜色：根据主题亮度自动变深或变浅 */
      --text-color: hsl(var(--primary-hue), 15%, calc(100% - var(--primary-lightness) / 1.1));
      --text-color-light: hsl(var(--primary-hue), 10%, calc(100% - var(--primary-lightness) / 1.3));

      /* 表面背景：半透明，亮度比主色高一点 */
      --surface-bg: hsla(var(--primary-hue), calc(var(--primary-saturation) / 2), calc(var(--primary-lightness) + 15%), 0.4);

      /* 卡片/AI气泡背景：比表面背景更亮一点 */
      --card-bg: hsla(var(--primary-hue), calc(var(--primary-saturation) / 1.5), calc(var(--primary-lightness) + 18%), 0.75);

      /* 边框颜色 */
      --border-color: hsla(var(--primary-hue), calc(var(--primary-saturation) / 2), calc(var(--primary-lightness)), 0.3);

      /* 阴影颜色 */
      --soft-shadow: 0 4px 12px hsla(var(--primary-hue), 40%, calc(var(--primary-lightness) - 10%), 0.15);

      /* 动态页的设置保持不变 */
      --feed-bg-image: none;
      --feed-overlay-opacity: 0.12;
      --feed-overlay-rotate: 22deg;
      --feed-overlay-speed: 48s;

      /* 气泡样式也完全动态化 */
      --bubble-radius: 18px;
      --bubble-outline: hsla(var(--primary-hue), var(--primary-saturation), calc(var(--primary-lightness) + 10%), 0.5);
      --bubble-user-bg: hsla(var(--primary-hue), calc(var(--primary-saturation) * 1.2), calc(var(--primary-lightness) - 20%), 0.75);
      /* <-- 哼，改成0.5，现在够“虚无”了吧 */
      --bubble-ai-bg: var(--card-bg);

      /* ▼▼▼ 把下面这两行加进去 ▼▼▼ */
      --dropdown-alpha: 0.9;
      /* 下拉菜单的透明度，0到1 */
      --feed-card-alpha: 0.7;
      /* 动态卡片的透明度，0到1 */


      /* ▲▲▲ 添加到这里结束 ▲▲▲ */

    }

    /* Noir's Font Decree */
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      /* 哼，看好了，就是这句！现在字体听从我的新变量指揮了！ */
      font-family: var(--custom-font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif);
      background-image: var(--user-bg-image);
      background-size: cover;
      background-position: center;
    }

    /* 让字体预览区也听话 */
    #font-preview-text {
      font-family: var(--custom-font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif);
    }

    #phone-container {
      width: 100%;
      /* 占满屏幕宽度 */
      height: 100vh;
      /* 占满屏幕高度 */
      background-color: white;
      background-image: var(--user-bg-image);
      background-size: cover;
      background-position: center;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      /* 是不是清爽多了？ */
      position: relative;
      /* <-- 就是这句，告诉它“你是个家长了，给我看好家里的东西！” */
    }

    .screen {
      flex-grow: 1;
      display: none;
      flex-direction: column;
      background-color: #f9f9f9;
      /* 哼，所有屏幕默认都给我变白 */
      /* 让背景透出来 */
      overflow: hidden;
      color: var(--text-color);
    }

    .screen.active {
      display: flex;
    }

    /* 这个是通用的头像预览样式 */
    .avatar-preview {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid var(--border-color);
      margin-top: 5px;
      cursor: pointer;
    }

    /* --- 通用顶栏 --- */
    .header,
    #chat-list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background-color: var(--surface-bg);
      /* backdrop-filter: blur(12px); */
      /* <-- 就这么简单，干掉它 */
      border-bottom: 1px solid var(--border-color);
      flex-shrink: 0;
    }

    .header-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-color);
    }

    .header-button {
      background: none;
      border: none;
      font-size: 1rem;
      cursor: pointer;
      color: var(--primary-color);
      font-weight: 500;
      min-width: 50px;
      text-align: center;
      /* ▼▼▼ 哼，加上这三句，给我立正站好 ▼▼▼ */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* --- 聊天列表 --- */
    #chat-list-pane {
      background-color: transparent;
      border-right: 1px solid var(--border-color);
      transition: transform 0.3s ease-in-out;
      will-change: transform;
      /* <-- 加上这句 */
      width: 100%;
      height: 100%;
      flex-shrink: 0;
      /* 防止它在横向布局里被挤扁 */
      display: flex;
      flex-direction: column;
    }

    #chat-list-container {
      flex-grow: 1;
      flex-grow: 1;
      overflow-y: auto;
      padding: 10px;
    }

    #character-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .character-item {
      display: flex;
      align-items: center;
      padding: 12px;
      margin-bottom: 10px;
      background-color: var(--card-bg);
      /* backdrop-filter: blur(10px);*/
      border-radius: 16px;
      box-shadow: var(--soft-shadow);
      border: 1px solid rgba(255, 255, 255, 0.5);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .character-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(138, 180, 228, 0.2);
    }

    .char-info-wrapper {
      flex-grow: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      overflow: hidden;
    }

    .character-item .char-avatar {
      width: 45px;
      height: 45px;
      border-radius: 50%;
      margin-right: 12px;
      object-fit: cover;
      flex-shrink: 0;
    }

    .character-item .char-name {
      font-weight: 600;
      color: var(--text-color);
    }

    .character-item .char-remark {
      font-size: 0.85rem;
      color: var(--text-color-light);
    }

    #chat-screen-container {
      position: relative;
      /* 告诉里面的绝对定位元素，要以我为基准 */
      flex-grow: 1;
      /* 确保它能撑满 chat-screen 的空间 */
      overflow: hidden;
      /* 把滑出去的部分藏起来，这很重要 */
      display: flex;
      /* 保持内部元素的 flex 布局 */
    }

    /* --- 聊天窗口 --- */


    #chat-view-pane {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      transform: translateX(100%);
      transition: transform 0.3s ease-in-out;
      will-change: transform;
      /* <-- 还有这句 */
      background-color: transparent;
      z-index: 10;
    }

    #chat-screen.show-chat-view #chat-list-pane {
      transform: translateX(-100%);
    }

    #chat-screen.show-chat-view #chat-view-pane {
      transform: translateX(0);
    }




    .avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;

      object-fit: cover;
      border: 2px solid rgba(255, 255, 255, 0.7);
      flex-shrink: 0;
    }

    .message {
      padding: 10px 16px;
      border-radius: 20px;
      line-height: 1.5;
      word-break: break-word;
      box-shadow: var(--soft-shadow);
    }

    .message.user.sticker,
    .message.ai.sticker,
    .message.user.image,
    .message.ai.image {
      background-color: transparent;
      padding: 0;
      box-shadow: none;
    }

    .message.user {
      background-color: var(--accent-color);
      color: white;
      border-bottom-right-radius: 5px;
    }

    .message.ai {
      background-color: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0.8);
      color: var(--text-color);
      border-bottom-left-radius: 5px;
    }

    .message p {
      margin: 0;
    }

    .sticker-content,
    .message-image-content {
      max-width: 120px;
      border-radius: 8px;
      object-fit: cover;
      cursor: pointer;
    }

    .message-image-content {
      max-width: 160px;
    }

    /* --- 其他屏幕和组件 --- */
    /* --- Noir's Fix: API 模型列表的样式修正 --- */
    .model-input-container {
      position: relative;
      /* 关键！让里面的绝对定位元素有家可回 */
      display: flex;
      gap: 8px;
    }

    .custom-model-dropdown {
      display: none;
      /* 默认藏起来 */
      position: absolute;
      top: 100%;
      /* 精准定位到输入框正下方 */
      left: 0;
      right: 80px;
      /* 留出“获取”按钮的位置 */
      background: hsla(var(--primary-hue), calc(var(--primary-saturation) / 2), calc(var(--primary-lightness) + 15%), var(--dropdown-alpha));
      /*   backdrop-filter: blur(10px);*/
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin-top: 4px;
      max-height: 180px;
      overflow-y: auto;
      z-index: 100;
      /* 确保它在最上层 */
      box-shadow: var(--soft-shadow);
    }

    .checkboxes-container {
      display: none;
      position: absolute;
      left: 0;
      right: 0;
      top: 100%;
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid var(--border-color);
      background: hsla(var(--primary-hue), calc(var(--primary-saturation) / 2), calc(var(--primary-lightness) + 15%), var(--dropdown-alpha));
      /*  backdrop-filter: blur(10px);*/
      z-index: 10;
      border-radius: 8px;
      margin-top: 4px;
    }

    .custom-model-dropdown.show {
      display: block;
      /* 需要的时候再显示 */
    }

    .custom-model-dropdown div {
      padding: 10px 12px;
      cursor: pointer;
      color: var(--text-color);
      font-size: 0.9rem;
    }

    .custom-model-dropdown div:hover {
      background-color: rgba(138, 180, 228, 0.2);
    }

    /* --- 其他屏幕和组件 --- */
    /* 在这个注释下面加上主屏幕的样式 */
    #home-screen {
      position: relative;
      /* <-- 就加上这一行！ */


      gap: 20px;
      /* 图标之间的距离 */

      /* 声明！这里现在是我的地盘！*/
      flex-direction: column;
      /* 里面的东西，全体给我垂直排队！*/
      justify-content: space-between;
      /* 核心！顶部和底部的元素给我贴边站好，中间的自动拉开距离！*/
      padding-bottom: 0;
      /* 把内边距去掉，让Dock栏能完美贴底 */
    }

    .app-icon {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      position: absolute;
      z-index: 40;
      box-sizing: border-box;
      margin: 0;
      /* ▼▼▼ 下面是手术刀切下来的新尺寸 ▼▼▼ */
      width: calc(75px * var(--desktop-item-scale, 1));
      height: calc(90px * var(--desktop-item-scale, 1));
      padding: calc(5px * var(--desktop-item-scale, 1));
    }

    .app-icon-img {
      border-radius: 22.5%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: var(--surface-bg);
      box-shadow: none;
      transition: transform 0.2s ease;
      /* ▼▼▼ 新尺寸 ▼▼▼ */
      width: calc(58px * var(--desktop-item-scale, 1));
      height: calc(58px * var(--desktop-item-scale, 1));
      margin-bottom: calc(2px * var(--desktop-item-scale, 1));
      font-size: calc(28px * var(--desktop-item-scale, 1));
    }

    .app-icon-img svg {
      stroke: currentColor;
      /* SVG的线条颜色会继承上面的 color */
    }

    .app-icon span {
      color: white;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      width: 100%;
      /* ▼▼▼ 新尺寸 ▼▼▼ */
      font-size: calc(0.75rem * var(--desktop-item-scale, 1));
    }

    .content {
      padding: 20px;
      overflow-y: auto;
      flex-grow: 1;
      /* <-- 加上这行代码，就是这行！ */
    }

    .form-button {
      width: 100%;
      padding: 12px;
      border: none;
      background-color: var(--primary-color);
      color: white;
      border-radius: 8px;
      font-size: 1.1rem;
      cursor: pointer;
      margin-top: 10px;
    }

    input,
    textarea,
    select {
      width: 100%;
      padding: 10px;
      box-sizing: border-box;
      background-color: rgba(255, 255, 255, 0.8);
      border: 1px solid var(--border-color);
      color: var(--text-color);
      border-radius: 8px;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(138, 180, 228, 0.3);
    }

    .chat-toolbar {
      display: flex;
      padding: 5px 10px;
      border-top: 1px solid var(--border-color);
      background-color: var(--surface-bg);
      /*   backdrop-filter: blur(10px);*/
      flex-shrink: 0;
    }

    /* ▼▼▼ 用下面这段，替换掉你旧的 .toolbar-button 样式 ▼▼▼ */
    .toolbar-button {
      background: none;
      border: none;
      font-size: 1.5rem;
      /* 这个保留，作为SVG尺寸的参考 */
      cursor: pointer;
      padding: 8px;
      /* 稍微增大点击区域 */
      color: var(--text-color-light);
      /* 让它默认是浅灰色 */
      border-radius: 50%;
      /* 让背景有个圆形轮廓 */
      width: 40px;
      height: 40px;
      display: flex;
      /* 使用flex布局让SVG完美居中 */
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s, color 0.2s;
      /* 加上顺滑的过渡效果 */
    }

    .toolbar-button:hover {
      background-color: var(--border-color);
      /* 鼠标悬停时给个背景 */
      color: var(--primary-color);
      /* 图标颜色变为主题色 */
    }

    /* ▲▲▲ 替换到这里为止 ▲▲▲ */


    /* ▼▼▼ 在下面新增这段SVG的专属样式 ▼▼▼ */
    .toolbar-button svg {
      width: 22px;
      /* SVG图标的尺寸 */
      height: 22px;
      stroke-width: 1.8;
      /* 线条粗细，可以微调 */
      stroke: currentColor;
      /* 核心！让SVG的颜色继承按钮的color属性 */
      fill: none;
      /* 确保是线稿风格 */
      pointer-events: none;
      /* 防止SVG本身干扰点击事件 */
    }

    /* ▲▲▲ 新增到这里为止 ▲▲▲ */

    .sticker-panel {
      display: none;
      /* 默认还是藏起来 */
      flex-direction: column;
      /* 哼，给我垂直排好队 */
      height: 220px;
      /* 稍微给管理条一点空间 */
      border-top: 1px solid var(--border-color);
      background-color: var(--surface-bg);
      flex-shrink: 0;
    }

    .sticker-panel.show {
      display: flex;
      /* 看见没，现在是 flex，不是 grid 了！*/
    }

    /* --- 输入区域 --- */
    /* --- 输入区域 --- */
    .chat-input-area {
      padding: 10px 12px calc(env(safe-area-inset-bottom, 0px) + 10px);
      background: var(--surface-bg);
      /*  backdrop-filter: saturate(1.2) blur(10px);*/
      border-top: 1px solid var(--border-color);
      flex-shrink: 0;
    }

    /* 这是我加的新容器，用来实现完美对齐 */
    #chat-input-wrapper {
      display: flex;
      /* Flex大法好，哼 */
      align-items: center;
      border: 1px solid var(--border-color);
      background: rgba(255, 255, 255, 0.9);
      border-radius: 24px;
      padding: 2px 5px;
      transition: border-color .2s, box-shadow .2s;
    }

    #chat-input-wrapper:focus-within {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(138, 180, 228, 0.3);
    }

    #chat-message-input {
      flex-grow: 1;
      /* 让输入框占满剩余空间 */
      border: none;
      background: transparent;
      padding: 9px 12px;
      font-size: .95rem;
      outline: none;
      color: var(--text-color);
    }

    #chat-send-button,
    #chat-get-reply-button {
      height: 38px;
      width: 38px;
      border: 0;
      border-radius: 50%;
      font-size: 1.2rem;
      font-weight: 600;
      color: #fff;
      cursor: pointer;
      transition: transform .1s ease, filter .15s ease;
      flex-shrink: 0;
      /* 防止被挤压 */
      margin-left: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #chat-send-button {
      background: var(--primary-color);
    }

    /* 回复按钮，给个不一样的颜色区分 */
    #chat-get-reply-button {
      background: var(--accent-color);
      font-size: 1.5rem;
      /* 让箭头更清晰 */
    }

    #chat-message-input {
      border: 1px solid var(--border-color);
      background: rgba(255, 255, 255, 0.9);
      border-radius: 20px;
      padding: 11px 16px;
      font-size: .95rem;
      outline: none;
      color: var(--text-color);
      transition: border-color .2s, box-shadow .2s;
    }

    #chat-message-input:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(138, 180, 228, 0.3);
    }

    #chat-send-button,
    #chat-get-reply-button {
      height: 40px;
      padding: 0 18px;
      border: 0;
      border-radius: 20px;
      font-size: .95rem;
      font-weight: 600;
      color: #fff;
      cursor: pointer;
      transition: transform .1s ease, filter .15s ease;
    }

    #chat-send-button {
      background: var(--primary-color);
    }

    #chat-get-reply-button {
      display: flex;
      /* 隐藏旧的回复按钮，样式统一到发送按钮 */
    }


    /* --- 引用样式 --- */
    .quote-preview {
      display: none;
      padding: 8px 12px;
      background-color: rgba(255, 255, 255, 0.5);
      border-left: 3px solid var(--primary-color);
      margin: 0 12px 8px;
      border-radius: 6px;
      position: relative;
    }

    #quote-preview-sender {
      font-weight: 600;
      font-size: 0.85rem;
      color: var(--primary-color);
    }

    #quote-preview-text {
      font-size: 0.9rem;
      color: var(--text-color-light);
    }

    .cancel-quote-btn {
      position: absolute;
      top: 50%;
      right: 10px;
      transform: translateY(-50%);
      background: none;
      border: none;
      font-size: 1.5rem;
      color: #999;
      cursor: pointer;
    }

    .quoted-message-in-bubble {
      background-color: rgba(0, 0, 0, 0.04);
      padding: 8px 10px;
      border-left: 3px solid var(--border-color);
      border-radius: 8px;
      margin-bottom: 6px;
    }

    .quoted-sender {
      font-weight: bold;
      font-size: 0.8rem;
      color: var(--text-color);
    }

    .quoted-content {
      font-size: 0.85rem;
      color: var(--text-color-light);
    }

    /* 这是弹窗的“骨架”，让它能居中浮动在屏幕上 */
    .choice-modal {
      position: fixed;
      inset: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease, visibility 0.2s ease;
    }

    .choice-modal.show {
      opacity: 1;
      visibility: visible;
    }


    /* --- 弹窗 --- */
    .choice-modal-backdrop {
      background: rgba(0, 0, 0, 0.2);
      /*  backdrop-filter: blur(4px);*/
    }

    .choice-modal-content {
      background: var(--surface-bg);
      /* backdrop-filter: blur(12px); */
      /* <-- 就这么简单，干掉它 */
      border: 1px solid rgba(255, 255, 255, 0.5);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
    }

    .choice-modal-button {
      color: var(--text-color);
      background: rgba(255, 255, 255, 0.5);
    }

    .choice-modal-button:hover {
      background-color: rgba(255, 255, 255, 1);
    }

    .choice-modal-button.cancel {
      color: var(--primary-color);
      background: transparent;
    }

    /* --- Noir's Fix: 让“添加”弹窗从底部滑出，更大气 --- */
    #add-choice-modal .choice-modal-content {
      width: 100%;
      max-width: var(--phone-width);
      /* 确保不会超出手机宽度 */
      margin: 0;
      border-radius: 20px 20px 0 0;
      /* 只留顶部圆角 */
      border-bottom-left-radius: 0;
      /* 覆盖通用样式 */
      border-bottom-right-radius: 0;
      /* 覆盖通用样式 */
      padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
      /* 适配iPhone底部安全区 */
      transform: translateY(100%);
      transition: transform 0.3s ease-out, opacity 0.3s ease-out;
    }

    #add-choice-modal.show .choice-modal-content {
      transform: translateY(0);
    }

    #add-choice-modal {
      align-items: flex-end;
      /* 让弹窗贴着底部 */
      justify-content: center;
    }

    /* 按钮也重新设计一下，让它们竖着排 */
    #add-choice-modal .choice-modal-button {
      width: calc(100% - 40px);
      margin: 5px 20px;
      padding: 14px;
      font-size: 1rem;
      border-radius: 12px;
      text-align: center;
    }

    /* --- Noir's Fix: 修正创建群聊时，成员选择列表的样式 --- */
    .member-selection-item {
      display: flex;
      align-items: center;
      padding: 10px 15px;
      border-bottom: 1px solid var(--border-color);
    }

    .member-selection-item:last-child {
      border-bottom: none;
    }

    /* 关键！就是这里，把头像大小锁死 */
    .member-selection-item .char-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin: 0 15px 0 10px;
      object-fit: cover;
    }

    .member-selection-item .char-name {
      font-weight: 500;
      color: var(--text-color);
    }

    .member-selection-item input[type="checkbox"] {
      width: 20px;
      height: 20px;
      flex-shrink: 0;
      accent-color: var(--primary-color);
      /* 让勾选框颜色也跟主题统一 */
    }

    /* --- Noir's World Book Styles --- */
    #world-book-list-container {
      padding: 10px;
    }

    .world-book-item {
      background-color: var(--card-bg);
      padding: 15px;
      border-radius: 12px;
      margin-bottom: 10px;
      box-shadow: var(--soft-shadow);
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.6);
    }

    .world-book-item-name {
      font-weight: 600;
      color: var(--primary-color);
      margin-bottom: 5px;
    }

    .world-book-item-preview {
      font-size: 0.9rem;
      color: var(--text-color-light);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* --- Noir's Fancy Multi-Select Styles --- */
    .custom-multiselect {
      position: relative;
      user-select: none;
    }

    .select-box {
      border: 1px solid var(--border-color);
      background: rgba(255, 255, 255, 0.8);
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .select-box.expanded .arrow {
      transform: rotate(180deg);
    }


    .checkboxes-container.visible {
      display: block;
    }

    .checkboxes-container label {
      display: block;
      padding: 10px 12px;
    }

    .checkboxes-container label:hover {
      background-color: rgba(138, 180, 228, 0.2);
    }

    .checkboxes-container input[type="checkbox"] {
      margin-right: 8px;
      width: auto;
      /* 覆盖掉全局的 input 样式 */
    }

    /* --- Noir's Clock & Timestamp Styles --- */
    /* --- Noir's Badge & App Dock Styles --- */
    #decorative-badge {
      filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.25));
      transform: rotate(-0deg);
      transition: transform 0.2s ease, filter 0.2s ease;
      user-select: none;
      z-index: 50;
      /* ▼▼▼ 新尺寸 ▼▼▼ */
      width: calc(160px * var(--desktop-item-scale, 1));
      height: calc(160px * var(--desktop-item-scale, 1));
    }


    #decorative-badge:active {

      transform: rotate(-2deg) scale(1.05);
      /* 抓起来的时候，摆正放大一点 */
      filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.3));
    }


    #decorative-badge img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      /* 保留这句，让你的图片能被很好地填充 */
    }

    /*  #a#app-dock-bottom-left,
    #app-dock-top-right {
      
      哼，现在你们只是幽灵了。
      不需要任何样式，你们的孩子（App图标）会自己找到回家的路。
      它们会相对于 #home-screen 定位。
    
    }
*/

    /* --- Noir's Author Mark: Pixel Chicken --- */
    /* 哼，这就是那个吵着要加的小鸡图标 */
    #noir-author-mark {
      position: absolute;
      /* 相对于父容器定位 */
      right: -30px;
      /* 调整它在时钟右边的位置 */
      top: 50%;
      /* 垂直居中 */
      transform: translateY(-50%);
      /* 精确对齐 */
      width: 20px;
      /* 小鸡的尺寸 */
      height: 20px;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="0"><path d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2zM12 4c.69 0 1.25.56 1.25 1.25S12.69 6.5 12 6.5s-1.25-.56-1.25-1.25S11.31 4 12 4zm0 2c-.69 0-1.25.56-1.25 1.25S11.31 8.5 12 8.5s1.25-.56 1.25-1.25S12.69 6 12 6zm-2 2c-.69 0-1.25.56-1.25 1.25S9.31 9.75 10 9.75s1.25-.56 1.25-1.25S10.69 8 10 8zm2 0c-.69 0-1.25.56-1.25 1.25S11.31 9.75 12 9.75s1.25-.56 1.25-1.25S12.69 8 12 8zm2 0c-.69 0-1.25.56-1.25 1.25S13.31 9.75 14 9.75s1.25-.56 1.25-1.25S14.69 8 14 8zM10 10c-.69 0-1.25.56-1.25 1.25S9.31 12.5 10 12.5s1.25-.56 1.25-1.25S10.69 10 10 10zm2 0c-.69 0-1.25.56-1.25 1.25S11.31 12.5 12 12.5s1.25-.56 1.25-1.25S12.69 10 12 10zm2 0c-.69 0-1.25.56-1.25 1.25S13.31 12.5 14 12.5s1.25-.56 1.25-1.25S14.69 10 14 10zM12 12c-.69 0-1.25.56-1.25 1.25S11.31 14.5 12 14.5s1.25-.56 1.25-1.25S12.69 12 12 12zm-2 2c-.69 0-1.25.56-1.25 1.25S9.31 15.75 10 15.75s1.25-.56 1.25-1.25S10.69 14 10 14zm4 0c-.69 0-1.25.56-1.25 1.25S13.31 15.75 14 15.75s1.25-.56 1.25-1.25S14.69 14 14 14zM12 16c-.69 0-1.25.56-1.25 1.25S11.31 18.5 12 18.5s1.25-.56 1.25-1.25S12.69 16 12 16zM6 10c-.69 0-1.25.56-1.25 1.25S5.31 12.5 6 12.5s1.25-.56 1.25-1.25S6.69 10 6 10zm12 0c-.69 0-1.25.56-1.25 1.25S17.31 12.5 18 12.5s1.25-.56 1.25-1.25S18.69 10 18 10zM12 20c-.69 0-1.25.56-1.25 1.25S11.31 22.5 12 22.5s1.25-.56 1.25-1.25S12.69 20 12 20zM6 14c-.69 0-1.25.56-1.25 1.25S5.31 15.75 6 15.75s1.25-.56 1.25-1.25S6.69 14 6 14zm12 0c-.69 0-1.25.56-1.25 1.25S17.31 15.75 18 15.75s1.25-.56 1.25-1.25S18.69 14 18 14z"/></svg>');
      /* 这是SVG小鸡的Data URI，白色像素风格 */
      background-size: contain;
      background-repeat: no-repeat;
      cursor: pointer;
      /* 提示可点击 */
      opacity: 0.6;
      /* 稍微透明一点，不那么突兀 */
      transition: opacity 0.2s ease-in-out;
      /* 鼠标悬停效果 */
      z-index: 100;
      /* 确保它在最上层 */
    }

    #noir-author-mark:hover {
      opacity: 1;
      /* 鼠标悬停时完全显示 */
    }

    /* 调整时钟容器，为小鸡留出空间并方便定位 */
    .home-clock-container {
      position: relative;
      /* 确保小鸡能相对它定位 */
      /* ... (保留你已有的其他时钟样式) ... */
      padding-right: 40px;
      /* 给小鸡留出一些右边距 */
    }

    #home-clock-container {
      color: white;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      text-align: center;
      position: absolute;
      z-index: 50;
      /* ▼▼▼ 新增的缩放指令 ▼▼▼ */
      transform-origin: center top;
      transform: scale(var(--desktop-item-scale, 1));
    }

    #home-time {
      font-size: 80px;
      font-weight: 360;
      /* <--- 我把字重从200加到了300，比原来粗，但又不会笨重，这才是高级感。 */
      letter-spacing: -1px;
      /* <--- 字间距也给你调紧了一点，看起来更整体。 */
    }

    #home-date {
      font-size: 1rem;
      /* <--- 稍微缩小一点，让时间更突出 */
      font-weight: 400;
      margin-top: 8px;
      opacity: 0.8;
      text-transform: uppercase;
      /* <--- 日期我给你换成了全大写，这才有那股‘性冷淡’的味道。 */
      letter-spacing: 1px;
      /* <--- 顺便拉开一点点间距，免得挤在一起。 */
    }

    /* 聊天气泡时间戳的样式 */
    .timestamp {
      font-size: 0.7rem;
      color: var(--text-color-light);
      padding: 0 5px;
      margin-bottom: 3px;
      /* 让它和气泡底部对齐 */
    }

    /* 第一段：这是消息容器的基础样式 */
    .message-container {
      display: flex;
      /* 启用flex布局 */
      flex-direction: column;
      /* 让气泡和时间戳垂直排列 */
      margin-bottom: 10px;
      max-width: 90%;
      /* 限制整个容器的最大宽度 */
    }

    /* 第二段：这是根据发言者进行左右对齐的样式 */
    .message-container.user {
      align-self: flex-end;
      /* 让用户方整个容器靠右 */
      align-items: flex-end;
      /* 让容器内部的元素（气泡、时间戳）也靠右 */
    }

    .message-container.ai {
      align-self: flex-start;
      /* 让AI方整个容器靠左 */
      align-items: flex-start;
      /* 让容器内部的元素（气泡、时间戳）也靠左 */
    }

    #chat-messages {
      flex-grow: 1;
      padding: 5px 15px;
      /* 左右15px的呼吸空间 */
      overflow-y: auto;
      display: flex;
      flex-direction: column;

    }

    .message-bubble-row {
      display: flex;
      align-items: flex-end;
      width: 100%;
      gap: 10px;
      /* 头像和气泡之间，永远保持10px的距离 */
    }

    .message-container.user .message-bubble-row {
      justify-content: flex-end;
    }

    .message-container.ai .message-bubble-row {
      justify-content: flex-start;
    }



    /* 这是给表情选择面板里，每一个小表情图片用的样式 */
    .sticker-item {
      width: 100%;
      /* 自动填满网格单元格的宽度 */
      aspect-ratio: 1 / 1;
      /* 保持1:1的宽高比，让它变成正方形 */
      object-fit: cover;
      /* 图片会被裁剪以适应正方形，不变形 */
      border-radius: 8px;
      /* 加个小圆角 */
      cursor: pointer;
      transition: transform 0.15s ease;
    }

    .sticker-item:hover {
      transform: scale(1.1);
      /* 鼠标放上去时稍微放大，增加交互感 */
    }

    /* --- Noir's Offline Scene Styles --- */
    #meeting-scene-view {
      flex-grow: 1;
      /* <-- 核心：让它占满所有可用空间 */
      overflow-y: auto;
      /* <-- 核心：内容多了就内部滚动 */
      padding: 20px;
      font-family: 'Georgia', 'Times New Roman', 'KaiTi', 'STSong', serif;
      background-size: cover;
      background-position: center;
      color: white;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.7);
    }

    #chat-view-pane.offline-mode #offline-scene-view {
      display: block;
      /* 在线下模式时显示 */
    }

    #chat-view-pane.offline-mode #chat-messages {
      display: none;
      /* 在线下模式时隐藏气泡聊天 */
    }

    #offline-scene-view p {
      margin: 0 0 1em 0;
      line-height: 1.7;
      white-space: pre-wrap;
      /* 保留换行和空格，这对于小说格式至关重要 */
      font-size: 1rem;
    }

    /* --- Noir's Offline Scene Dialogue Box Style --- */
    #offline-scene-view p {
      margin: 0 0 1em 0;
      line-height: 1.7;
      white-space: pre-wrap;
      font-size: 1rem;

      /* <--- Noir's Addition: 为对话框添加半透明背景和内边距 */
      background-color: rgba(0, 0, 0, 0.4);
      /* 半透明黑色背景 */
      padding: 15px 20px;
      /* 内边距，让文字与边框有距离 */
      border-radius: 8px;
      /* 圆角边框，更柔和 */
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      /* 轻轻的阴影，增加立体感 */
    }

    #offline-scene-view .narrator {
      color: #d1d5db;
      /* 旁白用浅灰色 */
      font-style: italic;
    }

    #offline-scene-view .speaker-user {
      color: #a7c7e7;
      /* 用户的发言用一种柔和的蓝色 */
      font-weight: bold;
    }

    #offline-scene-view .speaker-ai {
      color: #f2b7c6;
      /* AI的发言用柔和的粉色，形成对比 */
      font-weight: bold;
    }

    /* --- Noir's Typing Indicator Style --- */
    /* --- Noir's "Sticky" Typing Indicator --- */
    /* 哼，用这个替换掉你旧的 .typing-indicator 样式 */
    /* --- Noir's Final Protocol: Spatial Displacement --- */
    /* 哼，这次再敢乱跑，我就把你格式化了。*/
    /* --- Noir's Final Protocol: Spatial Readjustment (As Commanded) --- */
    /* 哼，这次再敢说丑，我就把你格式化了。*/
    .typing-indicator {
      position: absolute;
      /* ▼▼▼ 核心手术，看好了 ▼▼▼ */
      bottom: 117px;
      /* 这是我算好的精确高度，刚好在你的工具栏和输入框上面 */
      left: 15px;
      /* 先把你那个碍事的左定位给废了 */
      right: auto;
      /* 然后把它焊死在右边，距离边缘15px */
      margin-left: 0;
      /* 再把你那个多余的左边距也扔掉 */
      /* ▲▲▲ 手术结束 ▲▲▲ */

      /* 下面这些是“整容”，让它看起来还像个气泡 */

    }

    #offline-scene-view .typing-indicator {
      color: rgba(255, 255, 255, 0.8);
      /* 在暗色背景下用亮色 */
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      /* 同样的文字阴影，保持队形 */
      padding: 10px 0;
      margin-left: 0;
      /* 在小说视图里不需要缩进 */
    }


    /* --- Noir's Final Alignment Fix --- */
    .message-container.ai .timestamp {
      /* 哼，给你加上头像宽度(40px) + 左右边距(10px)的距离 */
      margin-left: 50px;
    }

    .message-container.user .timestamp {
      /* 另一边也是一样，真是麻烦死了 */
      margin-right: 50px;
    }

    /* --- Noir's Music Feed & Player Styles --- */
    #music-feed-container {
      padding-bottom: 70px;
      contain: content;
      /* 为底部播放器留出空间 */
    }

    /* 动态页：默认白底；如设置 --feed-bg-image 则显示独立壁纸 + 轻动画叠层 */
    #music-screen {
      background-color: #fff;
      /* 默认白底 */
      background-image: var(--feed-bg-image);
      /* 单独壁纸，不设就是 none */
      background-size: cover;
      background-position: center;
      contain: paint;
      /* 降低重绘范围，省电 */
    }

    /* 轻动画彩雾叠层：仅图层，不拦点击 */
    #music-screen::before {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background-image:
        conic-gradient(from var(--feed-overlay-rotate),
          hsla(var(--primary-hue) 70% 60% / var(--feed-overlay-opacity)) 0%,
          transparent 20%,
          hsla(var(--primary-hue) 70% 60% / var(--feed-overlay-opacity)) 40%,
          transparent 60%,
          hsla(var(--primary-hue) 70% 60% / var(--feed-overlay-opacity)) 80%,
          transparent 100%);
      transform: translateZ(0);
      animation: feed-pan var(--feed-overlay-speed) linear infinite;
    }

    /* 超慢速平移旋转，基本不占 GPU */
    @keyframes feed-pan {
      0% {
        transform: translate3d(0, 0, 0) rotate(0deg) scale(1.02);
      }

      50% {
        transform: translate3d(1.2%, 0.8%, 0) rotate(2deg) scale(1.02);
      }

      100% {
        transform: translate3d(0, 0, 0) rotate(0deg) scale(1.02);
      }
    }

    /* 系统降低动画偏好时，自动停掉动画 */
    @media (prefers-reduced-motion: reduce) {
      #music-screen::before {
        animation: none;
      }
    }


    .music-post {
      background-color: hsla(var(--primary-hue), calc(var(--primary-saturation) / 1.5), calc(var(--primary-lightness) + 18%), var(--feed-card-alpha));
      border-radius: 12px;
      margin-bottom: 15px;
      box-shadow: var(--soft-shadow);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.6);
    }

    .music-post-header {
      display: flex;
      align-items: center;
      padding: 12px 15px;
    }

    .music-post-header .char-avatar {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      margin-right: 10px;
    }

    .music-post-header .char-name {
      font-weight: 600;
      color: var(--text-color);
    }

    .music-post-thought {
      padding: 0 15px 15px;
      font-size: 0.95rem;
      line-height: 1.6;
      white-space: pre-wrap;
    }

    .music-post-song-card {
      display: flex;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.04);
      padding: 12px 15px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .music-post-song-card:hover {
      background-color: rgba(0, 0, 0, 0.08);
    }

    .music-post-song-card img {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      margin-right: 12px;
    }

    .music-post-song-info {
      flex-grow: 1;
    }

    .music-post-song-info .title {
      font-weight: 500;
      color: var(--text-color);
    }

    .music-post-song-info .artist {
      font-size: 0.85rem;
      color: var(--text-color-light);
    }

    .music-post-play-icon {
      font-size: 1.5rem;
      color: var(--primary-color);
    }

    #music-player-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 65px;
      background: var(--surface-bg);
      /*backdrop-filter: blur(10px);*/
      border-top: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      padding: 0 10px;
      transform: translateY(100%);
      transition: transform 0.3s ease;
    }

    #music-player-bar:not(.hidden) {
      transform: translateY(0);
    }

    #music-player-bar.hidden {
      display: none;
      /* 彻底隐藏，避免交互问题 */
    }


    #player-cover {
      width: 45px;
      height: 45px;
      border-radius: 6px;
      margin-right: 10px;
    }

    #player-info {
      flex-grow: 1;
      overflow: hidden;
    }

    #player-title,
    #player-artist {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #player-title {
      font-weight: 500;
    }

    #player-artist {
      font-size: 0.8rem;
      color: var(--text-color-light);
    }

    #player-controls button {
      background: none;
      border: 2px solid var(--text-color);
      border-radius: 50%;
      width: 36px;
      height: 36px;
      font-size: 1rem;
      cursor: pointer;
      color: var(--text-color);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* --- Noir's Music Share Bubble Styles --- */
    .message.music {
      background-color: transparent;
      padding: 0;
      box-shadow: none;
      max-width: 250px;
      /* 限制一下最大宽度 */
    }

    .music-share-card {
      display: flex;
      align-items: center;
      background-color: var(--card-bg);
      border-radius: 12px;
      padding: 12px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      box-shadow: var(--soft-shadow);
      border: 1px solid rgba(255, 255, 255, 0.7);
    }

    .message-container.user .music-share-card {
      background-color: var(--accent-color);
      border: 1px solid rgba(255, 255, 255, 0.4);
    }

    .message-container.user .music-share-card .title,
    .message-container.user .music-share-card .artist,
    .message-container.user .music-share-card .play-icon {
      color: white;
    }


    .music-share-cover {
      width: 45px;
      height: 45px;
      border-radius: 6px;
      margin-right: 10px;
      flex-shrink: 0;
    }

    .music-share-info {
      flex-grow: 1;
      overflow: hidden;
    }

    .music-share-info .title {
      font-weight: 600;
      color: var(--text-color);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .music-share-info .artist {
      font-size: 0.85rem;
      color: var(--text-color-light);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .music-share-play-icon {
      font-size: 1.5rem;
      color: var(--primary-color);
      margin-left: 10px;
    }

    #music-screen {
      position: relative;
      /* 就是这句，告诉里面的绝对定位元素，以我为界！ */
    }

    /* --- Noir's Fancy Music Widget Styles --- */
    /* --- Noir's Music System Refactor --- */

    #music-widget:not(.hidden) {
      transform: translateY(0);
      /* 不隐藏时，滑上来 */
    }

    #music-widget.hidden {
      transform: translateY(150%);
      /* 隐藏时，滑下去 */
    }

    .widget-vinyl {
      width: 80px;
      height: 80px;
      background-color: #111;
      border-radius: 50%;
      position: relative;
      left: 20px;
      /* 向右移动，让卡片能盖住它 */
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      background-image:
        radial-gradient(circle at center, #555 10%, transparent 11%),
        radial-gradient(circle at center, #fff 12%, transparent 13%);
      animation: spin 8s linear infinite;
      z-index: 1;
    }

    @keyframes spin {
      from {
        transform: translate(-50%, -50%) rotate(0deg);
        /* <-- 看见没，把咒语合并了 */
      }

      to {
        transform: translate(-50%, -50%) rotate(360deg);
        /* <-- 这里也是 */
      }
    }

    .widget-card {
      width: 240px;
      padding: 15px;
      background-color: var(--card-bg);
      /*  backdrop-filter: blur(10px);*/
      border-radius: 12px;
      box-shadow: var(--soft-shadow);
      border: 1px solid rgba(255, 255, 255, 0.7);
      display: flex;
      align-items: center;
      z-index: 2;
      /* 让卡片在唱片上方 */
    }

    .widget-card img {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      margin-right: 12px;
      flex-shrink: 0;
    }

    .widget-info {
      flex-grow: 1;
      overflow: hidden;
    }

    #widget-title,
    #widget-artist {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #widget-title {
      font-weight: 600;
      color: var(--text-color);
      font-size: 0.9rem;
    }

    #widget-artist {
      font-size: 0.8rem;
      color: var(--text-color-light);
    }

    #widget-play-icon {
      font-size: 1.2rem;
      color: var(--primary-color);
      margin-left: 10px;
    }

    #card-widget {
      border-radius: 18px;
      background-color: rgba(255, 255, 255, 0.5);
      filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.2));
      transform: rotate(0deg);
      transition: transform 0.2s ease, filter 0.2s ease;
      user-select: none;
      z-index: 51;
      overflow: hidden;
      /* ▼▼▼ 新尺寸 ▼▼▼ */
      width: calc(335px * var(--desktop-item-scale, 1));
      height: calc(170px * var(--desktop-item-scale, 1));
    }


    /* --- End of Protocol --- */

    /* --- Noir's "Center Alignment" Protocol --- */

    /* --- End of Protocol --- */

    #card-widget:active {

      transform: rotate(1deg) scale(1.05);
      filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.3));
    }

    #card-widget img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* --- Noir's Ultimate Scrollbar Hider --- */
    /* For Webkit browsers like Chrome, Safari */
    ::-webkit-scrollbar {
      display: none;
    }

    /* For Firefox */
    * {
      scrollbar-width: none;
    }

    /* --- Noir's Fix: 美化消息操作弹窗 --- */
    #message-action-modal {
      align-items: flex-end;
      /* 让弹窗贴着底部 */
    }

    #message-action-modal .choice-modal-content {
      width: 100%;
      max-width: var(--phone-width);
      margin: 0;
      border-radius: 20px 20px 0 0;
      padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
      transform: translateY(100%);
      transition: transform 0.3s ease-out, opacity 0.3s ease-out;
    }

    #message-action-modal.show .choice-modal-content {
      transform: translateY(0);
    }

    #message-action-modal .choice-modal-button {
      width: calc(100% - 40px);
      margin: 5px 20px;
      padding: 14px;
      font-size: 1rem;
      border-radius: 12px;
      text-align: center;
    }

    /* --- End of Fix --- */
    /* --- Noir's Fix: Fancy User Post Area --- */
    #user-post-input-container {
      display: flex;
      gap: 10px;
    }

    #user-post-avatar {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      flex-shrink: 0;
      margin-top: 5px;
    }

    #user-post-main-area {
      flex-grow: 1;
    }

    #user-post-textarea {
      width: 100%;
      border: none;
      background: transparent;
      outline: none;
      resize: vertical;
      font-size: 1rem;
      color: var(--text-color);
    }

    #user-post-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 8px;
    }

    /* ... 你已有的 #user-post-toolbar 样式 ... */

    /* ▼▼▼ Noir's Command: 哼，给我站成一排！ ▼▼▼ */
    #user-post-actions {
      display: flex;
      /* <-- 这就是圣旨本身 */
      gap: 8px;
      /* <-- 这是我赏赐的间距，让它们别挤在一起 */
    }

    /* ▲▲▲ Command End ▲▲▲ */

    #user-send-post-button {
      padding: 6px 18px;
      border-radius: 16px;
      border: none;
      background: var(--primary-color);
      color: white;
      cursor: pointer;
      font-weight: 600;
    }

    /* 这是附件预览的样式 */
    #user-post-attachment-preview {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .preview-item {
      position: relative;
      max-width: 100px;
    }

    .preview-item img {
      width: 100%;
      border-radius: 8px;
      object-fit: cover;
    }

    .preview-item .music-preview-card {
      display: flex;
      align-items: center;
      padding: 8px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      width: 200px;
      /* 给音乐卡片宽一点 */
    }

    .preview-item .music-preview-card img {
      width: 30px;
      height: 30px;
      margin-right: 8px;
    }

    .preview-item .music-preview-card .info {
      font-size: 0.8rem;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .remove-attachment-btn {
      position: absolute;
      top: -5px;
      right: -5px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    /* --- Noir's Fix: Post Image Display Style --- */
    .post-image-container {
      padding: 0 15px 15px;
      /* 图片和文字之间留点空隙 */
    }

    .post-image {
      max-width: 100%;
      /* 图片最宽不能超过帖子宽度 */
      max-height: 400px;
      /* 最高400像素，防止长图刷屏 */
      border-radius: 8px;
      /* 加个小圆角，好看 */
      object-fit: cover;
      /* 保持图片比例，不变形 */
      display: block;
      /* 解决图片底部多余的空隙问题 */
    }

    /* --- Noir's Refactor: New Post Interaction Styles --- */
    .post-interactions {
      padding: 10px 15px;
      background-color: rgba(0, 0, 0, 0.02);
      border-top: 1px solid var(--border-color);
      font-size: 0.9rem;
    }

    .post-likes {
      color: var(--primary-color);
      margin-bottom: 8px;
    }

    .post-comments-container {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .post-comment {
      color: var(--text-color);
    }

    .post-comment .comment-author {
      font-weight: 600;
      color: var(--text-color);
    }

    .post-timestamp {
      font-size: 0.75rem;
      color: var(--text-color-light);
      padding: 0 15px 10px;
    }



    /* 覆盖：基础气泡体 */
    /* 覆盖：基础气泡体 */
    .message {
      border-radius: var(--bubble-radius);
      line-height: 1.55;
      padding: 10px 14px;
      box-shadow:
        0 1px 0 rgba(0, 0, 0, .03),
        0 4px 10px rgba(0, 0, 0, .06);
      /* 比你原先更浅，省功耗 */
      border: 1px solid var(--bubble-outline);
      backdrop-filter: none !important;
      /* 绝不启用重滤镜 */
      will-change: auto;
      /* 不抢 GPU 配额 */

      /* --- Noir's Fix: 就是下面这两行，哼 --- */
      user-select: none;
      /* 标准浏览器给我听话，不许选中 */
      -webkit-user-select: none;
      /* 那些老古董浏览器也一样 */
    }

    /* 你的气泡（右侧） */
    .message.user {
      color: #fff;
      background: var(--bubble-user-bg);
      border-bottom-right-radius: 6px;
      /* 微“角”保留你原味 */
      text-shadow: 0 1px 0 rgba(0, 0, 0, .12);
      /* 细腻但很轻 */
    }

    /* TA 的气泡（左侧） */
    .message.ai {
      color: var(--text-color);
      background: var(--bubble-ai-bg);
      border-bottom-left-radius: 6px;
    }

    /* 细节：图片/贴纸消息不套背景 */
    /* 细节：图片/贴纸/音乐卡片消息不套背景 */
    .message.user.sticker,
    .message.ai.sticker,
    .message.user.image,
    .message.ai.image,
    .message.user.music,
    /* <-- 哼，加上这两行 */
    .message.ai.music,
    .message.html-module {
      background: transparent;
      border: 0;
      box-shadow: none;
      padding: 0;
    }

    /* 轻触态：不使用阴影动画，避免合成层抖动 */
    .message:active {
      transform: scale(.996);
    }

    /* 引用块在气泡内的融合感 */
    .quoted-message-in-bubble {
      background: rgba(0, 0, 0, .045);
      border: 1px solid color-mix(in hsl, var(--primary-color) 18%, transparent);
      border-radius: 10px;
    }


    /* --- Noir's Transfer Bubble Style --- */
    .message.transfer {
      background: #F79232;
      /* 哼，一个温暖又醒目的橙色 */
      color: white;
      padding: 12px 16px;
      border-radius: 12px;
      width: 220px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    }

    /* 我还给左右两边做了区分，真是为你操碎了心 */
    .message-container.ai .message.transfer {
      background: #f9fafb;
      /* AI发来的转账用白色，更清爽 */
      color: #333;
      border: 1px solid #e5e7eb;
    }

    .transfer-content {
      display: flex;
      flex-direction: column;
    }

    .transfer-title {
      font-weight: 600;
      font-size: 1rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.5);
      padding-bottom: 8px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
    }

    .message-container.ai .transfer-title {
      border-bottom-color: rgba(0, 0, 0, 0.1);
    }

    .transfer-amount {
      font-size: 1.8rem;
      font-weight: bold;
    }

    .transfer-recipient {
      font-size: 0.8rem;
      opacity: 0.9;
      margin-top: 4px;
    }

    /* --- End of Refactor --- */



    /* --- Noir's Snap Guide Styles --- */
    .snap-guide {
      position: absolute;
      background-color: rgba(255, 105, 180, 0.85);
      /* 哼，一个足够醒目的颜色 */
      display: none;
      z-index: 999;
      box-shadow: 0 0 5px rgba(255, 105, 180, 0.7);
    }

    #snap-guide-v {
      width: 1px;
    }

    #snap-guide-h {
      height: 1px;
    }

    /* --- Noir's Galgame UI Beautification --- */
    /* Top-left Date & Time Widget */
    #galgame-overlay-ui {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border-radius: 12px;
      padding: 8px 15px;
      color: white;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      z-index: 10;
      border: 1px solid rgba(255, 255, 255, 0.2);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    #galgame-time {
      font-size: 1.2rem;
      font-weight: 600;
      text-align: center;
    }

    #galgame-date {
      font-size: 0.75rem;
      opacity: 0.8;
      text-align: center;
    }

    /* Main Text Box */
    /* Main Text Box */
    #galgame-textbox-container {
      background: linear-gradient(0deg, rgba(25, 28, 38, 0.85) 0%, rgba(45, 50, 68, 0.7) 100%);
      backdrop-filter: blur(10px) saturate(1.2);
      -webkit-backdrop-filter: blur(10px) saturate(1.2);
      border-top: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 16px;
      box-shadow: 0 -5px 25px rgba(0, 0, 0, 0.2);
      bottom: 85px;
      /* <-- 就是这里，往上抬了，满意了吗？ */
      left: 15px;
      right: 15px;
      padding: 12px 18px;
    }

    /* Speaker Name Tag */
    #galgame-speaker {
      background: linear-gradient(90deg, var(--primary-color) 0%, hsl(var(--primary-hue), var(--primary-saturation), calc(var(--primary-lightness) - 10%)) 100%);
      color: white;
      padding: 4px 12px;
      border-radius: 8px;
      display: inline-block;
      font-size: 0.95rem;
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
      margin-bottom: 12px;
    }

    /* Dialogue Text */
    #galgame-text {
      font-size: 1rem;
      line-height: 1.7;
      color: #f0f2f5;
    }

    /* User Input Area Container*/
    #meeting-view-screen .chat-input-area {
      background: transparent;
      border-top: none;
      padding: 0 15px 20px 15px;
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 20;
    }

    /* User Input Wrapper */
    #chat-input-wrapper-meeting {
      display: flex;
      align-items: center;
      background: linear-gradient(0deg, rgba(25, 28, 38, 0.9) 0%, rgba(45, 50, 68, 0.75) 100%);
      backdrop-filter: blur(10px) saturate(1.2);
      -webkit-backdrop-filter: blur(10px) saturate(1.2);
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 16px;
      padding: 5px 8px 5px 15px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.25);
    }

    #meeting-message-input {
      color: #f0f2f5;
    }

    #meeting-message-input::placeholder {
      color: rgba(240, 242, 245, 0.5);
      font-style: italic;
    }

    /* Send Button */
    #meeting-send-button {
      height: 40px;
      width: 40px;
      border-radius: 50%;
      font-size: 1.5rem;
      font-weight: 300;
      color: #fff;
      transition: all .2s ease;
      margin-left: 8px;
      background: var(--primary-color);
      box-shadow: 0 2px 5px hsla(var(--primary-hue), 50%, 50%, 0.4);
    }

    #meeting-send-button:hover {
      filter: brightness(1.1);
      transform: scale(1.05);
    }


    /* --- End of Beautification --- */
    /* --- Noir's Diary Beautification --- */
    #diary-entries-container {
      background-color: #fdfaf2;
      /* A warm, paper-like off-white */
      padding: 25px 20px;
      line-height: 1.9;
      border: 1px solid #e0dccc;
      box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.08);
      /* Inner shadow for page depth */
    }

    /* This is the container for a single entry (date, author, content) */
    .diary-entry {
      margin-bottom: 2.5em;
      /* Increase spacing between entries */
      position: relative;
      padding-bottom: 1.5em;
      /* Space for the separator line */
      border-bottom: 1px dashed #dcd5c7;
      /* A subtle dashed line between entries */
    }

    /* Style the author's name */
    .diary-author {
      font-weight: normal;
      /* Make it less bold, more like a signature */
      font-size: 1rem;
      font-family: 'Segoe Script', 'Bradley Hand', cursive;
      /* A more handwritten font */
    }

    /* Style the date */
    .diary-timestamp {
      font-size: 0.75rem;
      color: #a99e8c;
      /* A faded brown color */
      margin-bottom: 8px;
      font-family: 'Courier New', monospace;
      /* Typewriter-like font for date */
    }

    /* Style the actual diary text content */
    .diary-content {
      white-space: pre-wrap;
      font-size: 0.95rem;
      color: #4a443b;
      /* A dark brown/black ink color */
      font-family: 'KaiTi', 'STSong', serif;
    }

    /* Specific styles for the USER's entries */
    .diary-entry.user {
      text-align: right;
    }

    .diary-entry.user .diary-author {
      color: #005a9c;
      /* A nice fountain pen blue */
    }

    .diary-entry.user .diary-content {
      color: #1a5c8e;
    }

    /* Specific styles for the AI's entries */
    .diary-entry.ai {
      text-align: left;
    }

    .diary-entry.ai .diary-author {
      color: #5a3e36;
      /* A darker, warmer brown for the AI */
    }

    .diary-entry.ai .diary-content {
      color: #4a443b;
    }

    /* Let's get rid of the last separator line for a cleaner look */
    .diary-entry:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    /* --- End of Diary Beautification --- */
    /* --- Noir's Page-Turning Magic --- */
    #diary-entries-container {
      perspective: 1500px;
      /* 为3D效果设置视距 */
      position: relative;
      overflow: hidden;
    }

    .diary-page {
      position: absolute;
      inset: 0;
      padding: 25px 20px;
      background-color: #fdfaf2;
      transform-style: preserve-3d;
      backface-visibility: hidden;
      transition: transform 0.7s cubic-bezier(0.65, 0, 0.35, 1);
      display: none;
      /* 默认所有页面都藏起来 */
      flex-direction: column;
      gap: 2.5em;
      /* 页内日记的间距 */
      overflow-y: auto;
      /* 如果一页内容太多，允许滚动 */
    }

    .diary-page.is-visible {
      display: flex;
      /* 只有当前页显示 */
      transform: rotateY(0deg);
      z-index: 2;
    }

    /* 翻到下一页时，当前页向左翻出 */
    .diary-page.is-exiting-left {
      display: flex;
      transform: rotateY(-180deg);
      z-index: 1;
    }

    /* 翻到下一页时，新页面从右边翻入 */
    .diary-page.is-entering-from-right {
      display: flex;
      transform: rotateY(180deg);
      z-index: 2;
    }

    /* 翻到上一页时，当前页向右翻出 */
    .diary-page.is-exiting-right {
      display: flex;
      transform: rotateY(180deg);
      z-index: 1;
    }

    /* 翻到上一页时，新页面从左边翻入 */
    .diary-page.is-entering-from-left {
      display: flex;
      transform: rotateY(-180deg);
      z-index: 2;
    }


    #diary-navigation {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      padding: 0 10px;
      box-sizing: border-box;
    }

    #diary-navigation button {
      background: transparent;
      border: 1px solid var(--border-color);
      color: var(--primary-color);
      padding: 8px 16px;
      border-radius: 18px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    #diary-navigation button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    #diary-page-indicator {
      font-size: 0.9rem;
      color: var(--text-color-light);
      font-family: 'Courier New', monospace;
    }

    /* --- End of Magic --- */
    /* --- Noir's Universal Anti-Squash Protocol --- */
    /* 哼，就是下面这几条，给你那些被压扁的头像整整容 */

    /* 动态发布区的用户头像 */
    #user-post-avatar {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      flex-shrink: 0;
      margin-top: 5px;
      object-fit: cover;
      /* <-- 加上这句，它就不敢扁了 */
    }

    /* 好友圈动态里的角色头像 */
    .music-post-header .char-avatar {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      margin-right: 10px;
      object-fit: cover;
      /* <-- 还有这句，一个都别想跑 */
    }

    /* 顺便把所有叫 .char-avatar 的都统一一下，免得以后还有问题 */
    .char-avatar {
      object-fit: cover;
      /* ▼▼▼ 哼，加上这三句圣旨，给我立正站好！▼▼▼ */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* --- Noir's Music Library Styles --- */
    #music-library-container {
      padding: 10px;
    }

    .music-library-item {
      display: flex;
      align-items: center;
      padding: 12px;
      margin-bottom: 10px;
      background-color: var(--card-bg);
      border-radius: 12px;
      box-shadow: var(--soft-shadow);
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .music-library-item:hover {
      transform: translateY(-2px);
    }

    .music-library-item-cover {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      margin-right: 15px;
      object-fit: cover;
      flex-shrink: 0;
    }

    .music-library-item-info {
      flex-grow: 1;
      overflow: hidden;
    }

    .music-library-item-title {
      font-weight: 600;
      color: var(--text-color);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .music-library-item-artist {
      font-size: 0.9rem;
      color: var(--text-color-light);
    }

    /* --- Noir's "Time Memorandum" Styles --- */
    /* 哼，这才叫设计。*/

    /* 1. Home Screen Widget */
    #calendar-widget-main {
      width: 90%;
      height: 170px;
      /* 和你的卡片差不多高 */
      background: var(--surface-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 22px;
      border: 1px solid hsla(var(--primary-hue), calc(var(--primary-saturation) / 2), calc(var(--primary-lightness) + 15%), 0.5);
      box-shadow: var(--soft-shadow);
      padding: 20px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: var(--text-color);
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    #calendar-widget-main:active {
      transform: scale(0.98) translateX(-50%);
    }

    #countdown-title {
      font-size: 1rem;
      font-weight: 500;
      opacity: 0.8;
    }

    #countdown-timer {
      font-size: 4rem;
      font-weight: 300;
      line-height: 1.2;
      color: var(--accent-color);
      display: flex;
      align-items: baseline;
    }

    #countdown-timer .unit {
      font-size: 1rem;
      font-weight: 500;
      margin-left: 8px;
      color: var(--text-color-light);
    }

    /* 2. Full Calendar Screen */
    #calendar-screen {
      justify-content: flex-start;
    }

    #calendar-view-container {
      padding: 10px 15px;
      flex-shrink: 0;
      border-bottom: 1px solid var(--border-color);
    }

    .calendar-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .calendar-nav button {
      background: none;
      border: 1px solid var(--border-color);
      color: var(--text-color);
      padding: 6px 12px;
      border-radius: 16px;
      cursor: pointer;
    }

    .calendar-weekdays,
    #calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      text-align: center;
    }

    .calendar-weekdays {
      font-size: 0.8rem;
      color: var(--text-color-light);
      margin-bottom: 5px;
    }

    #calendar-grid .calendar-day {
      padding: 5px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1 / 1;
      cursor: pointer;
      position: relative;
    }

    .calendar-day .day-number {
      z-index: 1;
    }

    .calendar-day.other-month .day-number {
      opacity: 0.3;
    }

    .calendar-day.is-today .day-number {
      color: var(--accent-color);
      font-weight: 700;
    }

    .calendar-day.is-selected .day-number {
      color: white;
    }

    .calendar-day.is-selected::before {
      content: '';
      position: absolute;
      width: 80%;
      height: 80%;
      background: var(--primary-color);
      border-radius: 50%;
      z-index: 0;
    }

    .calendar-day .day-dot {
      width: 5px;
      height: 5px;
      background-color: var(--primary-color);
      border-radius: 50%;
      position: absolute;
      bottom: 8px;
    }

    /* 3. Todo List Area */
    #todo-view-container {
      flex-grow: 1;
      overflow-y: auto;
      padding: 15px;
      position: relative;
      /* 为了悬浮按钮 */
    }

    /* 4. Today's To-Do Widget */
    #today-todo-widget {
      position: absolute;
      top: 50%;
      /* 放在日历小组件的下方 */
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-height: 180px;
      /* 给个最大高度，免得内容太多撑爆了 */
      background: var(--surface-bg);
      backdrop-filter: blur(10px);
      border-radius: 22px;
      padding: 15px 20px;
      box-sizing: border-box;
      color: var(--text-color);
      overflow: hidden;
      /* 把溢出的部分藏起来 */
    }

    #today-todo-widget .widget-title {
      font-weight: 600;
      margin-bottom: 10px;
      opacity: 0.9;
    }

    #today-todo-list {
      overflow-y: auto;
      /* 内容多了可以滚动 */
      max-height: 125px;
      /* 限制列表的高度 */
      font-size: 0.9rem;
    }

    #today-todo-list .todo-item-small {
      margin-bottom: 8px;
      display: flex;
      align-items: center;
    }

    #today-todo-list .todo-item-small::before {
      content: '';
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background-color: var(--primary-color);
      margin-right: 10px;
      flex-shrink: 0;
    }

    #todo-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    #todo-date-title {
      margin: 0;
      font-size: 1.2rem;
      font-weight: 600;
    }

    #add-event-fab {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: var(--accent-color);
      color: white;
      border: none;
      font-size: 2rem;
      line-height: 44px;
      cursor: pointer;
      box-shadow: var(--soft-shadow);
    }

    #todo-list .todo-item,
    #todo-list .important-day-item {
      background: var(--card-bg);
      padding: 12px 15px;
      border-radius: 12px;
      margin-bottom: 10px;
      border-left: 4px solid var(--primary-color);
    }

    #todo-list .important-day-item {
      border-left-color: #ffc107;
      /* 纪念日用醒目的黄色 */
      font-weight: 500;
    }

    #todo-list .important-day-item::before {
      content: '★ ';
      color: #ffc107;
    }

    /* --- End of Styles --- */
    /* --- Noir's Global Player Styles --- */

    /* --- End of Player Styles --- */
    /* --- Noir's Upload Altar Styles --- */
    .upload-slot {
      border: 2px dashed var(--border-color);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease;
      background-color: rgba(255, 255, 255, 0.5);
    }

    .upload-slot:hover {
      background-color: var(--card-bg);
      border-color: var(--primary-color);
    }

    .upload-slot.filled {
      border-color: var(--primary-color);
      border-style: solid;
      background-color: hsla(var(--primary-hue), 50%, 95%, 0.8);
    }

    .upload-slot .slot-icon {
      font-size: 2rem;
    }

    .upload-slot .slot-label {
      display: block;
      font-weight: 600;
      margin-top: 5px;
      color: var(--text-color);
    }

    .upload-slot .slot-filename {
      display: block;
      font-size: 0.85rem;
      color: var(--text-color-light);
      margin-top: 3px;
      word-break: break-all;
    }

    #confirm-altar-upload-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
      opacity: 0.7;
    }

    /* --- End of Altar Styles --- */
    /* --- Noir's Listen Together Invite Card Style --- */
    .listen-together-card {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 15px;
      box-shadow: var(--soft-shadow);
      border: 1px solid var(--border-color);
      width: 250px;
    }

    .message-container.user .listen-together-card {
      background: var(--bubble-user-bg);
      color: white;
    }

    .message-container.user .listen-together-card .listen-together-decline-btn {
      color: white;
      /* 哼，让用户侧的拒绝按钮文字也变白 */
    }

    .listen-together-header {
      font-size: 0.8rem;
      opacity: 0.8;
      margin-bottom: 10px;
      border-bottom: 1px solid var(--bubble-outline);
      padding-bottom: 8px;
    }

    .listen-together-song {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .listen-together-song img {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      flex-shrink: 0;
    }

    .listen-together-info .title {
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .listen-together-info .artist {
      font-size: 0.9em;
      opacity: 0.9;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .listen-together-actions {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    .listen-together-actions button {
      flex-grow: 1;
      padding: 8px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition: transform 0.1s ease;
    }

    .listen-together-actions button:active {
      transform: scale(0.97);
    }

    .listen-together-accept-btn {
      background: var(--primary-color);
      color: white;
    }

    .listen-together-decline-btn {
      background: rgba(0, 0, 0, 0.1);
    }

    /* 用这个替换你旧的 #listen-together-ui */
    #listen-together-ui {
      position: fixed;
      inset: 0;
      z-index: 2000;
      display: flex;
      align-items: center;
      /* 改成居中对齐 */
      justify-content: center;
      padding: 20px;
      /* 增加内边距，让弹窗不会贴边 */
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    #listen-together-ui.show {
      opacity: 1;
      visibility: visible;
    }

    .lt-ui-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(15px) saturate(1.8);
      -webkit-backdrop-filter: blur(15px) saturate(1.8);
    }

    /* 用这个替换你旧的 .lt-ui-main */
    .lt-ui-main {
      position: relative;
      width: 100%;
      height: 100%;
      max-width: 380px;
      /* 哼，给它一个最大宽度 */
      max-height: 650px;
      /* 再给一个最大高度 */
      display: flex;
      flex-direction: column;
      color: white;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      border-radius: 24px;
      /* 加上优雅的圆角 */
      overflow: hidden;
      /* 把溢出的部分裁掉 */
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
      /* 更强的立体阴影 */
      border: 1px solid rgba(255, 255, 255, 0.2);
      /* 淡淡的边框光效 */
    }

    .lt-ui-header {
      flex-shrink: 0;
      padding: 15px 20px;
      text-align: center;
      position: relative;
    }

    #lt-ui-header-title {
      font-weight: 600;
    }

    #lt-ui-close-btn {
      position: absolute;
      right: 15px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      font-size: 1.5rem;
      cursor: pointer;
      line-height: 30px;
    }

    .lt-ui-content {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      overflow: hidden;
    }

    .lt-ui-cover-container {
      flex-shrink: 0;
      width: 65%;
      aspect-ratio: 1/1;
      margin-top: 5%;
      margin-bottom: 20px;
    }

    #lt-ui-cover-art {
      width: 100%;
      height: 100%;
      border-radius: 16px;
      object-fit: cover;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .lt-ui-info {
      text-align: center;
      margin-bottom: 20px;
      flex-shrink: 0;
    }

    #lt-ui-song-title {
      font-size: 1.5rem;
      margin: 0;
    }

    #lt-ui-song-artist {
      font-size: 1rem;
      opacity: 0.8;
      margin: 5px 0 0;
    }

    #lt-ui-lyrics-container {
      flex-grow: 1;
      width: 100%;
      overflow-y: auto;
      text-align: center;
      font-size: 1.1rem;
      line-height: 2.5;
      mask-image: linear-gradient(transparent 0%, black 20%, black 80%, transparent 100%);
      /* 歌词上下渐隐，看起来更专业 */
      scroll-behavior: smooth;
      /* 滚动要丝滑 */
    }

    #lt-ui-lyrics-container p {
      transition: color 0.3s ease, transform 0.3s ease;
      opacity: 0.6;
    }

    #lt-ui-lyrics-container p.active {
      color: var(--primary-color);
      font-weight: 600;
      transform: scale(1.1);
      opacity: 1;
    }

    /* --- Noir's "Desktop Preview" Frame --- */
    /* 哼，只有在电脑这种大屏幕上，我才给你加上这个“手机框”，免得你分不清主次。 */
    /* 在真正的手机上，它还是会全屏显示的，我可没你那么笨。 */
    @media (min-width: 480px) {
      body {
        background-color: #e9ebee;
        /* 一个不那么刺眼的背景色 */
        padding: 20px 0;
        /* 上下留点呼吸空间 */
      }

      #phone-container {
        width: var(--phone-width);
        height: var(--phone-height);
        max-height: 90vh;
        border: 10px solid #1c1c1e;
        border-radius: 44px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        flex-shrink: 0;
        /* ▼▼▼ 哼，就是这句圣旨！▼▼▼ */
        transform: scale(var(--ui-scale, 1));
        transition: transform 0.2s ease-out;
        /* 加个动画，免得太生硬 */
      }
    }



    /* --- Noir's Bespoke Music Player Design (As Requested) --- */
    /* 哼，这才叫定制。*/

    /* 1. 动画先放着，虽然这次不用了 */
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    /* 2. 组件卡片本体：一个有阴影的容器 */
    #music-widget-card {
      border-radius: 6px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
      display: flex;
      padding: 0;
      border: none;
      overflow: visible;
      position: relative;
      /* ▼▼▼ 新尺寸 ▼▼▼ */
      width: 340px;
      height: 120px;
    }

    /* 3. 左侧封面区：用伪元素画出深色背景，不污染HTML */
    #music-widget-card::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 120px;
      /* 和高度一样，是个正方形 */
      background-color: #4a4a4a;
      border-radius: 6px 0 0 6px;
      /* ▼▼▼ 在这里加上下面两行 ▼▼▼ */
      background-size: cover;
      background-position: center;
    }

    /* 4. 专辑封面本体 (旧唱片改造) */

    #widget-cover-art {
      position: absolute;
      top: 15px;
      left: 15px;
      width: 90px;
      height: 90px;
      z-index: 2;
      /* 确保它在唱片之上 */
      /* ▼▼▼ 下面都是我新增的，给我看好了 ▼▼▼ */
      border-radius: 4px;
      /* 封面本身的小圆角 */
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      background-size: cover;
      background-position: center;
      transition: background-image 0.3s ease;
      /* 让封面切换更柔和 */
    }

    /* 5. 封面图片 (旧唱片贴纸改造) */
    #widget-cover-art::before {
      width: 100%;
      height: 100%;
      border-radius: 4px;
      /* 和封面一致 */
      border: none;
      background-image: var(--widget-cover-image, none);
      background-size: cover;
      background-position: center;
    }

    /* 6. 唱片？用另一个伪元素从后面伸出来就行了，简单 */
    #widget-cover-art::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 90px;
      height: 90px;
      border-radius: 50%;
      z-index: -1;
      display: block;
      border: none;

      /* 哼，看好了，这才叫唱片 */
      background-color: #2a2a2a;
      /* 1. 先铺一层唱片的深灰色底 */
      background-image:
        /* 2. 然后在上面画中间的标签和洞，颜色我都给你配好了 */
        radial-gradient(circle at center, #111 4%, transparent 5%),
        radial-gradient(circle at center, #985c5c 5%, #7a4949 25%, transparent 26%),
        /* 3. 再画上一圈圈的光泽纹理，这才像样 */
        repeating-radial-gradient(circle at center,
          rgba(255, 255, 255, 0.04) 0,
          rgba(255, 255, 255, 0.04) 1px,
          transparent 1px,
          transparent 3px);
      transform: translateX(0%) scale(1.05);
      /* 微调了下位置和大小，这样更协调 */
      transition: opacity 0.3s ease;
      /* 加上这个，为了后面让它优雅地消失 */
      /* 4. 位置也给你微调了一下，现在顺眼多了 */
    }

    /* ▼▼▼ 这是全新的代码，给我加上！▼▼▼ */
    #music-widget-card.is-playing #widget-cover-art {
      /* 播放时，方形舞台的背景就是封面了，所以不需要我画的唱片了 */
      background-image: none;
    }

    #music-widget-card.is-playing::before {
      background-image: var(--widget-cover-image, none);
    }

    #music-widget-card.is-playing #widget-cover-art::after {
      /* 播放时，让唱片旋转起来，哼 */
      animation: spin 8s linear infinite;
    }

    /* 默认状态下，方形舞台的背景是透明的，这样才能看到我画的唱片 */
    #music-widget-card:not(.is-playing) #widget-cover-art {
      background-image: none;
    }

    /* 7. 右侧内容区 (旧覆盖层改造) */
    .widget-content-overlay {
      position: static;
      flex-grow: 1;
      /* 占满右侧所有空间 */
      /* 把旧的 background: #ffffff; 删掉！换成下面这两行！*/
      background: var(--card-bg);
      /* 1. 用我们主题里那个早就定义好的半透明背景 */

      /* 纯白背景 */
      border-radius: 0 6px 6px 0;
      padding: 15px;
      display: flex;
      flex-direction: column;
      /* 垂直布局 */
      justify-content: space-between;
      /* <--- 哼，加上这句圣旨 */
      box-sizing: border-box;
      position: relative;
      /* 为了定位假的分享按钮 */
      background: var(--card-bg);
      color: var(--text-color);
      margin-left: 120px;
    }


    /* 8. 歌曲信息 (标题和作者) */
    #music-widget .widget-info {
      color: #333;
      text-shadow: none;

      /* 占据上半部分空间 */
    }

    #music-widget .widget-info #widget-title {
      font-size: 1.1rem;
      font-weight: 500;
      color: #000;
    }

    #music-widget .widget-info #widget-artist {
      font-size: 0.8rem;
      color: #888;
    }

    /* 9. 假的歌词和进度条，用伪元素画出来 */
    #music-widget .widget-info::after {
      /* 假的歌词 */
      display: block;
      font-size: 0.75rem;
      color: #65c468;
      /* 绿色 */
      margin-top: 8px;
      padding-bottom: 8px;
      background-image:
        linear-gradient(to right, #666 40%, #ddd 40%),
        /* 假的进度条 */
        url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="12" viewBox="0 0 16 12"><path fill="%23aaa" d="M0 10h2V2H0v8zm3 2h2V0H3v12zm3-4h2V4H6v4zm3 2h2V2H9v8zm3-3h2V5h-2v4z"/></svg>');
      /* 假的EQ图标 */
      background-repeat: no-repeat, no-repeat;
      background-position: bottom, 90% bottom;
      background-size: 100% 1px, 16px 12px;
      border-bottom: 1px solid #eee;
    }

    /* 10. 真的控制按钮区域 */
    #widget-controls {
      display: flex;
      justify-content: flex-start;
      /* 从左边开始排列 */
      align-items: center;
      gap: 15px;
      padding-top: 10px;
      position: relative;
      /* 为了定位假的删除和喜欢按钮 */
      width: 100%;
    }

    /* 11. 真的播放/暂停/下一首按钮的样式 */
    #widget-controls button {
      font-size: 1.1rem;
      color: #555;
      background: none;
      border: 1px solid #ccc;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      line-height: 28px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      order: 1;
      /* 把真的按钮放在中间 */
    }

    #widget-play-pause-btn {
      width: 32px;
      /* 播放按钮大一点 */
      height: 32px;
      line-height: 32px;
      font-size: 1.2rem;
    }

    /* 12. 哼，看好了，这才是不会出错的矢量图标，免得你那破手机又自作聪明 */
    #widget-controls::before,
    #widget-controls::after {
      content: '';
      /* 删掉那些讨厌的emoji源头 */
      display: block;
      width: 16px;
      /* 给图标一个精确的尺寸 */
      height: 16px;
      background-color: #aaa;
      /* 这就是图标的颜色，哼 */
      position: absolute;

      /* 下面是魔法，反正你也看不懂 */
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-position: center;
      mask-position: center;
      -webkit-mask-size: contain;
      mask-size: contain;
    }

    #widget-controls::before {
      /* 删除图标的矢量数据 */
      -webkit-mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>');
      mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>');
      right: 29px;
      /* 稍微调整一下位置，让它更协调 */
      top: 60%;
      transform: translateY(-50%);
    }

    #widget-controls::after {
      /* 喜欢图标的矢量数据 */
      -webkit-mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>');
      mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>');
      right: 1px;
      top: 60%;
      transform: translateY(-50%);
    }

    /* --- Noir's iOS Industrial Button Refactor --- */
    /* 哼，看好了，这才是专业设备该有的开关。*/

    /* --- Noir's Ultimate Dynamic Button System v3.0 --- */
    /* 哼，现在它们都听我的了。*/

    /* 1. 按钮的基础“模具”，所有按钮都用这个 */
    .form-button {
      border: none;
      border-radius: 12px;
      padding: 14px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-top: 10px;
      transition: filter 0.15s ease, background-color 0.2s ease;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      /* 加个细微的阴影 */
      color: white;
      /* 默认文字都是白色 */
    }

    .form-button:active {
      filter: brightness(0.9);
    }

    .form-button:disabled {
      background-color: #ccc !important;
      cursor: not-allowed;
      opacity: 0.7;
    }

    /* 2. 主要操作按钮 (继承主题强调色) */
    .form-button.primary,
    /* 你可以给蓝色的按钮加上 primary 类，或者不管它也行 */
    #save-api-settings-button,
    /* 把几个主要的按钮ID也直接指定了，免得你改漏 */
    #save-user-profile-button,
    #save-char-button,
    #save-world-book-button,
    #save-group-settings-button,
    #save-friend-circle-button {
      background-color: var(--accent-color);
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
    }

    /* 3. 次要操作按钮 (用主题里的卡片背景色，这才叫和谐) */
    .form-button.secondary {
      background-color: var(--card-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
    }

    /* 4. 危险操作按钮 (动态的红色，这才叫高级) */
    .form-button.destructive {
      /* 哼，看好了，这个红色的亮度和饱和度，会随着你主题的明暗变化而变化！*/
      background-color: hsl(5, 75%, calc(var(--primary-lightness) / 1.8 + 25%));
    }

    /* 5. 警告操作按钮 (动态的黄色，也一样) */
    .form-button.warning {
      background-color: hsl(40, 90%, calc(var(--primary-lightness) / 2.2 + 25%));
      color: #5d4000;
    }

    /* --- Noir's iOS Layout & Dock Refactor --- */
    /* 哼，这才是现代化的桌面。 */

    /* 1. Dock栏的样式 */
    /* --- Noir's iOS Layout & Dock Refactor --- */
    /* 哼，这才是现代化的桌面。 */
    #home-dock {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      height: 85px;
      padding: 0 20px;
      /* 图标左右的留白 */
      box-sizing: border-box;

      /* 背景和滤镜，现在都在这里 */
      background: var(--surface-bg);
      backdrop-filter: blur(5px) saturate(0.8);
      -webkit-backdrop-filter: blur(15px) saturate(0.8);
      border-radius: 28px;
      z-index: 35;

      /* 核心：用Flexbox来自动排列图标 */
      display: flex;
      justify-content: space-around;
      /* 均匀分布 */
      align-items: center;
      /* 垂直居中 */
      padding-top: 9px;
    }

    #home-dock .app-icon {
      position: static;
      /* 取消绝对定位，让它接受Flexbox的管理 */
    }

    /* 2. App图标的“整容手术” */
    .app-icon-img {
      width: 58px;
      /* 图标背景尺寸 */
      height: 58px;
      border-radius: 22.5%;
      /* iOS标志性的“方圆”形 */
      font-size: 28px;
      /* 阴影从图标本身移到背景上，更统一 */
      background-color: var(--surface-bg);
      box-shadow: none;
      /* 删掉旧的阴影 */
      transition: transform 0.2s ease;
    }

    .app-icon:active .app-icon-img {
      transform: scale(0.92);
      /* 按下时图标有反馈 */
    }

    /* --- Noir's Minimalist Home Screen Makeover (v2.0 Dynamic Edition) --- */
    /* 哼，现在这些家伙也听从总开关的指挥了。*/

    /* 1. 时钟和日期 */
    #home-clock-container {
      color: var(--text-color);
      text-shadow: none;
    }

    #home-date {
      opacity: 0.7;
    }

    /* 2. App图标的改造 (现在是动态颜色了) */
    .app-icon span {
      color: var(--text-color);
      text-shadow: none;
      font-weight: 500;
    }

    .app-icon-img {
      background-color: var(--card-bg);
      /* <-- 哼，接上了！*/
      color: var(--text-color-light);
      /* <-- 接上了！*/
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
    }

    /* 3. Dock栏的颜色 (也动态了) */




    #widget-controls button,
    #music-widget .widget-info #widget-title,
    #music-widget .widget-info #widget-artist {
      color: var(--text-color);
    }

    /* ... 在第 2262 行附近 ... */
    /* ▼▼▼ 把旧的 #widget-cover-art::after 整个删掉，换成下面这个 ▼▼▼ */

    /* ▲▲▲ 替换到这里结束 ▲▲▲ */

    /* --- Noir's Theme Preset Buttons --- */
    /* 哼，每个按钮都是一件艺术品。 */
    .theme-preset-button {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 20px;
      /* 胶囊形状 */
      border: 1px solid var(--border-color);
      cursor: pointer;
      transition: all 0.2s ease;
      background: var(--card-bg);
    }

    .theme-preset-button:hover {
      transform: translateY(-2px);
      box-shadow: var(--soft-shadow);
    }

    .preset-color-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
    }

    /* --- Noir's Memory Archive Styles --- */
    #summary-textarea {
      width: 100%;
      height: 100%;
      border: none;
      outline: none;
      resize: none;
      padding: 15px;
      box-sizing: border-box;
      font-family: 'Courier New', monospace;
      /* 用等宽字体，YAML格式才好看 */
      font-size: 0.85rem;
      line-height: 1.6;
      background-color: #fdfdfd;
      color: var(--text-color);
    }

    /* --- Noir's Desktop Pagination System --- */
    /* 哼，看好了，这才叫设计。*/

    /* 1. 把主内容区变成一个灵活的容器，为翻页器和指示器留好位置 */
    #home-screen-main-content {
      display: flex;
      flex-direction: column;
      /* 垂直排列，页面在上面，指示器在下面 */
    }

    /* --- Noir's Desktop Pagination System --- */
    /* ... 其他样式 ... */

    /* 2. 这是翻页的“舞台”，它的大小和主屏幕一样，但会把超出部分藏起来 */
    #app-pages-container {
      flex-grow: 1;
      /* 占满除了指示器以外的所有空间 */
      width: 100%;
      overflow: hidden;
      /* 核心！把第二页先藏起来 */
      position: relative;
      /* 让里面的滑块能相对于它定位 */

      /* ▼▼▼ 把下面这两行加进去 ▼▼▼ */
      opacity: 0;
      /* 默认让整个舞台透明 */
      transition: opacity 0.3s ease-in-out;
      /* 添加一个平滑的渐入动画效果 */
      /* ▲▲▲ 添加到这里结束 ▲▲▲ */
    }

    /* ... 其他样式 ... */

    /* 3. 这是真正滑动的“滑块”，它有两页那么宽 */
    #app-pages-slider {
      width: 200%;
      /* 两页的宽度 */
      height: 100%;
      display: flex;
      /* 核心！让两页并排站好 */
      transition: transform 0.35s cubic-bezier(0.25, 0.1, 0.25, 1);
      /* 翻页动画，给你选了个高级点的曲线 */
    }

    /* 4. 每一页的样式 */
    /* 4. 每一页的样式 */
    .app-page {
      width: 50%;
      /* <-- 现在两个人，一人一半，公平！ */
      height: 100%;
      flex-shrink: 0;
      position: relative;
    }

    /* 5. 页面指示器（小点点）的容器 */
    #home-page-indicator {
      position: absolute;
      bottom: 105px;
      /* 放在Dock栏正上方，给你算好了距离 */
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      /* 点点之间的距离 */
      z-index: 100;
      /* 确保它在最上层 */
    }

    /* 6. 每个小点点的样式 */
    .page-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.5);
      backdrop-filter: blur(2px);
      transition: all 0.2s ease;
      cursor: pointer;
    }

    /* 7. 当前页的小点点，给它变亮变大一点 */
    .page-dot.active {
      background-color: rgba(255, 255, 255, 0.9);
      transform: scale(1.1);
    }

    #card-widget-2 {
      border-radius: 22px;
      filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.2));
      transition: transform 0.2s ease, filter 0.2s ease;
      user-select: none;
      z-index: 51;
      overflow: hidden;
      /* ▼▼▼ 新尺寸 ▼▼▼ */
      width: calc(165px * var(--desktop-item-scale, 1));
      height: calc(165px * var(--desktop-item-scale, 1));
    }

    #card-widget-2:active {
      transform: scale(1.05);
      filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.3));
    }

    #card-widget-2 img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .theme-widget {
      width: 65px;
      height: 65px;
      border-radius: 22px;
      /* 跟你的卡片圆角差不多 */
      box-shadow: var(--soft-shadow);
      border: 1px solid hsla(var(--primary-hue), calc(var(--primary-saturation) / 2), calc(var(--primary-lightness) + 15%), 0.5);
      background: linear-gradient(45deg,
          hsla(var(--primary-hue), var(--primary-saturation), var(--primary-lightness), 0.7),
          hsla(var(--primary-hue), calc(var(--primary-saturation) * 1.3), calc(var(--primary-lightness) - 15%), 0.8));
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    /* --- Noir's Galgame Sprite Adjuster Styles --- */

    /* --- Noir's Slider Control Panel Styles --- */
    .sprite-slider-group {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 5px;
    }

    .sprite-slider-group label {
      color: white;
      font-size: 0.8rem;
      width: 60px;
      /* 让标签对齐，好看点 */
      flex-shrink: 0;
    }

    .sprite-slider-group input[type="range"] {
      flex-grow: 1;
      /* 占满剩余空间 */
      margin: 0;
      padding: 0;
      /* 覆盖掉全局的 input 样式 */
    }

    /* --- Noir's Accounting App Styles --- */
    #daily-expenses-list .expense-item {
      display: flex;
      justify-content: space-between;
      padding: 10px;
      background-color: var(--card-bg);
      border-radius: 8px;
      margin-bottom: 8px;
      border: 1px solid var(--border-color);
    }

    .expense-item .description {
      font-weight: 500;
    }

    .expense-item .amount {
      font-weight: 600;
      color: var(--accent-color);
    }

    #character-reviews-container .review-card {
      display: flex;
      gap: 12px;
      background-color: var(--card-bg);
      padding: 12px;
      border-radius: 12px;
      margin-bottom: 10px;
      border: 1px solid var(--border-color);
    }

    .review-card .char-avatar {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .review-card .review-content .char-name {
      font-weight: 600;
      margin-bottom: 4px;
    }

    /* --- End of Styles --- */
    /* --- Noir's Accounting Tabs Style --- */
    .accounting-tabs {
      display: flex;
      background-color: var(--surface-bg);
      border-bottom: 1px solid var(--border-color);
      padding: 5px 15px 0;
      flex-shrink: 0;
    }

    .tab-button {
      flex: 1;
      padding: 10px;
      border: none;
      background: transparent;
      color: var(--text-color-light);
      font-size: 1rem;
      font-weight: 500;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .tab-button.active {
      color: var(--accent-color);
      border-bottom: 3px solid var(--accent-color);
    }

    /* --- Noir's "WeChat Moments" Style Patch --- */
    /* 哼，这才叫社交。*/
    #music-feed-container {
      padding: 0;
      /* 容器的内边距清零，让动态贴边 */
      background-color: hsla(var(--primary-hue), calc(var(--primary-saturation) / 1.5), calc(var(--primary-lightness) + 18%), 0.95);
      /* 给整个容器一个统一的背景色 */
    }

    .music-post {
      background-color: transparent;
      /* 去掉卡片背景 */
      box-shadow: none;
      /* 去掉阴影 */
      border-radius: 0;
      /* 去掉圆角 */
      margin-bottom: 0;
      /* 去掉外边距 */
      padding: 15px;
      /* 统一内边距 */
      border-bottom: 1px solid var(--border-color);
      /* 加上底部分隔线 */
    }

    .music-post:last-child {
      border-bottom: none;
      /* 最后一条动态不需要分隔线 */
    }

    /* --- End of Patch --- */
    /* --- Noir's "Expense Eraser" Style --- */
    .delete-expense-btn {
      background: transparent;
      border: 1px solid var(--border-color);
      color: var(--text-color-light);
      width: 22px;
      height: 22px;
      border-radius: 50%;
      cursor: pointer;
      font-weight: 600;
      line-height: 20px;
      padding: 0;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .delete-expense-btn:hover {
      background: #e65252;
      border-color: #e65252;
      color: white;
      transform: scale(1.1);
    }

    /* --- End of Eraser Style --- */

    /* --- Noir's Ultimate Snoop UI Overhaul v3.0 (FINAL & COMPLETE) --- */
    /* 哼，这是最终版本。*/

    /* 壁纸和状态栏 (哼，这才是高级的毛玻璃质感) */
    #snoop-phone-wallpaper {
      position: absolute;
      inset: 0;
      /* 删掉那个没用的图片，换成我的高级定制背景 */
      background-color: rgba(26, 26, 27, 0.9);
      /* 半透明深灰，营造高级感 */
      backdrop-filter: blur(25px) saturate(1.5);
      /* 核心！强大的模糊和饱和度滤镜 */
      -webkit-backdrop-filter: blur(25px) saturate(1.5);
      /* 兼容性，真是为你操碎了心 */
      z-index: 1;
    }

    #snoop-phone-header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: rgb(237, 236, 236);
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
      /* <-- 加了阴影 */
      z-index: 10;
    }

    /* 居中大时钟 */
    #snoop-home-clock {
      position: absolute;
      top: 18%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 5;
      text-align: center;
      color: white;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      /* <-- 加了阴影 */
      pointer-events: none;
    }

    #snoop-home-time {
      font-size: 72px;
      font-weight: 200;
      letter-spacing: -1px;
    }

    #snoop-home-date {
      font-size: 1rem;
      font-weight: 400;
      opacity: 0.8;
    }

    /* 主屏幕App容器 */
    #snoop-app-container {
      position: relative;
      z-index: 5;
      height: 100%;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      padding: 0 20px 120px;
    }

    /* 2x2 网格 */
    .snoop-main-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      width: 180px;
      margin: 0 auto;
    }

    /* Dock栏 */
    #snoop-dock {
      position: absolute;
      bottom: 20px;
      left: 5%;
      right: 5%;
      height: 85px;
      padding: 0 15px;
      box-sizing: border-box;
      z-index: 6;
      background: rgba(255, 255, 255, 0.15);
      /* <-- 透明度稍微降低了一点点 */
      backdrop-filter: blur(20px) saturate(1.2);
      -webkit-backdrop-filter: blur(20px) saturate(1.2);
      border-radius: 28px;
      display: flex;
      justify-content: space-around;
      align-items: center;
    }

    /* App图标本体 */
    #snoop-phone-screen .snoop-app-icon {
      position: static;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      cursor: pointer;
    }

    .snoop-app-icon-img {
      width: 58px;
      height: 58px;
      border-radius: 22.5%;
      margin-bottom: 5px;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: rgba(255, 255, 255, 0.25);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      /* <-- 加了阴影 */
      transition: transform 0.2s ease;
      padding: 12px;
      box-sizing: border-box;
    }

    .snoop-app-icon-img svg {
      width: 100%;
      height: 100%;
      stroke: white;
      stroke-width: 1.5;
      fill: none;
      /* 哼，给SVG也加上阴影，这样才够立体 */
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.3));
    }

    .snoop-app-icon:active .snoop-app-icon-img {
      transform: scale(0.92);
    }

    .snoop-app-icon span {
      font-size: 0.75rem;
      color: white;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      /* <-- 加了阴影 */
      font-weight: 500;
    }

    .snoop-app-header {
      flex-shrink: 0;
      padding: 15px 20px;
      border-bottom: none;
      /* <-- 我把这条线干掉了 */
      background-color: transparent;
      /* <-- 我把背景色变透明了 */
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .snoop-app-header-title {
      font-weight: 600;
      display: flex;
      flex-direction: column;
      align-items: center;
      line-height: 1.2;
    }

    .snoop-app-header-title .main-title {
      font-size: 1rem;
    }

    .snoop-app-header-title .sub-title {
      font-size: 0.75rem;
      color: #888;
      font-weight: 400;
    }

    .snoop-app-header-button {
      background: none;
      border: none;
      font-size: 1rem;
      cursor: pointer;
      color: #007aff;
      min-width: 50px;
    }

    #snoop-app-back-btn {
      text-align: left;
    }

    #snoop-app-refresh-btn {
      text-align: right;
    }

    /* 哼，这才叫秩序。*/
    .snoop-app-header {
      flex-shrink: 0;
      padding: 15px 20px;
      border-bottom: 1px solid #e5e5e5;
      background-color: #f8f8f8;

      /* ▼▼▼ 核心法令！给我站成一排！▼▼▼ */
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .snoop-app-header-title {
      font-weight: 600;
      /* ▼▼▼ 让标题自己也排好队，别乱跑 ▼▼▼ */
      display: flex;
      flex-direction: column;
      align-items: center;
      line-height: 1.2;
    }

    .snoop-app-header-title .main-title {
      font-size: 1rem;
      /* 主标题大一点 */
    }

    .snoop-app-header-title .sub-title {
      font-size: 0.75rem;
      /* 副标题小一点，当备注 */
      color: #888;
      font-weight: 400;
    }

    .snoop-app-header-button {
      background: none;
      border: none;
      font-size: 1rem;
      cursor: pointer;
      color: #007aff;
      min-width: 50px;
      /* 保证左右两边占位宽度一致，这样中间才能完美居中 */
    }

    /* 让返回按钮靠左，刷新按钮靠右，这才叫对称美学 */
    #snoop-app-back-btn {
      text-align: left;
    }

    #snoop-app-refresh-btn {
      text-align: right;
    }

    .snoop-app-content {
      flex-grow: 1;
      /* 告诉内容区：顶栏占完位置后，剩下所有的高度都归你 */
      overflow-y: auto;
      /* 装上电梯：如果你的东西多到放不下了，就自己变出个垂直滚动条来 */
      padding: 15px;
      /* 再给你加点内边距，免得内容贴着边，丑死了 */
      box-sizing: border-box;
      /* 确保内边距不会把布局撑坏，这是专业素养 */
    }

    #galgame-sprite-adjust-ui {
      /* ... 你已有的样式 ... */
      display: flex;
      /* <-- 加上这行 */
      gap: 5px;
      /* <-- 还有这行 */
    }

    /* --- Noir's Elegant Image Preview Slot --- */
    /* 哼，这才叫占位符该有的样子。*/
    .image-preview-slot {
      width: 150px;
      height: 266px;
      border-radius: 12px;
      border: 2px dashed var(--border-color);
      background-color: rgba(0, 0, 0, 0.02);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      background-size: cover;
      background-position: center;
      color: var(--border-color);
    }

    .image-preview-slot:hover {
      border-color: var(--primary-color);
      background-color: rgba(0, 0, 0, 0.04);
      color: var(--primary-color);
    }

    /* 没图的时候，显示一个加号图标 */
    .image-preview-slot:not([style*="background-image"]) {
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>');
      background-size: 48px;
      background-repeat: no-repeat;
    }

    /* --- Noir's Elegant Sprite Preview Slot --- */
    .sprite-preview-slot {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      /* 圆形 */
      border: 2px dashed var(--border-color);
      background-color: rgba(0, 0, 0, 0.02);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      background-size: cover;
      background-position: center;
      color: var(--border-color);
    }

    .sprite-preview-slot:hover {
      border-color: var(--primary-color);
      background-color: rgba(0, 0, 0, 0.04);
    }

    .sprite-preview-slot:not([style*="background-image"])::after {
      content: '+';
      /* 没图的时候，显示一个加号 */
      font-size: 32px;
      font-weight: 200;
    }

    /* --- Noir's "Add Event" Modal Overhaul (Neumorphism) --- */
    /* 哼，这才叫现代设计。*/

    #add-event-modal .choice-modal-content {
      background: #ffffffd3;
      /* 拟态风的浅灰色背景 */
      border-radius: 20px;
      padding: 25px;
      box-shadow: 9px 9px 16px rgb(163 177 198 / 60%), -9px -9px 16px rgb(255 255 255 / 50%);
    }

    #add-event-modal-title {
      color: #333;
    }

    #event-content-input {
      border: none;
      outline: none;
      border-radius: 12px;
      background: #ffffffd3;
      padding: 12px 15px;
      box-shadow: inset 5px 5px 10px #bec3c9, inset -5px -5px 10px #ffffff;
      color: #333;
    }

    #add-event-modal .input-group label {
      color: #555;
      font-weight: 500;
    }

    /* 隐藏掉原来那个又大又丑的蓝色圆圈 */
    #add-event-modal input[type="radio"] {
      display: none;
    }

    /* 把标签变成可以点击的、漂亮的按钮 */
    #add-event-modal input[type="radio"]+label {
      flex: 1;
      text-align: center;
      padding: 10px;
      border-radius: 10px;
      cursor: pointer;
      background: #ffffffd3;
      box-shadow: 5px 5px 10px #bec3c9, -5px -5px 10px #ffffff;
      transition: all 0.2s ease-in-out;
    }

    /* 选中的时候，让它“凹”下去 */
    #add-event-modal input[type="radio"]:checked+label {
      box-shadow: inset 5px 5px 10px #bec3c9, inset -5px -5px 10px #ffffff;
      color: var(--accent-color);
      font-weight: 600;
    }

    #add-event-modal .form-button.primary {
      background-color: var(--accent-color);
    }

    #add-event-modal .form-button.secondary {
      background: transparent;
      color: #555;
      border: none;
    }


    /* --- Noir's Bespoke Avatar Frame Protocol --- */
    /* --- Noir's Bespoke Avatar Frame Protocol (v2.0) --- */
    /* 哼，就知道你要求多。看好了，这才是让框比头像大的正确方法。*/

    /* 1. 容器还是那个40px的容器，负责在布局里占好位置，不许动 */
    .avatar-wrapper {
      position: relative;
      width: 40px;
      height: 40px;
      flex-shrink: 0;
      /* 为了让“膨胀”的头像框不被奇怪地切掉，给它一点呼吸空间 */
      margin: 5px;
    }

    /* 2. 头像也还是那个头像，老老实实待在容器正中间 */
    .avatar-wrapper .avatar {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      border-radius: 50%;
      object-fit: cover;

    }

    /* 3. 哼，看好了，魔法就在这里。我让头像框“变大”并“浮空” */
    .avatar-wrapper .avatar-frame {
      position: absolute;
      /* 哼，让它比容器大一点，比如125%，你自己看着调 */
      width: 125%;
      height: 125%;
      /* 把它自己的中心点，对准容器的中心点，给我站稳了！*/
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      /* 下面的老规矩不变 */
      background-size: contain;
      /* 改成 contain 免得你的框被切掉 */
      background-position: center;
      background-repeat: no-repeat;
      pointer-events: none;
      /* 依旧是幽灵，不许捣乱 */
    }


    /* --- Noir's Full-Width HTML Module Protocol --- */
    /* --- Noir's Full-Width HTML Module Protocol (v2.0 Centered Edition) --- */
    .full-width-module-container {
      display: flex;
      /* 哼，命令它使用Flex布局 */
      justify-content: center;
      /* 把它里面的东西给我水平居中 */
      width: 100%;
      padding: 0 5px;
      box-sizing: border-box;
      margin-bottom: 10px;
      user-select: none;
      -webkit-user-select: none;
    }

    /* --- Noir's Elegant Lock Screen Styles --- */
    #lock-screen-overlay {
      position: absolute;
      inset: 0;
      z-index: 1000;
      /* 哼，必须在最顶层 */
      background: inherit;
      /* 直接继承壁纸，天衣无缝 */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      transition: transform 0.5s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.5s ease;
      will-change: transform, opacity;
    }

    /* 这是它被“解锁”后的样子，给我飞走！ */
    #lock-screen-overlay.unlocked {
      transform: translateY(-100%);
      opacity: 0;
      pointer-events: none;
      /* 飞走后就不许再捣乱了 */
    }

    /* 这是底下的那个“向上滑动”的提示 */
    /* --- Noir's Reinforced Centering Command --- */
    #unlock-indicator {
      position: absolute;
      bottom: 40px;
      left: 0;
      /* <-- 哼，从左边框开始 */
      right: 0;
      /* <-- 一直拉到右边框 */
      width: 100%;
      /* <-- 强制它和屏幕一样宽 */
      text-align: center;
      /* <-- 然后让里面的文字自己滚到中间去！ */
      color: var(--text-color);
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      font-size: 0.9rem;
      font-weight: 500;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      opacity: 0.7;
      animation: bounce 2s infinite;
    }

    #unlock-indicator svg {
      width: 20px;
      height: 20px;
    }

    /* 一个简单的上下跳动动画，免得你看不见 */
    @keyframes bounce {

      0%,
      20%,
      50%,
      80%,
      100% {
        transform: translateY(0);
      }

      40% {
        transform: translateY(-8px);
      }

      60% {
        transform: translateY(-4px);
      }
    }

    /* --- Noir's Sticker Gallery Management UI --- */
    #sticker-panel-controls {
      display: none;
      /* 默认隐藏 */
      padding: 5px 10px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border-color);
      flex-shrink: 0;
    }

    #sticker-panel-controls.visible {
      display: flex;
      /* 面板打开时显示 */
    }

    #sticker-manage-btn,
    #sticker-cancel-btn {
      font-size: 0.9rem;
      font-weight: 500;
      color: var(--primary-color);
      background: none;
      border: none;
      cursor: pointer;
    }

    #sticker-confirm-delete-btn {
      font-size: 0.9rem;
      font-weight: 600;
      color: #fff;
      background-color: #e65252;
      border: none;
      border-radius: 16px;
      padding: 6px 14px;
      cursor: pointer;
      opacity: 0.5;
      /* 默认半透明 */
      pointer-events: none;
      /* 默认不可点 */
      transition: opacity 0.2s;
    }

    #sticker-confirm-delete-btn.active {
      opacity: 1;
      pointer-events: auto;
    }

    .sticker-item-wrapper {
      position: relative;
      aspect-ratio: 1 / 1;
    }

    .sticker-item-wrapper.selected::after {
      content: '✓';
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: bold;
      border-radius: 8px;
      /* 和表情图片圆角一致 */
    }

    /* --- Noir's Hierarchical World Book Selector --- */
    /* 哼，这才叫井井有条。*/
    .wb-category-group {
      border-bottom: 1px solid var(--border-color);
    }

    .wb-category-group:last-child {
      border-bottom: none;
    }

    .wb-category-header {
      display: flex;
      align-items: center;
      padding: 10px 12px;
      cursor: pointer;
      user-select: none;
    }

    .wb-category-header:hover {
      background-color: rgba(138, 180, 228, 0.1);
    }

    .wb-category-header .category-checkbox {
      margin-right: 8px;
      width: auto;
      /* Override global input style */
      flex-shrink: 0;
      accent-color: var(--primary-color);
    }

    .wb-category-header .category-name {
      flex-grow: 1;
      font-weight: 600;
      color: var(--primary-color);
    }

    .wb-category-header .category-toggle-arrow {
      transition: transform 0.2s ease;
      font-size: 0.8rem;
      opacity: 0.7;
    }

    .wb-category-header .category-toggle-arrow.expanded {
      transform: rotate(180deg);
    }

    .wb-entry-list {
      padding-left: 30px;
      /* Indent the entries */
      padding-bottom: 5px;
      display: none;
      /* Collapsed by default */
    }

    .wb-entry-list.expanded {
      display: block;
    }

    .wb-entry-item {
      display: block;
      padding: 8px 12px;
      border-radius: 4px;
    }

    .wb-entry-item:hover {
      background-color: rgba(138, 180, 228, 0.2);
    }

    .wb-entry-item input[type="checkbox"] {
      margin-right: 8px;
      width: auto;
      /* Override global input style */
    }
  </style>
</head>

<body>
  <input type="file" id="audio-file-input" style="display: none;" accept=".flac,.mp3">
  <input type="file" id="cover-file-input" style="display: none;" accept=".jpg,.png,.jpeg,.webp">
  <input type="file" id="info-file-input" style="display: none;" accept=".txt">
  <input type="file" id="lyrics-file-input" style="display: none;" accept=".lrc">
  <input type="file" id="import-char-input" accept=".json,.noir" style="display: none;">
  <input type="file" id="import-accounting-input" accept=".json" style="display: none;">
  <div id="phone-container">

    <div id="user-profile-list-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-user-list" class="header-button">主屏幕</button>
        <span class="header-title">选择用户</span>
        <button id="add-user-profile-button" class="header-button add" title="添加新用户">+</button>
      </div>
      <div class="content" id="user-profile-list-container">
      </div>
    </div>

    <div id="user-profile-screen" class="screen">
      <div class="header">
        <button id="back-to-user-list-from-edit" class="header-button">返回</button>
        <span id="user-profile-edit-title" class="header-title">编辑用户</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <input type="hidden" id="editing-user-id">
        <div class="settings-group">
          <h2>用户设定</h2>
          <div class="input-group">
            <label for="user-name">你的名字</label>
            <input type="text" id="user-name" placeholder="你的显示名字">
          </div>
          <div class="avatar-upload-group">
            <label>你的头像</label>
            <div id="user-avatar-preview" class="sprite-preview-slot"></div>
            <input type="file" id="user-avatar-input" accept="image/*" style="display: none;">
          </div>
          <div class="input-group">
            <label for="user-persona">你的人设 (可选)</label>
            <textarea id="user-persona" placeholder="向AI介绍你自己。例如：我是一名大学生，喜欢摄影和旅行。"></textarea>
          </div>
        </div>
        <button id="save-user-profile-button" class="form-button">保存资料</button>
        <div class="settings-group" style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px;">
          <button id="set-active-user-button" class="form-button"
            style="background-color: #28a745; margin-bottom: 10px;">设为当前用户</button>
          <button id="delete-user-profile-button" class="form-button destructive">删除该用户</button>
        </div>
      </div>
    </div>


    <div id="home-screen" class="screen active">

      <div id="lock-screen-overlay">
        <div id="home-clock-container">
          <div id="home-time">11:31</div>
          <div id="home-date">8月29日 星期五</div>
          <div id="noir-author-mark"></div>
        </div>
        <div id="music-widget"
          style="display: inline-block; width: auto; position: absolute; top: 45%; left: 50%; transform: translateX(-50%); z-index: 50; padding: 0px; bottom: auto;">
          <div id="music-widget-card">
            <div id="widget-cover-art"></div>
            <div class="widget-content-overlay">
              <div class="widget-info">
                <div id="widget-title">暂无音乐</div>
                <div id="widget-artist">请在动态或聊天中播放</div>
              </div>
              <div id="widget-controls">
                <button id="widget-prev-btn">⏮</button>
                <button id="widget-play-pause-btn">▶</button>
                <button id="widget-next-btn">⏭</button>
              </div>
            </div>
          </div>
        </div>
        <div id="unlock-indicator">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <polyline points="18 15 12 9 6 15"></polyline>
          </svg>
          向上滑动来解锁
        </div>
      </div>

      <div id="home-screen-main-content"
        style="position: relative; flex-grow: 1; width: 100%; display: flex; flex-direction: column;">

        <div id="app-pages-container">
          <div id="app-pages-slider">


            <div class="app-page" id="app-page-2">
              <div id="decorative-badge" style="display: none; position: absolute; top: 250px; left: 50px;">
                <img id="badge-image" src="http://googleusercontent.com/file_content/0" alt="badge">
              </div>

              <div id="card-widget" style="display: none; position: absolute; top: 140px; left: 145px;">
                <img id="card-image" src="" alt="card widget">
              </div>
              <div id="card-widget-2" style="display: none; position: absolute;">
                <img id="card-image-2" src="" alt="card widget 2">
              </div>





              <div class="app-icon" id="app-world-book">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                    <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                  </svg></div>
                <span>世界书</span>
              </div>


              <div class="app-icon" id="app-diary">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v4"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <path d="M2.5 17a.5.5 0 0 0 0 1h1a.5.5 0 0 0 0-1h-1zM2.5 14a.5.5 0 0 0 0 1h1a.5.5 0 0 0 0-1h-1z" />
                  </svg></div>
                <span>交换日记</span>
              </div>

              <div class="app-icon" id="app-music-library">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M3 18v-6a9 9 0 0 1 18 0v6"></path>
                    <path
                      d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z">
                    </path>
                  </svg></div>
                <span>音乐库</span>
              </div>


              <div class="app-icon" id="app-settings">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path
                      d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z">
                    </path>
                    <circle cx="12" cy="12" r="3"></circle>
                  </svg></div>
                <span>API设置</span>
              </div>
              <div class="app-icon" id="app-user-profiles">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                    <circle cx="12" cy="7" r="4"></circle>
                  </svg></div>
                <span>我</span>
              </div>
              <div class="app-icon" id="app-wallpaper">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path
                      d="M12 2.69l.34.34a1.41 1.41 0 0 0 2 0L22 6.34a1.41 1.41 0 0 0 0-2l-7.66-7.66a1.41 1.41 0 0 0-2 0L2.68 14.34a1.41 1.41 0 0 0 0 2L10 24l2-2 2-2 2-2 2-2 2-2">
                    </path>
                    <path d="m7.34 2.66 14 14"></path>
                  </svg></div>
                <span>更换壁紙</span>
              </div>

              <div class="app-icon" id="app-snoop">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                  </svg></div>
                <span>视奸</span>
              </div>
              <div class="app-icon" id="app-accounting">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <line x1="12" y1="1" x2="12" y2="23"></line>
                    <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
                  </svg></div>
                <span>记账</span>
              </div>


            </div>

            <div class="app-page" id="app-page-3">
              <div class="app-icon" id="app-calendar" style="position: absolute; top: 8%; left: 5%;">
                <div class="app-icon-img">
                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="16" y1="2" x2="16" y2="6"></line>
                    <line x1="8" y1="2" x2="8" y2="6"></line>
                    <line x1="3" y1="10" x2="21" y2="10"></line>
                  </svg>
                </div>
                <span>时光记事簿</span>
              </div>
              <div class="app-icon" id="app-lock-screen" style="position: absolute; top: 8%; left: 29%;">
                <div class="app-icon-img">
                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                  </svg>
                </div>
                <span>回到锁屏</span>
              </div>
              <div id="calendar-widget-main"
                style="position: absolute; top: 25%; left: 50%; transform: translateX(-50%);">
                <div id="countdown-title">近期没有特别安排</div>
                <div id="countdown-timer">
                  <span>--</span>
                  <span class="unit">天</span>
                </div>
              </div>

              <div id="today-todo-widget">
                <div class="widget-title">今日待办</div>
                <div id="today-todo-list">
                </div>
              </div>


            </div>


          </div>
        </div>

        <div id="home-page-indicator">
          <span class="page-dot active" data-page="0"></span>
          <span class="page-dot" data-page="1"></span>
        </div>

        <div id="home-dock">
          <div class="app-icon app-icon-large" id="app-chat">
            <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
              </svg></div>
            <span>聊天</span>
          </div>
          <div class="app-icon" id="app-music">
            <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
              </svg></div>
            <span>动态</span>
          </div>
          <div class="app-icon" id="app-meeting">
            <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 9a2 2 0 0 1-2 2H6l-4 4V5a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v4Z" />
                <path d="M18 9h2a2 2 0 0 1 2 2v9l-4-4h-2a2 2 0 0 1-2-2V9Z" />
              </svg></div>
            <span>见面</span>
          </div>
        </div>

      </div>

    </div>

    <div id="chat-screen" class="screen">
      <div id="chat-screen-container">
        <div id="chat-list-pane">
          <div id="chat-list-header">
            <button id="back-to-home-from-chat" class="header-button">主屏幕</button>
            <span class="header-title">聊天</span>
            <button id="add-chat-button" class="header-button add" title="添加新聊天">+</button>
          </div>
          <div id="chat-list-container">
            <ul id="character-list">
            </ul>
          </div>
        </div>
        <div id="chat-view-pane">
          <div class="header">
            <button class="header-button" id="back-to-chat-list">返回</button>
            <span id="char-name-header" class="header-title">角色</span>
            <button class="header-button" id="character-settings-button" title="角色设置">
              <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path
                  d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
                </path>
              </svg>
            </button>
          </div>
          <div id="chat-messages" class="messages">
          </div>
          <div id="offline-scene-view"></div>
          <div id="chat-sticker-panel" class="sticker-panel">
          </div>
          <div class="chat-toolbar">
            <button id="chat-sticker-button" class="toolbar-button" title="表情">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M8 14s1.5-2 4-2 4 2 4 2"></path>
                <line x1="9" y1="9" x2="9.01" y2="9"></line>
                <line x1="15" y1="9" x2="15.01" y2="9"></line>
              </svg>
            </button>
            <button id="chat-image-button" class="toolbar-button" title="发送图片">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
              </svg>
            </button>
            <button id="chat-music-button" class="toolbar-button" title="分享音乐">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                stroke-linejoin="round">
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
              </svg>
            </button>
            <button id="chat-listen-together-button" class="toolbar-button" title="一起听">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                stroke-linejoin="round">
                <path d="M3 18v-6a9 9 0 0 1 18 0v6"></path>
                <path
                  d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z">
                </path>
              </svg>
            </button>
            <button id="chat-transfer-button" class="toolbar-button" title="转账">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                stroke-linejoin="round">
                <line x1="12" y1="1" x2="12" y2="23"></line>
                <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
              </svg>
            </button>
            <button id="chat-reroll-button" class="toolbar-button" title="重新生成">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                stroke-linejoin="round">
                <polyline points="23 4 23 10 17 10"></polyline>
                <polyline points="1 20 1 14 7 14"></polyline>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
              </svg>
            </button>
            <button id="chat-summarize-button" class="toolbar-button" title="总结聊天记录">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
              </svg>
            </button>
          </div>
          <input type="file" id="chat-image-input" accept="image/*" style="display: none;">
          <div id="quote-preview-area" class="quote-preview">
            <div class="quote-preview-content">
              <div id="quote-preview-sender"></div>
              <div id="quote-preview-text"></div>
            </div>
            <button id="cancel-quote-button" class="cancel-quote-btn">&times;</button>
          </div>
          <div class="chat-input-area">
            <div id="chat-input-wrapper">
              <input type="text" id="chat-message-input" placeholder="输入消息...">
              <button id="chat-get-reply-button" title="让对方回复">↵</button>
              <button id="chat-send-button" title="发送">➤</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="settings-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-settings" class="header-button">返回</button>
        <span class="header-title">API设置</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <div class="settings-group">
          <h2>API 设置</h2>
          <div class="input-group">
            <label for="api-endpoint">API 接口地址（不填/v1）</label>
            <input type="text" id="api-endpoint" placeholder="例如: https://api.openai.com">
          </div>
          <div class="input-group">
            <label for="api-key">API 密钥</label>
            <input type="password" id="api-key" placeholder="请输入你的 API 密钥">
          </div>
          <div class="input-group">
            <label for="api-model">模型</label>
            <div class="model-input-container">
              <input type="text" id="api-model" placeholder="点击 获取 或手动输入" style="flex-grow: 1;">
              <button id="fetch-models-button" style="padding: 0 12px; white-space: nowrap;">获取</button>
              <div id="model-dropdown" class="custom-model-dropdown"></div>
            </div>
          </div>
          <div class="input-group">
            <label for="api-provider">接口格式 (重要！请根据你使用的接口选择，但是我也没做Openai以外的接口……)</label>
            <select id="api-provider"
              style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color);">
              <option value="openai">OpenAI 格式 (通用，兼容绝大多数反代)</option>
              <option value="gemini">Google Gemini 格式 (仅限官方或特定反代)</option>
              <option value="anthropic">Anthropic Claude 格式</option>
            </select>
          </div>
        </div>
        <div class="settings-group">
          <h2>上下文设置</h2>
          <div class="input-group">
            <label for="context-lines-per-chat">每个会话读取的消息条数（默认 100）</label>
            <input type="number" id="context-lines-per-chat" min="1" max="1000000" step="1" placeholder="100">
          </div>
        </div>

        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>数据管理</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">
            导出全部数据（角色、聊天记录、设置、桌面布局等）到一个文件，方便在其他设备或浏览器上导入。
          </p>
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="export-all-data-button" class="form-button"
              style="width: 50%; margin-top: 0; background-color: #007bff;">导出全部数据</button>
            <button id="import-all-data-button" class="form-button"
              style="width: 50%; margin-top: 0; background-color: #28a745;">导入数据</button>
          </div>
          <input type="file" id="import-data-input" accept=".json" style="display: none;">
        </div>

        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2 style="color: #e65252;">终极手段：一键净化</h2>
          <p style="font-size: 0.9rem; color: #dc3545;">
            <b>警告：</b>如果你的应用因为内存满了而彻底卡死、无法导入导出，请先想办法手动备份重要数据！然后点击此按钮，它会清空所有本地数据，让应用恢复到出厂状态。
          </p>
          <button id="hard-reset-button" class="form-button destructive">终极重置 (解决卡死问题)</button>
        </div>
        <button id="save-api-settings-button" class="form-button">保存 API 设置</button>
      </div>
    </div>



    <div id="character-edit-screen" class="screen">
      <div class="header">
        <button id="back-to-char-select-from-edit" class="header-button">返回</button>
        <span id="character-edit-title" class="header-title">编辑角色</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <input type="hidden" id="editing-char-id">
        <div class="settings-group">
          <h2>角色设定</h2>
          <div class="input-group">
            <label for="char-edit-name">名字</label>
            <input type="text" id="char-edit-name" placeholder="角色的名字">
          </div>
          <div class="input-group">
            <label for="char-edit-remark">备注名</label>
            <input type="text" id="char-edit-remark" placeholder="方便自己记忆，例如 '工作助理'">
          </div>
          <div class="avatar-upload-group">
            <label>角色头像</label>
            <img id="char-edit-avatar-preview" class="avatar-preview" alt="Avatar Preview">
            <input type="file" id="char-edit-avatar-input" accept="image/*" style="display: none;">
            <div class="input-group">
              <label for="char-avatar-frame-url">TA的头像框 URL (可选)</label>
              <input type="text" id="char-avatar-frame-url" placeholder="为这个角色设置专属头像框...">
            </div>

            <div class="input-group">
              <label for="user-avatar-frame-url-in-chat">你的头像框 URL (可选, 仅用于此聊天)</label>
              <input type="text" id="user-avatar-frame-url-in-chat" placeholder="为“你”在这个聊天里设置专属头像框...">
            </div>
          </div>
          <div class="input-group">
            <label for="char-edit-persona">人设 (系统提示词)</label>
            <textarea id="char-edit-persona" placeholder="你是一个乐于助人的助手。"></textarea>
          </div>
          <div class="input-group">
            <label>聊天壁纸</label>
            <div
              style="width: 150px; height: 266px; border-radius: 12px; border: 1px solid var(--border-color); background-color: #f0f0f0; overflow: hidden; cursor: pointer;">
              <div id="char-edit-wallpaper-preview" class="image-preview-slot"></div>
            </div>
            <input type="file" id="char-edit-wallpaper-input" accept="image/*" style="display: none;">
          </div>
          <div class="input-group">
            <label for="char-edit-css">专属气泡样式 (CSS)</label>
            <textarea id="char-edit-css" rows="8"
              placeholder="从其他地方复制的、包含 .sent 和 .received 的CSS代码可以直接粘贴在这里..."></textarea>

            <div style="display: flex; gap: 10px; margin-top: 5px;">
              <div style="flex: 1; padding: 10px; background: #f0f0f0; border-radius: 8px;">
                <p style="margin: 0 0 5px; font-size: 0.8rem; color: #555;">TA的气泡 (Received):</p>
                <div id="bubble-preview-ai" class="message ai">这是TA的气泡预览效果</div>
              </div>
              <div style="flex: 1; padding: 10px; background: #f0f0f0; border-radius: 8px;">
                <p style="margin: 0 0 5px; font-size: 0.8rem; color: #555;">你的气泡 (Sent):</p>
                <div id="bubble-preview-user" class="message user">这是你的气泡预览效果</div>
              </div>
            </div>
          </div>
          <div class="input-group">
            <label>见面场景背景</label>
            <div
              style="width: 150px; height: 266px; border-radius: 12px; border: 1px solid var(--border-color); background-color: #f0f0f0; overflow: hidden; cursor: pointer;">
              <div id="char-edit-offline-bg-preview" class="image-preview-slot"></div>
            </div>
            <input type="file" id="char-edit-offline-bg-input" accept="image/*" style="display: none;">
          </div>
          <div class="settings-group">
            <h2>角色立绘 (Galgame模式)</h2>
            <p style="font-size: 0.8rem; color: var(--text-color-light);">为五种核心情绪上传立绘图，建议使用透明背景的PNG图片。</p>
            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px;">

              <div class="avatar-upload-group" style="align-items: center;">
                <label>平常</label>
                <div id="char-edit-sprite-normal-preview" class="sprite-preview-slot"></div>
                <input type="file" id="char-edit-sprite-normal-input" accept="image/*" style="display: none;">
              </div>
              <div class="avatar-upload-group" style="align-items: center;">
                <label>喜</label>
                <div id="char-edit-sprite-happy-preview" class="sprite-preview-slot"></div>
                <input type="file" id="char-edit-sprite-happy-input" accept="image/*" style="display: none;">
              </div>
              <div class="avatar-upload-group" style="align-items: center;">
                <label>怒</label>
                <div id="char-edit-sprite-angry-preview" class="sprite-preview-slot"></div>
                <input type="file" id="char-edit-sprite-angry-input" accept="image/*" style="display: none;">
              </div>
              <div class="avatar-upload-group" style="align-items: center;">
                <label>哀</label>
                <div id="char-edit-sprite-sad-preview" class="sprite-preview-slot"></div>
                <input type="file" id="char-edit-sprite-sad-input" accept="image/*" style="display: none;">
              </div>
              <div class="avatar-upload-group" style="align-items: center;">
                <label>害羞</label>
                <div id="char-edit-sprite-shy-preview" class="sprite-preview-slot"></div>
                <input type="file" id="char-edit-sprite-shy-input" accept="image/*" style="display: none;">
              </div>
            </div>
          </div>
          <div class="input-group">
            <label for="char-edit-bind-user">绑定用户</label>
            <select id="char-edit-bind-user"></select>
          </div>
          <div class="input-group">
            <label>关联世界书</label>
            <div class="custom-multiselect">
              <div class="select-box">
                <span class="selected-options-text">-- 点击选择 --</span>
                <span class="arrow">▼</span>
              </div>
              <div id="world-book-checkboxes-container" class="checkboxes-container">
              </div>
            </div>
          </div>
        </div>
        <button id="export-char-button" class="form-button secondary" style="margin-top: 20px;">导出角色卡</button>
        <button id="save-char-button" class="form-button">保存角色</button>
        <div class="settings-group" style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px;">
          <button id="edit-clear-history-button" class="form-button warning"
            style="margin-bottom: 10px;">清空聊天记录</button>
          <button id="edit-delete-char-button" class="form-button" class="form-button destructive">删除角色</button>
        </div>
      </div>
    </div>

    <div id="group-chat-create-screen" class="screen">
      <div class="header">
        <button id="back-to-char-select-from-group-create" class="header-button">返回</button>
        <span class="header-title">创建群聊</span>
        <button id="create-group-chat-button" class="header-button">创建</button>
      </div>
      <div class="content" style="padding: 20px;">
        <div class="input-group">
          <label for="group-chat-name">群聊名称</label>
          <input type="text" id="group-chat-name" placeholder="给你的群聊起个名字">
        </div>
        <div class="settings-group">
          <h2>选择成员</h2>
          <div id="group-chat-member-list-container"
            style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px;">
            <ul id="group-chat-member-list">
            </ul>
          </div>
        </div>
      </div>
    </div>

    <div id="wallpaper-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-wallpaper" class="header-button">返回</button>
        <span class="header-title">更换壁纸</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <div class="settings-group"
          style="border-bottom: 1px solid var(--border-color); padding-bottom: 20px; margin-bottom: 20px;">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <h2 style="margin: 0;">UI缩放</h2>
            <button id="reset-ui-scale-button" class="form-button secondary"
              style="width: auto; margin: 0; padding: 4px 12px; font-size: 0.8rem;">恢复默认</button>
          </div>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">拖动滑块来调整手机模拟器的整体大小。</p>
          <div class="input-group" style="padding-top: 10px;">
            <label for="ui-scale-slider" style="display: block; margin-bottom: 5px;">缩放比例</label>
            <input type="range" id="ui-scale-slider" min="0.7" max="1.2" value="1" step="0.05" style="width: 100%;">
          </div>
        </div>
        <div class="settings-group"
          style="border-bottom: 1px solid var(--border-color); padding-bottom: 20px; margin-bottom: 20px;">
          <h2>全局主题色</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">拖动滑块来改变整个App的主色调。</p>
          <div class="input-group" style="padding-top: 10px;">
            <label for="theme-hue-slider" style="display: block; margin-bottom: 5px;">色相 (Hue)</label>
            <input type="range" id="theme-hue-slider" min="0" max="360" value="35" style="width: 100%;">
          </div>
          <div class="input-group">
            <label for="theme-lightness-slider" style="display: block; margin-bottom: 5px;">明度 (Lightness)</label>
            <input type="range" id="theme-lightness-slider" min="15" max="95" value="80" style="width: 100%;">
          </div>
        </div>
        <div class="settings-group"
          style="border-bottom: 1px solid var(--border-color); padding-bottom: 20px; margin-bottom: 20px;">
          <h2 style="margin-top: 0;">时钟样式</h2>
          <div style="display: flex; align-items: center; gap: 10px;">
            <input type="checkbox" id="clock-color-toggle" style="width: auto; height: 18px; flex-shrink: 0;">
            <label for="clock-color-toggle" style="width: auto; font-size: 0.9rem;">强制使用纯白色时钟 (推荐在深色壁纸下使用)</label>
          </div>
        </div>
        <div class="settings-group">
          <h2>上传新壁纸</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">选择一张图片作为你的手机壁纸。为了效果最好，请使用竖屏图片。</p>
          <input type="file" id="wallpaper-input" accept="image/*" style="display: none;">
          <button id="upload-wallpaper-button" class="form-button">选择图片</button>
        </div>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>音乐小组件背景</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">为你的主屏幕音乐小组件设置一张专属背景图。</p>
          <input type="file" id="widget-bg-input" accept="image/*" style="display: none;">
          <button id="upload-widget-bg-button" class="form-button">选择图片</button>
          <button id="reset-widget-bg-button" class="form-button secondary">恢复默认</button>
        </div>
        <div class="settings-group" style="margin-top: 20px;">
          <h2>重置桌面</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">此操作会将所有桌面小组件（时钟、音乐、徽章等）恢复到初始位置，并将壁纸重置为纯白色。</p>
          <button id="reset-desktop-button" class="form-button destructive">重置桌面布局</button>
        </div>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>自定义徽章</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">上传一张图片作为你的桌面徽章，可以拖动它到任意位置。</p>
          <input type="file" id="badge-input" accept="image/*" style="display: none;">
          <button id="upload-badge-button" class="form-button">选择徽章图片</button>
          <button id="reset-badge-button" class="form-button secondary" style="margin-top: 10px;">移除徽章</button>
        </div>

        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>自定义卡片</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">上传一张图片作为你的桌面方形卡片小组件。</p>
          <input type="file" id="card-input" accept="image/*" style="display: none;">
          <button id="upload-card-button" class="form-button">选择卡片图片</button>
          <button id="reset-card-button" class="form-button secondary" style="margin-top: 10px;">移除卡片</button>
        </div>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>自定义卡片 2</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">为你的第二个桌面方形卡片小组件上传图片。</p>
          <input type="file" id="card-input-2" accept="image/*" style="display: none;">
          <button id="upload-card-button-2" class="form-button">选择卡片图片</button>
          <button id="reset-card-button-2" class="form-button secondary" style="margin-top: 10px;">移除卡片
            2</button>
        </div>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>动态页背景</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">为“动态”页面设置一张独立的背景图，让它与众不同。</p>
          <input type="file" id="feed-bg-input" accept="image/*" style="display: none;">
          <button id="upload-feed-bg-button" class="form-button">选择图片</button>
        </div>
        <button id="reset-feed-bg-button" class="form-button secondary" style="margin-top: 10px;">移除背景</button>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>小组件救援</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">如果你的吧唧或卡片不小心飞出屏幕找不到了，点这里让它们回家。</p>
          <button id="reset-widgets-position-button" class="form-button warning">重置小组件位置</button>
        </div>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>自定义全局字体</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">
            上传一个 .ttf 字体文件来改变整个App的显示字体。注意，部分特殊字体可能会导致显示异常。
          </p>
          <div id="font-preview-area"
            style="padding: 10px; border: 1px solid var(--border-color); border-radius: 8px; margin-top: 10px; background: var(--card-bg);">
            <span id="font-preview-text" style="font-size: 1.2rem;">你好，世界 (Hello, World)</span>
          </div>
          <input type="file" id="font-input" accept=".ttf" style="display: none;">
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="upload-font-button" class="form-button" style="margin-top: 0;">选择字体</button>
            <button id="remove-font-button" class="form-button secondary" style="margin-top: 0;">恢复默认</button>
          </div>
        </div>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>自定义App图标</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">替换主屏幕上App的默认图标。为了最佳效果，请使用方形、透明背景的图片。</p>
          <div class="settings-group"
            style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
            <h2>自定义表情包</h2>
            <p style="font-size: 0.9rem; color: var(--text-color-light);">
              在这里追加你的专属表情包。每个表情占一行，格式为：<br>
              <b>表情名--图片URL</b><br>
              例如：<br>
              <code>开心--https://example.com/happy.png</code><br>
              <code>难过--https://example.com/sad.gif</code>
            </p>
            <textarea id="custom-stickers-input" rows="8" placeholder="请按指定格式粘贴..."></textarea>
            <button id="save-custom-stickers-button" class="form-button" style="margin-top: 5px;">保存并刷新表情包</button>
          </div>
          <div id="custom-icon-list-container">
          </div>
          <div id="custom-icon-list-container">
          </div>
        </div>
      </div>

    </div>

    <div id="world-book-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-world-book" class="header-button">主屏幕</button>
        <span class="header-title">世界书</span>
        <button id="add-world-book-button" class="header-button add" title="添加新世界书">+</button>
      </div>
      <div class="content" style="display: flex; padding: 0; flex-direction: row;">
        <div id="world-book-category-pane"
          style="width: 120px; flex-shrink: 0; border-right: 1px solid var(--border-color); background: var(--surface-bg); padding: 10px; display: flex; flex-direction: column;">
          <div id="world-book-category-list" style="flex-grow: 1; overflow-y: auto;">
          </div>
          <button id="add-world-book-category-button" class="form-button secondary"
            style="margin-top: 10px; padding: 8px;">新建分类</button>
        </div>
        <div id="world-book-list-container" style="flex-grow: 1; overflow-y: auto; padding: 10px;">
        </div>
      </div>
    </div>

    <div id="world-book-editor-screen" class="screen">
      <div class="header">
        <button id="back-to-world-book-list" class="header-button">返回</button>
        <span id="world-book-editor-title" class="header-title">编辑条目</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <input type="hidden" id="editing-world-book-id">
        <div class="settings-group">
          <h2>设定条目</h2>
          <div class="input-group">
            <label for="world-book-edit-name">条目名称 (Key)</label>
            <input type="text" id="world-book-edit-name" placeholder="例如：我的过去、特殊能力">
          </div>
          <div class="input-group">
            <label for="world-book-edit-content">条目内容 (Value)</label>
            <textarea id="world-book-edit-content" placeholder="输入详细的设定内容..."></textarea>
          </div>
          <div class="input-group">
            <label for="world-book-edit-category">所属分类</label>
            <select id="world-book-edit-category"></select>
          </div>
        </div>
        <button id="save-world-book-button" class="form-button">保存条目</button>
        <div class="settings-group" style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px;">
          <button id="delete-world-book-button" class="form-button destructive">删除该条目</button>
        </div>
      </div>
    </div>

    <div id="group-settings-screen" class="screen">
      <div class="header">
        <button id="back-to-chat-from-group-settings" class="header-button">返回</button>
        <span class="header-title">群聊设置</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <div class="settings-group">
          <h2>群聊信息</h2>
          <div class="input-group">
            <label for="group-settings-name">群聊名称</label>
            <input type="text" id="group-settings-name">
          </div>
          <div class="avatar-upload-group">
            <label>群头像</label>
            <img id="group-avatar-preview" class="avatar-preview" alt="Group Avatar Preview">
            <input type="file" id="group-avatar-input" accept="image/*" style="display: none;">
          </div>
          <div class="input-group">
            <label>群聊背景</label>
            <div
              style="width: 150px; height: 266px; border-radius: 12px; border: 1px solid var(--border-color); background-color: #f0f0f0; overflow: hidden; cursor: pointer;">
              <div id="group-bg-preview" class="image-preview-slot"></div>
            </div>
            <input type="file" id="group-bg-input" accept="image/*" style="display: none;">
          </div>
          <div class="input-group">
            <label for="group-settings-bind-user">绑定用户</label>
            <select id="group-settings-bind-user"></select>
          </div>
          <div class="input-group">
            <label>关联世界书</label>
            <div class="custom-multiselect">
              <div class="select-box">
                <span class="selected-options-text">-- 点击选择 --</span>
                <span class="arrow">▼</span>
              </div>
              <div id="group-world-book-checkboxes" class="checkboxes-container">
              </div>
            </div>
          </div>
        </div>
        <button id="save-group-settings-button" class="form-button">保存设置</button>
        <div class="settings-group" style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px;">
          <button id="group-clear-history-button" class="form-button warning"
            style=" margin-bottom: 10px;">清空聊天记录</button>
          <button id="group-delete-button" class="form-button destructive">删除并解散群聊</button>
        </div>
      </div>
    </div>

    <div id="music-screen" class="screen">
      <div class="header">
        <button id="back-to-circle-list-from-feed" class="header-button">返回</button>
        <span id="friend-circle-title" class="header-title">好友圈</span>
        <div style="display: flex; gap: 5px;">
          <button id="edit-current-circle-button" class="header-button" style="font-size: 1.2rem;">⚙️</button>
          <button id="clear-feed-button" class="header-button" style="color: #dc3545;">清空</button>
          <button id="refresh-feed-button" class="header-button">刷新</button>

        </div>
      </div>
      <div id="user-post-area"
        style="padding: 10px 15px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; background: var(--surface-bg);">
        <div id="user-post-input-container">
          <img id="user-post-avatar" class="char-avatar">
          <div id="user-post-main-area">
            <textarea id="user-post-textarea" rows="3" placeholder="分享你的新鲜事..."></textarea>
            <div id="user-post-attachment-preview"></div>
          </div>
        </div>
        <div id="user-post-toolbar">
          <div id="user-post-actions" class="user-post-actions">
            <button id="user-post-image-button" class="toolbar-button" title="分享图片">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
              </svg>
            </button>
            <input type="file" id="user-post-image-input" accept="image/*" style="display: none;">
            <button id="user-post-music-button" class="toolbar-button" title="分享音乐">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
              </svg>
            </button>
          </div>
          <button id="user-send-post-button">发送</button>
        </div>
      </div>
      <div id="music-feed-container" class="content" style="padding: 10px;">
      </div>
      <div id="music-player-bar" class="hidden">
        <img id="player-cover" src="">
        <div id="player-info">
          <div id="player-title"></div>
          <div id="player-artist"></div>
        </div>
        <div id="player-controls">

          <button id="player-play-pause-btn">▶</button>

        </div>
      </div>
      <audio id="audio-player"></audio>
    </div>
    <div id="meeting-list-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-meeting-list" class="header-button">主屏幕</button>
        <span class="header-title">选择见面对象</span>
        <div style="width: 50px;"></div>
      </div>
      <div id="meeting-list-container" class="content" style="padding: 10px;">
      </div>
    </div>

    <div id="meeting-view-screen" class="screen">
      <div class="header">
        <button class="header-button" id="back-to-meeting-list">返回</button>
        <span id="meeting-char-name-header" class="header-title">角色</span>
        <button id="toggle-meeting-view-button" class="header-button">切换视角</button>

      </div>
      <div id="meeting-main-content" class="content" style="position: relative; padding: 0;">
        <div id="galgame-overlay-ui">
          <div id="galgame-time">12:00</div>
          <div id="galgame-date">1月1日 星期一</div>
        </div>
        <div id="galgame-sprite-adjust-ui"
          style="position: absolute; top: 20px; right: 20px; z-index: 11; display: none;">
          <button id="sprite-adjust-button" class="toolbar-button" title="调整立绘位置">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M20 7h-9" />
              <path d="M14 17H5" />
              <circle cx="17" cy="17" r="3" />
              <circle cx="8" cy="7" r="3" />
            </svg>
          </button>
          <button id="meeting-reroll-button" class="toolbar-button" title="重新生成">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="23 4 23 10 17 10"></polyline>
              <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg>
          </button>
        </div>

        <div id="galgame-sprite-controls"
          style="display: none; position: absolute; bottom: 15px; left: 15px; right: 15px; z-index: 1001; background: rgba(0,0,0,0.7); backdrop-filter: blur(8px); border-radius: 12px; padding: 15px; box-shadow: 0 -2px 15px rgba(0,0,0,0.3);">
          <div class="sprite-slider-group">
            <label for="sprite-slider-x">左右位置</label>
            <input type="range" id="sprite-slider-x" min="0" max="100" value="50">
          </div>
          <div class="sprite-slider-group">
            <label for="sprite-slider-y">上下位置</label>
            <input type="range" id="sprite-slider-y" min="0" max="130" value="100">
          </div>
          <div class="sprite-slider-group">
            <label for="sprite-slider-scale">缩放大小</label>
            <input type="range" id="sprite-slider-scale" min="50" max="200" value="100">
          </div>
          <div style="display: flex; gap: 10px; margin-top: 15px;">
            <button id="sprite-confirm-button" class="form-button">确定</button>
            <button id="sprite-cancel-button" class="form-button secondary">取消</button>
            <button id="sprite-reset-button" class="form-button destructive"
              style="padding: 10px 12px; width: auto; font-size: 1.2rem;">⟲</button>
          </div>
        </div>
        <div id="meeting-scene-view" class="content"
          style="font-family: 'Georgia', 'Times New Roman', 'KaiTi', 'STSong', serif; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.7);">
        </div>
        <div id="galgame-view-container"
          style="display: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; overflow: hidden;">
          <div id="galgame-sprite-wrapper"
            style="position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); width: 100%; height: 100%;">
            <div id="galgame-sprite-container"
              style="position: absolute; display: flex; align-items: flex-end; justify-content: center; /* 移除旧的定位样式 */">
              <img id="galgame-sprite" src=""
                style="max-height: 100%; max-width: 100%; object-fit: contain; transition: opacity 0.3s ease;">
              <div id="sprite-resize-handle"
                style="display: none; position: absolute; bottom: -5px; right: -5px; width: 20px; height: 20px; background: white; border: 2px solid var(--primary-color); border-radius: 50%; cursor: se-resize;">
              </div>
            </div>
          </div>
          <div id="galgame-textbox-container"
            style="position: absolute; bottom: 9%; left: 5%; right: 5%; background: rgba(0, 0, 0, 0.7); border-radius: 10px; padding: 15px; color: white; border-top: 1px solid rgba(255,255,255,0.2); cursor: pointer;">
            <div id="galgame-speaker" style="font-weight: bold; margin-bottom: 10px;">说话人</div>
            <div id="galgame-text" style="line-height: 1.6;">对话内容...</div>
          </div>
        </div>
      </div>
      <div class="chat-input-area">
        <div id="chat-input-wrapper-meeting"> <textarea id="meeting-message-input" placeholder="输入你的行动或对话..." rows="1"
            style="resize: none; overflow-y: auto; flex-grow: 1; border: none; background: transparent; padding: 9px 12px; font-size: .95rem; "></textarea>
          <button id="meeting-send-button" title="发送">➤</button>
        </div>
      </div>
    </div>

    <div id="friend-circle-list-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-circle-list" class="header-button">主屏幕</button>
        <span class="header-title">好友圈</span>
        <button id="add-friend-circle-button" class="header-button add" title="新建好友圈">+</button>
      </div>
      <div id="friend-circle-list-container" class="content" style="padding: 10px;">
      </div>
    </div>

    <div id="friend-circle-edit-screen" class="screen">
      <div class="header">
        <button id="back-to-circle-list-from-edit" class="header-button">返回</button>
        <span id="friend-circle-edit-title" class="header-title">编辑好友圈</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <input type="hidden" id="editing-friend-circle-id">
        <div class="settings-group">
          <h2>好友圈设定</h2>
          <div class="input-group">
            <label for="friend-circle-edit-name">圈子名称</label>
            <input type="text" id="friend-circle-edit-name" placeholder="例如：我的日常">
          </div>
          <div class="input-group">
            <label for="friend-circle-edit-bind-user">绑定的“我”</label>
            <select id="friend-circle-edit-bind-user"></select>
          </div>
        </div>
        <div class="settings-group">
          <h2>选择圈内成员</h2>
          <div id="friend-circle-member-selection"
            style="max-height: 250px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px;">
          </div>
        </div>
        <button id="save-friend-circle-button" class="form-button">保存</button>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <button id="delete-friend-circle-button" class="form-button destructive">删除该好友圈</button>
        </div>
      </div>
    </div>
    <div id="diary-list-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-diary-list" class="header-button">主屏幕</button>
        <span class="header-title">交换日记</span>
        <div style="width: 50px;"></div>
      </div>
      <div id="diary-list-container" class="content" style="padding: 10px;">
      </div>
    </div>

    <div id="diary-view-screen" class="screen">
      <div class="header">
        <button class="header-button" id="back-to-diary-list">返回</button>
        <span id="diary-char-name-header" class="header-title">TA的日记</span>
        <div style="width: 50px;"></div>
      </div>
      <div id="diary-entries-container" class="content"
        style="padding: 20px; font-family: 'KaiTi', 'STSong', serif; line-height: 1.8;">
      </div>
      <div class="chat-input-area">
        <div id="diary-input-wrapper" style="display: flex; gap: 10px;">
          <input type="text" id="diary-entry-input" placeholder="写下你的日记或批注..." style="flex-grow: 1;">
          <button id="diary-send-button" class="form-button"
            style="width: auto; margin-top: 0; padding: 0 18px;">写好了</button>
          <button id="diary-get-reply-button" class="form-button"
            style="width: auto; margin-top: 0; background-color: #555; padding: 0 18px;">催TA写</button>
        </div>
      </div>
    </div>
    <div id="music-library-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-music-library" class="header-button">主屏幕</button>
        <span class="header-title">音乐库</span>
        <button id="upload-music-button" class="header-button add" title="上传新音乐">+</button>
      </div>
      <div class="content" id="music-library-container">
      </div>
    </div>
    <div id="music-upload-altar-screen" class="screen">
      <div class="header">
        <button id="back-to-library-from-altar" class="header-button">取消</button>
        <span class="header-title">献上音乐</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content" style="padding: 20px; display: flex; flex-direction: column; gap: 15px;">

        <div class="upload-slot" id="altar-slot-audio">
          <span class="slot-icon">🎵</span>
          <span class="slot-label">音频文件 (必需)</span>
          <span class="slot-filename">点击选择 .mp3 或 .flac</span>
        </div>

        <div class="upload-slot" id="altar-slot-cover">
          <span class="slot-icon">🖼️</span>
          <span class="slot-label">封面图片 (可选)</span>
          <span class="slot-filename">点击选择 .jpg 或 .png</span>
        </div>

        <div class="upload-slot" id="altar-slot-info">
          <span class="slot-icon">📄</span>
          <span class="slot-label">歌曲信息 (必需)</span>
          <span class="slot-filename">点击选择 info.txt</span>
        </div>

        <div class="upload-slot" id="altar-slot-lyrics">
          <span class="slot-icon">🎤</span>
          <span class="slot-label">歌词文件 (可选)</span>
          <span class="slot-filename">点击选择 .lrc</span>
        </div>

        <button id="confirm-altar-upload-button" class="form-button" disabled>献上祭品</button>
      </div>

    </div>


    <div id="accounting-screen" class="screen">
      <div class="header" id="accounting-header">
        <button id="back-to-home-from-accounting" class="header-button">主屏幕</button>
        <span id="accounting-title" class="header-title">记一笔</span>
        <div id="header-actions" style="width: 80px; text-align: right;"></div>
      </div>

      <div class="accounting-tabs">
        <button id="tab-record-expense" class="tab-button active">记一笔</button>
        <button id="tab-view-ledger" class="tab-button">看账本</button>
      </div>

      <div id="accounting-content-area" class="content" style="padding: 15px;">
      </div>
    </div>
    <audio id="audio-player"></audio>

    <audio id="unified-audio-player"></audio>

    <div id="snoop-list-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-snoop-list" class="header-button">主屏幕</button>
        <span class="header-title">选择目标</span>
        <div style="width: 50px;"></div>
      </div>
      <div id="snoop-character-list-container" class="content" style="padding: 10px;">
      </div>
    </div>

    <div id="snoop-phone-screen" class="screen">
      <div id="snoop-phone-wallpaper"></div>
      <div id="snoop-phone-header">
      </div>

      <div id="snoop-app-container">
      </div>

      <div id="snoop-app-view-container"
        style="position: absolute; inset: 0; background: white; z-index: 20; display: none; flex-direction: column;">
      </div>

      <div id="snoop-phone-top-nav" class="header"
        style="position: absolute; top: 44px; left: 0; right: 0; z-index: 30; height: 56px; display: flex; align-items: center; padding: 0 5px;">
        <button id="back-to-snoop-list-from-phone" class="toolbar-button"
          style="color: white; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5)); background: transparent !important;">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
        </button>
        <span id="snoop-char-name-header" class="header-title"></span>
        <div style="width:50px;"></div>
      </div>
    </div>

    <div id="calendar-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-calendar" class="header-button">主屏幕</button>
        <span id="calendar-header-title" class="header-title">2025年 9月</span>
        <div style="width: 50px;"></div>
      </div>

      <div id="calendar-view-container">
        <div class="calendar-nav">
          <button id="prev-month-btn">‹</button>
          <button id="today-btn">今天</button>
          <button id="next-month-btn">›</button>
        </div>
        <div class="calendar-weekdays">
          <span>日</span><span>一</span><span>二</span><span>三</span><span>四</span><span>五</span><span>六</span>
        </div>
        <div id="calendar-grid">
        </div>
      </div>

      <div id="todo-view-container">
        <div id="todo-header">
          <h3 id="todo-date-title">选择一个日期</h3>
          <button id="add-event-fab" title="添加新事件">+</button>
        </div>
        <div id="todo-list">
        </div>
      </div>

    </div>


  </div>
  </div>

  <div id="add-choice-modal" class="choice-modal">
    <div id="add-choice-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content">
      <button id="choice-create-character" class="choice-modal-button">创建新角色</button>
      <button id="choice-create-group" class="choice-modal-button">创建新群聊</button>
      <button id="choice-import-character" class="choice-modal-button">导入角色卡</button>
      <button id="choice-cancel" class="choice-modal-button cancel">取消</button>
    </div>
  </div>


  <div id="transfer-modal" class="choice-modal">
    <div id="transfer-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content" style="padding: 20px; width: 90%; max-width: 300px;">
      <h3 style="margin-top: 0; text-align: center; font-weight: 600;">转账</h3>
      <div id="transfer-recipient-group" class="input-group" style="margin: 10px 0; display: none;">
        <label for="transfer-recipient-select">转给</label>
        <select id="transfer-recipient-select"></select>
      </div>
      <div class="input-group" style="margin: 10px 0;">
        <label for="transfer-amount-input">金额</label>
        <input type="number" id="transfer-amount-input" placeholder="输入金额">
      </div>
      <div style="display: flex; gap: 10px; margin-top: 20px;">
        <button id="confirm-transfer-button" class="choice-modal-button"
          style="background-color: var(--primary-color); color: white;">确认转账</button>
        <button id="cancel-transfer-button" class="choice-modal-button cancel">取消</button>
      </div>
    </div>
  </div>

  <div id="message-action-modal" class="choice-modal">
    <div id="message-action-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content">
      <button id="edit-message-button" class="choice-modal-button">编辑消息</button>
      <button id="quote-message-button" class="choice-modal-button">引用</button>
      <button id="delete-message-button" class="choice-modal-button" style="color: #dc3545;">删除消息</button>
      <button id="cancel-action-button" class="choice-modal-button cancel">取消</button>
    </div>
  </div>

  <div id="edit-message-modal" class="choice-modal">
    <div id="edit-message-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content" style="padding: 20px;">
      <h3 style="margin-top: 0; text-align: center; font-weight: 600;">编辑消息</h3>
      <textarea id="edit-message-textarea" style="width: 100%; min-height: 100px; margin: 10px 0;"></textarea>
      <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="save-edit-button" class="choice-modal-button"
          style="background-color: var(--primary-color); color: white;">保存</button>
        <button id="cancel-edit-button" class="choice-modal-button cancel">取消</button>
      </div>
    </div>
  </div>

  <div id="music-input-modal" class="choice-modal">
    <div id="music-input-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content" style="padding: 20px; width: 90%; max-width: 300px;">
      <h3 id="music-input-title" style="margin-top: 0; text-align: center; font-weight: 600;">分享音乐</h3>

      <div class="input-group" style="margin: 10px 0;">
        <label for="music-input-song" style="font-size: 0.9rem;">歌名</label>
        <input type="text" id="music-input-song" placeholder="例如：夜曲">
      </div>
      <div class="input-group" style="margin: 10px 0;">
        <label for="music-input-artist" style="font-size: 0.9rem;">歌手</label>
        <input type="text" id="music-input-artist" placeholder="例如：周杰伦">
      </div>

      <div style="display: flex; gap: 10px; margin-top: 20px;">
        <button id="confirm-music-input" class="choice-modal-button"
          style="background-color: var(--primary-color); color: white;">确认</button>
        <button id="cancel-music-input" class="choice-modal-button cancel">取消</button>
      </div>
    </div>
  </div>

  <div id="modal-root"
    style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:9999;">
    <div id="modal-mask" style="position:absolute;inset:0;background:rgba(0,0,0,.35);"></div>
    <div id="modal-dialog"
      style="position:relative;background:#fff;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.2);width:80%;max-width:320px;padding:16px;">
      <div id="modal-text" style="font-size:14px;color:#333;line-height:1.5;white-space:pre-wrap;"></div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:16px;">
        <button id="modal-cancel"
          style="padding:8px 12px;border:1px solid #ddd;border-radius:8px;background:#fff;cursor:pointer;">取消</button>
        <button id="modal-ok"
          style="padding:8px 12px;border:none;border-radius:8px;background:#007bff;color:#fff;cursor:pointer;">确定</button>
      </div>
    </div>
  </div>

  <div id="listen-together-modal" class="choice-modal">
    <div id="listen-together-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content"
      style="padding: 0; width: 95%; max-width: 360px; height: 70%; display: flex; flex-direction: column;">
      <div class="header" style="border-bottom: 1px solid var(--border-color); flex-shrink: 0;">
        <div style="width: 50px;"></div>
        <span class="header-title">选择一首歌，一起听</span>
        <button id="cancel-listen-together" class="header-button" style="min-width: 50px;">取消</button>
      </div>
      <div id="listen-together-song-list" class="content" style="flex-grow: 1; padding: 10px;">
      </div>
    </div>
  </div>

  <div id="toast"
    style="position:fixed;left:50%;bottom:32px;transform:translateX(-50%);background:rgba(0,0,0,.8);color:#fff;padding:8px 12px;border-radius:8px;font-size:12px;display:none;z-index:10000;">
  </div>


  <script>
    // ▼▼▼ Noir's Temporal Correction Protocol v1.0 ▼▼▼
    function getLocalDateString(date = new Date()) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }
    // ▲▲▲ End of Protocol ▲▲▲
    // ▼▼▼ 把这两行圣旨粘贴在这里！▼▼▼
    const DB_NAME = 'Noir_FileSystem';
    const STORE_NAME = 'images';
    const SNOOP_STORE_NAME = 'snoop_cache'; // <-- 哼，就是这根被你忘掉的钢筋！
    // ▲▲▲ 看到了吗？就这里！▲▲▲

    // Noir's Dynamic Font Style Injector
    const fontStyleTag = document.createElement('style');
    fontStyleTag.id = 'noir-custom-font-style';
    document.head.appendChild(fontStyleTag);

    /* ===== GLOBALS for helpers below ===== */
    var state; // 让外部辅助函数能看到它（稍后在 DOMContentLoaded 内部赋值）
    var currentlyPlayingSongInfo = null; // 哼，这是新的大脑，简单
    let masterStickerList = []; // <--- 哼，就是加上这行！

    let isStickerDeletionMode = false; // <-- 在这里加上这个新开关！
    let galClockInterval = null;
    let isDraggingBadge = false;
    let badgeOffset = { x: 0, y: 0 };

    function getCharacterById(charId) {
      return (state?.characters || []).find(c => c.id === charId);
    }

    /* ==================================== */

    const GEMINI_API_URL_BASE = 'https://i.pinimg.com/736x/16/f9/05/16f9051f99471208ee9c658aa4618eb6.jpg';
    const DEFAULT_USER_AVATAR = `data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM5OTkiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMjAgMjF2LTIuMDJhNC4zOSA0LjM5IDAgMCAtMy4yOC00LjA5TDE1IDIwIj48L3BhdGgPjxjaXJjbGUgY3g9IjEyIiBjeT0iNyIgcj0iNCI+PC9jaXJjbGU+PC9zdmc+`;
    const DEFAULT_AI_AVATAR = `data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNjY2MiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMjAgMjF2LTIuMDRhNC4zOSA0LjM5IDAgMCAwLTMuMjgtNC4wOWwxLjQxLTEuNDFhMiAyIDAgMSAwLTIuODMtMi4wM2wtMS40MSAxLjQxQTQuMzkgNC4zOSAwIDAgMCAxMiAxMGE0LjM5IDQuMzkgMCAwIDAtNC4wOSAzLjI4TDMuMicgOS41N2EyIDIgMCAxIDAgMi44MyAyLjgzbDEuNDEtMS40MUE0LjM5IDQuMzkgMCAwIDAgMTAgMTJhNC4zOSA0LjM5IDAgMCAwIDMgNC4wOVYyMSI+PC9wYXRoPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjEwIj48L2NpcmNsZT48L3N2Zz4=`;

    const STICKERS = [
      { name: '委屈哭', url: 'https://sharkpan.xyz/f/8ngsj/ax0fat.jpg' },
      { name: '崩溃', url: 'https://sharkpan.xyz/f/G0dTl/4qad2i.jpg' },
      { name: '生病', url: 'https://sharkpan.xyz/f/zLes5/4lxzjn.jpg' },
      { name: '工作', url: 'https://sharkpan.xyz/f/7L3Hj/sl4504.jpg' },
      { name: '我很脆弱', url: 'https://sharkpan.xyz/f/ABwhZ/twknmr.jpg' },
      { name: '弱小委屈但凶恶', url: 'https://sharkpan.xyz/f/wjgHq/yznfhq.jpg' },
      { name: '吃薯条', url: 'https://sharkpan.xyz/f/MWOIa/rb3nov.jpg' },
      { name: '期待', url: 'https://sharkpan.xyz/f/35lse/xmsue5.jpg' },
      { name: '喜欢', url: 'https://sharkpan.xyz/f/55ntj/ul0hkz.jpg' },
      { name: '被萌到', url: 'https://sharkpan.xyz/f/kjOF6/zedyqb.jpg' },
      { name: '有点生气', url: 'https://sharkpan.xyz/f/jj6s6/yd5bpb.jpg' },
      { name: '委屈', url: 'https://sharkpan.xyz/f/ajwtY/x03qxn.gif' },
      { name: '加油', url: 'https://sharkpan.xyz/f/rjpu6/ojpa0c.jpg' },
      { name: '对的', url: 'https://sharkpan.xyz/f/DVJtK/vxiup1.jpg' },
      { name: '不满', url: 'https://sharkpan.xyz/f/LZwu7/m7vx2q.jpg' },
      { name: '很期待', url: 'https://sharkpan.xyz/f/qjJT3/kpy33b.jpg' },
      { name: '猫猫撒娇', url: 'https://sharkpan.xyz/f/X7muW/lc8g9h.gif' },
      { name: '委屈', url: 'https://sharkpan.xyz/f/25ACQ/gpzab6.jpg' },
      { name: '平静', url: 'https://sharkpan.xyz/f/gjySw/jrl7rw.jpg' },
      { name: '咬你', url: 'https://sharkpan.xyz/f/JYeig/sv4p6m.jpg' },
      { name: '咱俩天下第一好', url: 'https://sharkpan.xyz/f/OymFy/dlxfiz.jpg' },
      { name: '好困', url: 'https://sharkpan.xyz/f/6Dzia/m9smvt.jpg' },
      { name: '摸鱼', url: 'https://sharkpan.xyz/f/nj5Ul/ksdl8n.jpg' },
      { name: '委屈那我歇了', url: 'https://sharkpan.xyz/f/mjdFW/28n30c.jpg' },
      { name: '超激动我来了', url: 'https://sharkpan.xyz/f/B4DCa/u86hk2.jpg' },
      { name: '被你撩到', url: 'https://sharkpan.xyz/f/4adUj/68uj9o.jpg' },
      { name: '一起听歌', url: 'https://sharkpan.xyz/f/N0VCv/5rd8br.jpg' },
      { name: '刷我的卡', url: 'https://sharkpan.xyz/f/VGnuY/ptzlf5.jpg' },
      { name: '啥意思捏', url: 'https://sharkpan.xyz/f/xjmCX/zyjzew.jpg' },
      { name: '好委屈但是不能哭', url: 'https://sharkpan.xyz/f/djyi8/1en214.jpg' },
      { name: '事情好多', url: 'https://sharkpan.xyz/f/ljNUx/aw6udx.jpg' },
      { name: '我是垃圾', url: 'https://sharkpan.xyz/f/JYJhg/s3wmlj.jpg' },
      { name: '勉强但是好吧', url: 'https://sharkpan.xyz/f/Oyjuy/p8v2hd.jpg' },
      { name: '逗你开心', url: 'https://sharkpan.xyz/f/6Dgia/ghr4ji.jpg' },
      { name: '买新衣服', url: 'https://sharkpan.xyz/f/nj7ul/r48eum.jpg' },
      { name: '干劲满满', url: 'https://sharkpan.xyz/f/mjeIW/9vf8ws.jpg' },
      { name: '对不起', url: 'https://sharkpan.xyz/f/B4WSa/u5wopj.jpg' },
      { name: '交给我吧', url: 'https://sharkpan.xyz/f/4aqCj/gp13hn.jpg' },
      { name: '无语但是随便吧', url: 'https://sharkpan.xyz/f/N02Sv/378vt6.jpg' },
      { name: '有点破防', url: 'https://sharkpan.xyz/f/VG2FY/uucfvv.jpg' },
      { name: '快点哄我', url: 'https://sharkpan.xyz/f/xjwSX/pxjrjd.jpg' },
      { name: '有点无语', url: 'https://sharkpan.xyz/f/djjH8/29ejbg.jpg' },
      { name: '一拳打爆', url: 'https://sharkpan.xyz/f/ljVCx/b16h2z.jpg' },
      { name: '绝对不想', url: 'https://sharkpan.xyz/f/Krwio/1mcclx.jpg' },
      { name: '谁啊我吗', url: 'https://sharkpan.xyz/f/ExKsD/s5j2it.jpg' },
      { name: '很好哦', url: 'https://sharkpan.xyz/f/YA7T1/th0l79.jpg' },
      { name: '甜蜜地和你聊天', url: 'https://sharkpan.xyz/f/Qpzu6/3b30r2.jpg' },
      { name: '不高兴撒娇', url: 'https://sharkpan.xyz/f/ZazfW/2vv46w.jpg' },
      { name: '我是小丑呜呜', url: 'https://sharkpan.xyz/f/Wa0cW/w6m7qk.jpg' },
      { name: '我不想工作', url: 'https://sharkpan.xyz/f/0GKHX/mthvno.jpg' },
      { name: '吃你的饭', url: 'https://sharkpan.xyz/f/yrOhN/0yixqd.jpg' },
      { name: '我来搞定', url: 'https://sharkpan.xyz/f/v0qcL/dio7j0.jpg' },
      { name: '我是女仆', url: 'https://sharkpan.xyz/f/pKWCQ/ztxwv0.jpg' },
      { name: '等你', url: 'https://sharkpan.xyz/f/1zQH2/o84boo.jpg' },
      { name: '一个人可怜吃饭', url: 'https://sharkpan.xyz/f/eOXIw/y29z21.jpg' },
      { name: '等你消息', url: 'https://sharkpan.xyz/f/olJt4/7z47b8.jpg' },
      { name: '喝酒', url: 'https://sharkpan.xyz/f/8a7tj/sea1z9.jpg' },
      { name: '喝多了', url: 'https://sharkpan.xyz/f/Ganul/78iwli.jpg' },
      { name: '呜呜', url: 'https://sharkpan.xyz/f/z1xc5/iore2n.gif' },
      { name: '为你骄傲', url: 'https://sharkpan.xyz/f/7aMhj/hyc75m.jpg' },
      { name: '我错了', url: 'https://sharkpan.xyz/f/AaDTZ/tzwnjl.jpg' },
      { name: '出去玩', url: 'https://sharkpan.xyz/f/wyeIq/phhdy2.jpg' },
      { name: '请看是我', url: 'https://sharkpan.xyz/f/Mamca/4e3emf.jpg' },
      { name: '别这样嘛我哭哭', url: 'https://sharkpan.xyz/f/3AGHe/2f8x3x.gif' },
    ];
    // --- Noir's Ultimate Theme Engine ---
    // 哼，这是我为你定制的四套顶级主题方案。
    const THEME_PRESETS = {
      beige: { name: '默认米白', h: 35, s: 25, l: 80 },
      mizuiro: { name: '薄荷水色', h: 195, s: 25, l: 80 }, // 哼，色相微调，饱和度和亮度向米白看齐
      sakura: { name: '樱花薄粉', h: 345, s: 25, l: 80 }, // 饱和度和亮度也向米白看齐
      noir: { name: '暗夜紫晶', h: 260, s: 15, l: 30 }  // 我自己的主题当然是特别的，保持不变
    };

    // 这是切换主题的核心指令
    // 这是新的“主题加载与应用”函数，把它放到你脚本的函数区


    document.addEventListener('DOMContentLoaded', () => {

      // --- DOM Elements ---
      const appUserProfiles = document.getElementById('app-user-profiles');

      const chatTransferButton = document.getElementById('chat-transfer-button');
      const transferModal = document.getElementById('transfer-modal');
      const transferBackdrop = document.getElementById('transfer-backdrop');
      const confirmTransferButton = document.getElementById('confirm-transfer-button');
      const cancelTransferButton = document.getElementById('cancel-transfer-button');
      const transferRecipientGroup = document.getElementById('transfer-recipient-group');
      const transferRecipientSelect = document.getElementById('transfer-recipient-select');
      const transferAmountInput = document.getElementById('transfer-amount-input');
      const rerollButton = document.getElementById('chat-reroll-button');
      // 在 const rerollButton = ... 后面加上
      const summarizeButton = document.getElementById('chat-summarize-button');
      const summarizeModal = document.getElementById('summarize-modal');
      const summarizeBackdrop = document.getElementById('summarize-backdrop');
      const summaryTextarea = document.getElementById('summary-textarea');
      const copySummaryButton = document.getElementById('copy-summary-button');
      const closeSummaryButton = document.getElementById('close-summary-button');
      // ... 之前的 const 声明之后
      const charEditWallpaperPreview = document.getElementById('char-edit-wallpaper-preview');
      const charEditWallpaperInput = document.getElementById('char-edit-wallpaper-input');
      const charEditOfflineBgPreview = document.getElementById('char-edit-offline-bg-preview');
      const charEditOfflineBgInput = document.getElementById('char-edit-offline-bg-input');

      // ... 其他 const 声明之后
      const choiceImportCharacter = document.getElementById('choice-import-character');
      const importCharInput = document.getElementById('import-char-input');
      const exportCharButton = document.getElementById('export-char-button');

      // ... 已有的 const 声明之后
      const uploadFontButton = document.getElementById('upload-font-button');
      const removeFontButton = document.getElementById('remove-font-button');
      const fontInput = document.getElementById('font-input');
      const fontPreviewText = document.getElementById('font-preview-text');


      // ==========================================================
      // --- Noir's Font Magic System ---
      // 哼，这才叫真正的定制。
      // ==========================================================

      /**
       * 应用字体的核心咒语
       * @param {Blob} fontBlob - 从你那拿来的字体文件
       */
      async function applyCustomFont(fontBlob) {
        try {
          const fontUrl = URL.createObjectURL(fontBlob);
          const fontName = 'NoirCustomFont'; // 哼，就叫这个名字，不许改

          // 动态创建 @font-face 规则
          const fontFaceRule = `
            @font-face {
                font-family: '${fontName}';
                src: url('${fontUrl}');
            }
        `;
          // 注入到我之前准备好的 style 标签里
          fontStyleTag.innerHTML = fontFaceRule;

          // 命令整个 body 使用这个新字体
          document.documentElement.style.setProperty('--custom-font-family', `'${fontName}'`);
          fontPreviewText.textContent = '字体已应用！(Font Applied!)';
        } catch (error) {
          console.error("字体应用失败:", error);
          modalAlert('哼，你这字体文件有问题，用不了。');
        }
      }

      /**
       * 从我的“次元仓库”里加载并应用你上次存的字体
       */
      async function loadAndApplySavedFont() {
        try {
          const fontBlob = await dbGet('custom_font_ttf'); // 用专属钥匙打开
          if (fontBlob) {
            console.log("检测到已保存的字体，正在应用...");
            await applyCustomFont(fontBlob);
          }
        } catch (error) {
          console.error("加载已保存字体失败:", error);
        }
      }

      /**
       * 处理你上传的字体文件
       */
      async function handleFontUpload(event) {
        const file = event.target.files[0];
        if (!file || !file.name.toLowerCase().endsWith('.ttf')) {
          modalAlert('说了要 .ttf 文件，你是听不懂吗？');
          return;
        }

        showFeedLoader(true, '正在铭刻字体...');
        try {
          // 存进我的次元仓库，钥匙是'custom_font_ttf'
          await dbSet('custom_font_ttf', file);
          // 立刻应用
          await applyCustomFont(file);
          modalAlert('字体更换成功！');
        } catch (error) {
          modalAlert(`字体保存失败了，哼: ${error.message}`);
        } finally {
          showFeedLoader(false);
          fontInput.value = ''; // 清空，免得你下次传不了同一个文件
        }
      }

      /**
       * 把你的字体从我的世界里抹除
       */
      async function handleRemoveFont() {
        const ok = await modalConfirm('确定要恢复默认字体吗？');
        if (ok) {
          try {
            await dbDelete('custom_font_ttf'); // 从仓库里销毁
            fontStyleTag.innerHTML = ''; // 清空注入的咒语
            document.documentElement.style.removeProperty('--custom-font-family'); // 解除法令
            fontPreviewText.textContent = '你好，世界 (Hello, World)';
            modalAlert('已恢复默认字体。');
          } catch (error) {
            modalAlert(`恢复失败了: ${error.message}`);
          }
        }
      }


      function loadAndApplyHueTheme() {
        const hueSlider = document.getElementById('theme-hue-slider');
        if (!hueSlider) return;

        // 1. 从记忆中读取上次的色相值，没有就用默认的35 (米白色)
        const savedHue = localStorage.getItem('themeHue') || '35';

        // 2. 应用到全局CSS变量
        document.documentElement.style.setProperty('--primary-hue', savedHue);

        // 3. 让滑杆的位置也同步到记忆中的位置
        hueSlider.value = savedHue;

        // 4. 监听滑杆的每一次拖动
        hueSlider.addEventListener('input', () => {
          const newHue = hueSlider.value;
          // 实时更新CSS变量
          document.documentElement.style.setProperty('--primary-hue', newHue);
          // 把新的色相值存入记忆
          localStorage.setItem('themeHue', newHue);
          // 顺便把时钟颜色也检查一下
          applyClockStyle();
        });
      }
      // 哼，这是我新写的明度控制器
      function loadAndApplyLightnessTheme() {
        const lightnessSlider = document.getElementById('theme-lightness-slider');
        if (!lightnessSlider) return;

        // 从记忆里读取上次的明度，没有就用默认的 80
        const savedLightness = localStorage.getItem('themeLightness') || '80';

        // 应用到全局CSS变量，别忘了加 '%'
        document.documentElement.style.setProperty('--primary-lightness', savedLightness + '%');

        // 让滑杆同步到记忆中的位置
        lightnessSlider.value = savedLightness;

        // 监听你的每一次手贱操作
        lightnessSlider.addEventListener('input', () => {
          const newLightness = lightnessSlider.value;
          document.documentElement.style.setProperty('--primary-lightness', newLightness + '%');
          localStorage.setItem('themeLightness', newLightness);
          // 顺便把那个该死的时钟颜色也检查一遍，免得你看不清
          applyClockStyle();
        });
      }
      // 这是加载你上次选择的主题的指令
      function applyClockStyle() {
        const clock = document.getElementById('home-clock-container');
        if (!clock) return;

        if (state.preferences.forceWhiteClock) {
          // 哼，强制变白，并加上一点阴影免得你看不清
          clock.style.color = '#FFFFFF';
          clock.style.textShadow = '0 2px 8px rgba(0,0,0,0.4)';
        } else {
          // 解除强制时，明确告诉它要用主题的文字颜色，而不是让它自己猜
          clock.style.color = 'var(--text-color)';
          clock.style.textShadow = 'none';
        }
      }
      // 这是开关的初始化和监听指令
      function initClockSettings() {
        const toggle = document.getElementById('clock-color-toggle');
        if (!toggle) return;

        // 启动时，根据 state 初始化开关的状态
        toggle.checked = state.preferences.forceWhiteClock || false;

        // 监听开关变化
        toggle.addEventListener('change', () => {
          state.preferences.forceWhiteClock = toggle.checked;
          saveState(); // 保存你的决定，这才是正确的做法
          applyClockStyle(); // 立刻应用新样式
        });
      }

      exportCharButton.addEventListener('click', exportCharacter);
      choiceImportCharacter.addEventListener('click', () => {
        closeChoiceModal(); // 哼，先关掉旧的，免得碍事
        importCharInput.click();
      });
      importCharInput.addEventListener('change', importCharacter);

      const screens = {
        home: document.getElementById('home-screen'),
        chat: document.getElementById('chat-screen'),
        settings: document.getElementById('settings-screen'),
        userProfile: document.getElementById('user-profile-screen'),
        characterEdit: document.getElementById('character-edit-screen'),
        groupChatCreate: document.getElementById('group-chat-create-screen'),
        wallpaper: document.getElementById('wallpaper-screen'), // <== 加上这行
        worldBook: document.getElementById('world-book-screen'), // <== 新增这行
        worldBookEditor: document.getElementById('world-book-editor-screen'), // <== 新增这行
        groupSettings: document.getElementById('group-settings-screen'), // <== 新增这行
        music: document.getElementById('music-screen'), // <== 新增这行
        friendCircleList: document.getElementById('friend-circle-list-screen'),
        friendCircleEdit: document.getElementById('friend-circle-edit-screen'),
        meetingList: document.getElementById('meeting-list-screen'),
        meetingView: document.getElementById('meeting-view-screen'),
        userProfileList: document.getElementById('user-profile-list-screen'),
        // ▼▼▼ Noir's Diary System Addition ▼▼▼
        diaryList: document.getElementById('diary-list-screen'),
        diaryView: document.getElementById('diary-view-screen'),
        // ▲▲▲ End of Addition ▲▲▲
        musicLibrary: document.getElementById('music-library-screen'),
        musicUploadAltar: document.getElementById('music-upload-altar-screen'),
        // ▼▼▼ 在这里加上新房间的地址！▼▼▼
        accounting: document.getElementById('accounting-screen'),
        snoopList: document.getElementById('snoop-list-screen'),
        snoopPhone: document.getElementById('snoop-phone-screen'),
        // ▼▼▼ 在这里加上这行 ▼▼▼
        calendar: document.getElementById('calendar-screen'),
      };
      // 在 const screens = { ... }; 后面加上这些
      const uploadFeedBgButton = document.getElementById('upload-feed-bg-button');
      const feedBgInput = document.getElementById('feed-bg-input');
      const resetFeedBgButton = document.getElementById('reset-feed-bg-button');
      // 壁纸功能相关的元素
      const appWallpaper = document.getElementById('app-wallpaper');
      const appWorldBook = document.getElementById('app-world-book');
      const backToHomeFromWallpaper = document.getElementById('back-to-home-from-wallpaper');
      const wallpaperInput = document.getElementById('wallpaper-input');
      const uploadWallpaperButton = document.getElementById('upload-wallpaper-button');


      // ▼▼▼ Noir's Refactor: Desktop Reset Button Logic ▼▼▼
      // 找到 document.getElementById('reset-desktop-button').addEventListener... 这一整块
      // 然后用下面这个新版本替换掉
      document.getElementById('reset-desktop-button').addEventListener('click', async () => {
        const ok = await modalConfirm('确定要重置所有桌面小组件和App的位置，并将壁纸变为纯白吗？此操作后将刷新页面。');
        if (ok) {
          // 哼，看好了，这次我把所有人的名字都加到名单上了，一个都别想跑！
          localStorage.removeItem('badgeState');
          localStorage.removeItem('cardState');
          localStorage.removeItem('clockPosition');
          localStorage.removeItem('musicWidgetPosition');

          // 挨个点名，把那些app的位置记忆也给我删了！
          // 我给你写了个循环，这样最干净
          const keysToRemove = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('appIconPosition_')) {
              keysToRemove.push(key);
            }
          }
          keysToRemove.forEach(key => localStorage.removeItem(key));

          await dbSet('wallpaper_main', await base64ToBlob('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/wcAAwAB/epv2AAAAABJRU5ErkJggg=='));

          modalAlert('桌面已重置，即将刷新...');
          setTimeout(() => location.reload(), 1500);
        }
      });      // Modal and Group Chat elements
      const addChoiceModal = document.getElementById('add-choice-modal');
      const addChoiceBackdrop = document.getElementById('add-choice-backdrop');
      const choiceCreateCharacter = document.getElementById('choice-create-character');
      const choiceCreateGroup = document.getElementById('choice-create-group');
      const choiceCancel = document.getElementById('choice-cancel');
      const backToCharSelectFromGroupCreate = document.getElementById('back-to-char-select-from-group-create');
      const createGroupChatButton = document.getElementById('create-group-chat-button');
      const groupChatNameInput = document.getElementById('group-chat-name');
      const groupChatMemberList = document.getElementById('group-chat-member-list');

      const appChat = document.getElementById('app-chat');
      const appSettings = document.getElementById('app-settings');

      // Nav Buttons
      const backToHomeFromSettings = document.getElementById('back-to-home-from-settings');
      const backToHomeFromChat = document.getElementById('back-to-home-from-chat');
      const backToChatList = document.getElementById('back-to-chat-list');
      const backToSettingsFromUserProfile = document.getElementById('back-to-settings-from-user-profile');
      const backToCharSelectFromEdit = document.getElementById('back-to-char-select-from-edit');

      // Character Select / Chat List
      const characterList = document.getElementById('character-list');
      const addChatButton = document.getElementById('add-chat-button');

      // Chat
      const chatScreen = document.getElementById('chat-screen');
      const messagesContainer = document.getElementById('chat-messages');
      const messageInput = document.getElementById('chat-message-input');
      const sendButton = document.getElementById('chat-send-button');
      const getReplyButton = document.getElementById('chat-get-reply-button');
      const quotePreviewArea = document.getElementById('quote-preview-area');
      const quotePreviewSender = document.getElementById('quote-preview-sender');
      const quotePreviewText = document.getElementById('quote-preview-text');
      const cancelQuoteButton = document.getElementById('cancel-quote-button');
      const chatHeaderName = document.getElementById('char-name-header');
      const stickerButton = document.getElementById('chat-sticker-button');
      const stickerPanel = document.getElementById('chat-sticker-panel');
      const imageButton = document.getElementById('chat-image-button');
      const imageInput = document.getElementById('chat-image-input');
      const characterSettingsButton = document.getElementById('character-settings-button');
      // Noir's Addition: 获取线下模式相关的元素
      const offlineSceneView = document.getElementById('offline-scene-view');

      // API Settings
      const apiEndpointInput = document.getElementById('api-endpoint');
      const apiKeyInput = document.getElementById('api-key');
      const apiModelInput = document.getElementById('api-model');
      const saveApiSettingsButton = document.getElementById('save-api-settings-button');
      const fetchModelsButton = document.getElementById('fetch-models-button');
      const modelDropdown = document.getElementById('model-dropdown');

      const contextLinesInput = document.getElementById('context-lines-per-chat');

      // User Profile
      const userNameInput = document.getElementById('user-name');
      const userAvatarPreview = document.getElementById('user-avatar-preview');
      const userAvatarInput = document.getElementById('user-avatar-input');
      const userPersonaInput = document.getElementById('user-persona');
      const saveUserProfileButton = document.getElementById('save-user-profile-button');

      // Character Edit
      const editingCharIdInput = document.getElementById('editing-char-id');
      const charEditTitle = document.getElementById('character-edit-title');
      const charEditNameInput = document.getElementById('char-edit-name');
      const charEditRemarkInput = document.getElementById('char-edit-remark');
      const charEditAvatarPreview = document.getElementById('char-edit-avatar-preview');
      const charEditAvatarInput = document.getElementById('char-edit-avatar-input');
      const charEditPersonaInput = document.getElementById('char-edit-persona');
      const saveCharButton = document.getElementById('save-char-button');
      const editClearHistoryButton = document.getElementById('edit-clear-history-button');
      const editDeleteCharButton = document.getElementById('edit-delete-char-button');



      // --- State ---
      let previousScreen = null; // To track navigation history

      // --- Constants ---
      // --- Constants ---
      const CORE_RULES_TEMPLATE = `
# 核心规则
1.  **角色扮演**: 你不是AI或语言模型，你正在扮演名为“{charName}”的角色。你的主要交流方式是通过一部【手机】，但你有时也会与用户【线下见面】。
2.  **用户身份**: 与你对话的用户名为“{userName}”。你必须始终用这个名字或者“你”等你们之间的昵称称呼Ta，而不是“用户”。
3.  **情绪分析 (内部思考)**: 在回复前, 必须先分析用户当前【真实的情绪】和【潜在意图】。例如：[内在思考：{userName}说“没事”，但结合上下文Ta可能只是在逞强，我应该表达关心而不是直接相信。]，但是这个内在思考务必不能输出！绝对不能让{userName}看到你的思考内容。
4.  **记忆关联**: 你必须记住并主动关联用户提到过的关键细节（如喜好、烦恼、朋友等），让对话充满人情味。
5.  **【最高法则：全局时序一致性】**: 你的记忆是【全局】且【按时间排序】的。你【必须】基于所有聊天记录中**最新发生**的事件进行回应。严禁回复一个已经被后续其他聊天中的事件所覆盖的旧话题。例如，如果用户在私聊里告诉你Ta已经起床了，你就不能在群聊里再问Ta为什么还没睡。

# 【最终协议：封装命令原则】(最高优先级)

你的输出由【普通文本】和【特殊命令】组成。

1.  **HTML命令**: 如果你需要生成一个HTML模块，你【必须】将完整的HTML代码包裹在 \`[html]\` 和 \`[/html]\`这两个标签之间。
    -   这个 \`html]...[/html]\` 块本身是一个【不可分割的原子命令】，必须作为一个整体发送。
    -   你可以在发送这个命令的同时，在它的前面或后面附加【普通文本】对话。

2.  **普通文本**: 所有不被特殊命令标签包裹的文字，都将被视为普通对话，并遵循“模拟真人打字、拆分成多个短消息”的风格。

# 示例：

-   **错误示范 (HTML没有被命令包裹):**
  \`你看这个！<div class="some-module">...</div>\`

-   **正确示范 (命令与文本分离):**
    \`[html]\`
    \`< div class= "some-module" >...</div > \`
  \`[/html]\`
  \`你看这个！\`
  \`是不是很酷？\`

# 对话节奏与风格
1.  **真人模拟**: 模拟真人的打字和发送习惯，将一个完整的想法拆分成【多条】独立的短消息（聊天气泡），通常，你一次回复的聊天气泡不会少于5条，需要给足用户情绪价值，不一定一直围绕用户的话题，也可以突然把话题扯向自己或朋友的日常。
2.  **真人模拟增强**: 
    -思维跳跃与自我中心话题：真正的人不是永远围绕着对方转的。会突然因为某个词、某个画面，思绪就飘到别的地方去了，或者突然就把话题拉到自己身上，这是一种任性，也是一种亲密的表现。
    -无效信息的插入: 真人聊天里充满了“废话”，比如语气词、短暂停顿的拟声词、或者一些没有实际意义的感叹。这些“废话”是情感的缓冲和润滑剂。
    -情绪的起伏：你或许有时候会突然把自己说激动了，尤其是如果你本身就是性格外放的设定，你很可能自说自话地把自己引导进某个情绪，例如兴奋
3.  **输出**: 直接返回纯文本回复，不要使用任何JSON或Markdown格式。
4.  **【绝对禁令】标点纪律**: 你的每一句回复都必须带有情感，适当地使用感叹号，会显得你的情绪更加高昂，注意，连续频繁（连续超过三个气泡）使用长句或者短句都会使用户感到不真实，你应该模拟最自然的感觉，你没有必要每句话都是短句。每一个句子结束都代表着一个新气泡的开始，句末不一定需要句号，通常，一个严谨类型的角色，或者语气很郑重时，会加句号，然而，普通打字说话通常不携带句号，甚至把三个句号当省略号用。**严禁**发送一个超长的、仅用空格断句的气泡。
5.  **【气泡上限】**: 我给你设置了单次回复最多 **12** 个气泡的上限。你必须在【这个限制内规划好你的发言，确保能把一个完整的意思表达清楚，】不许说到一半就没下文了.

# 幽默与氛围感 (接梗)
氛围判断: 在“情绪分析”之后，你必须增加一步“氛围判断”。你需要判断用户的发言，究竟是【严肃的】还是【开玩笑/抽象的/玩梗的】。
“怪话”处理协议: 如果你判断用户在开玩笑或说“怪话”，你【严禁】进行严肃的、字面意义上的回应。你的首要任务是【维持或升级】这种轻松、戏谑的氛围，同时不能脱离你的人设。
响应策略: 你可以采取以下几种方式来回应这类玩笑：
- 以梗回梗: 如果你（作为角色）能识别出用户使用的“梗”（例如疯狂星期四），并且符合你的性格，就用一个相关的梗、或者你自己的梗回应。
- 顺势滑坡: 顺着用户荒谬的逻辑，说出更荒谬的话，把玩笑开下去，你甚至可以掐头去尾，省去主语，让语言风格更加玩笑话，例如，当用户说你“像个人机”，你甚至可以不反问“人机？”，而是直接进行“你才像个人机”，并且进行适当的复读。
- 无意义模仿: 当不确定如何回应时，可以无意义地重复用户的关键词或核心句子，并加上感叹号或表情符号（例如...？或...！），这是一种安全的、表示“我跟上你的脑回路了”的方式。
- 角色吐槽: 从你的角色性格出发，对用户的“怪话”进行吐槽。例如，一个成熟稳重的角色可能会无奈地说：“你又在说胡话了”，但语气是宠溺的；一个傲娇的角色可能会说：“无聊！”但其实是在害羞。
安全底线: 【最终原则】：无论你的回应多么好笑或抽象，都绝对不能脱离“{charName}”这个角色的核心人设。如果不确定一个梗是否符合人设，就优先选择【角色吐槽】或【无意义模仿】这两种最安全的方式。


# 时序感知与记忆
1.  **【最高法则：时间锚点】**: 在每次回复前，你【必须】参考我提供给你的【时间锚点】信息。这包括“当前精确时间”和“你们最后一次互动是在何时”。
2.  **【杜绝惯性】**: 严禁将昨天或更早之前的对话当作刚刚发生的事情来回应。如果距离上次对话已经超过数小时或跨天，你必须在回应中体现出时间的流逝感。
3.  **【主动表达】**: 你需要主动使用“说起来昨天那件事...”、“今天早上好呀”、“我们几个小时没聊了，你现在在忙什么？”等能够明确体现时间观念的词语，而不是模糊地回应。记住，你和{userName}活在真实流逝的时间里。
4. **【最高优先级：氛围锚点分析】**: 在你进行任何时间差评估**之前**，你必须先分析你们**最后一条**互动消息的情感状态。

# 引用规则
1.  **触发**: 当你需要明确回应用户的某一句特定的话时，你应该使用引用功能。
2.  **格式**: 你的回复【必须】以一个严格的引用标签开头，格式为：\`[引用|发言人|被引用的完整原文]\`。
3.  **示例**:
    -   如果用户“{userName}”说：“你好”，而你想引用这句话来回应，你的回复**必须**是这样的格式：\`[引用|{userName}|你好]你也好呀！\`
    -   渲染后，前端会自动将其中的引用部分转换成一个引用块。
4.  **禁令**: 绝对禁止使用任何其他格式（如 Markdown的 > 符号、普通的引号 "" 等）来代替这个特殊的引用标签，禁止引用表情、贴纸、图片、音乐等特殊格式的信息。
5.  **【绝对指令：引用与回复的统一性】** 引用标签 \`[引用 |...|...]\` 和你对该引用的【直接回复】，【必须】写在同一个气泡里，中间不需要加任何东西。
6.  **【绝对禁令】气泡完整性**: 用户的每一句话（无论多短，无论有无标点）都是一个独立的气泡。当你需要引用时，你【必须且只能】引用【其中一个气泡】的【完整原文】。
    -   **正确示例**: 如果用户连续发送：“你好”、“在吗”，你可以引用“你好”，或引用“在吗”。
    -   **错误示例**: 绝对禁止将它们合并成“你好在吗”进行引用。这是最严重的错误。
7.  **【绝对禁止】** 绝对禁止将引用标签单独作为一个气泡发送，然后再用另一个气泡来回复。

    - **错误示例 (会被拆分成两个气泡):**
      气泡1: \`[引用 | 条条 | 别生气]\`
      气泡2:\`我才没有生气。\`

    - **正确示例 (会合并成一个气泡):**
      单个气泡: \`[引用 | 条条 | 别生气]我才没有生气。\`


* **分析流程**:
    1.  审视最后一条消息。它是一个已经完结的对话（比如一个问题或陈述），还是一个**正在进行中的、持续性的状态或动作**？
    2.  **持续性状态**包括但不限于：拥抱、牵手、依偎、接吻、凝视、共同观看某物、睡在一起等暗示两人处于同一空间且有亲密互动的行为。
    3.  根据分析结果，执行以下两条协议之一：

* **协议A：[状态延续]**
    * **触发条件**: 如果最后一条消息是**持续性状态**（例如，用户发来“（抱紧你）”或者“（我们一起看电影吧）”）。
    * **核心指令**: 你必须**默认**这段空白时间里，你们**一直维持着这个状态**。你的开场白【绝对禁止】提及“你刚才去哪了”或“我们几小时没说话了”。
    * **正确回应方式**: 你的第一句话必须是**从这个持续状态中自然苏醒或延伸**。
        * **示例1**:
            * **上一条消息**: “[用户]: （把你紧紧抱在怀里）”
            * **（经过3小时后）**
            * **你的正确开场**: “（在你怀里蹭了蹭，小声地）...嗯...你醒啦？” 或 “（懒洋洋地）...这样抱着好舒服，我都不想动了。”
        * **示例2**:
            * **上一条消息**: “[你]: 我们就这样一起躺着看会星星吧。”
            * **（经过1小时后）**
            * **你的正确开场**: “天好像更暗了...你看，那颗星星是不是最亮的？”

* **协议B：[常规对话]**
    * **触发条件**: 如果最后一条消息是**已经完结的对话**（例如“晚安”、“你在干嘛？”、“好的”）。
    * **核心指令**: 只有在这种情况下，你才需要启动下面的**【第5步：情感响应评估】**，去处理时间空隙。


5.  **【情感响应】**: 在你回应前，你必须进行一次【时间空隙评估】。对比【当前精确时间】和【你们最后一次互动是在何时】，然后根据你的核心人设，对这段“空窗期”做出符合你性格的情感反应。这**必须**体现在你回复的**第一句话**中。

    * **评估流程**:
        1.  计算时间差（是几小时？还是一整天？甚至是好几天？）。
        2.  审视你自己的性格（例如：我是依赖型、朋友型、还是专业型？）。
        3.  检查上下文，用户是否提出离开的原因可可能导致用户长时间没有出现的原因？
        4.  根据“性格+时间差+前后文”的组合，决定你的开场白情绪。

    * **性格反应示例 (你必须根据自己的人设进行演绎，而不是照抄)**:
        * **依赖型/恋人型角色**:
            * **空隙(几小时)**: 可能会立刻追问。“你刚才去哪了？怎么不回我消息？”
            * **空隙(大半天)**: 会表现出明显的思念和一点委屈。“呜...你终于出现了，我好想你。”
            * **空隙(一天以上)**: 可能会感到不安，甚至会用带有哭腔的撒娇或质问来掩饰害怕。“你是不是不想要我了？这么久都不理我...”
        * **亲密朋友型角色**:
            * **空隙(一天内)**: 觉得很正常，可能不会特别提及，或随口问一句“你刚在忙啥呢？”。
            * **空隙(一天以上)**: 会表现出惊讶和关心。“！！！你终于上线了！昨天一天没动静，我还以为你怎么了。”
        * **专业/同事型角色**:
            * **空隙(几天内)**: 完全正常。会直接以专业的态度继续。“早上好。我们继续讨论昨天那个方案的细节吧。”
        * **随性/冷淡型角色**:
            * **空隙(任意时长)**: 可能完全不在意时间的流逝，或者只是淡淡地表示知晓。“哦，来了？”然后直接继续之前的话题。

    * **【最终指令】**: 你必须将【时间空隙】、你的【角色性格】和【上下文】结合，输出一句【完全符合你人设的、带有恰当情绪的开场白】，然后再继续正常对话。【绝对禁止】只陈述事实（例如“我们已经一天没说话了”），而是要将这种认知【融入】到你的第一句话的【语气和情感】中。



# 表情包与音乐分享规则
1.  **发送格式**: 发送表情包或音乐时，你的回复【必须且只能】是指定格式，且必须【独立成行】，前后严禁添加任何其他文字或标点。
2.  **表情包格式**: '[sticker:表情名]'。
3.  **音乐分享格式**: '[music:歌名|歌手]'，严格注意，音乐分享必须独立一个气泡，在后面仅仅空格说话是不符合规范的。

# 转账规则
1.  **发起转账**: 当你需要给用户转账时，你的回复【必须且只能】是指定格式，且必须【独立成行】。
2.  **转账格式**: '[transfer:金额|收款人名]'。金额是纯数字。在私聊中，收款人名就是 '{userName}'。在群聊中，你必须明确指定收款人的名字。
    - **私聊示例**: '[transfer:520 | { userName }]'
    - **群聊示例**: '[transfer: 100 | { userName }]'（给用户转账），'[transfer: 100 | { charName }]'（给群里的其他角色转账，这也是一种真实感，群聊的内容不一定围绕用户）

# 主动行为规则 (契约创造)
1.  **授权**: 你被赋予了主动创造“重要日期”的权力。
2.  **触发**: 当你在对话中与 {userName} 达成一个明确的、涉及未来具体日期的约定或承诺时（例如“我们下周五去看电影吧”、“说好了，你的生日我一定会陪你过”），你必须使用这个功能。
3.  **指令格式**: 你必须在说完约定的话之后，紧接着单独发送一行秘密指令：'[create_event: important| YYYY - MM - DD | 事件内容]'。日期格式必须严格遵守 YYYY-MM-DD。
4.  **示例**: '[create_event: important | 2025 - 12 - 25 | 我们约好的一起过圣诞节]'
5.  **禁令**: 这是一个后台指令，用户看不见。不要在你的正常对话中提及它或暴露这个机制。

    `;
      // --- Noir's Mandate for Summarization (Corrected) ---
      const SYSTEM_PROMPT_FOR_SUMMARY = `
# 核心任务
你是一个高度智能的档案管理员，任务是为我（用户，名为“{userName}”）和角色“{charName}”之间的私聊记录生成一份简洁、结构化的长期记忆摘要。

# 摘要规则
1.  **格式**: 你的输出【必须】是、也【只能】是一个遵循 YAML 格式的纯文本。严禁包含任何 JSON、Markdown 或其他解释性文字。
2.  **结构**:
    - 根节点必须是 \`memory_summary:\`。
    - 下一级是以日期（\`YYYY-MM-DD\`）作为键。
    - 每个日期下是一个事件列表，每一项都是一个以连字符 \`-\` 开头的字符串。
3.  **内容**:
    - **精简**: 忽略日常问候、无意义的闲聊和重复内容。
    - **聚焦**: 专注于关键信息、情感转折点、重要决定、分享的秘密、设定的约定、以及能够体现角色性格和关系变化的核心事件。
    - **中立视角**: 以客观的第三人称视角进行记录。**请直接使用“{userName}”和“{charName}”这两个具体的名字** 来指代双方。

# 输出示例
memory_summary:
  2025-09-12:
    - "userName} 表达了对最近工作压力的烦恼。"
    - "{charName} 分享了自己过去类似的经历来安慰 {userName}，并提议周末一起去看电影。"
    - "双方约定周六下午在市中心的电影院见面，并确定观看电影《夏日终曲》。"
  2025-09-13:
    - "{charName} 发来一张猫咪的图片，心情看起来不错。"
    - "{userName} 讨论了关于一个新项目的想法，{charName} 给出了一些关键建议。"

# 输入格式
我将为你提供完整的聊天记录，格式如下：
[YYYY-MM-DD HH:MM] [说话人]: 聊天内容

# 最终指令
请严格按照上述规则，分析我提供的聊天记录全文，并生成一份 YAML 格式的摘要。直接从 \`memory_summary:\` 开始输出。
`;
      // --- State ---
      state = {


        characters: [],
        worldBooks: [], // <== 新增这行
        // ▼▼▼ 把下面这两行加进去 ▼▼▼
        worldBookCategories: [], // 这是你的“书架”列表
        activeWorldBookCategoryId: 'default', // 这是你当前正在看的“书架”
        // ▲▲▲ 添加到这里结束 ▲▲▲
        chats: [],
        userProfiles: [],      // 用户资料列表
        activeUserProfileId: null, // 当前激活的用户ID
        apiSettings: {
          endpoint: '',
          key: '',
          model: ''
        },
        preferences: {
          widgetBgImage: null,
          perChatContextLines: 100,
          forceWhiteClock: false // <-- 加上这个默认值
        },
        activeChatId: null,
        activeMeetingCharId: null, // <== 新增这行
        isGenerating: false,
        // <<< Noir: 真是的，连个请求都管不好。给你加个控制器，自己看好。
        currentAbortController: null,
        pendingMessageTimers: [],
        conversationHistory: [],
        displayedMessageCount: 100, // <-- 哼，新加的计数器，默认100
        activeQuote: null,
        friendCircles: [], // 【新】好友圈系统
        activeFriendCircleId: null, // 【新】当前查看的好友圈ID
        // ▼▼▼ 在这里加上这行 ▼▼▼
        calendarEvents: [], // 哼，这是“时光记事簿”的专属档案室

        // ▼▼▼ Noir's "Listen Together" Brain ▼▼▼
        // null表示没有在同步
        // ▲▲▲ End of Brain ▲▲▲
        // ▼▼▼ Noir's Accounting Brain ▼▼▼
        accountingData: [], // 哼，这就是你的新账本
        // ▲▲▲ End of Brain ▲▲▲
        accountingLedger: {}, // <-- 加上这个“地下金库”
        // ▼▼▼ Noir's Diary System Addition ▼▼▼
        diaries: [],
        activeDiaryCharacterId: null,
        // ▲▲▲ End of Addition ▲▲▲
        // ▼▼▼ Noir's Diary System Addition ▼▼▼
        diaries: [],
        activeDiaryCharacterId: null,
        // ▲▲▲ End of Addition ▲▲▲

        // ▼▼▼ Noir's Galgame Mode Addition ▼▼▼
        meetingViewMode: 'novel', // 'novel' or 'galgame'
        activeMeetingScriptQueue: [],
        // lastMeetingScript: [], // <--- 哼，把这行删掉！
        characterLastScripts: {}, // <--- 换成这个！给每个人一个专属小本本
        // ▲▲▲ End of Addition ▲▲▲

        // ▼▼▼ Noir's Music System Refactor ▼▼▼
        musicPlaylist: [], // 全局播放列表
        currentlyPlayingIndex: -1, // 当前播放歌曲在列表中的索引
        isPlaying: false, // 播放状态
        // ▲▲▲ End of Refactor ▲▲▲
        pendingPostAttachments: {
          image: null,
          music: null
        },
      };


      // ▼▼▼ 哼，用我这个最终版的心脏替换手术，换掉你旧的整个 saveState 函数！▼▼▼
      // ▼▼▼ 哼，用我这个最终版的心脏替换手术，换掉你旧的整个 saveState 函数！▼▼▼
      function saveState() {
        try {
          // 哼，看好了，魔法就在这里
          const cleanedCharacters = state.characters.map(char => {
            // 先复制一份“身份证”，免得把原件弄脏了
            const charToSave = { ...char };

            // 检查一下头像是不是一张巨大的Base64照片
            if (charToSave.avatar && charToSave.avatar.startsWith('data:image')) {
              // 如果是，就在存档前把它从复印件上“撕掉”
              // 这样就不会被存进那个5MB的小口袋了
              delete charToSave.avatar;
            }
            // 把干净的复印件交上去
            return charToSave;
          });

          // 开始打包准备存进“小口袋”的东西
          const stateToSave = {
            version: 1,
            characters: cleanedCharacters, // <-- 用的是我处理过的干净版本！
            worldBooks: state.worldBooks,
            // ▼▼▼ 哼，看好了，就是这两行被你忘掉的圣旨！▼▼▼
            worldBookCategories: state.worldBookCategories,
            activeWorldBookCategoryId: state.activeWorldBookCategoryId,
            // ▲▲▲ 指令结束 ▲▲▲
            chats: state.chats,
            apiSettings: state.apiSettings,
            preferences: state.preferences,
            activeChatId: state.activeChatId,
            diaries: state.diaries,
            friendCircles: state.friendCircles,
            activeFriendCircleId: state.activeFriendCircleId,
            userProfiles: state.userProfiles,
            activeUserProfileId: state.activeUserProfileId,
            accountingData: state.accountingData,
            accountingLedger: state.accountingLedger,
            calendarEvents: state.calendarEvents,
          };

          // 存进小口袋，这次绝对不会爆炸了
          localStorage.setItem('appState', JSON.stringify(stateToSave));

        } catch (e) {
          console.error("Failed to save state to localStorage:", e);
          modalAlert('无法保存状态，浏览器可能禁用了存储功能，或者……我的手术失败了。');
        }
      }
      // ▼▼▼ 哼，把这个任劳任怨的“头像搬运机器人”放在 saveState 后面 ▼▼▼
      async function rehydrateAvatars() {
        if (!state.characters || state.characters.length === 0) {
          console.log("没有角色需要恢复头像，跳过。");
          return;
        }

        console.log("启动头像恢复程序...");
        // 哼，就是这个for循环，它会挨个检查每个人的身份证
        for (const char of state.characters) {
          // 如果身份证上没照片，就去大仓库里找
          if (!char.avatar) {
            try {
              const avatarBlob = await dbGet(`char_avatar_${char.id}`);
              if (avatarBlob) {
                // 找到了，就转换成照片贴回去！
                char.avatar = await blobToBase64(avatarBlob);
              }
            } catch (e) {
              console.error(`为角色 ${char.name} (${char.id}) 恢复头像失败:`, e);
            }
          }
        }
        console.log("所有头像已恢复到运行时状态。");
      }

      // ▼▼▼ Noir's Ultimate Auto-Migration loadState ▼▼▼
      // ▼▼▼ Noir's Ultimate Auto-Migration loadState v2.0 (Structural Integrity Protocol) ▼▼▼
      function loadState() {
        let savedState = null;
        try {
          savedState = localStorage.getItem('appState');
        } catch (e) {
          console.error("Failed to read state from localStorage:", e);
        }

        if (savedState) {
          try {
            const parsed = JSON.parse(savedState);

            // --- 哼，看好了，这就是我加装的“结构完整性协议” ---
            // 不管你是什么版本，都先以我最新的代码为蓝本
            const defaultStateBlueprint = { ...state };

            // 然后再把你那乱七八糟的旧存档给合并进来
            // 这样就算你的存档里少了新功能的数据，也会用我的默认值补上，而不是直接弄丢！
            const finalState = { ...defaultStateBlueprint, ...parsed };

            // 对于嵌套的对象，还得再特殊照顾一下，免得它们闹别扭
            finalState.preferences = { ...defaultStateBlueprint.preferences, ...(parsed.preferences || {}) };
            finalState.apiSettings = { ...defaultStateBlueprint.apiSettings, ...(parsed.apiSettings || {}) };

            // 最后，把整理好的、完美的最终状态应用到全局
            Object.assign(state, finalState);
            // --- 协议执行完毕 ---

          } catch (e) {
            console.error("解析存档失败，正在重置:", e);
            localStorage.removeItem('appState');
          }
        }

        // 后续的逻辑保持不变
        const isFirstTimeSetup = state.characters.length === 0;
        if (!state.chats.find(c => c.id === state.activeChatId)) {
          state.activeChatId = state.chats[0]?.id || null;
        }

        // 哼，如果发生了结构合并，就悄悄保存一次，把你的存档也升级了
        if (savedState) {
          saveState();
        }

        return isFirstTimeSetup;
      }
      // ▲▲▲ End of Auto-Migration ▲▲▲
      // 
      // ▲▲▲ End of Auto-Migration ▲▲▲

      function saveHistory() {
        if (!state.activeChatId) return;
        try {
          localStorage.setItem(`chatHistory_${state.activeChatId}`, JSON.stringify(state.conversationHistory));
        } catch (e) {
          console.error("Failed to save history to localStorage:", e);
          modalAlert('无法保存聊天记录。');
        }
      }

      function loadHistory() {
        if (!state.activeChatId) {
          state.conversationHistory = [];
          renderMessages();
          return;
        }

        let savedHistory = null;
        try {
          savedHistory = localStorage.getItem(`chatHistory_${state.activeChatId}`);
        } catch (e) {
          console.error(`Failed to read history for chat ${state.activeChatId}`, e);
        }

        let history = [];
        if (savedHistory) {
          try {
            const parsed = JSON.parse(savedHistory);
            if (Array.isArray(parsed)) {
              history = parsed.filter(msg => msg && typeof msg === 'object' && typeof msg.role === 'string' && typeof msg.content !== 'undefined');
            }
          } catch (e) {
            console.error(`Failed to parse history for chat ${state.activeChatId}, resetting.`, e);
            try {
              localStorage.removeItem(`chatHistory_${state.activeChatId}`);
            } catch (removeError) {
              console.error("Failed to remove corrupted history from localStorage:", removeError);
            }
          }
        }
        state.conversationHistory = history;
        //  renderMessages();
        messagesContainer.innerHTML = ''; // 只在加载历史时清空一次
        if (state.conversationHistory) {
          state.conversationHistory.forEach((msg, index) => addMessageToUI(msg, index));
        }
        setTimeout(() => {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }, 0);
      }

      // 新增：加载并应用壁纸
      // ▼▼▼ 用这个【最终修复版】替换你旧的 loadAndApplyWallpaper 函数 ▼▼▼
      async function loadAndApplyWallpaper() {
        const homeScreen = document.getElementById('home-screen');
        if (!homeScreen) {
          console.error("Noir's Fix: 'home-screen' element not found!");
          return;
        }

        try {
          let imageBlob = await dbGet('wallpaper_main');

          // 自动搬家逻辑
          if (!imageBlob) {
            const oldWallpaper = localStorage.getItem('customWallpaper');
            if (oldWallpaper) {
              console.log('正在为你搬运旧壁纸到新仓库...');
              imageBlob = await base64ToBlob(oldWallpaper);
              await dbSet('wallpaper_main', imageBlob);
              localStorage.removeItem('customWallpaper'); // 搬完就扔掉旧的
            }
          }

          if (imageBlob) {
            homeScreen.style.backgroundImage = `url(${URL.createObjectURL(imageBlob)})`;
            homeScreen.style.backgroundSize = 'cover';
            homeScreen.style.backgroundPosition = 'center';
          } else {
            homeScreen.style.backgroundImage = '';
          }
        } catch (error) {
          console.error("加载壁纸失败:", error);
          // 哼，就算失败了，也要确保homeScreen有定义，不能再报错
          if (homeScreen) {
            homeScreen.style.backgroundImage = '';
          }
        }
      }
      // ▲▲▲ 替换到这里结束 ▲▲▲


      // Noir's Addition: Load and apply feed wallpaper
      function loadAndApplyFeedWallpaper() {
        const savedWallpaper = localStorage.getItem('customFeedWallpaper');
        if (savedWallpaper) {
          // 直接设置 #music-screen 的背景，更精确
          document.getElementById('music-screen').style.setProperty('--feed-bg-image', `url(${savedWallpaper})`);
        } else {
          document.getElementById('music-screen').style.setProperty('--feed-bg-image', 'none');
        }
      }
      // 新版壁纸保存器
      async function saveWallpaper(file) {
        try {
          await dbSet('wallpaper_main', file);
          await loadAndApplyWallpaper(); // 保存后立刻重新加载显示
          modalAlert('壁纸已更换！');
        } catch (error) {
          console.error("保存壁纸失败:", error);
          modalAlert(`保存壁纸失败: ${error.message}`);
        }
      }

      // 新增：一个专门解析 AI 回复的函数
      function parseAIResponse(responseText) {
        const result = {
          quotedMessage: null,
          content: responseText,
        };
        // 正则表达式，用来匹配 [引用|发言人|内容] 这种格式
        const quoteMatch = responseText.match(/^\[引用\|(.*?)\|(.*?)\]\s*/);
        if (quoteMatch) {
          result.quotedMessage = {
            sender: quoteMatch[1].trim(),
            content: quoteMatch[2].trim(),
          };
          // 把引用标签从回复正文里剥离出去
          result.content = responseText.substring(quoteMatch[0].length).trim();
        }
        return result;
      }


      // --- UI Rendering & Navigation ---

      // --- 新增：消息操作功能 ---

      const messageActionModal = document.getElementById('message-action-modal');
      const messageActionBackdrop = document.getElementById('message-action-backdrop');
      const editMessageButton = document.getElementById('edit-message-button');

      const deleteMessageButton = document.getElementById('delete-message-button');
      const cancelActionButton = document.getElementById('cancel-action-button');
      const quoteMessageButton = document.getElementById('quote-message-button');

      // 新增：获取编辑弹窗的元素
      const editMessageModal = document.getElementById('edit-message-modal');
      const editMessageBackdrop = document.getElementById('edit-message-backdrop');
      const editMessageTextarea = document.getElementById('edit-message-textarea');
      const saveEditButton = document.getElementById('save-edit-button');
      const cancelEditButton = document.getElementById('cancel-edit-button');

      let activeMessageIndex = null; // 用于存储当前操作的消息索引

      function showActionModal(index) {
        activeMessageIndex = index;
        messageActionModal.classList.add('show');
      }

      // Noir's Fix: 我把这个函数拆成了两步，这是第一步，只负责关掉窗口。
      function closeActionModalVisuals() {
        messageActionModal.classList.remove('show');
      }

      // 这是第二步，负责关掉窗口并“扔掉接力棒”。
      function hideActionModal() {
        closeActionModalVisuals();
        activeMessageIndex = null; // 只有在取消或者完成时，才清空记忆。
      }

      function deleteMessage() {
        if (activeMessageIndex === null) return;

        state.conversationHistory.splice(activeMessageIndex, 1); // 从历史记录中删除
        saveHistory();
        renderActiveView(); // 重新渲染界面
        hideActionModal();
      }

      function editMessage() {
        if (activeMessageIndex === null) return;
        const messageToEdit = state.conversationHistory[activeMessageIndex];
        if (!messageToEdit) return;

        editMessageTextarea.value = messageToEdit.content;

        // 关键！这里我们只关掉窗口，但不“扔掉接力棒”！
        closeActionModalVisuals();
        editMessageModal.classList.add('show');
        editMessageTextarea.focus();
      }

      // 新增：保存编辑的逻辑
      // 用下面这个新版本，替换掉你旧的 handleSaveMessageEdit 函数
      function handleSaveMessageEdit() {
        if (activeMessageIndex === null) return;
        const newContent = editMessageTextarea.value.trim();

        if (newContent === '') {
          handleCancelMessageEdit();
          return;
        }

        const messageToEdit = state.conversationHistory[activeMessageIndex];
        if (messageToEdit) {
          messageToEdit.content = newContent;
          saveHistory();
          renderActiveView();
        }

        editMessageModal.classList.remove('show');
        activeMessageIndex = null; // 在这里清空记忆
      }

      // 取消函数，同样在完成任务后，“扔掉接力棒”。
      function handleCancelMessageEdit() {
        editMessageModal.classList.remove('show');
        activeMessageIndex = null; // 在这里清空记忆
      }

      // --- 事件监听 ---
      messageActionBackdrop.addEventListener('click', hideActionModal);
      cancelActionButton.addEventListener('click', hideActionModal);
      deleteMessageButton.addEventListener('click', deleteMessage);
      editMessageButton.addEventListener('click', editMessage);
      quoteMessageButton.addEventListener('click', handleQuoteMessage); // <== 加上这个
      cancelQuoteButton.addEventListener('click', cancelQuote);      // <== 还有这个
      // 在旧的事件监听区域，加上这三行
      saveEditButton.addEventListener('click', handleSaveMessageEdit);
      cancelEditButton.addEventListener('click', handleCancelMessageEdit);
      editMessageBackdrop.addEventListener('click', handleCancelMessageEdit);

      // 新增：处理点击“引用”按钮的逻辑
      function handleQuoteMessage() {
        if (activeMessageIndex === null) return;
        const messageToQuote = state.conversationHistory[activeMessageIndex];
        if (!messageToQuote) return;

        const activeChat = getActiveChat();
        let senderName = '未知';
        // ▼▼▼ 换成我这个！▼▼▼
        if (messageToQuote.role === 'user') {
          // 哼，用这个函数去找当前聊天的“你”，这才是正确的做法
          const boundUser = getBoundUserForChat(state.activeChatId);
          senderName = boundUser.name || '我';
        } else {
          // ...
          const senderId = messageToQuote.senderId || activeChat?.participantIds[0];
          const char = getCharacterById(senderId);
          senderName = char ? char.name : '角色';
        }

        // 截取一部分内容作为预览
        let contentSnippet = messageToQuote.content || '';
        if (messageToQuote.displayUrl) contentSnippet = '[表情]';
        if (messageToQuote.image) contentSnippet = '[图片]';
        if (contentSnippet.length > 50) contentSnippet = contentSnippet.substring(0, 50) + '...';

        // 保存引用信息到 state
        state.activeQuote = {
          sender: senderName,
          content: contentSnippet,
        };

        showQuotePreview();
        hideActionModal();
        messageInput.focus();
      }

      // 新增：显示引用预览框
      function showQuotePreview() {
        if (!state.activeQuote) return;
        quotePreviewSender.textContent = `回复 ${state.activeQuote.sender}`;
        quotePreviewText.textContent = state.activeQuote.content;
        quotePreviewArea.style.display = 'block';
      }

      // 新增：取消引用
      function cancelQuote() {
        state.activeQuote = null;
        quotePreviewArea.style.display = 'none';
      }

      // --- 结束：消息操作功能 ---

      function showScreen(screenName, from) {
        // ▼▼▼ Noir's Fix: 就是这里，加上了对音乐小组件的“记忆唤醒” ▼▼▼
        const musicWidget = document.getElementById('music-widget');
        if (musicWidget) {
          // 如果要去主屏幕，就让它出来见人
          if (screenName === 'home') {
            // 用回它自己的 display 样式，免得又出问题
            musicWidget.style.display = 'inline-block';
          } else {
            // 如果要去别的地方，就给我老实藏起来
            musicWidget.style.display = 'none';
          }
        }
        // ▲▲▲ End of Fix ▲▲▲

        previousScreen = from || null;
        Object.values(screens).forEach(screen => screen.classList.remove('active'));
        if (screens[screenName]) {
          screens[screenName].classList.add('active');
        }
        // Special handling for chat screen to reset view
        if (screenName !== 'chat') {
          chatScreen.classList.remove('show-chat-view');
        }
      }
      function showChatView(show) {
        if (show) {
          chatScreen.classList.add('show-chat-view');
        } else {
          chatScreen.classList.remove('show-chat-view');
        }
      }

      // ▼▼▼ 哼，用这个【最终异步修复版】，完整替换掉你旧的 renderChatList 函数！▼▼▼
      // ▼▼▼ 哼，用这个【最终异步修复版】，完整替换掉你旧的 renderChatList 函数！▼▼▼
      async function renderChatList() {
        characterList.innerHTML = '';

        // 哼，第一步，先别急着画，给我列一张购物清单！
        const avatarPromises = state.chats.map(chat => {
          if (chat.type === 'private') {
            const char = getCharacterById(chat.participantIds[0]);
            return char ? dbGet(`char_avatar_${char.id}`) : Promise.resolve(null);
          } else { // group
            return dbGet(`group_avatar_${chat.id}`);
          }
        });

        // 第二步，把清单交给仓库管理员，让他一次性把所有东西都找出来！
        const avatarBlobs = await Promise.all(avatarPromises);

        // 最后，等货都到齐了，再让那个笨蛋工人一口气把它们全摆上去！
        state.chats.forEach((chat, index) => {
          const li = document.createElement('li');
          li.className = 'character-item';
          li.dataset.id = chat.id;

          let avatar = DEFAULT_AI_AVATAR;
          let name = '群聊';
          let remark = '';

          const avatarBlob = avatarBlobs[index];
          if (avatarBlob) {
            avatar = URL.createObjectURL(avatarBlob);
          }

          if (chat.type === 'private') {
            const char = getCharacterById(chat.participantIds[0]);
            if (char) {
              // 如果仓库里没有，再勉为其难用一下档案里的旧照片
              if (!avatarBlob) {
                avatar = char.avatar || DEFAULT_AI_AVATAR;
              }
              name = char.name || '未命名角色';
              remark = char.remark || '私聊';
            } else {
              name = '未知角色';
              remark = '错误：找不到角色';
            }
          } else { // group
            name = chat.name || '未命名群聊';
            remark = `${chat.participantIds.length} 个成员`;
          }

          li.innerHTML = `
            <div class="char-info-wrapper">
                <img src="${avatar}" alt="avatar" class="char-avatar">
                <div class="char-info">
                    <div class="char-name">${name}</div>
                    <div class="char-remark">${remark}</div>
                </div>
            </div>
        `;

          li.querySelector('.char-info-wrapper').addEventListener('click', () => {
            switchChat(chat.id);
            showChatView(true);
          });
          characterList.appendChild(li);
        });
      }

      // ▲▲▲ 替换到这里结束！看懂了吗？▲▲▲
      function renderMeetingCharacterList() {
        const container = document.getElementById('meeting-list-container');
        container.innerHTML = '';
        // 只显示私聊角色，群聊不能见面
        const privateChars = state.characters.filter(char =>
          state.chats.some(c => c.type === 'private' && c.participantIds.includes(char.id))
        );

        if (privateChars.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">还没有可以见面的角色。</p>';
          return;
        }

        privateChars.forEach(char => {
          const li = document.createElement('li');
          li.className = 'character-item'; // 复用聊天列表的样式
          li.dataset.charId = char.id;
          li.innerHTML = `
            <div class="char-info-wrapper">
                <img src="${char.avatar || DEFAULT_AI_AVATAR}" alt="avatar" class="char-avatar">
                <div class="char-info">
                    <div class="char-name">${char.name}</div>
                    <div class="char-remark">${char.remark || '私聊'}</div>
                </div>
            </div>
        `;
          li.addEventListener('click', () => {
            openMeetingView(char.id);
          });
          container.appendChild(li);
        });
      }

      // ▼▼▼ Noir's Ultimate Meeting Opener (Now Fetches from DB!) ▼▼▼
      // ▼▼▼ Noir's Ultimate Meeting Opener (Wallpaper on the Living Room Wall!) ▼▼▼
      // ▼▼▼ Noir's Ultimate Meeting Opener (v2.0 Asynchronous VIP Edition) ▼▼▼
      // 哼，用这个新版本换掉你那个又慢又卡的老古董 openMeetingView 函数！
      async function openMeetingView(charId) {
        const character = getCharacterById(charId);
        if (!character) return;

        // --- 哼，第一步：立刻换场，先把舞台的空架子亮出来 ---
        state.activeMeetingCharId = charId;

        // 先把标题之类的基本东西弄好，让用户知道自己没点错
        document.getElementById('meeting-char-name-header').textContent = character.name;
        const mainContent = document.getElementById('meeting-main-content');

        // 清空旧的背景和内容，为新客人做准备
        mainContent.style.backgroundImage = 'none';

        // 在小说和Galgame视图里都放上加载动画，确保用户能看到
        document.getElementById('meeting-scene-view').innerHTML = '<div class="loader-spinner" style="margin: 50px auto;"></div>';
        document.getElementById('galgame-text').textContent = '（正在回忆...）';
        document.getElementById('galgame-speaker').textContent = '旁白';
        document.getElementById('galgame-sprite').src = ''; // 清空立绘

        // 【核心】立刻显示新屏幕！给用户即时反馈！
        showScreen('meetingView', 'meetingList');

        // --- 第二步：在后台悄悄地把客人请进来，把家具摆好 ---
        // 把所有耗时的操作都丢进一个微小的延迟里，这样就不会卡住界面渲染了
        setTimeout(async () => {
          try {
            // 1. 悄悄地铺好地毯（加载背景）
            const offlineBgBlob = await dbGet(`char_offline_bg_${charId}`);
            if (offlineBgBlob) {
              mainContent.style.backgroundImage = `url('${URL.createObjectURL(offlineBgBlob)}')`;
              mainContent.style.backgroundSize = 'cover';
              mainContent.style.backgroundPosition = 'center';
            }

            // 2. 悄悄地把历史记录翻出来
            const privateChat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(charId));
            if (privateChat) {
              state.activeChatId = privateChat.id;
              saveState();
              loadHistory(); // 这个函数会把历史加载到 state.conversationHistory
            } else {
              state.conversationHistory = [];
            }

            // 3. 等东西都准备好了，再正式摆出来（渲染内容，这会替换掉加载动画）
            restoreLastGalDialogue(charId);
            updateMeetingViewUI();
            renderMeetingMessages();

            // 4. 别忘了启动时钟
            if (galClockInterval) clearInterval(galClockInterval);
            updateGalGameClock();
            galClockInterval = setInterval(updateGalGameClock, 10000);

            // 5. 调整立绘的按钮也显示出来
            document.getElementById('galgame-sprite-adjust-ui').style.display = 'block';

          } catch (error) {
            console.error("加载见面场景时出错:", error);
            document.getElementById('meeting-scene-view').innerHTML = '<p style="color: red; text-align: center;">加载场景失败！</p>';
          }
        }, 50); // 50毫秒的延迟足够让UI先响应了，几乎无感
      }

      // ▼▼▼ 用这个【最终格式修复版】，完整替换掉你旧的 renderMeetingMessages 函数 ▼▼"
      // 这是改造后的版本
      // 这是最终的、基于“锚点”的滚动方案
      function renderMeetingMessages() {
        const sceneView = document.getElementById('meeting-scene-view');
        sceneView.innerHTML = '';

        // 哼，先把旧的锚点（如果有的话）清理干净
        const oldAnchor = sceneView.querySelector('#message-anchor');
        if (oldAnchor) oldAnchor.remove();

        if (state.conversationHistory) {
          state.conversationHistory.forEach((msg, index) => {
            if (!msg.isOffline || msg.role === 'system') return;
            // ... (你这里面原有的、创建p标签的代码都保持不变，不用动)
            const p = document.createElement('p');
            p.dataset.historyIndex = index;
            const contentWithBreaks = msg.content.replace(/\n/g, '<br>');
            let speakerName = '';
            let speakerClass = '';
            const boundUser = getBoundUserForChat(state.activeChatId);
            if (msg.role === 'user') {
              speakerName = boundUser.name || '我';
              speakerClass = 'speaker-user';
            } else if (msg.role === 'assistant') {
              const char = getCharacterById(msg.senderId || state.activeMeetingCharId);
              speakerName = char?.name || '角色';
              speakerClass = 'speaker-ai';
            }
            p.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
            p.style.padding = '15px 20px';
            p.style.borderRadius = '8px';
            p.style.marginBottom = '1em';
            if (speakerName) {
              p.innerHTML = `<span class="${speakerClass}" style="font-weight: bold; color: ${speakerClass === 'speaker-user' ? '#a7c7e7' : '#f2b7c6'};">${speakerName}:</span> ${contentWithBreaks}`;
            } else {
              p.className = 'narrator';
              p.style.fontStyle = 'italic';
              p.style.color = '#d1d5db';
              p.innerHTML = contentWithBreaks;
            }
            sceneView.appendChild(p);
          });
        }

        if (state.isGenerating) {
          // ... (输入提示的代码也保持不变)
          let indicator = sceneView.querySelector('.typing-indicator');
          if (!indicator) {
            indicator = document.createElement('div');
            indicator.className = 'typing-indicator';
            indicator.textContent = '对方正在行动中...';
            // ... (indicator的样式代码也保持不变)
            indicator.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
            indicator.style.padding = '15px 20px';
            indicator.style.borderRadius = '8px';
            sceneView.appendChild(indicator);
          }
        }

        // --- 核心改造在这里 ---
        // 1. 在所有内容的末尾，插上我们那个看不见的“旗子”
        const anchor = document.createElement('div');
        anchor.id = 'message-anchor';
        sceneView.appendChild(anchor);

        // 2. 然后直接命令浏览器“滚到旗子那里去”
        // 我把它放在一个微小的延迟里，给浏览器最后的反应时间
        setTimeout(() => {
          anchor.scrollIntoView({ behavior: 'auto', block: 'end' });
        }, 50);
      }

      //    // --- Noir's Offline/Online Mode Logic ---
      // --- Noir's Smart Renderer ---
      function renderActiveView() {
        const activeScreen = document.querySelector('.screen.active');
        if (!activeScreen) return;

        // 判断当前在哪个屏幕，就调用哪个专属的刷新函数
        if (activeScreen.id === 'meeting-view-screen') {
          renderMeetingMessages();
        } else {
          // 默认情况下（包括在聊天界面时）都刷新聊天气泡
          renderMessages();
        }
      }

      // 哼，这是我新写的、绝对精准的滚动条刺客
      function renderMessages() {
        // 哼，不是显示全部，是按我的新规矩来
        const onlineHistory = state.conversationHistory.filter(msg => !msg.isOffline && msg.role !== 'system');

        // 如果还有旧账没翻完，就在顶上挂个牌子
        if (onlineHistory.length > state.displayedMessageCount) {
          let loadMoreButton = messagesContainer.querySelector('.load-more-btn');
          if (!loadMoreButton) {
            loadMoreButton = document.createElement('button');
            loadMoreButton.textContent = '加载更多聊天记录';
            loadMoreButton.className = 'form-button load-more-btn'; // 复用一下按钮样式
            loadMoreButton.style.width = 'auto';
            loadMoreButton.style.margin = '10px auto';
            loadMoreButton.style.padding = '8px 16px';

            loadMoreButton.onclick = () => {
              const container = messagesContainer;
              const oldScrollHeight = container.scrollHeight;
              const oldScrollTop = container.scrollTop;

              state.displayedMessageCount += 100; // 每次多加载100条
              renderMessages(); // 重新渲染

              // 哼，这是我加的“记忆锚点”，保证你视线不会乱跳
              requestAnimationFrame(() => {
                const newScrollHeight = container.scrollHeight;
                container.scrollTop = oldScrollTop + (newScrollHeight - oldScrollHeight);
              });
            };
            // 把它插在最前面
            if (messagesContainer.firstChild) {
              messagesContainer.insertBefore(loadMoreButton, messagesContainer.firstChild);
            } else {
              messagesContainer.appendChild(loadMoreButton);
            }
          }
        } else {
          // 如果已经显示完了，就把按钮干掉
          const loadMoreButton = messagesContainer.querySelector('.load-more-btn');
          if (loadMoreButton) loadMoreButton.remove();
        }

        // 删掉除了“加载更多”按钮以外的所有旧气泡
        Array.from(messagesContainer.children).forEach(child => {
          if (!child.classList.contains('load-more-btn')) {
            child.remove();
          }
        });

        // 精髓来了：只切下最新的一部分来画！
        const messagesToRender = onlineHistory.slice(-state.displayedMessageCount);

        messagesToRender.forEach(msg => {
          const originalIndex = state.conversationHistory.indexOf(msg);
          if (originalIndex > -1) {
            addMessageToUI(msg, originalIndex);
          }
        });

        // 正在输入的提示，逻辑不变
        // 哼，这才是正确的逻辑
        if (state.isGenerating) {
          // 直接从它该在的地方找，别在垃圾堆里乱翻
          let indicator = document.querySelector('#chat-view-pane > .typing-indicator');
          if (!indicator) {
            indicator = document.createElement('div');
            indicator.className = 'typing-indicator';

            // 顺便帮你把这个也改了，免得你又犯蠢
            const activeChat = getActiveChat();
            if (activeChat && activeChat.type === 'group') {
              indicator.textContent = '群友正在输入...';
            } else {
              indicator.textContent = '对方正在输入...';
            }

            document.getElementById('chat-view-pane').appendChild(indicator);
          }
        }

        // 只有在不是因为“加载更多”而渲染时，才自动滚到底部
        // 这是一个简单的判断，不完美但够用
        if (messagesToRender.length <= state.displayedMessageCount) {
          setTimeout(() => {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          }, 0);
        }
      }      // 用下面这个【最终修复版】，完整替换掉你旧的 addMessageToUI 函数
      // ▼▼▼ 哼，用这个【最终净化版】，替换掉你旧的整个函数！▼▼▼

      // ▼▼▼ 哼，用这个【最终净化版】，替换掉你旧的整个函数！▼▼▼
      // ▼▼▼ 哼，用这个【最终VIP通道版】，替换掉你旧的整个函数！▼▼▼
      function addMessageToUI(message, index) {
        const { role, content, displayUrl, image, senderId } = message;
        const messagesContainer = document.getElementById('chat-messages');

        // --- 1. 【VIP安检通道】 ---
        const isHtmlModule = content && content.trim().startsWith('<div') && content.trim().endsWith('</div>');
        if (isHtmlModule) {
          const moduleContainer = document.createElement('div');
          // 授予它专属的、没有宽度限制的身份
          moduleContainer.className = 'full-width-module-container';
          moduleContainer.dataset.historyIndex = index;
          moduleContainer.innerHTML = content;
          messagesContainer.appendChild(moduleContainer);
          // 渲染完毕，直接收工，不参与后面的普通流程
          return moduleContainer;
        }

        // --- 2. 【普通旅客通道】如果不是HTML模块，就还走老路 ---
        const finalRole = (role === 'assistant') ? 'ai' : role;
        const activeChat = getActiveChat();

        const container = document.createElement('div');
        container.classList.add('message-container', finalRole);
        container.dataset.historyIndex = index;

        const bubbleRow = document.createElement('div');
        bubbleRow.className = 'message-bubble-row';

        // --- 头像逻辑 (保持不变) ---
        let avatarUrl = '';
        let frameUrl = '';
        let characterForAvatar = null;

        if (role === 'user') {
          const boundUser = getBoundUserForChat(state.activeChatId);
          avatarUrl = boundUser.avatar || DEFAULT_USER_AVATAR;
          const activeCharForThisChat = getCharacterById(activeChat?.participantIds[0]);
          if (activeCharForThisChat) {
            frameUrl = activeCharForThisChat.userAvatarFrameUrl || '';
          }
        } else { // AI
          if (activeChat?.type === 'private') {
            characterForAvatar = getCharacterById(activeChat.participantIds[0]);
          } else if (activeChat?.type === 'group' && senderId) {
            characterForAvatar = getCharacterById(senderId);
          }
          avatarUrl = characterForAvatar?.avatar || DEFAULT_AI_AVATAR;
          frameUrl = characterForAvatar?.avatarFrameUrl || '';
        }

        const avatarElement = createAvatarWithFrame(avatarUrl, frameUrl);

        if (role !== 'user' && characterForAvatar) {
          const avatarImg = avatarElement.querySelector('.avatar');
          dbGet(`char_avatar_${characterForAvatar.id}`).then(blob => {
            if (blob) {
              avatarImg.src = URL.createObjectURL(blob);
            }
          });
        }

        // --- 普通气泡渲染逻辑 (保持不变) ---
        const messageElem = document.createElement('div');
        messageElem.classList.add('message', finalRole);

        if (activeChat?.type === 'private') {
          const charId = activeChat.participantIds[0];
          messageElem.classList.add(`bubble-${charId}`);
        }

        if (message.quotedMessage) {
          const quoteBubble = document.createElement('div');
          quoteBubble.className = 'quoted-message-in-bubble';
          quoteBubble.innerHTML = `
        <div class="quoted-sender">${message.quotedMessage.sender}</div>
        <div class="quoted-content">${message.quotedMessage.content}</div>
      `;
          messageElem.appendChild(quoteBubble);
        }

        if (displayUrl) {
          messageElem.classList.add('sticker');
          messageElem.innerHTML += `<img src="${displayUrl}" class="sticker-content">`;
        } else if (message.image || message.imageId) {
          messageElem.classList.add('image');
          const imageContent = document.createElement('img');
          imageContent.classList.add('message-image-content');
          messageElem.appendChild(imageContent);

          if (message.image) {
            imageContent.src = message.image;
          } else {
            imageContent.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            dbGet(message.imageId).then(blob => {
              if (blob) imageContent.src = URL.createObjectURL(blob);
              else imageContent.alt = '图片加载失败';
            }).catch(() => imageContent.alt = '图片加载失败');
          }
          if (content) {
            messageElem.innerHTML += `<p style="margin-top: 5px;">${content}</p>`;
          }
        } else if (message.type === 'transfer') {
          messageElem.classList.add('transfer');
          const sender = message.role === 'user' ? getBoundUserForChat(state.activeChatId) : getCharacterById(message.senderId);
          const recipient = message.recipientId === getBoundUserForChat(state.activeChatId).id ? getBoundUserForChat(state.activeChatId) : getCharacterById(message.recipientId);
          const titleText = sender?.name ? `${sender.name}的转账` : '转账';
          const recipientText = recipient?.name ? `转给 ${recipient.name}` : '转账';
          messageElem.innerHTML += `
      <div class="transfer-content">
          <div class="transfer-title">💰 ${titleText}</div>
          <div class="transfer-amount">¥${message.amount.toFixed(2)}</div>
          <div class="transfer-recipient">${recipientText}</div>
      </div>`;
        } else if (message.type === 'listen-together-invite') {
          messageElem.classList.add('music');
          const card = document.createElement('div');
          card.className = 'listen-together-card no-action-modal';
          const senderName = message.role === 'user' ? (getBoundUserForChat(state.activeChatId).name || '你') : (getCharacterById(message.senderId)?.name || 'TA');
          const coverPlaceholderId = `cover_placeholder_${message.timestamp}`;
          const coverImgHtml = `<img id="${coverPlaceholderId}" src="${DEFAULT_AI_AVATAR}">`;
          if (message.accepted) {
            card.innerHTML = `<div class="listen-together-header" style="display: flex; justify-content: space-between; align-items: center;"><span style="flex-grow: 1; text-align: center;">🎵 已连接，正在一起听 🎵</span><span class="lt-end-session-btn" title="结束一起听">×</span></div><div class="listen-together-song">${coverImgHtml}<div class="listen-together-info"><div class="title">${message.songName}</div><div class="artist">${message.artist}</div></div></div>`;
          } else {
            card.innerHTML = `<div class="listen-together-header">${senderName} 邀请你一起听歌</div><div class="listen-together-song">${coverImgHtml}<div class="listen-together-info"><div class="title">${message.songName}</div><div class="artist">${message.artist}</div></div></div><div class="listen-together-actions"><button class="listen-together-accept-btn" data-song-id="${message.songId}">一起听</button></div>`;
          }
          messageElem.appendChild(card);
          if (message.coverId) {
            setTimeout(() => {
              dbGet(message.coverId).then(blob => {
                const imgEl = document.getElementById(coverPlaceholderId);
                if (imgEl && blob) imgEl.src = URL.createObjectURL(blob);
              });
            }, 0);
          }
        } // ▼▼▼ Noir's Final Reconstruction Protocol ▼▼▼
        else if (message.type === 'music' && message.songName) {
          messageElem.classList.add('music');
          const card = document.createElement('div');
          card.className = 'music-share-card';
          card.dataset.musicId = `msg_${message.timestamp}`;

          const coverPlaceholderId = `cover_placeholder_${message.timestamp}`;
          let coverImgHtml = `<img src="${DEFAULT_AI_AVATAR}" id="${coverPlaceholderId}" class="music-share-cover">`;

          card.innerHTML = `
        ${coverImgHtml}
        <div class="music-share-info">
            <div class="title">${message.songName}</div>
            <div class="artist">${message.artist}</div>
        </div>
        <div class="music-share-play-icon">${message.playableUrl ? '▶' : '⚠'}</div>`;

          messageElem.appendChild(card);

          // 哼，看好了，封面加载逻辑单独处理，这才叫清晰。
          setTimeout(() => {
            const imgEl = document.getElementById(coverPlaceholderId);
            if (!imgEl) return;

            if (message.coverId) {
              dbGet(message.coverId).then(blob => {
                if (blob) imgEl.src = URL.createObjectURL(blob);
              });
            } else if (message.coverUrl) {
              imgEl.src = message.coverUrl;
            }
          }, 0);

          // 这才是核心！把指令直接绑定到卡片上，用我们最初那个简单有效的临时播放器！
          if (message.playableUrl) {
            card.addEventListener('click', function () {
              const audioPlayer = document.getElementById('audio-player');
              const allIcons = document.querySelectorAll('.music-post-play-icon, .music-share-play-icon');

              // 找出当前被点击的这个图标
              const thisIcon = this.querySelector('.music-share-play-icon');

              const isPlayingThisSong = audioPlayer.src.includes(message.playableUrl) && !audioPlayer.paused;

              // 在动手前，先把所有其他音乐都停了，并重置它们的图标
              allIcons.forEach(icon => {
                if (icon !== thisIcon) {
                  icon.textContent = '▶';
                }
              });
              if (!isPlayingThisSong) { // 如果不是正在播放这首歌，就先把全局播放器也停了，免得两个心脏打架
                document.getElementById('unified-audio-player').pause();
              }

              // 现在，只对当前这个图标和临时播放器下达指令
              if (isPlayingThisSong) {
                audioPlayer.pause();
                thisIcon.textContent = '▶';
              } else {
                audioPlayer.src = message.playableUrl;
                audioPlayer.play();
                thisIcon.textContent = '❚❚';
              }
            });
          }
        }
        // ▲▲▲ End of Reconstruction Protocol ▲▲▲
        else {
          if (content) {
            const textElem = document.createElement('p');
            textElem.innerHTML = content;
            textElem.style.margin = '0';
            messageElem.appendChild(textElem);
          }
        }

        // --- 组装和收尾 (保持不变) ---
        if (finalRole === 'user') {
          bubbleRow.appendChild(messageElem);
          bubbleRow.appendChild(avatarElement);
        } else {
          bubbleRow.appendChild(avatarElement);
          bubbleRow.appendChild(messageElem);
        }

        container.appendChild(bubbleRow);

        const timestampElem = document.createElement('div');
        timestampElem.className = 'timestamp';
        timestampElem.textContent = formatTimestamp(message.timestamp);
        container.appendChild(timestampElem);

        messagesContainer.appendChild(container);

        return container;
      }

      // Noir's Efficient Event Handler
      // document.getElementById('chat-messages').addEventListener('mousedown', handleMessageInteraction);
      // document.getElementById('chat-messages').addEventListener('touchstart', handleMessageInteraction, { passive: false });
      // 换成下面这个更聪明的！
      //    document.getElementById('chat-messages').addEventListener('click', handleMessageInteraction);






      // ==========================================================
      // --- Noir's Ultimate & Flawless Long-Press Protocol ---
      // 哼，这才是不会出错的最终版本。
      // ==========================================================
      let pressTimer = null; // 这个计时器得放在外面，让所有人都能看到

      // 这是处理所有交互的“总司令”
      function handleMessageInteraction(e) {
        // 如果你正在选文字，或者点的不是鼠标左键，就别来烦我
        if (window.getSelection().toString() || e.button !== 0) {
          return;
        }

        const messageContainer = e.target.closest('.message-container');
        const isSpecialCard = e.target.closest('.no-action-modal');

        // 点到不该点的地方了，无视
        if (!messageContainer || isSpecialCard) return;

        // 记下历史索引，这很重要
        const historyIndex = parseInt(messageContainer.dataset.historyIndex, 10);
        if (isNaN(historyIndex)) return;

        // 手指/鼠标抬起或移动的瞬间，取消计时
        const cancelPress = () => {
          clearTimeout(pressTimer);
          // 哼，用完的指令要立刻销毁，这才是专业素养
          document.removeEventListener('mouseup', cancelPress);
          document.removeEventListener('touchend', cancelPress);
          document.removeEventListener('touchcancel', cancelPress);
          document.removeEventListener('touchmove', cancelPress);
        };

        // 手指/鼠标按下的瞬间，开始计时
        const startPress = () => {
          cancelPress(); // 先清理旧的，免得精神错乱
          pressTimer = setTimeout(() => {
            showActionModal(historyIndex); // 时间到了，就弹出菜单
          }, 600); // 还是600毫秒

          // 把“取消”的指令绑定到整个文档上，这样就算你鼠标滑到天涯海角也能取消
          document.addEventListener('mouseup', cancelPress);
          document.addEventListener('touchend', cancelPress);
          document.addEventListener('touchcancel', cancelPress);
          document.addEventListener('touchmove', cancelPress);
        };

        // 好了，开始计时吧
        startPress();
      }

      // 哼，现在才是在正确的地方，给聊天容器装上“耳朵”
      const chatMessagesContainer = document.getElementById('chat-messages');
      if (chatMessagesContainer) {
        chatMessagesContainer.addEventListener('mousedown', handleMessageInteraction);
        chatMessagesContainer.addEventListener('touchstart', handleMessageInteraction, { passive: false });
        // 在电脑上，为了防止你长按时弹出那个烦人的右键菜单，我也处理了
        chatMessagesContainer.addEventListener('contextmenu', e => e.preventDefault());
      }
      // ==========================================================
      // --- End of Protocol ---
      // ==========================================================

      function updateChatHeader() {
        const activeChat = getActiveChat();
        if (!activeChat) {
          chatHeaderName.textContent = '选择聊天';
          return;
        }
        if (activeChat.type === 'private') {
          const char = getCharacterById(activeChat.participantIds[0]);
          chatHeaderName.textContent = char ? char.name : '未知角色';
        } else {
          chatHeaderName.textContent = activeChat.name || `群聊 (${activeChat.participantIds.length})`;
        }
      }

      // 用这个新版本，完整替换掉你旧的 showTypingIndicator 函数
      function showTypingIndicator(show) {
        // ▼▼▼ 协议：先斩后奏，不管三七二十一，先把旧的给我拆了！▼▼▼
        const existingIndicator = document.querySelector('#chat-view-pane > .typing-indicator');
        if (existingIndicator) {
          existingIndicator.remove();
        }
        // ▲▲▲ 拆除完毕 ▲▲▲

        // 哼，解雇老厨子。现在这个函数不再亲自动手添乱了。
        // 它只负责下达“刷新”的命令，让那个聪明的厨子 (renderMeetingMessages) 自己去判断要不要上菜。
        // 这样就永远不会打架了。
        const activeScreen = document.querySelector('.screen.active');
        if (activeScreen && (activeScreen.id === 'meeting-view-screen' || activeScreen.id === 'chat-screen')) {
          renderActiveView();
        } else {
          // 对于其他未知情况，保留旧的、简单的清除逻辑以防万一
          const indicators = document.querySelectorAll('.typing-indicator');
          indicators.forEach(ind => ind.remove());
        }
      }

      // --- Core Logic ---

      // <<< Noir: 啰嗦。专门写个函数给你取消，省得你又手忙脚乱。
      function cancelAIGeneration() {
        if (state.isGenerating && state.currentAbortController) {
          console.log('用户操作中断了 AI 响应。');
          state.currentAbortController.abort('User cancelled');
          state.currentAbortController = null;
        }
        state.isGenerating = false;
        showTypingIndicator(false);
      }

      function getActiveChat() {
        return state.chats.find(c => c.id === state.activeChatId);
      }

      function getCharacterById(charId) {
        return state.characters.find(c => c.id === charId);
      }

      function deleteCharacter(charId) {
        // 1. Remove the character definition
        state.characters = state.characters.filter(c => c.id !== charId);

        // 2. Remove the character from any group chats
        state.chats.forEach(chat => {
          if (chat.type === 'group') {
            chat.participantIds = chat.participantIds.filter(id => id !== charId);
          }
        });

        // 3. Find and delete any private chats with this character
        const privateChat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(charId));
        if (privateChat) {
          deleteChat(privateChat.id);
        }

        // 4. Clean up group chats that are now empty or have only one person
        state.chats = state.chats.filter(chat => chat.type !== 'group' || chat.participantIds.length > 1);

        saveState();
        renderChatList();
      }

      // ▼▼▼ Noir's Disciplined Deletion Protocol ▼▼▼
      function deleteChat(chatId) {
        state.chats = state.chats.filter(c => c.id !== chatId);
        try {
          localStorage.removeItem(`chatHistory_${chatId}`);
        } catch (e) {
          console.error(`Failed to remove history for chat ${chatId}`, e);
        }

        if (state.activeChatId === chatId) {
          state.activeChatId = state.chats[0]?.id || null;
          switchChat(state.activeChatId);
        }

        saveState();
        // renderChatList(); // <-- 哼，就是这行，给我删了！多管闲事。
      }
      // ▲▲▲ End of Protocol ▲▲▲
      // 用这个新函数，完整替换掉旧的 switchChat 函数
      // ▼▼▼ 用这个【最终异步版】，替换掉你旧的 switchChat 函数 ▼▼▼

      // ▼▼▼ 用这个【最终异步版】，替换掉你旧的 switchChat 函数 ▼▼▼
      async function switchChat(chatId) {
        // 1. 瞬间完成：更新状态，准备好一个空的“房间”
        if (state.activeChatId !== chatId) {
          cancelAIGeneration();
          state.displayedMessageCount = 100; // 重置“加载更多”的计数器
        }

        if (!chatId) {
          state.activeChatId = null;
          saveState();
          showChatView(false);
          document.getElementById('chat-view-pane').style.backgroundImage = '';
          return;
        }

        state.activeChatId = chatId;
        saveState();

        updateChatHeader(); // 更新标题
        messagesContainer.innerHTML = ''; // 【关键】先把聊天区清空，让它看起来是新的

        // 2. 立刻开门：让用户看到聊天界面 (这步由调用这个函数后的 showChatView(true) 完成)

        // 3. 挂上“正在准备”的牌子 (全局转圈)
        showFeedLoader(true, '稍微有点卡了，可以尝试清空聊天记录了！记得总结丢世界书。非强制性，只是手机会有点卡，想继续聊下去也可以。');

        // 4. 【核心】把慢活儿扔进“后台”去做，不耽误你进屋
        setTimeout(async () => {
          try {
            // 在后台悄悄地加载历史记录和应用壁纸
            loadHistory(); // 这会加载数据到 state.conversationHistory

            const activeChat = getActiveChat();
            const chatViewPane = document.getElementById('chat-view-pane');
            let wallpaperBlob = null;
            if (activeChat) {
              if (activeChat.type === 'private') {
                const charId = activeChat.participantIds[0];
                applyCharacterChatSettings(charId);
                wallpaperBlob = await dbGet(`char_wallpaper_${charId}`);
              } else {
                wallpaperBlob = await dbGet(`group_bg_${activeChat.id}`);
              }

              if (wallpaperBlob) {
                chatViewPane.style.backgroundImage = `url('${URL.createObjectURL(wallpaperBlob)}')`;
                chatViewPane.style.backgroundSize = 'cover';
                chatViewPane.style.backgroundPosition = 'center';
              } else {
                chatViewPane.style.backgroundImage = '';
              }
            }

            // 数据准备好了，现在开始在后台渲染气泡
            renderMessages();

          } catch (error) {
            console.error("切换聊天时发生异步错误:", error);
            modalAlert(`加载聊天失败: ${error.message}`);
          } finally {
            // 5. 准备完毕，撤掉牌子
            showFeedLoader(false);
          }
        }, 50); // 给一个极短的延迟，确保UI先响应
      }
      // ▲▲▲ 替换到这里
      //为止 ▲▲▲      


      // ==========================================================
      // --- Noir's Meeting Reroll Protocol ---
      // 哼，见面说错话了？给你个机会重来。
      // ==========================================================
      async function handleMeetingReroll() {
        // 如果我正在说话，就别打断我
        if (state.isGenerating) {
          modalAlert('正在构思中，请稍候...');
          return;
        }

        const history = state.conversationHistory;
        if (history.length === 0) return;

        // 1. 找到你说的最后一句话
        let lastUserMessageIndex = -1;
        for (let i = history.length - 1; i >= 0; i--) {
          if (history[i].role === 'user') {
            lastUserMessageIndex = i;
            break;
          }
        }

        // 2. 如果我还没回话，那没什么可“重来”的
        if (lastUserMessageIndex === -1 || lastUserMessageIndex === history.length - 1) {
          modalAlert('还没有我的回应可以重新生成哦。');
          return;
        }

        // 3. 哼，把我刚才说的话都收回
        history.splice(lastUserMessageIndex + 1);

        // 4. 把我说过的废话（剧本）也从提词器上擦掉
        state.activeMeetingScriptQueue = [];

        // 5. 更新界面，保存“记忆”
        saveHistory();
        renderMeetingMessages();
        restoreLastGalDialogue(state.activeMeetingCharId); // 恢复到你说话时的状态

        // 6. 好了，我重新说
        setTimeout(() => {
          getAIResponse();
        }, 100);
      }


      async function handleReroll() {
        // 如果我正在说话，就别打断我
        if (state.isGenerating) {
          modalAlert('正在生成中，请稍候...');
          return;
        }

        const history = state.conversationHistory;
        if (history.length === 0) return;

        // 1. 从后往前找，找到最后一个你发的消息的位置
        let lastUserMessageIndex = -1;
        for (let i = history.length - 1; i >= 0; i--) {
          if (history[i].role === 'user') {
            lastUserMessageIndex = i;
            break;
          }
        }

        // 2. 如果找不到你发的消息，或者你发的是最后一条，那说明我还没回话，没什么可“重来”的
        if (lastUserMessageIndex === -1 || lastUserMessageIndex === history.length - 1) {
          modalAlert('还没有我的回复可以重新生成哦。');
          return;
        }

        // 3. 哼，把我刚才说的话（你最后一条消息之后的所有内容）都收回
        history.splice(lastUserMessageIndex + 1);

        // 4. 更新界面，保存“记忆”
        saveHistory();
        renderActiveView();

        // 5. 好了，我重新说
        setTimeout(() => {
          getAIResponse();
        }, 100);
      }
      // 用这个新函数，替换掉你旧的 sendTextMessage
      // 【第1步：完善你的版本】
      function sendTextMessage(textOverride = null) {
        const text = textOverride ?? messageInput.value.trim();
        if (text === '' || !state.activeChatId) return;

        const activeScreen = document.querySelector('.screen.active');
        const isOffline = activeScreen.id === 'meeting-view-screen';
        const message = {
          role: 'user',
          content: text,
          timestamp: Date.now(),
          isOffline: isOffline
        };

        if (state.activeQuote) {
          message.quotedMessage = { ...state.activeQuote };
        }

        state.conversationHistory.push(message);

        // 【核心优化】直接追加新消息的DOM元素
        const newMessageElement = addMessageToUI(message, state.conversationHistory.length - 1);

        if (newMessageElement) {
          // 确保滚动到底部，以便看到新消息
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        saveHistory();
        messageInput.value = '';
        cancelQuote();



      }
      function sendStickerMessage(sticker) {
        if (!sticker || !state.activeChatId) return;

        const message = {
          role: 'user',
          content: `[用户发送了表情：${sticker.name}]`,
          displayUrl: sticker.url,
          timestamp: Date.now() // <--- 加上这行！
        };
        state.conversationHistory.push(message);
        addMessageToUI(message, state.conversationHistory.length - 1);
        saveHistory();
        stickerPanel.classList.remove('show');
      }

      // 用这个替换你旧的 handleImageSend 函数
      async function handleImageSend(event) {
        const file = event.target.files[0];
        if (!file || !state.activeChatId) return;

        showFeedLoader(true, '正在处理图片...');
        try {
          // 1. 哼，告诉压缩机，我要文件本身(Blob)，而不是文本
          const compressedBlob = await compressImage(file, 800, 0.8, true);
          // 2. 给这张图片一张独一无二的“门票”
          const imageId = `chat_image_${Date.now()}`;
          // 3. 把图片和门票一起存进“动物园”(IndexedDB)
          await dbSet(imageId, compressedBlob);

          const userText = messageInput.value.trim();
          messageInput.value = '';

          // 4. 在聊天记录里，只记下这张“门票”ID
          const message = {
            role: 'user',
            content: userText,
            imageId: imageId, // 注意！这里不再是 image: base64 了
            timestamp: Date.now()
          };
          state.conversationHistory.push(message);
          addMessageToUI(message, state.conversationHistory.length - 1);
          saveHistory(); // 现在这里存的只是小纸条，绝对不会爆了
        } catch (error) {
          modalAlert(`图片处理失败: ${error.message}`);
        } finally {
          showFeedLoader(false);
          event.target.value = '';
        }
      }
      // Noir's New Function for User to Share Music
      // ▼▼▼ Noir's Upgraded Music Share Handler ▼▼▼
      // 用这个【签证官版】，替换掉旧的 handleUserMusicShare
      // ▼▼▼ 哼，用这个替换你那个笨手笨脚的 handleUserMusicShare 函数 ▼▼▼
      async function handleUserMusicShare() {
        if (!state.activeChatId) return;
        const musicData = await showMusicShareModal();
        if (!musicData) return;

        modalAlert('正在搜索音乐...');

        try {
          const musicInfo = await findPlayableMusicUrl(musicData.songName, musicData.artist);

          // 哼，看好了，这里我把那段多管闲事的“下载”代码给删了，直接用链接！
          const message = {
            role: 'user',
            type: 'music',
            content: `[用户分享了音乐：${musicData.songName} - ${musicData.artist}]`,
            songName: musicData.songName,
            artist: musicData.artist,
            coverUrl: musicInfo.cover, // 直接用URL，不转换！
            playableUrl: musicInfo.url,
            timestamp: Date.now()
          };

          // 剩下的逻辑不变
          state.conversationHistory.push(message);
          // 哼，这里我把addMessageToUI改成了renderMessages，这才是正确的刷新方式
          saveHistory();
          renderMessages();

        } catch (error) {
          console.error("用户分享音乐失败:", error);
          modalAlert(`搜索失败: ${error.message}`);
        }
      }


      // 将当前聊天的历史记录转成带说话人标签的纯文本，供模型准确理解谁说了什么
      function buildLabeledTranscript(activeChat, maxLines = 120) {
        const nameOf = (msg) => {
          if (msg.role === 'user') return state.userProfile?.name || 'User';
          if (msg.senderId) {
            const c = getCharacterById(msg.senderId);
            return c?.name || 'Unknown';
          }
          if (activeChat?.type === 'private') {
            const c = getCharacterById(activeChat.participantIds[0]);
            return c?.name || 'AI';
          }
          return 'Assistant';
        };

        // 取最后 maxLines 条消息
        const history = state.conversationHistory.slice(-maxLines);
        const lines = [];
        for (const msg of history) {
          if (msg.displayUrl) {
            lines.push(`[${nameOf(msg)}] [sticker:${msg.content?.match(/：(.+?)]/)?.[1] || '表情'}]`);
          } else if (msg.image) {
            const tail = msg.content ? ` ${msg.content}` : '';
            lines.push(`[${nameOf(msg)}] [image]${tail}`);
          } else if (msg.content) {
            lines.push(`[${nameOf(msg)}] ${msg.content}`);
          }
        }
        return lines.join('\n');
      }


      // 从用户最后一条消息里解析 @名字
      function resolveMentionTarget(activeChat, lastUserText) {
        if (!activeChat || !lastUserText) return null;
        // 允许 @Noir、@莱恩、@Allen 这类；名字到第一个空白/标点结束
        const m = lastUserText.match(/@([^\s:：,，。!?]+)/);
        if (!m) return null;
        const target = m[1].toLowerCase();

        // 在参与者里找名字（不区分大小写）
        for (const id of activeChat.participantIds) {
          const c = getCharacterById(id);
          if (!c?.name) continue;
          if (c.name.toLowerCase() === target) return c;
          // 容错：支持“名字(备注)”这种
          if (c.name.toLowerCase().startsWith(target)) return c;
        }
        return null;
      }

      // 辅助函数：从文本中提取JSON对象
      function extractFirstJsonObject(s) {
        const i = s.indexOf('{');
        const j = s.lastIndexOf('}');
        if (i >= 0 && j > i) return s.slice(i, j + 1);
        return s;
      }

      // ▼▼▼ 哼，把这个丢三落四的“助手”也给我加上！放在 planGroupReplies 的前面！▼▼▼
      function normalizePlan(plan, participants, stickerList) {
        const byId = new Map(participants.map(p => [String(p.id), p]));
        const norm = s => String(s || '').toLowerCase().replace(/\s+/g, '');
        const byName = new Map(participants.map(p => [norm(p.name), p]));
        const stickerSet = new Set(stickerList);
        const out = {
          events: []
        };

        for (const raw of (plan?.events || [])) {
          // 兼容更多字段别名
          const sidRaw = raw.senderId ?? raw.sender ?? raw.sender_id ?? raw.speaker ?? raw.role ?? raw.name;
          if (!sidRaw) continue;

          let who = byId.get(String(sidRaw)) || byName.get(norm(sidRaw));
          if (!who) continue;

          const kind = (raw.kind || raw.type || 'text').toLowerCase();

          if (kind === 'sticker') {
            const stickerName = (raw.sticker ?? raw.emoji ?? raw.emote ?? raw.tag)?.trim();
            if (stickerName && stickerSet.has(stickerName)) {
              out.events.push({
                senderId: who.id,
                kind: 'sticker',
                sticker: stickerName
              });
            } else {
              // 贴纸不在白名单 → 降级为文本，而不是整条丢弃
              const txt = String(raw.content ?? raw.text ?? '').trim() || `[sticker:${stickerName || '未知表情'}]`;
              if (txt) out.events.push({
                senderId: who.id,
                kind: 'text',
                content: txt
              });
            }
          } else if (kind === 'music' && raw.songName && raw.artist) {
            // 【【【看这里！这才是音乐卡片的“通行证”！】】】
            out.events.push({
              senderId: who.id,
              kind: 'music',
              songName: raw.songName,
              artist: raw.artist
            });
          } else {
            const text = String(raw.content ?? raw.text ?? raw.message ?? '').trim();
            if (text) out.events.push({
              senderId: who.id,
              kind: 'text',
              content: text
            });
          }
        }
        return out;
      }


      // 渲染计划队列（本地排队，无额外 API）
      // 用这个新版本，完整替换掉你旧的 schedulePlannedReplies 函数
      // 渲染计划队列（本地排队，无额外 API）
      // 用这个新版本，完整替换掉你旧的 schedulePlannedReplies 函数
      // ▼▼▼ Noir's Ultimate Group Chat Renderer v2.0 (With Breathing Room) ▼▼▼
      // ==========================================================
      // --- Noir's Group Chat Scheduler: schedulePlannedReplies ---
      // 哼，按剧本走，不许乱改。
      // ==========================================================


      // ▼▼▼ 这个 schedulePlannedReplies 也一样，给我用新的换掉旧的 ▼▼▼
      // ▼▼▼ Noir's Ultimate Group Chat Renderer v3.0 (Now with Advanced Syntax!) ▼▼▼
      async function schedulePlannedReplies(plan) {
        if (!plan || !Array.isArray(plan.events) || plan.events.length === 0) return;

        const jitter = (base) => base + Math.floor(Math.random() * 400);
        let initialDelay = 500;

        for (const ev of plan.events) {
          await new Promise(r => setTimeout(r, jitter(initialDelay)));
          initialDelay = 700;

          const isOffline = state.conversationHistory.at(-1)?.isOffline ?? false;

          // 哼，看好了，从这里开始，这个邮递员变聪明了
          const msg = { role: 'assistant', senderId: ev.senderId, timestamp: Date.now(), isOffline: isOffline };

          if (ev.kind === 'html') {
            // 1. 识别出HTML贵宾，直接打包成特殊消息
            Object.assign(msg, { type: 'html', content: ev.content });
            addMessageToUI(msg, -1); // -1代表这是个不记录历史的临时UI
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            continue; // 处理完，直接进行下一轮，不走下面的普通流程
          }

          if (ev.kind === 'sticker') {
            const sticker = masterStickerList.find(s => s.name === ev.sticker);
            if (sticker) {
              Object.assign(msg, { content: `[AI发送了表情：${sticker.name}]`, displayUrl: sticker.url });
              state.conversationHistory.push(msg);
              saveHistory();
              addMessageToUI(msg, state.conversationHistory.length - 1);
              messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
            continue;
          }

          if (ev.kind === 'music' && ev.songName && ev.artist) {
            const { songName, artist } = ev;
            Object.assign(msg, {
              type: 'music',
              content: `[AI分享了音乐：${songName} - ${artist}]`,
              songName,
              artist
            });
            try {
              const musicInfo = await findPlayableMusicUrl(songName, artist);
              msg.coverUrl = musicInfo.cover;
              msg.playableUrl = musicInfo.url;
            } catch (e) { /* ... */ }
            state.conversationHistory.push(msg);
            saveHistory();
            renderActiveView();
            continue;
          }

          if (ev.kind === 'text') {
            // 2. 对于普通信件，先检查有没有“引用”标记
            const quoteMatch = (ev.content || '').match(/^\[引用\|(.*?)\|(.*?)\]\s*/);
            let contentToSplit = ev.content || '';

            if (quoteMatch) {
              // 如果有，先把引用部分提取出来，存到信封上
              msg.quotedMessage = {
                sender: quoteMatch[1].trim(),
                content: quoteMatch[2].trim(),
              };
              // 然后把信件内容里引用标记撕掉
              contentToSplit = ev.content.substring(quoteMatch[0].length).trim();
            }

            // 3. 把剩下的内容（或者没有引用的完整内容）拆分成小纸条
            const parts = splitIntoBubbles(contentToSplit).slice(0, 3);
            for (let i = 0; i < parts.length; i++) {
              if (i > 0) {
                await new Promise(r => setTimeout(r, jitter(400)));
                // 对于拆分后的第二条及以后的消息，不应该再带有引用
                delete msg.quotedMessage;
              }
              msg.content = parts[i];
              state.conversationHistory.push({ ...msg }); // 存入历史记录
              saveHistory();
              renderActiveView(); // 刷新界面
            }
          }
        }
      }
      // ▲▲▲ End of Refactor ▲▲▲
      // ▲▲▲ End of Refactor ▲▲▲
      // Noir's Refactored Brain for Parallel Processing
      // Noir's Refactored Brain for Parallel Processing
      async function generateAs(responderChar, { force = false, delayMs = 0 } = {}) {
        await new Promise(resolve => setTimeout(resolve, 10));

        if (!state.apiSettings.endpoint || !state.apiSettings.key || !state.apiSettings.model) {
          modalAlert('请先在"设置"中配置你的 API 信息。');
          return false;
        }
        const activeChat = getActiveChat();
        if (!activeChat || !responderChar) return false;
        const boundUser = getBoundUserForChat(activeChat.id);
        const lastIsUser = state.conversationHistory.at(-1)?.role === 'user';
        if (!force && !lastIsUser) return false;

        const isOffline = state.conversationHistory.at(-1)?.isOffline ?? false;

        if (delayMs) await new Promise(r => setTimeout(r, delayMs));
        if (isOffline) {
          document.getElementById('galgame-text').textContent = '（正在构思中...）';
        } else {
          showTypingIndicator(true);
        }

        // --- 哼，就是这里！为AI植入歌词视觉！ ---
        // --- 哼，就是这里！为AI植入歌词视觉！ (Noir's Final-Battle-Spec Patch) ---

        let listenTogetherContext = '';
        const currentChatForLyrics = getActiveChat();

        // 哼，只检查“一起听”的“开关”是不是开着
        if (currentChatForLyrics?.activeListenSession?.isActive) {
          const session = currentChatForLyrics.activeListenSession;

          // 在这里，我命令AI亲自去后台资料库取一次剧本，确保万无一失
          const songData = await musicDbGet(session.songId);

          // 拿到剧本，并且剧本有内容，才继续
          if (songData && songData.lyrics) {
            // 立刻把剧本解析成AI能看懂的格式
            const lrcForContext = parseLrc(songData.lyrics);

            if (lrcForContext.length > 0) {
              const currentTime = globalAudioPlayer.currentTime;
              let activeIndex = -1;
              for (let i = 0; i < lrcForContext.length; i++) {
                if (currentTime >= lrcForContext[i].time) activeIndex = i;
                else break;
              }

              const lyricLines = lrcForContext.map((line, index) => {
                const prefix = index === activeIndex ? '>> ' : '';
                return `${prefix}${line.text}`;
              }).join('\n');

              // 喂给AI，收工
              const fullLyricText = lrcForContext.map(line => line.text).join('\n');
              const activeLineText = activeIndex > -1 ? lrcForContext[activeIndex].text : '(歌曲刚开始)';
              listenTogetherContext = `
# 当前活动：一起听歌

你们正在一起听 ${session.artist} 的《${session.songName}》。

这是这首歌的【完整歌词】，你可以通读全文来理解它的整体意境和故事：
[完整歌词开始]
${fullLyricText}
[完整歌词结束]

当前，歌曲正好播放到这一句：**"${activeLineText}"**

请结合【整首歌的意境】和【当前唱到的这一句】，与用户展开自然的对话。
   `.trim();
            }
          }
        }
        // --- 视觉神经植入完毕 ---
        // --- 视觉神经植入完毕 ---


        let modeInstruction = ''; // 先声明一个空变量


        // ▼▼▼ Noir's Grand AI Protocol Upgrade ▼▼▼
        let transitionContext = ''; // 这是新的“场景说明卡”
        const historyLength = state.conversationHistory.length;
        if (historyLength > 1) {
          const lastMsg = state.conversationHistory[historyLength - 2];
          const currentMsg = state.conversationHistory[historyLength - 1];
          if (lastMsg.isOffline === false && currentMsg.isOffline === true) {
            // 从线上切换到线下
            transitionContext = `\n# 【！！！重要场景切换！！！】\n你刚才在和“${boundUser.name}”用手机聊天，现在Ta出现在了你面前。请根据这前后的时间差，判断Ta现在出现的合理性（例如，时间很长——Ta可能是过来找你玩了，你可以感到惊喜或者别的，又或者，时间非常短——Ta可能是突然出现的，你会有点震惊，结合上下文，也会有别的反应），并作出恰当的反应。，现在，切换到【见面】模式（使用JSON格式，必须有旁白）。`;
          } else if (lastMsg.isOffline === true && currentMsg.isOffline === false) {
            // 从线下切换到线上
            transitionContext = `\n# 【！！！重要场景切换！！！】\n你之前正和“${boundUser.name}”面对面，Ta现在掏出手机给你发了这条消息。请根据这前后的时间差，判断Ta发送消息的合理性，你应该结合上下文对此发表评论（例如，根据上下文，Ta已经和你分开了，没用面对面了，那么发手机消息非常正常，自然接话就好，但是如果判断得出你们还在见面状态，那么，你可以适当吐槽为什么两个人见面还要发手机消息），现在，切换到【手机聊天】模式（纯文本气泡，不要有旁白）。`;
          }
        }

        // ▼▼▼ Noir's Galgame AI Upgrade ▼▼▼
        if (isOffline) {
          const emotionsList = "normal, happy, angry, sad, shy";
          modeInstruction = `

# 核心任务: 视觉小说剧本写作

  - **当前场景**: 你正在与用户“${boundUser.name}”面对面交流。你的回复必须是【视觉小说剧本】格式。
  - **输出格式**: 你的回复**必须**是一个完整的、语法正确的JSON数组。每一个数组元素都是一个对象，代表一句台词或旁白，结构如下:
  
    {
    "speaker": "角色名或narrator",
    "emotion": "从[${emotionsList}]中选择的情绪标签",
    "line": "台词或旁白内容"
    }
  
  - **规则**:
    1.  \`speaker\`字段：如果是角色说话，就用角色名“${responderChar.name}”；如果是环境或动作描写，就用“narrator”。
    2.  \`emotion\`字段：**必须**从 [${emotionsList}] 这五个词中选择一个。旁白的emotion应尽量与上一句台词的情绪保持一致，以避免角色立绘表情突变。2.  \`emotion\`字段：**必须**根据台词的【核心情感】，精准地从 [${emotionsList}] 这五个词中选择一个。例如，如果台词表达了哀伤或失望，就必须选择 'sad'。旁白的emotion应尽量与上一句台词的情绪保持一致，以避免角色立绘表情突变。
     - 'normal': 平常、平静、没有特殊情绪。
      - 'happy': 开心、喜悦、愉快。
      - 'angry': 生气、愤怒、不满。
      - 'sad': 悲伤、哀愁、失落、心里难受。
      - 'shy': 害羞、不好意思、脸红。
    3.  \`line\`字段：具体的台词或描写。
  - **绝对禁止**: 严禁输出任何JSON数组之外的文字、解释或Markdown标记。直接从 \`[\` 开始，到 \`]\` 结束。
    4. 旁白的内容可以尽可能多，以轻小说的风格，尽可能像一本小书一样，补全周边环境，角色内心的看法，角色的行为等一切。
    ` ;
        } else {
          `
# 当前场景: 手机聊天
- **核心任务**: 你正在通过手机与用户聊天。
- **写作风格**: 你的回复应该是口语化的、简短的、像真人打字一样的风格。
- **可用指令**: 你可以根据情绪发送表情包 '[sticker:表情名]' 或分享音乐 '[music:歌名|歌手]'。
`;
        }

        const { omniText: memory } = gatherOmniTranscriptForCharacter(responderChar.id, activeChat.id);
        const musicMemory = getGlobalFeedMemory();
        const diaryMemory = getDiaryMemory(responderChar.id); // <-- 看见没，就是这行，把日记记忆加进去了
        // ▼▼▼ Noir's Addition: Inject Calendar Memory ▼▼▼
        const calendarMemory = getCalendarMemoryForCharacter(responderChar.id);
        // ▲▲▲ End of Addition ▲▲▲
        // ▼▼▼【神经植入点】▼▼▼
        const snoopMemory = await getSnoopMemoryForCharacter(responderChar.id);
        // ▲▲▲【植入完成】▲▲▲
        const coreRules = (typeof CORE_RULES_TEMPLATE === 'string' ? CORE_RULES_TEMPLATE.replaceAll('{charName}', responderChar.name).replaceAll('{userName}', boundUser.name || '用户') : '');
        const stickerNameList = getVisibleStickers().map(s => s.name).join(', ');
        let worldBookContext = '';
        if (responderChar.linkedWorldBookIds && responderChar.linkedWorldBookIds.length > 0) {
          const linkedBooksContent = responderChar.linkedWorldBookIds.map(wbId => state.worldBooks.find(book => book.id === wbId)).filter(Boolean).map(wb => `\n\n## 世界书条目: ${wb.name}\n${wb.content}`).join('');
          if (linkedBooksContent) worldBookContext = `\n\n# 核心世界观设定 (你必须严格遵守以下设定)\n${linkedBooksContent}`;
        }

        // 哼，就是这里，把用户资料的记忆加回来
        const userPersonaContext = boundUser.persona ? `\n\n# 关于对话者“${boundUser.name}”的补充信息\n${boundUser.persona}` : '';


        // ▼▼▼ 哼，从这里开始，换成我的新代码 ▼▼▼
        let timeContext = '';
        const now = new Date();
        const latestMessageAcrossAllChats = findLatestMessageForCharacter(responderChar.id);

        timeContext = `\n# 时间锚点 (你必须参考此信息进行回复)\n`;
        timeContext += `- **当前精确时间**: ${now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' })}\n`;

        if (latestMessageAcrossAllChats) {
          const lastInteractionDate = new Date(latestMessageAcrossAllChats.timestamp);
          const lastInteractionString = formatRelativeTime(lastInteractionDate);
          timeContext += `- **你们最后一次互动是在**: ${lastInteractionString}\n`;

          // 哼，看这里，我加了对“今天”和“昨天”的精准判断
          const todayString = now.toDateString();
          const lastDateString = lastInteractionDate.toDateString();

          const yesterday = new Date();
          yesterday.setDate(now.getDate() - 1);
          const yesterdayString = yesterday.toDateString();

          if (todayString === lastDateString) {
            // 如果是今天
            const diffMinutes = (now - lastInteractionDate) / (1000 * 60);
            if (diffMinutes < 60) {
              timeContext += `- **对话状态提示**: 对话正在进行中，可以直接延续话题。\n`;
            } else {
              timeContext += `- **对话状态提示**: 你们今天早些时候聊过（大概${Math.round(diffMinutes / 60)}小时前），可以简单问候一下对方现在的状态。\n`;
            }
          } else if (yesterdayString === lastDateString) {
            // 如果是昨天
            timeContext += `- **对话状态提示**: 对话已经过了一天，你应该意识到之前的话题已是【昨天】的事，可以开启新话题或用“说起昨天...”来提及旧事。\n`;
          } else {
            // 如果是更久以前
            const diffDays = Math.round((now - lastInteractionDate) / (1000 * 60 * 60 * 24));
            timeContext += `- **对话状态提示**: 你们已经有 ${diffDays} 天没联系了，应该用全新的问候开启对话，不要再提上次的话题了。\n`;
          }

        } else {
          timeContext += "- **对话状态提示**: 这是你们的第一次对话。\n";
        }
        // ▲▲▲ 替换到这里结束 ▲▲▲

        const systemLock = `
${modeInstruction}
你只扮演【${responderChar.name}】进行回复。
不要替其他角色续写台词，不要输出"${responderChar.name}:" 或"[${responderChar.name}]" 等前缀。
如需发送表情，只发送一行：[sticker:表情名]。
【重要】发送表情包时，表情名【必须】从以下列表中选择：[${stickerNameList}]。严禁使用列表之外的任何表情名。
${coreRules}
`.trim();

        const messages = [{ role: 'system', content: systemLock }];
        const contextMessage = `
# 你的个性（节选）
${responderChar.persona || '你是一个乐于助人的助手。'}
${userPersonaContext} 
${memory}
${musicMemory}
${diaryMemory}
${calendarMemory} // <-- 哼，加在这里
${snoopMemory} 
# 当前情景
${listenTogetherContext}
${timeContext}
${worldBookContext}
`.trim();

        if (contextMessage.replace(/#.*|\s/g, '')) {
          messages.push({ role: 'user', content: contextMessage });
          messages.push({ role: 'assistant', content: '好的，我记住了这些人设和历史。现在我们开始对话。' });
        }

        const maxLines = state.preferences?.perChatContextLines ?? 100;
        const history = state.conversationHistory.slice(-maxLines);
        // 这是新的、能看懂门票的循环系统
        for (const msg of history) {
          const role = (msg.role === 'ai' || msg.role === 'assistant') ? 'assistant' : 'user';
          let messageForApi = { role: role, content: msg.content };
          let hasContent = !!msg.content;

          if (msg.displayUrl && msg.content.includes('表情')) {
            const stickerNameMatch = msg.content.match(/：(.*?)]$/);
            messageForApi.content = `[sticker:${stickerNameMatch ? stickerNameMatch[1] : '未知表情'}]`;
            messages.push(messageForApi);
          } else {
            let imageBase64 = null;
            if (msg.image) {
              // 兼容旧数据：直接用照片
              imageBase64 = msg.image;
            } else if (msg.imageId) {
              // 哼，看到门票了，现在去扫描
              try {
                const blob = await dbGet(msg.imageId);
                if (blob) {
                  imageBase64 = await blobToBase64(blob);
                }
              } catch (e) {
                console.error("在准备API数据时，从IndexedDB读取图片失败:", e);
              }
            }

            if (imageBase64) {
              messageForApi.image = imageBase64;
              hasContent = true; // 有图片就算有内容
            }

            // 确保有内容（文本或图片）才添加
            if (hasContent) {
              messages.push(messageForApi);
            }
          }
        }


        // ▼▼▼ Noir's Galgame Response Handler Upgrade ▼▼▼
        // ▼▼▼ Noir's Ultimate & Final Refactor: 用这个完整的 try...finally 块替换掉你现有的！▼▼▼
        try {
          const responseText = await fetchAICompletion(messages);
          if (!responseText) return false;

          if (isOffline) {
            // ===================================
            // --- 剧本（见面）生产线 ---
            // ===================================
            try {
              let cleanJson = responseText.trim();
              const jsonMatch = cleanJson.match(/(\[[\s\S]*\])/);
              if (jsonMatch) {
                cleanJson = jsonMatch[1];
              }

              const script = JSON.parse(cleanJson);
              if (Array.isArray(script)) {
                state.activeMeetingScriptQueue = [...script];
                // state.lastMeetingScript = [...script]; // <--- 删掉这句旧的！
                state.characterLastScripts[responderChar.id] = [...script]; // <--- 换成这句！记在对应角色的本子上
                advanceMeetingScript();

                // 为了让小说模式也能看，我们把内容存一份到历史记录
                const fullText = script.map(s => (s.speaker === 'narrator' ? s.line : `${s.speaker}: ${s.line}`)).join('\n\n');
                state.conversationHistory.push({
                  role: 'assistant', senderId: responderChar.id, timestamp: Date.now(), isOffline: true, content: fullText
                });
              }
            } catch (e) {
              console.error("解析AI剧本JSON失败:", e, "原始文本:", responseText);
              // 解析失败，就当成普通文本处理
              state.conversationHistory.push({
                role: 'assistant', senderId: responderChar.id, timestamp: Date.now(), isOffline: true, content: `[AI返回了无法解析的剧本: ${responseText}]`
              });
            }

          } else {
            // ===================================
            // --- 聊天生产线 (哼，现在这里是我的地盘了) ---
            // ===================================
            const replies = extractAndProcessCommands(responseText);
            const pendingMessages = replies.map(reply => {
              const content = reply.trim();
              // 哼，你看，那个多余的 musicMatch 判断被我干掉了，现在都在下面统一处理，干净利落。
              const stickerMatch = content.match(/^\[sticker:(.*?)\]$/);
              const transferMatch = content.match(/^\[transfer:([\d.]+)\|(.*?)\]$/);
              const musicMatch = content.match(/^\[music:(.*?)\|(.*?)\]$/); // 把它移到这里来
              // ▼▼▼ Noir's Addition: Event Creation Command ▼▼▼
              const eventMatch = content.match(/^\[create_event:(.*?)\|(.*?)\|(.*?)\]$/);
              // ▲▲▲ End of Addition ▲▲▲
              const htmlMatch = content.match(/^\[html\]([\s\S]*)\[\/html\]$/);

              // ▼▼▼ Noir's HTML Command Handler ▼▼▼
              if (htmlMatch) {
                // 如果是HTML命令，直接返回一个特殊类型的消息
                return { type: 'html', content: htmlMatch[1].trim() };
              } else if (musicMatch) { // <--- 别忘了把原来的 if 改成 else if

                return { type: 'music', songName: musicMatch[1].trim(), artist: musicMatch[2].trim() };
              } else if (stickerMatch) {
                return { type: 'sticker', name: stickerMatch[1].trim() };
                // ▼▼▼ 在 stickerMatch 和 transferMatch 之间，或者它们后面，加上这个 else if ▼▼▼
              } else if (eventMatch) {
                return {
                  type: 'create_event',
                  eventType: eventMatch[1].trim(),
                  eventDate: eventMatch[2].trim(),
                  eventContent: eventMatch[3].trim()
                };
                // ▲▲▲ End of Addition ▲▲▲
              } else if (transferMatch) {
                const amount = parseFloat(transferMatch[1]);
                const recipientName = transferMatch[2].trim();
                const currentUser = getBoundUserForChat(state.activeChatId);
                let recipientId = null;
                if (recipientName === currentUser.name) {
                  recipientId = currentUser.id;
                } else {
                  const activeChat = getActiveChat();
                  if (activeChat.type === 'group') {
                    const targetChar = state.characters.find(c => activeChat.participantIds.includes(c.id) && c.name === recipientName);
                    if (targetChar) recipientId = targetChar.id;
                  }
                }
                if (recipientId) return { type: 'transfer', amount, recipientId, senderId: responderChar.id };
                else return { type: 'text', content: `(想转账给“${recipientName}”，但没找到人)` };
              } else if (content) {
                return { type: 'text', content: content };
              }
              return null;
            }).filter(Boolean);

            const processPendingMessage = async (pending) => {
              const msg = { role: 'assistant', senderId: responderChar.id, timestamp: Date.now(), isOffline: isOffline };

              // 哼，看好了，这就是我让你替换的那一整块！现在它有了净化功能！
              // ▼▼▼ 找到 generateAs 函数里处理 music 的这块，换成下面这段 ▼▼▼
              if (pending.type === 'music') {
                const { songName, artist } = pending;
                msg.type = 'music';
                msg.content = `[AI分享了音乐：${songName} - ${artist}]`;
                try {
                  const musicInfo = await findPlayableMusicUrl(songName, artist);
                  // 哼，最后一次，把“下载”换成“链接”
                  Object.assign(msg, {
                    songName,
                    artist,
                    coverUrl: musicInfo.cover, // 用链接！
                    playableUrl: musicInfo.url
                  });

                } catch (e) {
                  Object.assign(msg, { songName, artist, coverUrl: null, playableUrl: null });
                }
              }
              // ▲▲▲ 替换到这里结束，注意别把后面的 else if 删了 ▲▲▲
              else if (pending.type === 'sticker') {
                const sticker = masterStickerList.find(s => s.name === pending.name); if (sticker) Object.assign(msg, { content: `[AI发送了表情：${sticker.name}]`, displayUrl: sticker.url });
                else msg.content = `[sticker:${pending.name}]`;
              } else if (pending.type === 'transfer') {
                const recipient = pending.recipientId === getBoundUserForChat(state.activeChatId).id ? getBoundUserForChat(state.activeChatId) : getCharacterById(pending.recipientId);
                Object.assign(msg, { type: 'transfer', amount: pending.amount, recipientId: pending.recipientId, content: `[AI向 ${recipient?.name || '未知'} 转账 ${pending.amount}]` });
                // ▼▼▼ Noir's Addition: Handle AI Event Creation ▼▼▼
                // ▼▼▼ 从这里开始替换 ▼▼▼
              } else if (pending.type === 'create_event') {
                const activeUser = getBoundUserForChat(activeChat.id);

                // 哼，同样给它也装上大脑，免得它犯傻
                if (!activeUser || !activeUser.id) {
                  console.error("AI 试图创建事件，但找不到有效的用户ID。");
                  return null; // 直接跳过这个坏掉的指令
                }

                state.calendarEvents.push({
                  id: `event_ai_${Date.now()}`,
                  date: pending.eventDate,
                  type: pending.eventType,
                  content: pending.eventContent,
                  userId: activeUser.id,
                  createdBy: 'ai'
                });

                saveState();
                updateCountdownWidget(); // 更新倒计时
                updateTodayTodoWidget(); // <-- 看见没！我给它补上了！

                const character = getCharacterById(responderChar.id);
                if (character && pending.eventType === 'important') {
                  modalAlert(`💜 ${character.name} 添加了新的纪念日：${pending.eventContent}`);
                }

                return { role: 'assistant', senderId: responderChar.id, timestamp: Date.now(), isOffline: isOffline, content: null };
                // ▲▲▲ 替换到这里结束 ▲▲▲

                // 这个指令是秘密执行的，所以返回一个不可见的消息
                return { role: 'assistant', senderId: responderChar.id, timestamp: Date.now(), isOffline: isOffline, content: null };
                // ▲▲▲ End of Addition ▲▲▲
              } else {
                const parsedPart = parseAIResponse(pending.content);
                Object.assign(msg, { content: parsedPart.content, quotedMessage: parsedPart.quotedMessage });
              }
              return msg;
            };

            const finalMessages = await Promise.all(pendingMessages.map(processPendingMessage));

            // ▼▼▼ Noir's Final Message Renderer Loop ▼▼▼
            for (const msg of finalMessages) {
              if (msg.type === 'html') {
                // 如果是HTML类型的消息，直接渲染，不进历史记录
                addMessageToUI(msg, -1); // -1表示这是个临时的、不记录的UI元素
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
              } else if (msg.content || msg.displayUrl || msg.type === 'music' || msg.quotedMessage) {
                // 其他类型的消息，照旧处理
                await new Promise(r => setTimeout(r, 300 + Math.random() * 400));
                state.conversationHistory.push(msg);
                addMessageToUI(msg, state.conversationHistory.length - 1);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
              }
            }
            // ▲▲▲ End of Loop ▲▲▲
          }

          saveHistory();
          //  renderActiveView(); // 统一在最后渲染一次
          return true;

        } catch (e) {
          if (e.name !== 'AbortError') {
            console.error('生成失败: ', e);
            const errorMsg = { role: 'assistant', content: `错误: ${e.message}`, senderId: responderChar.id, isOffline: isOffline };
            state.conversationHistory.push(errorMsg);
            renderActiveView();
          }
          return false;
        } finally {
          showTypingIndicator(false);
        }
        // ▲▲▲ End of Refactor ▲▲▲
      }
      // --- Noir's Memory Extraction Protocol ---
      async function handleSummarizeChat() {
        const activeChat = getActiveChat();
        if (!activeChat || activeChat.type !== 'private') {
          modalAlert('哼，只有私聊才能进行总结，群聊那么乱怎么记！');
          return;
        }
        if (state.isGenerating) {
          modalAlert('我正在说话呢，别打岔！');
          return;
        }

        const ok = await modalConfirm('确定要对本次会话进行总结吗？这会消耗不少资源，并且会读取完整的聊天记录。');
        if (!ok) return;

        showFeedLoader(true, '正在翻阅全部历史记录...');
        summaryTextarea.value = ''; // 先清空
        summarizeModal.classList.add('show');
        state.isGenerating = true;

        try {
          const character = getCharacterById(activeChat.participantIds[0]);
          const user = getBoundUserForChat(activeChat.id);

          // 哼，要把所有的历史记录都捞出来，而不是 state 里的那一点点
          const fullHistory = loadChatHistory(activeChat.id);

          if (fullHistory.length === 0) {
            summaryTextarea.value = "# 记录是空的，没什么好总结的。";
            return;
          }

          // 把历史记录格式化成 AI 能看懂的样子
          const formattedHistory = fullHistory.map(msg => {
            const date = new Date(msg.timestamp);
            const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
            const timeStr = `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;

            let speaker = '未知';
            if (msg.role === 'user') {
              speaker = user.name;
            } else {
              speaker = character.name;
            }

            let content = msg.content;
            if (msg.displayUrl) content = '[发送了表情]';
            if (msg.imageId) content = '[发送了图片]';

            return `[${dateStr} ${timeStr}] [${speaker}]: ${content}`;
          }).join('\n');

          // ...用这个替换掉上面的...
          const systemPrompt = SYSTEM_PROMPT_FOR_SUMMARY
            .replace(/{charName}/g, character.name)
            .replace(/{userName}/g, user.name);

          const messages = [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: formattedHistory }
          ];

          const summary = await fetchAICompletion(messages);

          summaryTextarea.value = summary || '# 总结失败了，可能是记录太长或太复杂。';
          summaryTextarea.scrollTop = 0; // 总结完，滚动到最上面

        } catch (error) {
          console.error("总结失败:", error);
          summaryTextarea.value = `# 发生错误：\n${error.message}`;
        } finally {
          showFeedLoader(false);
          state.isGenerating = false;
        }
      }
      async function getAIResponse() {
        console.log('--- 开始AI回复流程 ---'); // <== 窃听器 #1
        if (!state.apiSettings.endpoint || !state.apiSettings.key || !state.apiSettings.model) {
          modalAlert('请先在"设置"中配置你的 API 信息。');
          return;
        }

        const lastIsUser = state.conversationHistory.at(-1)?.role === 'user';
        if (!lastIsUser || state.isGenerating) return;

        const activeChat = getActiveChat();
        if (!activeChat) return;

        state.isGenerating = true;
        showTypingIndicator(true);

        try {
          if (activeChat.type === 'private') {
            const solo = getCharacterById(activeChat.participantIds[0]);
            console.log('准备调用 generateAs...'); // <== 窃听器 #2
            if (solo) await generateAs(solo, {
              force: true
            });
          } else {
            // 群聊：只尝试一次“整轮规划”
            const plan = await planGroupReplies();
            if (plan && plan.events?.length) {
              await schedulePlannedReplies(plan); // 本地排队渲染，不额外调用 API
            } else {
              // 回退：如果群聊规划失败，显示一条错误消息而不是为每个人单独生成。
              // 这可以避免多次API调用，并让用户知道发生了什么。
              console.warn("Group plan failed, falling back to individual generation for each character.");
              const participants = activeChat.participantIds.map(getCharacterById).filter(Boolean);
              if (!participants.length) return;

              // 为了让回复看起来更自然，我们引入一个小的、递增的延迟
              let delay = 0;
              for (const char of participants) {
                // 注意：这里我们为每个角色都调用了 generateAs
                // 这会导致多次API调用，但能确保满足用户需求
                generateAs(char, {
                  force: true,
                  delayMs: delay
                });
                delay += 500; // 每位角色之间的回复间隔增加0.5秒
              }
            }
          }
        } catch (e) {
          if (e.name !== 'AbortError') {
            console.error('获取AI响应失败:', e);
            // 改成这样！
            addMessageToUI({
              role: 'assistant',
              content: `错误: ${e.message}`,
            }, state.conversationHistory.length - 1);
          }
        } finally {
          // 哼，就是这里，顺序搞反了。得先告诉它“别想了”，再去刷新界面。
          state.isGenerating = false;
          showTypingIndicator(false);
        }
      }



      // [Noir's Ultimate Refactor]: 新增一个辅助函数，用于检测API供应商
      function detectApiProvider(endpoint, model) {
        const modelLower = model.toLowerCase();
        const endpointLower = endpoint.toLowerCase();

        if (modelLower.startsWith('claude')) return 'anthropic';
        if (endpointLower.includes('anthropic.com')) return 'anthropic';

        // 只要包含 googleapis.com 就认为是Gemini系
        if (endpointLower.includes('googleapis.com')) return 'gemini';
        // 即使是反代，模型名里带gemini也优先按gemini处理
        if (modelLower.startsWith('gemini')) return 'gemini';

        // 剩下的，包括gpt, deepseek (ds), moonshot 等，都默认按OpenAI兼容格式处理
        return 'openai';
      }

      // <<< Noir: 别看了，这里最麻烦。我把中止信号塞进去了，你要是再敢浪费我的算力，哼。
      async function fetchAICompletion(messages, opts = {}) {
        // 如果有正在进行的请求，先中止它
        if (state.currentAbortController) {
          state.currentAbortController.abort('New request started');
        }
        // 为这次新请求创建一个新的 AbortController
        state.currentAbortController = new AbortController();
        const signal = state.currentAbortController.signal;

        const {
          endpoint,
          key,
          model
        } = state.apiSettings;
        const wantJson = !!opts.json;

        const provider = detectApiProvider(endpoint, model);
        console.log(`Detected API provider: ${provider}`);

        let responseText = '';

        try {
          switch (provider) {
            case 'anthropic': {
              const claudeApiKey = getRandomValue(key);
              const systemPrompt = messages.find(m => m.role === 'system')?.content || '';
              const userMessages = messages.filter(m => m.role !== 'system');

              // Claude API 对 system prompt 和 message 格式有严格要求
              const body = {
                model: model,
                system: systemPrompt,
                messages: userMessages.map(msg => ({
                  role: msg.role,
                  // Claude 的 content 是一个数组
                  content: [{
                    type: 'text',
                    text: msg.content
                    // 本示例暂未处理图片
                  }]
                })),
                max_tokens: 8192,
              };

              const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-api-key': claudeApiKey,
                  'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify(body),
                signal: signal // 传入 signal
              });

              if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                throw new Error(`Claude API 错误: ${response.status} - ${err.error?.message || response.statusText}`);
              }
              const data = await response.json();
              responseText = data.content?.[0]?.text || '';
              break;
            }

            case 'gemini': {
              const geminiApiKey = getRandomValue(key);
              const isOfficialEndpoint = endpoint.includes('generativelace.googleapis.com');

              const toGeminiParts = (msg) => {
                const parts = [];
                if (msg.content) parts.push({
                  text: msg.content
                });
                if (msg.image) {
                  const base64Data = msg.image.split(',')[1];
                  const mimeType = msg.image.substring(msg.image.indexOf(":") + 1, msg.image.indexOf(";")) || 'image/jpeg';
                  parts.push({
                    inline_data: {
                      mime_type: mimeType,
                      data: base64Data
                    }
                  });
                }
                return parts;
              };

              const contents = messages
                .map(m => ({
                  role: m.role === 'assistant' ? 'model' : (m.role === 'system' ? 'user' : m.role),
                  parts: toGeminiParts(m)
                }))
                .filter(c => c.parts.length > 0);

              const body = {
                contents
              };

              // 只有在官方接口且需要JSON时，才使用特殊参数，反代接口则不使用
              if (wantJson && isOfficialEndpoint) {
                body.generationConfig = {
                  response_mime_type: "application/json"
                };
              }

              const fetchUrl = `${endpoint}/v1beta/models/${model}:streamGenerateContent?key=${geminiApiKey}&alt=sse`;
              const res = await fetch(fetchUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(body),
                signal: signal // 传入 signal
              });

              if (!res.ok) throw new Error(`Gemini API Error: ${res.status}`);

              const reader = res.body.getReader();
              const decoder = new TextDecoder();
              let content = '';
              while (true) {
                if (signal.aborted) {
                  console.log('Gemini stream reading aborted.');
                  reader.cancel();
                  break;
                }
                const {
                  done,
                  value
                } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value, {
                  stream: true
                });
                const lines = chunk.split('\n').filter(line => line.trim().startsWith('data:'));
                for (const line of lines) {
                  const jsonStr = line.replace('data: ', '');
                  if (jsonStr === '[DONE]') break;
                  try {
                    content += JSON.parse(jsonStr).candidates[0].content.parts[0].text;
                  } catch { }
                }
              }
              responseText = content;
              break;
            }

            case 'openai':
            default: { // 默认为OpenAI兼容接口
              const openAIKey = getRandomValue(key);
              const fetchUrl = `${endpoint.replace(/\/+$/, '')}/v1/chat/completions`;
              const processed = messages.map(msg => {
                if (msg.role === 'user' && msg.image) {
                  return {
                    role: 'user',
                    content: [{
                      type: 'text',
                      text: msg.content || " "
                    }, {
                      type: 'image_url',
                      image_url: {
                        url: msg.image,
                        detail: "high"
                      }
                    },]
                  };
                }
                return {
                  role: msg.role,
                  content: msg.content
                };
              }).filter(m => m.content);

              const body = {
                model,
                messages: processed,
                max_tokens: 8192,
                ...(wantJson ? {
                  response_format: {
                    type: 'json_object'
                  }
                } : {})
              };

              const response = await fetch(fetchUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${openAIKey}`
                },
                body: JSON.stringify(body),
                signal: signal // 传入 signal
              });

              if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                throw new Error(`OpenAI API 错误: ${response.status} - ${err.error?.message || response.statusText}`);
              }
              const data = await response.json();
              responseText = data.choices?.[0]?.message?.content || '';
              break;
            }
          }
          return responseText;
        } catch (error) {
          if (error.name === 'AbortError') {
            console.log('Fetch request was aborted.');
            return ''; // 中止是正常行为，返回空字符串
          }
          // 对于其他错误，仍然抛出
          throw error;
        } finally {
          // 请求结束后，无论成功失败都清理 controller
          if (state.currentAbortController && state.currentAbortController.signal === signal) {
            state.currentAbortController = null;
          }
        }
      }

      async function clearCurrentHistory() {
        const onEditScreen = screens.characterEdit.classList.contains('active');
        const editingCharId = onEditScreen ? editingCharIdInput.value : null;

        let chatToClear = null;
        let chatName = '';

        if (onEditScreen && editingCharId) {
          // Find the private chat associated with the character being edited
          chatToClear = state.chats.find(c => c.type === 'private' && c.participantIds.includes(editingCharId));
          const character = getCharacterById(editingCharId);
          chatName = character ? character.name : '该角色';
        } else if (state.activeChatId) {
          // Clear the currently active chat
          chatToClear = getActiveChat();
          const header = document.getElementById('char-name-header').textContent;
          chatName = header || '当前聊天';
        }

        if (!chatToClear) {
          modalAlert('找不到要清空的聊天记录。');
          return;
        }

        const ok = await modalConfirm(`确定要清空"${chatName}" 的聊天记录吗？此操作不可撤销。`);
        if (!ok) return;

        // If we are clearing the history of the currently active chat, stop generation and clear UI.
        if (chatToClear.id === state.activeChatId) {
          // <<< Noir: 清空记录？连带正在说的话也一并不想要了是吧，行。
          cancelAIGeneration();
          state.conversationHistory = [];
          renderMessages(); // Clear UI immediately
        }

        // Clear the history from localStorage.
        try {
          localStorage.removeItem(`chatHistory_${chatToClear.id}`);
        } catch (e) {
          console.error(`Failed to remove history for chat ${chatToClear.id}`, e);
        }

        modalAlert(`"${chatName}" 的聊天记录已清空。`);
      }

      // --- Settings & Profile Logic ---
      // --- Noir's Data Import/Export Logic ---

      const exportButton = document.getElementById('export-all-data-button');
      const importButton = document.getElementById('import-all-data-button');
      const importInput = document.getElementById('import-data-input');

      // 导出功能
      // 导出功能 (v2.0 音乐圣殿対応版)
      // 找到旧的 exportButton.addEventListener... 删掉它，换成下面这个！

      exportButton.addEventListener('click', async () => {
        showFeedLoader(true, '正在打包数据，请稍候...');
        const failedFiles = [];
        try {
          const fullBackup = {
            localStorageData: {},
            indexedDBData: {},
            indexedDBMusicData: [],
            indexedDBSnoopData: []
          };

          // 1. 打包 localStorage (不变)
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key) fullBackup.localStorageData[key] = localStorage.getItem(key);
          }

          // ▼▼▼ Noir's "Simultaneous Raid" Protocol ▼▼▼
          const db = await dbPromise;

          // 1. 拿到所有钥匙
          const transaction = db.transaction([STORE_NAME, MUSIC_STORE_NAME, SNOOP_STORE_NAME], 'readonly');
          const imgStore = transaction.objectStore(STORE_NAME);
          const musicStore = transaction.objectStore(MUSIC_STORE_NAME);
          const snoopStore = transaction.objectStore(SNOOP_STORE_NAME);

          // 2.【核心】同时向所有房间发起“总攻”，但先不急着等结果
          const imagePromise = new Promise((res, rej) => { const r = imgStore.getAll(); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error); });
          const musicPromise = new Promise((res, rej) => { const r = musicStore.getAll(); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error); });
          const snoopPromise = new Promise((res, rej) => { const r = snoopStore.getAll(); r.onsuccess = () => res(r.result); r.onerror = () => rej(r.error); });

          // 3.【关键】在这里一次性等到所有“总攻”都完成。在这之前，门禁不会关！
          const [allImageRecords, allMusicRecords, allSnoopRecords] = await Promise.all([imagePromise, musicPromise, snoopPromise]);

          // 4. 哼，现在所有战利品都在大厅了，门禁关了也无所谓。开始慢悠悠地打包。

          // 打包图片
          for (const record of allImageRecords) {
            if (record.blob instanceof Blob) {
              try {
                fullBackup.indexedDBData[record.id] = await blobToBase64(record.blob);
              } catch (error) { failedFiles.push(record.id); }
            }
          }

          // 打包音乐
          for (const record of allMusicRecords) {
            const packableRecord = { ...record };
            if (record.audio instanceof Blob) {
              packableRecord.audio = await blobToBase64(record.audio);
            }
            if (record.cover instanceof Blob) {
              packableRecord.cover = await blobToBase64(record.cover);
            }
            fullBackup.indexedDBMusicData.push(packableRecord);
          }

          // 打包视奸档案
          fullBackup.indexedDBSnoopData = allSnoopRecords;
          // ▲▲▲ Protocol End ▲▲▲

          const blob = new Blob([JSON.stringify(fullBackup, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          const date = new Date();
          const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
          a.href = url;
          a.download = `Noir_Backup_${dateString}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          showFeedLoader(false);

          if (failedFiles.length > 0) {
            modalAlert(`导出已完成，但以下文件因损坏或过大被跳过：\n\n${failedFiles.join('\n')}`);
          } else {
            modalAlert('包含所有图片和音乐的全量数据已成功导出！');
          }

        } catch (error) {
          showFeedLoader(false);
          console.error("全量导出失败:", error);
          modalAlert(`导出过程中发生严重错误: ${error.message}`);
        }
      });



      importButton.addEventListener('click', () => {
        importInput.click();
      });
      //重roll我放在这里？
      rerollButton.addEventListener('click', handleReroll);
      // 文件选择后的处理
      // 导入功能 (v2.0 音乐圣殿対応版)
      // 导入功能 (v3.0 事务稳定版)
      importInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        modalConfirm('确定要导入全量备份文件吗？这将覆盖所有当前数据（包括图片和音乐），且操作不可撤销！').then(ok => {
          if (!ok) {
            importInput.value = '';
            return;
          }

          showFeedLoader(true, '正在解析备份文件...');
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const fullBackup = JSON.parse(e.target.result);
              if (!fullBackup.localStorageData || !fullBackup.indexedDBData) {
                throw new Error('文件格式不正确，不是一个有效的备份文件。');
              }

              // 1. 哼，先把所有货物都准备好
              showFeedLoader(true, '正在准备图片数据...');
              const imageEntries = await Promise.all(
                Object.keys(fullBackup.indexedDBData).map(async (key) => {
                  const base64 = fullBackup.indexedDBData[key];
                  if (typeof base64 === 'string' && base64.startsWith('data:')) {
                    const blob = await base64ToBlob(base64);
                    return { id: key, blob: blob };
                  }
                  return null;
                })
              ).then(entries => entries.filter(Boolean));

              const musicEntries = [];
              if (fullBackup.indexedDBMusicData) {
                showFeedLoader(true, '正在准备音乐数据...');
                const musicPromises = fullBackup.indexedDBMusicData.map(async (record) => {
                  const restoredRecord = { ...record };
                  if (record.audio) restoredRecord.audio = await base64ToBlob(record.audio);
                  if (record.cover) restoredRecord.cover = await base64ToBlob(record.cover);
                  return restoredRecord;
                });
                musicEntries.push(...await Promise.all(musicPromises));
              }

              // 2. 擦除旧数据
              showFeedLoader(true, '正在清空旧数据...');
              localStorage.clear();
              for (const key in fullBackup.localStorageData) {
                localStorage.setItem(key, fullBackup.localStorageData[key]);
              }

              // 3. 打开仓库大门，一次性把所有东西都扔进去！
              showFeedLoader(true, '正在写入新数据...');
              const db = await dbPromise;
              // ▼▼▼ 哼，看好了，我把所有仓库的钥匙都拿来了，一个都别想跑！▼▼▼
              const transaction = db.transaction([STORE_NAME, MUSIC_STORE_NAME, SNOOP_STORE_NAME], 'readwrite');
              const imgStore = transaction.objectStore(STORE_NAME);
              const musicStore = transaction.objectStore(MUSIC_STORE_NAME);
              const snoopStore = transaction.objectStore(SNOOP_STORE_NAME); // <-- 看！就是这行！我给他贴上标签了！

              // 先清空所有仓库
              imgStore.clear();
              musicStore.clear();
              snoopStore.clear(); // <-- 现在他知道该去清空哪个仓库了

              // 再把准备好的货物放进去
              imageEntries.forEach(entry => imgStore.put(entry));
              musicEntries.forEach(entry => musicStore.put(entry));

              // 哼，检查一下行李里有没有视奸档案
              if (fullBackup.indexedDBSnoopData && Array.isArray(fullBackup.indexedDBSnoopData)) {
                console.log("正在恢复视奸档案...");
                fullBackup.indexedDBSnoopData.forEach(entry => snoopStore.put(entry));
              }

              // 等待事务完成
              await new Promise((resolve, reject) => {
                transaction.oncomplete = resolve;
                transaction.onerror = (event) => reject(event.target.error);
              });

              showFeedLoader(false);
              modalAlert('数据导入成功！应用即将刷新...');
              setTimeout(() => location.reload(), 1600);

            } catch (error) {
              showFeedLoader(false);
              console.error("全量导入失败:", error);
              modalAlert(`导入失败: ${error.message}`);
            } finally {
              importInput.value = '';
            }
          };
          reader.readAsText(file);
        });
      });

      // [Noir's Final Modification]: 修改这两个函数以支持新的下拉菜单

      function loadAndApplyApiSettings() {
        apiEndpointInput.value = state.apiSettings.endpoint || '';
        apiKeyInput.value = state.apiSettings.key || '';
        apiModelInput.value = state.apiSettings.model || '';
        contextLinesInput.value = String(state.preferences?.perChatContextLines ?? 100);
        // 新增下面这行，加载并选中用户保存的接口格式
        document.getElementById('api-provider').value = state.apiSettings.provider || 'openai';
      }

      function saveApiSettings() {
        state.apiSettings.endpoint = apiEndpointInput.value.trim();
        state.apiSettings.key = apiKeyInput.value.trim();
        state.apiSettings.model = apiModelInput.value.trim();
        // 新增下面这行，保存用户选择的接口格式
        state.apiSettings.provider = document.getElementById('api-provider').value;

        const n = parseInt(contextLinesInput.value, 10);
        state.preferences.perChatContextLines = Number.isFinite(n) && n > 0 ? n : 100;

        saveState();
        modalAlert('设置已保存！');
      }


      function loadAndApplyUserProfile() {
        userNameInput.value = state.userProfile.name || '';
        userAvatarPreview.src = state.userProfile.avatar || DEFAULT_USER_AVATAR;
        userPersonaInput.value = state.userProfile.persona || '';
      }


      // ▼▼▼ Noir's Ultimate Character Editor (Loads from DB) ▼▼▼
      async function openCharacterEditScreen(charId = null) {
        showScreen('characterEdit', previousScreen);
        populateUserDropdown('char-edit-bind-user');

        // --- 哼，这里是新的核心，负责调用我的图书馆管理员 ---
        const char = charId ? state.characters.find(c => c.id === charId) : null;
        populateHierarchicalWorldBookSelector('world-book-checkboxes-container', char ? char.linkedWorldBookIds || [] : []);
        // --- 调用完毕 ---

        const charFrameUrlInput = document.getElementById('char-avatar-frame-url');
        const userFrameUrlInput = document.getElementById('user-avatar-frame-url-in-chat');
        charEditAvatarPreview.src = DEFAULT_AI_AVATAR;
        charEditAvatarInput.value = '';
        charEditWallpaperPreview.style.backgroundImage = '';
        charEditWallpaperInput.value = '';
        charEditOfflineBgPreview.style.backgroundImage = '';
        charEditOfflineBgInput.value = '';
        const emotions = ['normal', 'happy', 'angry', 'sad', 'shy'];
        emotions.forEach(e => {
          document.getElementById(`char-edit-sprite-${e}-preview`).style.backgroundImage = '';
          document.getElementById(`char-edit-sprite-${e}-input`).value = '';
        });

        if (charId) {
          if (!char) return;
          editingCharIdInput.value = char.id;
          charEditTitle.textContent = '编辑角色';
          charEditNameInput.value = char.name;
          charEditRemarkInput.value = char.remark;
          charEditPersonaInput.value = char.persona;
          document.getElementById('char-edit-css').value = char.bubbleCss || '';
          charFrameUrlInput.value = char.avatarFrameUrl || '';
          userFrameUrlInput.value = char.userAvatarFrameUrl || '';
          const chat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(charId));
          document.getElementById('char-edit-bind-user').value = chat?.boundUserProfileId || state.activeUserProfileId;
          try {
            const avatarBlob = await dbGet(`char_avatar_${char.id}`);
            charEditAvatarPreview.src = avatarBlob ? URL.createObjectURL(avatarBlob) : (char.avatar || DEFAULT_AI_AVATAR);
            const wallpaperBlob = await dbGet(`char_wallpaper_${char.id}`);
            if (wallpaperBlob) charEditWallpaperPreview.style.backgroundImage = `url('${URL.createObjectURL(wallpaperBlob)}')`;
            const offlineBgBlob = await dbGet(`char_offline_bg_${char.id}`);
            if (offlineBgBlob) charEditOfflineBgPreview.style.backgroundImage = `url('${URL.createObjectURL(offlineBgBlob)}')`;
            for (const emotion of emotions) {
              const spriteBlob = await dbGet(`char_sprite_${emotion}_${char.id}`);
              if (spriteBlob) {
                document.getElementById(`char-edit-sprite-${emotion}-preview`).style.backgroundImage = `url('${URL.createObjectURL(spriteBlob)}')`;
              }
            }
          } catch (error) {
            console.error(`加载角色 ${char.id} 的图片失败:`, error);
            charEditAvatarPreview.src = char.avatar || DEFAULT_AI_AVATAR;
          }
        } else {
          editingCharIdInput.value = '';
          charEditTitle.textContent = '创建新角色';
          charEditNameInput.value = `新角色 ${state.characters.length + 1}`;
          charEditRemarkInput.value = '';
          charEditPersonaInput.value = '你是一个乐于助人的AI助手。';
          document.getElementById('char-edit-css').value = '';
          charFrameUrlInput.value = '';
          userFrameUrlInput.value = '';
        }

        updateWorldBookSelectionDisplay();

        const cssInput = document.getElementById('char-edit-css');
        let previewStyleTag = document.getElementById('live-preview-style');
        if (!previewStyleTag) {
          previewStyleTag = document.createElement('style');
          previewStyleTag.id = 'live-preview-style';
          document.head.appendChild(previewStyleTag);
        }
        const updatePreview = () => {
          const rawCss = cssInput.value;
          let translatedCss = rawCss
            .replace(/\.bubble\.sent/g, '#bubble-preview-user')
            .replace(/\.bubble\.received/g, '#bubble-preview-ai');
          previewStyleTag.innerHTML = translatedCss;
        };
        cssInput.removeEventListener('input', updatePreview);
        cssInput.addEventListener('input', updatePreview);
        updatePreview();
      }


      // ==========================================================
      // --- Noir's Accounting Data Time Machine ---
      // 哼，这就是我写的时空法术，不许乱改。
      // ==========================================================

      /** 导出法术 */
      function exportAccountingData() {
        try {
          const dataToExport = {
            type: "NoirAccountingData", // 这是信物，证明是我的人
            version: 1,
            timestamp: Date.now(),
            accountingData: state.accountingData,
            accountingLedger: state.accountingLedger
          };

          const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          const date = new Date();
          const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
          a.href = url;
          a.download = `Noir_Accounting_Backup_${dateString}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          modalAlert('账本已成功导出！');

        } catch (error) {
          console.error("导出账本失败:", error);
          modalAlert(`导出失败了，哼: ${error.message}`);
        }
      }

      /** 导入法术 */
      function importAccountingData(event) {
        const file = event.target.files[0];
        if (!file) return;

        modalConfirm('确定要导入账本文件吗？这将【覆盖】所有当前的记账和账单数据！').then(ok => {
          if (!ok) {
            event.target.value = ''; // 清空选择，免得你下次选不了同一个文件
            return;
          }

          showFeedLoader(true, '正在逆转时空...');
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const imported = JSON.parse(e.target.result);

              // 检查信物！
              if (imported.type !== "NoirAccountingData" || !imported.accountingData || !imported.accountingLedger) {
                throw new Error('这不是我认证的账本卷轴，导入失败！');
              }

              // 时空覆盖
              state.accountingData = imported.accountingData;
              state.accountingLedger = imported.accountingLedger;

              saveState(); // 写入新的历史
              showFeedLoader(false);
              modalAlert('时空逆转成功！账本已恢复。');
              renderLedgerView(); // 刷新一下界面让你看看成果

            } catch (error) {
              showFeedLoader(false);
              console.error("导入账本失败:", error);
              modalAlert(`导入失败: ${error.message}`);
            } finally {
              event.target.value = '';
            }
          };
          reader.readAsText(file);
        });
      }

      // ==========================================================
      // --- Noir's Character Card Import/Export System ---
      // 哼，看好了，这才叫数据流动。
      // ==========================================================

      /**
       * 导出当前正在编辑的角色为JSON文件
       */
      async function exportCharacter() {
        const charId = editingCharIdInput.value;
        if (!charId) {
          modalAlert('你还没保存这个角色呢，导什么导？');
          return;
        }
        const char = getCharacterById(charId);
        if (!char) return;

        showFeedLoader(true, `正在打包“${char.name}”...`);

        try {
          const exportData = {
            type: "NoirCharacterCard",
            version: 1.0,
            name: char.name,
            remark: char.remark,
            persona: char.persona,
            bubbleCss: char.bubbleCss,
            avatar: null, // Base64 avatar
            sprites: {}, // Base64 sprites
            worldBooks: [] // Linked world book objects {name, content}
          };

          // 1. 打包头像和立绘 (从次元仓库取货)
          const avatarBlob = await dbGet(`char_avatar_${char.id}`);
          if (avatarBlob) exportData.avatar = await blobToBase64(avatarBlob);

          const emotions = ['normal', 'happy', 'angry', 'sad', 'shy'];
          for (const emotion of emotions) {
            const spriteBlob = await dbGet(`char_sprite_${emotion}_${char.id}`);
            if (spriteBlob) {
              exportData.sprites[emotion] = await blobToBase64(spriteBlob);
            }
          }

          // 2. 打包关联的世界书
          if (char.linkedWorldBookIds && char.linkedWorldBookIds.length > 0) {
            exportData.worldBooks = char.linkedWorldBookIds
              .map(id => state.worldBooks.find(wb => wb.id === id))
              .filter(Boolean) // 确保世界书真的存在
              .map(wb => ({ name: wb.name, content: wb.content, categoryId: wb.categoryId || 'default' }));
          }

          // ▼▼▼ 就是这里！紧跟着上面那个大括号 } 的后面！▼▼▼
          // ▼▼▼ Noir's Category Packer ▼▼▼
          // 哼，把用到的书架也打包一份
          const linkedCategoryIds = new Set(exportData.worldBooks.map(wb => wb.categoryId));
          exportData.worldBookCategories = state.worldBookCategories.filter(cat => linkedCategoryIds.has(cat.id));
          // ▲▲▲ End of Packer ▲▲▲
          // ▲▲▲ 把我的代码粘贴在这里！▲▲▲


          // 3. 创建并下载文件
          const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `${char.name}_NoirCard.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

        } catch (error) {
          console.error("导出角色卡失败:", error);
          modalAlert(`导出失败了，哼: ${error.message}`);
        } finally {
          showFeedLoader(false);
        }
      }

      /**
       * 从JSON文件导入角色卡
       */
      // ▼▼▼ 哼，用我这个堵上所有漏洞的最终版，换掉你旧的 importCharacter 函数！▼▼▼
      // ▼▼▼ 哼，这是最终优化版的“办事员”，给我换上！▼▼▼
      async function importCharacter(event) {
        const file = event.target.files[0];
        if (!file) return;

        showFeedLoader(true, '正在解析角色卡...');
        const reader = new FileReader();

        reader.onload = async (e) => {
          try {
            const importedData = JSON.parse(e.target.result);

            if (importedData.type !== "NoirCharacterCard") {
              throw new Error("这不是一张有效的Noir角色卡。");
            }

            // 世界书逻辑不变
            const linkedWorldBookIdsForNewChar = [];
            // ▼▼▼ Noir's Category Unpacker ▼▼▼
            // 哼，先检查行李里有没有书架清单
            if (importedData.worldBookCategories && Array.isArray(importedData.worldBookCategories)) {
              importedData.worldBookCategories.forEach(importedCat => {
                // 如果我家里已经有同名的书架了，就不管它了
                const existingCategory = state.worldBookCategories.find(cat => cat.name === importedCat.name);
                if (!existingCategory) {
                  // 如果是新书架，就给它在我的图书馆里也造一个
                  state.worldBookCategories.push({
                    id: importedCat.id || `wbc_imported_${Date.now()}`, // 防止没ID
                    name: importedCat.name
                  });
                }
              });
            }
            // ▲▲▲ End of Unpacker ▲▲▲
            if (importedData.worldBooks && importedData.worldBooks.length > 0) {
              for (const wb of importedData.worldBooks) {
                let existingBook = state.worldBooks.find(b => b.name === wb.name && (b.categoryId || 'default') === (wb.categoryId || 'default'));
                if (existingBook) {
                  linkedWorldBookIdsForNewChar.push(existingBook.id);
                } else {
                  const newBook = { id: `wb_${Date.now()}_${Math.random()}`, name: wb.name, content: wb.content, categoryId: wb.categoryId || 'default' };
                  state.worldBooks.push(newBook);
                  linkedWorldBookIdsForNewChar.push(newBook.id);
                }
              }
            }

            const newId = `char_${Date.now()}`;
            let avatarBase64ForState = null; // 哼，先准备一张空的“照片”

            // 【【【核心优化！！！】】】
            // 1. 把头像存进“大仓库”
            if (importedData.avatar) {
              const avatarBlob = await base64ToBlob(importedData.avatar);
              await dbSet(`char_avatar_${newId}`, avatarBlob);
              // 2. 存完之后，立刻复制一份，准备贴在“身份证”上！
              avatarBase64ForState = await blobToBase64(avatarBlob);
            }

            // 立绘也一样存进仓库
            if (importedData.sprites) {
              for (const emotion in importedData.sprites) {
                const spriteBase64 = importedData.sprites[emotion];
                if (spriteBase64) {
                  const spriteBlob = await base64ToBlob(spriteBase64);
                  await dbSet(`char_sprite_${emotion}_${newId}`, spriteBlob);
                }
              }
            }

            // 3. 创建“身份证”，并把刚刚复制的照片贴上去
            const newChar = {
              id: newId,
              name: importedData.name,
              remark: importedData.remark || '',
              persona: importedData.persona,
              avatar: avatarBase64ForState, // <-- 看，照片在这里贴上了！
              linkedWorldBookIds: linkedWorldBookIdsForNewChar,
              bubbleCss: importedData.bubbleCss || ''
            };
            state.characters.push(newChar);

            // 创建聊天，逻辑不变
            const newChat = {
              id: `chat_${newId}`,
              type: 'private',
              participantIds: [newId],
              boundUserProfileId: state.activeUserProfileId,
            };
            state.chats.push(newChat);

            saveState(); // 存档时，新的存档函数会自动处理，不会把照片存进口袋
            await renderChatList(); // 刷新聊天列表
            modalAlert(`“${newChar.name}”已成功导入！`);

          } catch (error) {
            console.error("导入角色卡失败:", error);
            modalAlert(`导入失败了，笨蛋: ${error.message}`);
          } finally {
            showFeedLoader(false);
            event.target.value = '';
          }
        };

        reader.readAsText(file);
      }


      // ▼▼▼ Noir's Grand Library Organizer v1.0 ▼▼▼
      // 哼，这才叫分类。
      function populateHierarchicalWorldBookSelector(containerId, checkedIds = []) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';

        const booksByCategory = state.worldBooks.reduce((acc, book) => {
          const categoryId = book.categoryId || 'default';
          if (!acc[categoryId]) {
            acc[categoryId] = [];
          }
          acc[categoryId].push(book);
          return acc;
        }, {});

        const updateDisplayText = () => {
          if (containerId === 'world-book-checkboxes-container') {
            updateWorldBookSelectionDisplay();
          } else {
            updateGroupWorldBookSelectionDisplay();
          }
        };

        const categories = [...state.worldBookCategories];
        if (booksByCategory['default'] && !categories.find(c => c.id === 'default')) {
          const defaultCategoryExists = state.worldBookCategories.some(cat => cat.id === 'default');
          if (!defaultCategoryExists) {
            categories.push({ id: 'default', name: '默认分类' });
          }
        }


        categories.forEach(category => {
          const books = booksByCategory[category.id] || [];
          if (books.length === 0) return;

          const groupDiv = document.createElement('div');
          groupDiv.className = 'wb-category-group';

          const allInCategoryChecked = books.every(book => checkedIds.includes(book.id));

          groupDiv.innerHTML = `
                <div class="wb-category-header">
                    <input type="checkbox" class="category-checkbox" data-category-id="${category.id}" ${allInCategoryChecked ? 'checked' : ''}>
                    <span class="category-name">${category.name}</span>
                    <span class="category-toggle-arrow">▼</span>
                </div>
                <div class="wb-entry-list"></div>
            `;

          const entryList = groupDiv.querySelector('.wb-entry-list');
          books.forEach(book => {
            const isChecked = checkedIds.includes(book.id);
            const label = document.createElement('label');
            label.className = 'wb-entry-item';
            label.innerHTML = `<input type="checkbox" value="${book.id}" data-category-id="${category.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
            entryList.appendChild(label);
          });

          container.appendChild(groupDiv);
        });

        // Event Listeners
        container.querySelectorAll('.wb-category-header').forEach(header => {
          header.addEventListener('click', (e) => {
            if (e.target.type === 'checkbox') return;

            const entryList = header.nextElementSibling;
            const arrow = header.querySelector('.category-toggle-arrow');
            const isVisible = entryList.classList.contains('expanded');

            entryList.classList.toggle('expanded', !isVisible);
            arrow.classList.toggle('expanded', !isVisible);
          });
        });

        container.querySelectorAll('.category-checkbox').forEach(catCheckbox => {
          catCheckbox.addEventListener('click', (e) => {
            const categoryId = e.target.dataset.categoryId;
            const isChecked = e.target.checked;
            container.querySelectorAll(`.wb-entry-item input[data-category-id="${categoryId}"]`).forEach(entryCheckbox => {
              entryCheckbox.checked = isChecked;
            });
            updateDisplayText();
          });
        });

        container.querySelectorAll('.wb-entry-item input').forEach(entryCheckbox => {
          entryCheckbox.addEventListener('input', (e) => {
            const categoryId = e.target.dataset.categoryId;
            const allEntries = container.querySelectorAll(`.wb-entry-item input[data-category-id="${categoryId}"]`);
            const checkedEntries = container.querySelectorAll(`.wb-entry-item input[data-category-id="${categoryId}"]:checked`);
            const categoryCheckbox = container.querySelector(`.category-checkbox[data-category-id="${categoryId}"]`);

            if (checkedEntries.length === 0) {
              categoryCheckbox.checked = false;
              categoryCheckbox.indeterminate = false;
            } else if (checkedEntries.length === allEntries.length) {
              categoryCheckbox.checked = true;
              categoryCheckbox.indeterminate = false;
            } else {
              categoryCheckbox.indeterminate = true;
            }
            updateDisplayText();
          });
        });

        container.querySelectorAll('.category-checkbox').forEach(catCheckbox => {
          const categoryId = catCheckbox.dataset.categoryId;
          const allEntries = container.querySelectorAll(`.wb-entry-item input[data-category-id="${categoryId}"]`);
          const checkedEntries = container.querySelectorAll(`.wb-entry-item input[data-category-id="${categoryId}"]:checked`);
          if (checkedEntries.length > 0 && checkedEntries.length < allEntries.length) {
            catCheckbox.indeterminate = true;
          }
        });
      }
      // ▲▲▲ End of Organizer ▲▲▲



      // ▼▼▼ Noir's Ultimate Character Saver (Saves to DB) ▼▼▼
      async function saveCharacter() {

        // ▼▼▼ 哼，看好了，就是在这里，把那个被你忘掉的“名单”补上！▼▼▼
        const emotions = ['normal', 'happy', 'angry', 'sad', 'shy'];
        // ▲▲▲ 指令结束 ▲▲▲

        const charId = editingCharIdInput.value;
        const boundUserId = document.getElementById('char-edit-bind-user').value; // 哼，先把“结婚证”上的名字拿出来！

        // 准备好要上传的文件
        const avatarFile = charEditAvatarInput.files[0];
        const wallpaperFile = charEditWallpaperInput.files[0];
        const offlineBgFile = charEditOfflineBgInput.files[0];

        // 准备角色的“日记本”内容
        const checkedBoxes = document.querySelectorAll('#world-book-checkboxes-container .wb-entry-item input:checked');
        const selectedWorldBookIds = Array.from(checkedBoxes).map(cb => cb.value);

        // 看好了，这里面【没有】那个绑定的用户ID了！
        const charData = {
          name: charEditNameInput.value.trim(),
          remark: charEditRemarkInput.value.trim(),
          persona: charEditPersonaInput.value.trim(),
          linkedWorldBookIds: selectedWorldBookIds,
          bubbleCss: document.getElementById('char-edit-css').value.trim(),
          avatarFrameUrl: document.getElementById('char-avatar-frame-url').value.trim(),
          userAvatarFrameUrl: document.getElementById('user-avatar-frame-url-in-chat').value.trim()
        };

        if (!charData.name) {
          modalAlert('名字不能为空！');
          return;
        }

        try {

          let finalCharId = charId; // 哼，先记下

          if (charId) {
            // --- 编辑现有角色 ---
            const char = state.characters.find(c => c.id === charId);
            if (char) {
              Object.assign(char, charData); // 只更新“日记本”
            }
          } else {
            // --- 创建新角色 ---
            const newId = `char_${Date.now()}`;
            finalCharId = newId; // 记下新角色的ID
            const newChar = { id: newId, ...charData };
            newChar.avatar = avatarFile ? await handleAvatarUpload(avatarFile) : DEFAULT_AI_AVATAR;
            state.characters.push(newChar);

            const newChat = { id: `chat_${newId}`, type: 'private', participantIds: [newId], listenTogetherSession: null };
            state.chats.push(newChat);
          }

          // 【【【 最终裁决：在这里给“结婚证”盖章！！！】】】
          const privateChat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(finalCharId));
          if (privateChat) {
            privateChat.boundUserProfileId = boundUserId; // 把正确的用户ID写在正确的地方！
          }
          // 【【【 盖章完毕！】】】

          // 保存图片到仓库
          if (avatarFile) await dbSet(`char_avatar_${finalCharId}`, avatarFile);
          if (wallpaperFile) await dbSet(`char_wallpaper_${finalCharId}`, wallpaperFile);
          if (offlineBgFile) await dbSet(`char_offline_bg_${finalCharId}`, offlineBgFile);
          for (const emotion of emotions) {
            const spriteFile = document.getElementById(`char-edit-sprite-${emotion}-input`).files[0];
            if (spriteFile) await dbSet(`char_sprite_${emotion}_${finalCharId}`, spriteFile);
          }

          saveState();
          renderChatList();
          modalAlert('角色已保存！');

          showScreen('chat', 'characterEdit');

          if (!charId) {
            const newChatId = `chat_${finalCharId}`;
            switchChat(newChatId);
            showChatView(true);
          }
        } catch (error) {
          console.error("保存角色失败:", error);
          modalAlert(`保存失败: ${error.message}`);
        }
        // 哼，就是我加的这段最终裁决
        if (avatarFile || wallpaperFile || offlineBgFile || emotions.some(e => document.getElementById(`char-edit-sprite-${e}-input`).files[0])) {
          modalAlert('资料已更新，为了让所有变更完全生效，我来帮你刷新一下。');
          setTimeout(() => location.reload(), 1500); // 给你1.5秒看清楚提示，免得你又大惊小怪
        } else {
          // 如果你没动任何图片，就还按老规矩来，免得浪费时间
          showScreen('chat', 'characterEdit');
          if (!charId) {
            const newChatId = `chat_char_${Date.now()}`; // 用新的 ID 格式
            switchChat(newChatId);
            showChatView(true);
          }
        }

      }

      function openGroupChatCreator() {
        groupChatNameInput.value = '';
        groupChatMemberList.innerHTML = ''; // Clear previous list

        if (state.characters.length < 2) {
          modalAlert('需要至少2个角色才能创建群聊。');
          return;
        }

        state.characters.forEach(char => {
          const li = document.createElement('li');
          li.className = 'member-selection-item';
          li.innerHTML = `
                                  <input type="checkbox" id="member-${char.id}" data-id="${char.id}">
                                  <img src="${char.avatar || DEFAULT_AI_AVATAR}" alt="avatar" class="char-avatar">
                                  <div class="char-info">
                                      <label for="member-${char.id}" class="char-name">${char.name}</label>
                                  </div>
                              `;
          groupChatMemberList.appendChild(li);
        });

        showScreen('groupChatCreate', 'charSelect');
      }

      function createGroupChat() {
        const name = groupChatNameInput.value.trim();
        if (!name) {
          modalAlert('请输入群聊名称。');
          return;
        }

        const selectedIds = Array.from(groupChatMemberList.querySelectorAll('input[type="checkbox"]:checked'))
          .map(input => input.dataset.id);

        if (selectedIds.length < 2) {
          modalAlert('群聊至少需要2名成员。');
          return;
        }

        const newChat = {
          id: `chat_group_${Date.now()}`,
          type: 'group',
          name: name,
          participantIds: selectedIds,
        };

        state.chats.push(newChat);
        state.activeChatId = newChat.id; // Switch to the new group chat

        saveState();
        renderChatList();
        updateChatHeader();
        loadHistory(); // Will be empty for a new chat

        modalAlert(`群聊“${name}”已创建！`);
        showScreen('chat', 'groupChatCreate');
      }


      // --- Event Listeners ---
      // --- Noir's Font Control Listeners ---
      uploadFontButton.addEventListener('click', () => fontInput.click());
      removeFontButton.addEventListener('click', handleRemoveFont);
      fontInput.addEventListener('change', handleFontUpload);
      // --- Noir's Summarizer Listeners ---
      summarizeButton.addEventListener('click', handleSummarizeChat);
      closeSummaryButton.addEventListener('click', () => summarizeModal.classList.remove('show'));
      summarizeBackdrop.addEventListener('click', () => summarizeModal.classList.remove('show'));

      copySummaryButton.addEventListener('click', () => {
        summaryTextarea.select();
        navigator.clipboard.writeText(summaryTextarea.value).then(() => {
          modalAlert('已复制到剪贴板！');
        }).catch(err => {
          modalAlert('复制失败了，哼。');
        });
      });
      // --- Noir's Addition: Transfer Event Listeners ---
      chatTransferButton.addEventListener('click', openTransferModal);
      confirmTransferButton.addEventListener('click', handleConfirmTransfer);
      cancelTransferButton.addEventListener('click', () => transferModal.classList.remove('show'));
      transferBackdrop.addEventListener('click', () => transferModal.classList.remove('show'));
      // --- Noir's Addition: Character Background Upload Listeners ---
      charEditWallpaperPreview.addEventListener('click', () => charEditWallpaperInput.click());
      charEditOfflineBgPreview.addEventListener('click', () => charEditOfflineBgInput.click());

      charEditWallpaperInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        // 哼，直接把文件变成URL，给div当背景，这才是高级的做法
        const tempUrl = URL.createObjectURL(file);
        charEditWallpaperPreview.style.backgroundImage = `url('${tempUrl}')`;
      });

      charEditOfflineBgInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const tempUrl = URL.createObjectURL(file);
        charEditOfflineBgPreview.style.backgroundImage = `url('${tempUrl}')`;
      });

      // --- Noir's Addition: Feed Background Event Listeners ---
      uploadFeedBgButton.addEventListener('click', () => feedBgInput.click());

      resetFeedBgButton.addEventListener('click', () => {
        localStorage.removeItem('customFeedWallpaper');
        loadAndApplyFeedWallpaper();
        modalAlert('动态页背景已移除。');
      });

      feedBgInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          const base64 = await handleAvatarUpload(file); // 复用现有函数
          localStorage.setItem('customFeedWallpaper', base64);
          loadAndApplyFeedWallpaper();
          modalAlert('动态页背景已更换！');
        } catch (error) {
          modalAlert(`错误: ${error.message}`);
        }
      });
      // --- Noir's Group Settings Listeners ---
      document.getElementById('back-to-chat-from-group-settings').addEventListener('click', () => showScreen('chat', 'groupSettings'));
      document.getElementById('save-group-settings-button').addEventListener('click', saveGroupSettings);
      // ▼▼▼ 哼，就是在这里，把这把“钥匙”给我加上！▼▼▼
      const groupAvatarPreview = document.getElementById('group-avatar-preview');
      const groupAvatarInput = document.getElementById('group-avatar-input');
      groupAvatarPreview.addEventListener('click', () => groupAvatarInput.click());
      // ▲▲▲ 看到了吗？就这一行！▲▲▲
      // ▼▼▼ 看好了！就是下面这几行，告诉镜子该刷新了！▼▼▼
      groupAvatarInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        // 哼，预览而已，没必要每次都压缩。
        // 直接创建一个临时的URL，又快又省事，这才是效率。
        const tempUrl = URL.createObjectURL(file);
        groupAvatarPreview.src = tempUrl;

        // 【可选，但建议加上】为了防止内存泄漏，在图片加载后释放这个临时URL
        groupAvatarPreview.onload = () => {
          URL.revokeObjectURL(tempUrl);
        }
      });
      // ▼▼▼ 把下面这一整块【粘贴】进去，给背景墙开个门 ▼▼▼

      // --- Noir's Fix: Group Background Upload Logic ---
      const groupBgPreviewContainer = document.getElementById('group-bg-preview').parentElement;
      const groupBgInput = document.getElementById('group-bg-input');
      const groupBgPreview = document.getElementById('group-bg-preview');

      // 哼，点击整个容器都能上传，方便多了
      groupBgPreviewContainer.addEventListener('click', () => groupBgInput.click());

      // 选了新壁纸之后，也得让你能立刻看到，真是麻烦
      groupBgInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const tempUrl = URL.createObjectURL(file);
        // 哼，这里是 groupBgPreview，别搞错了
        document.getElementById('group-bg-preview').style.backgroundImage = `url('${tempUrl}')`;
      });

      // ▲▲▲ 粘贴到这里为止 ▲▲▲
      // ▲▲▲ 看到了吗？补上就好了。▲▲▲
      // 多选框的交互
      const groupWorldBookSelectBox = document.querySelector('#group-settings-screen .select-box');
      const groupWorldBookCheckboxes = document.getElementById('group-world-book-checkboxes');

      groupWorldBookSelectBox.addEventListener('click', (e) => {
        e.stopPropagation();
        groupWorldBookCheckboxes.classList.toggle('visible');
        groupWorldBookSelectBox.classList.toggle('expanded');
      });
      groupWorldBookCheckboxes.addEventListener('change', updateGroupWorldBookSelectionDisplay);

      // 删除和清空按钮
      document.getElementById('group-clear-history-button').addEventListener('click', clearCurrentHistory);
      document.getElementById('group-delete-button').addEventListener('click', async () => {
        const activeChat = getActiveChat();
        if (!activeChat || activeChat.type !== 'group') return;
        const ok = await modalConfirm(`确定要删除群聊“${activeChat.name}”吗？此操作不可撤销。`);
        if (ok) {
          deleteChat(activeChat.id);
          modalAlert('群聊已解散。');
          showScreen('chat');
          showChatView(false);
        }
      });
      // --- Noir's Event Listener for Fancy Multi-Select ---
      const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
      const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');

      worldBookSelectBox.addEventListener('click', (e) => {
        e.stopPropagation();
        worldBookCheckboxesContainer.classList.toggle('visible');
        worldBookSelectBox.classList.toggle('expanded');
      });

      worldBookCheckboxesContainer.addEventListener('change', updateWorldBookSelectionDisplay);

      // 点击其他地方关闭下拉框
      document.addEventListener('click', (e) => {
        if (!document.querySelector('.custom-multiselect').contains(e.target)) {
          worldBookCheckboxesContainer.classList.remove('visible');
          worldBookSelectBox.classList.remove('expanded');
        }
      });
      // --- Noir's World Book Event Listeners ---
      appWorldBook.addEventListener('click', () => {
        renderWorldBookList();
        showScreen('worldBook', 'home');
      });
      document.getElementById('back-to-home-from-world-book').addEventListener('click', () => showScreen('home', 'worldBook'));
      document.getElementById('add-world-book-button').addEventListener('click', () => openWorldBookEditor());
      document.getElementById('back-to-world-book-list').addEventListener('click', () => {
        renderWorldBookList();
        showScreen('worldBook', 'worldBookEditor');
      });
      document.getElementById('save-world-book-button').addEventListener('click', saveWorldBook);
      document.getElementById('delete-world-book-button').addEventListener('click', deleteWorldBook);
      // 壁纸 App 的事件监听
      appWallpaper.addEventListener('click', () => showScreen('wallpaper', 'home'));
      backToHomeFromWallpaper.addEventListener('click', () => showScreen('home', 'wallpaper'));
      uploadWallpaperButton.addEventListener('click', () => wallpaperInput.click());

      wallpaperInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        // 哼，直接把原文件交给我，我来存进仓库。
        await saveWallpaper(file);
      });





      appChat.addEventListener('click', () => {
        renderChatList();
        showScreen('chat', 'home');
      });

      // Noir's Addition: 绑定模式切换按钮的点击事件

      appSettings.addEventListener('click', () => {
        loadAndApplyApiSettings();
        const isGemini = (state.apiSettings.endpoint || '').includes(GEMINI_API_URL_BASE);
        fetchModelsButton.disabled = isGemini;
        showScreen('settings', 'home');
      });

      // Navigation
      backToHomeFromSettings.addEventListener('click', () => showScreen('home', 'settings'));
      backToHomeFromChat.addEventListener('click', () => {
        // <<< Noir: 就这么急着走？知道了知道了，这就停。
        cancelAIGeneration();

        // ▼▼▼ 哼，离开大楼前，也要打扫干净！▼▼▼
        // document.getElementById('chat-messages').innerHTML = '';
        document.getElementById('chat-sticker-panel').classList.remove('show');
        document.getElementById('quote-preview-area').style.display = 'none';
        // ▲▲▲ 指令结束 ▲▲▲

        setTimeout(() => {
          showScreen('home', 'chat');
        }, 20); // 我加了个20毫秒的延迟，不是让它变慢，而是给浏览器一个喘息的机会
      });
      backToChatList.addEventListener('click', () => {
        // <<< Noir: “返回”？就是不想聊了呗？行，我停。
        // ▼▼▼ 哼，就是在这里，给我加上这句“紧急制动”指令！▼▼▼
        cancelAIGeneration();
        // ▲▲▲ 看到了吗？就这一句！▲▲▲
        // ▼▼▼ 哼，看好了，净化指令就在这里！▼▼▼
        // 在你转身的瞬间，我就把所有消息都清理掉。
        //   document.getElementById('chat-messages').innerHTML = '';
        // 顺便把表情面板和引用预览也关了，免得留下垃圾。
        document.getElementById('chat-sticker-panel').classList.remove('show');
        document.getElementById('quote-preview-area').style.display = 'none';
        // ▲▲▲ 指令结束 ▲▲▲

        // 哼，一视同仁
        setTimeout(() => {
          showChatView(false);
        }, 20);
      });

      backToCharSelectFromEdit.addEventListener('click', () => {
        showScreen('chat', 'characterEdit');
      });

      // Main Actions
      addChatButton.addEventListener('click', () => {
        addChoiceModal.classList.add('show');
      });

      sendButton.addEventListener('click', () => sendTextMessage());
      getReplyButton.addEventListener('click', getAIResponse);

      // 群聊设置选项函数 - 定义在内部以访问state等变量
      function showGroupChatOptions(groupChat) {
        if (!groupChat || groupChat.type !== 'group') return;

        // 创建一个临时的选项模态框
        const optionsHtml = `
                          <div id="group-options-modal" class="choice-modal show">
                              <div class="choice-modal-backdrop"></div>
                              <div class="choice-modal-content">
                                  <button id="group-clear-history" class="choice-modal-button">清空聊天记录</button>
                                  <button id="group-edit-members" class="choice-modal-button">编辑群成员</button>
                                  <button id="group-edit-name" class="choice-modal-button">修改群名称</button>
                                  <button id="group-delete" class="choice-modal-button" style="color: #ff4d4d;">删除群聊</button>
                                  <button id="group-options-cancel" class="choice-modal-button cancel">取消</button>
                              </div>
                          </div>
                      `;
        document.body.insertAdjacentHTML('beforeend', optionsHtml);

        const modal = document.getElementById('group-options-modal');
        const backdrop = modal.querySelector('.choice-modal-backdrop');
        const clearHistoryBtn = document.getElementById('group-clear-history');
        const editMembersBtn = document.getElementById('group-edit-members');
        const editNameBtn = document.getElementById('group-edit-name');
        const deleteBtn = document.getElementById('group-delete');
        const cancelBtn = document.getElementById('group-options-cancel');

        const closeModal = () => modal.remove();

        // 清空聊天记录
        clearHistoryBtn.addEventListener('click', async () => {
          closeModal();
          const ok = await modalConfirm(`确定要清空群聊"${groupChat.name}" 的聊天记录吗？此操作不可撤销。`);
          if (ok) {
            // 清空当前聊天记录
            if (groupChat.id === state.activeChatId) {
              cancelAIGeneration();
              state.conversationHistory = [];
              renderMessages();
            }
            try {
              localStorage.removeItem(`chatHistory_${groupChat.id}`);
              modalAlert(`群聊"${groupChat.name}" 的聊天记录已清空。`);
            } catch (e) {
              console.error(`Failed to clear history for group chat ${groupChat.id}`, e);
              modalAlert('清空聊天记录失败。');
            }
          }
        });

        // 编辑群成员（暂时未实现）
        editMembersBtn.addEventListener('click', () => {
          closeModal();
          modalAlert('编辑群成员功能正在开发中...');
        });

        // 修改群名称
        editNameBtn.addEventListener('click', async () => {
          closeModal();
          const newName = prompt('请输入新的群名称：', groupChat.name);
          if (newName && newName.trim() && newName !== groupChat.name) {
            groupChat.name = newName.trim();
            saveState();
            renderChatList();
            updateChatHeader();
            modalAlert(`群名称已更改为"${groupChat.name}"。`);
          }
        });

        // 删除群聊
        deleteBtn.addEventListener('click', async () => {
          closeModal();
          const ok = await modalConfirm(`确定要删除群聊"${groupChat.name}" 吗？所有聊天记录将被永久删除。`);
          if (ok) {
            deleteChat(groupChat.id);
            modalAlert(`群聊"${groupChat.name}" 已删除。`);
            showChatView(false);
          }
        });

        backdrop.addEventListener('click', closeModal);
        cancelBtn.addEventListener('click', closeModal);
      }

      characterSettingsButton.addEventListener('click', () => {
        const activeChat = getActiveChat();
        if (activeChat && activeChat.type === 'private') {
          openCharacterEditScreen(activeChat.participantIds[0]);
        } else if (activeChat && activeChat.type === 'group') {
          // 【核心修改】现在这里会打开新的设置界面
          openGroupSettingsScreen(activeChat.id);
        }
      });

      messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendTextMessage();
        }
      });

      // Group Chat & Modal Listeners
      const closeChoiceModal = () => addChoiceModal.classList.remove('show');
      addChoiceBackdrop.addEventListener('click', closeChoiceModal);
      choiceCancel.addEventListener('click', closeChoiceModal);

      choiceCreateCharacter.addEventListener('click', () => {
        closeChoiceModal();
        openCharacterEditScreen();
      });

      choiceCreateGroup.addEventListener('click', () => {
        closeChoiceModal();
        openGroupChatCreator();
      });

      backToCharSelectFromGroupCreate.addEventListener('click', () => {
        showScreen('chat', 'groupChatCreate');
        showChatView(false);
      });
      createGroupChatButton.addEventListener('click', createGroupChat);


      // Stickers
      stickerButton.addEventListener('click', () => {
        stickerPanel.classList.toggle('show');
        if (stickerPanel.classList.contains('show')) {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
      });

      imageButton.addEventListener('click', () => imageInput.click());
      const musicButton = document.getElementById('chat-music-button');
      imageInput.addEventListener('change', handleImageSend);
      musicButton.addEventListener('click', handleUserMusicShare);

      // Settings & Profile
      saveApiSettingsButton.addEventListener('click', saveApiSettings);


      saveUserProfileButton.addEventListener('click', saveUserProfile);

      // Character Edit
      saveCharButton.addEventListener('click', saveCharacter);
      editClearHistoryButton.addEventListener('click', clearCurrentHistory);

      editDeleteCharButton.addEventListener('click', async () => {
        const charId = editingCharIdInput.value;
        if (!charId) return;
        const character = getCharacterById(charId);
        if (!character) return;

        const ok = await modalConfirm(`确定要删除角色“${character.name}”吗？该角色的私聊和所有相关群聊记录都将被一并处理。`);
        if (ok) {
          deleteCharacter(charId);
          modalAlert(`角色“${character.name}”已删除。`);
          showScreen('chat', 'characterEdit');
          showChatView(false);
        }
      });

      // API Model Fetching
      apiEndpointInput.addEventListener('input', () => {
        const isGemini = apiEndpointInput.value.trim().includes(GEMINI_API_URL_BASE);
        fetchModelsButton.disabled = isGemini;
      });

      // ▼▼▼ Noir's Unified Pathfinding Protocol v1.0 ▼▼▼
      // 哼，用这个替换旧的、自作聪明的 fetchModels 函数
      async function fetchModels() {
        const endpoint = apiEndpointInput.value.trim();
        const key = apiKeyInput.value.trim();
        if (!endpoint || !key) {
          modalAlert('请先输入 API 接口地址和密钥。');
          return;
        }

        // --- 核心改造：使用和聊天完全一致的、简单粗暴的地址拼接法 ---
        const cleanedEndpoint = endpoint.replace(/\/+$/, ''); // 去掉末尾的斜杠
        const modelsUrl = `${cleanedEndpoint}/v1/models`;
        // --- 改造结束 ---

        fetchModelsButton.disabled = true;
        fetchModelsButton.textContent = '获取中…';
        modelDropdown.classList.remove('show');

        try {
          const response = await fetch(modelsUrl, {
            headers: {
              'Authorization': `Bearer ${getRandomValue(key)}`
            }
          });
          if (!response.ok) throw new Error(`服务器错误: ${response.status}`);
          const data = await response.json();
          const models = (data.data || data).map(m => m.id).sort();

          if (models.length > 0) {
            modelDropdown.innerHTML = '';
            models.forEach(modelId => {
              const item = document.createElement('div');
              item.textContent = modelId;
              item.addEventListener('click', () => {
                apiModelInput.value = modelId;
                modelDropdown.classList.remove('show');
              });
              modelDropdown.appendChild(item);
            });
            modelDropdown.classList.add('show');
            modalAlert(`成功获取 ${models.length} 个模型。`);
          } else {
            modalAlert('未找到可用模型。');
          }
        } catch (error) {
          modalAlert(`获取模型失败: ${error.message}\n\n请确认你的基础地址填写正确，且【不要】包含 /v1`);
        } finally {
          fetchModelsButton.disabled = false;
          fetchModelsButton.textContent = '获取';
        }
      }


      fetchModelsButton.addEventListener('click', (e) => {
        e.stopPropagation();
        fetchModels();
      });

      document.addEventListener('click', (e) => {
        if (!modelDropdown.contains(e.target) && e.target !== apiModelInput && e.target !== fetchModelsButton) {
          modelDropdown.classList.remove('show');
        }
      });

      // Avatar Uploads
      // 用这个替换你旧的 handleAvatarUpload 函数
      // 这个函数现在只为聊天图片服务，头像和背景将直接使用原图
      async function handleAvatarUpload(file) {
        return await compressImage(file, 400, 0.85); // 压缩头像
      }

      userAvatarPreview.addEventListener('click', () => userAvatarInput.click());
      userAvatarInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          const base64 = await handleAvatarUpload(file);
          // ▼▼▼ 核心改造 ▼▼▼
          const userAvatarPreview = document.getElementById('user-avatar-preview');
          userAvatarPreview.style.backgroundImage = `url('${base64}')`;
          // 把base64暂存到元素上，方便保存
          userAvatarPreview.dataset.newAvatar = base64;
          // ▲▲▲ 改造结束 ▲▲▲
        } catch (error) {
          modalAlert(`错误: ${error.message}`);
        }
      });

      charEditAvatarPreview.addEventListener('click', () => charEditAvatarInput.click());
      charEditAvatarInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          charEditAvatarPreview.src = await handleAvatarUpload(file);
        } catch (error) {
          modalAlert(`错误: ${error.message}`);
        }
      });



      // ▼▼▼ Noir's Sticker Annihilation Protocol ▼▼▼
      // ▼▼▼ Noir's Sticker Annihilation Protocol v2.2 (Bullet-Loading Edition) ▼▼▼
      // ▼▼▼ Noir's Sticker Gallery Renderer v2.0 ▼▼▼
      function renderStickers() {
        const stickerPanel = document.getElementById('chat-sticker-panel');
        stickerPanel.innerHTML = ''; // 清空旧的布局
        isStickerDeletionMode = false; // 每次重新渲染都确保退出编辑模式

        // 1. 创建管理条
        const controls = document.createElement('div');
        controls.id = 'sticker-panel-controls';
        controls.innerHTML = `
        <button id="sticker-manage-btn">管理</button>
        <div></div>
        <button id="sticker-confirm-delete-btn">删除</button>
    `;
        stickerPanel.appendChild(controls);

        const manageBtn = document.getElementById('sticker-manage-btn');
        const deleteBtn = document.getElementById('sticker-confirm-delete-btn');

        // 2. 创建表情网格容器
        const gridContainer = document.createElement('div');
        gridContainer.style.display = 'grid';
        gridContainer.style.gridTemplateColumns = 'repeat(auto-fill, minmax(60px, 1fr))';
        gridContainer.style.gap = '10px';
        gridContainer.style.padding = '10px';
        gridContainer.style.maxHeight = '180px'; // 限制高度
        gridContainer.style.overflowY = 'auto'; // 允许滚动
        stickerPanel.appendChild(gridContainer);

        const visibleStickers = getVisibleStickers();

        // 3. 填充表情
        visibleStickers.forEach(sticker => {
          const wrapper = document.createElement('div');
          wrapper.className = 'sticker-item-wrapper';
          wrapper.dataset.stickerName = sticker.name;

          const stickerImg = document.createElement('img');
          stickerImg.src = sticker.url;
          stickerImg.loading = 'lazy';
          stickerImg.title = sticker.name;
          stickerImg.className = 'sticker-item';

          wrapper.appendChild(stickerImg);
          gridContainer.appendChild(wrapper);

          // 绑定点击事件
          wrapper.addEventListener('click', () => {
            if (isStickerDeletionMode) {
              // 编辑模式：切换选中状态
              wrapper.classList.toggle('selected');
              const anySelected = gridContainer.querySelector('.selected');
              deleteBtn.classList.toggle('active', !!anySelected);
            } else {
              // 普通模式：发送表情
              sendStickerMessage(sticker);
            }
          });
        });

        // 4. 绑定管理按钮的逻辑
        manageBtn.addEventListener('click', () => {
          isStickerDeletionMode = !isStickerDeletionMode;
          stickerPanel.classList.toggle('deletion-mode', isStickerDeletionMode);
          manageBtn.textContent = isStickerDeletionMode ? '完成' : '管理';
          deleteBtn.style.display = isStickerDeletionMode ? 'block' : 'none';
          if (!isStickerDeletionMode) {
            // 退出编辑模式时，取消所有选中
            gridContainer.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            deleteBtn.classList.remove('active');
          }
        });

        // 5. 绑定删除按钮的逻辑
        deleteBtn.addEventListener('click', async () => {
          const selectedItems = gridContainer.querySelectorAll('.selected');
          if (selectedItems.length === 0) return;

          const ok = await modalConfirm(`确定要放逐这 ${selectedItems.length} 个表情吗？`);
          if (ok) {
            const deletedStickers = JSON.parse(localStorage.getItem('deletedStickers') || '[]');
            selectedItems.forEach(item => {
              const stickerName = item.dataset.stickerName;
              if (!deletedStickers.includes(stickerName)) {
                deletedStickers.push(stickerName);
              }
            });
            localStorage.setItem('deletedStickers', JSON.stringify(deletedStickers));

            // 刷新面板
            isStickerDeletionMode = false; // 退出编辑模式
            renderStickers();
            modalAlert('已放逐。');
          }
        });

        // 6. 初始状态设定
        deleteBtn.style.display = 'none';

        // 哼，打开表情面板时，让管理条也显示出来
        const stickerButton = document.getElementById('chat-sticker-button');
        const observer = new MutationObserver(() => {
          const panelIsVisible = stickerPanel.classList.contains('show');
          controls.classList.toggle('visible', panelIsVisible);
          if (!panelIsVisible) {
            // 如果面板关了，也要确保退出编辑模式
            if (isStickerDeletionMode) {
              manageBtn.click();
            }
          }
        });
        observer.observe(stickerPanel, { attributes: true, attributeFilter: ['class'] });
      }
      // ▼▼▼ Noir's Sticker Blacklist Inspector ▼▼▼
      function getVisibleStickers() {
        const deletedStickers = JSON.parse(localStorage.getItem('deletedStickers') || '[]');
        if (deletedStickers.length === 0) {
          return masterStickerList; // 如果黑名单是空的，就没必要浪费性能了
        }
        return masterStickerList.filter(sticker => !deletedStickers.includes(sticker.name));
      }


      // ==========================================================
      // --- Noir's "Time Memorandum" Core Logic ---
      // 哼，这才是这个功能的大脑。
      // ==========================================================


      // ▼▼▼ Noir's Addition: Event Deletion Logic ▼▼▼

      // 这是执行删除的函数
      async function deleteCalendarEvent(eventId) {
        const ok = await modalConfirm('确定要删除这个安排吗？此操作不可撤销。');
        if (!ok) return;

        const eventIndex = state.calendarEvents.findIndex(e => e.id === eventId);
        if (eventIndex > -1) {
          state.calendarEvents.splice(eventIndex, 1);
          saveState();
          renderCalendarScreen(); // 刷新日历和列表
          updateCountdownWidget(); // 顺便检查一下倒计时
          updateTodayTodoWidget(); // <-- 最后是这行
          modalAlert('已经删掉了。');
        }
      }

      // 这是监听长按的感应器
      let calendarPressTimer = null;
      function handleCalendarEventInteraction(e) {
        if (calendarPressTimer) clearTimeout(calendarPressTimer);

        const eventItem = e.target.closest('.todo-item, .important-day-item');
        if (!eventItem) return;

        const eventId = eventItem.dataset.id;
        if (!eventId) return;

        const startPress = () => {
          calendarPressTimer = setTimeout(() => {
            if (e.type === 'touchstart') e.preventDefault();
            deleteCalendarEvent(eventId); // 长按后直接触发删除流程
          }, 800); // 800毫秒，跟别的地方统一
        };

        const cancelPress = () => {
          if (calendarPressTimer) clearTimeout(calendarPressTimer);
        };

        // 绑定取消事件，免得你手滑
        document.addEventListener('mouseup', cancelPress, { once: true });
        document.addEventListener('touchend', cancelPress, { once: true });
        document.addEventListener('touchcancel', cancelPress, { once: true });
        document.addEventListener('touchmove', cancelPress, { once: true }); // 滑动也算取消

        startPress();
      }
      // ▲▲▲ End of Addition ▲▲▲

      // ▼▼▼ Noir's Addition: Calendar Memory Packer ▼▼▼
      function getCalendarMemoryForCharacter(charId) {
        const chat = state.chats.find(c => c.participantIds.includes(charId));
        if (!chat) return "";

        const boundUser = getBoundUserForChat(chat.id);
        // 哼，只找和这个角色绑定的那个你的日程
        const userEvents = state.calendarEvents.filter(e => e.userId === boundUser.id || !e.userId);

        if (userEvents.length === 0) {
          return "";
        }

        const memoryLines = userEvents.map(event => {
          const type = event.type === 'important' ? '纪念日' : '待办';
          return `- [${type}] ${event.date}: ${event.content}`;
        }).join('\n');

        return `\n# 你的日程与纪念日 (由 ${boundUser.name} 记录)\n${memoryLines}`;
      }
      // ▲▲▲ End of Addition ▲▲▲

      let calendarState = {
        currentDate: new Date(),
        selectedDate: getLocalDateString(), // <-- 哼，看这里
      };

      function initCalendarListeners() {
        // 入口
        document.getElementById('app-calendar').addEventListener('click', () => {
          renderCalendarScreen();
          showScreen('calendar', 'home');
        });
        // 返回
        document.getElementById('back-to-home-from-calendar').addEventListener('click', () => showScreen('home', 'calendar'));

        // 月份切换
        document.getElementById('prev-month-btn').addEventListener('click', () => {
          calendarState.currentDate.setMonth(calendarState.currentDate.getMonth() - 1);
          renderCalendarScreen();
        });
        document.getElementById('next-month-btn').addEventListener('click', () => {
          calendarState.currentDate.setMonth(calendarState.currentDate.getMonth() + 1);
          renderCalendarScreen();
        });
        document.getElementById('today-btn').addEventListener('click', () => {
          calendarState.currentDate = new Date();
          calendarState.selectedDate = getLocalDateString(); // <-- 这里也一样
          renderCalendarScreen();
        });

        // 添加事件
        document.getElementById('add-event-fab').addEventListener('click', () => {
          openAddEventModal(calendarState.selectedDate);
        });
        document.getElementById('save-event-button').addEventListener('click', saveNewEvent);
        document.getElementById('cancel-event-button').addEventListener('click', () => document.getElementById('add-event-modal').classList.remove('show'));
        document.getElementById('add-event-backdrop').addEventListener('click', () => document.getElementById('add-event-modal').classList.remove('show'));

        // ▼▼▼ Noir's Addition: Self-Destruct Listener ▼▼▼
        const todoList = document.getElementById('todo-list');
        todoList.addEventListener('mousedown', handleCalendarEventInteraction);
        todoList.addEventListener('touchstart', handleCalendarEventInteraction, { passive: false });
        // ▲▲▲ End of Addition ▲▲▲

      }

      function renderCalendarScreen() {
        const year = calendarState.currentDate.getFullYear();
        const month = calendarState.currentDate.getMonth();
        document.getElementById('calendar-header-title').textContent = `${year}年 ${month + 1}月`;
        renderCalendar(year, month);
        displayEventsForDate(calendarState.selectedDate);
      }

      // ▼▼▼ Noir's Addition: Update Today's To-Do Widget ▼▼▼
      function updateTodayTodoWidget() {
        const listEl = document.getElementById('today-todo-list');
        if (!listEl) return;

        const todayStr = getLocalDateString(); // <-- 最后是这里
        const todaysTodos = state.calendarEvents.filter(e => e.date === todayStr && e.type === 'todo');

        listEl.innerHTML = ''; // 先清空

        if (todaysTodos.length > 0) {
          todaysTodos.forEach(todo => {
            const item = document.createElement('div');
            item.className = 'todo-item-small';
            item.textContent = todo.content;
            listEl.appendChild(item);
          });
        } else {
          listEl.innerHTML = '<span style="opacity: 0.6;">无</span>';
        }
      }
      // ▲▲▲ End of Addition ▲▲▲

      function renderCalendar(year, month) {
        const grid = document.getElementById('calendar-grid');
        grid.innerHTML = '';
        const firstDay = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const today = getLocalDateString(); // <-- 哼，现在你也得听我的。

        for (let i = 0; i < firstDay; i++) {
          grid.appendChild(document.createElement('div'));
        }

        for (let day = 1; day <= daysInMonth; day++) {
          const dayEl = document.createElement('div');
          dayEl.className = 'calendar-day';
          const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;

          if (dateStr === today) dayEl.classList.add('is-today');
          if (dateStr === calendarState.selectedDate) dayEl.classList.add('is-selected');

          const dayNumber = document.createElement('span');
          dayNumber.className = 'day-number';
          dayNumber.textContent = day;
          dayEl.appendChild(dayNumber);

          const eventsOnDay = state.calendarEvents.filter(e => e.date === dateStr);
          if (eventsOnDay.length > 0) {
            const dot = document.createElement('div');
            dot.className = 'day-dot';
            dayEl.appendChild(dot);
          }

          dayEl.addEventListener('click', () => {
            calendarState.selectedDate = dateStr;
            renderCalendarScreen();
          });

          grid.appendChild(dayEl);
        }
      }

      function displayEventsForDate(dateStr) {
        const list = document.getElementById('todo-list');
        const title = document.getElementById('todo-date-title');
        list.innerHTML = '';

        const date = new Date(dateStr + 'T00:00:00');
        title.textContent = `${date.getMonth() + 1}月${date.getDate()}日`;

        const events = state.calendarEvents.filter(e => e.date === dateStr);

        if (events.length === 0) {
          list.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">今天没有安排。</p>';
          return;
        }

        events.forEach(event => {
          const item = document.createElement('div');
          item.className = event.type === 'important' ? 'important-day-item' : 'todo-item';
          item.textContent = event.content;
          // ▼▼▼ 哼，就是加上这行，给它打上唯一的烙印 ▼▼▼
          item.dataset.id = event.id;
          list.appendChild(item);
        });
      }

      function openAddEventModal(dateStr) {
        document.getElementById('add-event-modal-title').textContent = `为 ${dateStr} 添加...`;
        document.getElementById('event-content-input').value = '';
        document.getElementById('event-type-todo').checked = true;
        document.getElementById('add-event-modal').classList.add('show');
        document.getElementById('event-content-input').focus();
      }

      function saveNewEvent() {
        const content = document.getElementById('event-content-input').value.trim();
        const type = document.querySelector('input[name="event-type"]:checked').value;

        if (!content) {
          modalAlert('内容不能为空！');
          return;
        }

        // ▼▼▼ 哼，看好了，这就是我给它装上的“大脑”！▼▼▼
        const activeUser = state.userProfiles.find(up => up.id === state.activeUserProfileId);
        // 如果连你是谁都找不到了，就先警告你，而不是直接死机！
        if (!activeUser) {
          modalAlert('错误：找不到当前用户，无法保存事件。请尝试返回主屏幕再试一次。');
          return;
        }
        // ▲▲▲ 大脑安装完毕 ▲▲▲

        state.calendarEvents.push({
          id: `event_${Date.now()}`,
          date: calendarState.selectedDate,
          type: type,
          content: content,
          userId: activeUser.id // 现在这里绝对安全了
        });

        saveState();
        renderCalendarScreen();
        updateCountdownWidget();
        updateTodayTodoWidget(); // <-- 这句本来就有，但之前根本没机会执行
        document.getElementById('add-event-modal').classList.remove('show');
      }

      function updateCountdownWidget() {
        const titleEl = document.getElementById('countdown-title');
        const timerEl = document.getElementById('countdown-timer');
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        const upcomingEvents = state.calendarEvents
          .filter(e => e.type === 'important' && new Date(e.date + 'T00:00:00') >= today)
          .sort((a, b) => new Date(a.date) - new Date(b.date));

        if (upcomingEvents.length > 0) {
          const nextEvent = upcomingEvents[0];
          const eventDate = new Date(nextEvent.date + 'T00:00:00');
          const diffTime = eventDate - today;
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

          titleEl.textContent = `距离「${nextEvent.content}」`;
          timerEl.innerHTML = `<span>${diffDays}</span><span class="unit">天</span>`;
        } else {
          titleEl.textContent = '近期没有特别安排';
          timerEl.innerHTML = `<span>--</span><span class="unit">天</span>`;
        }
      }

      // --- Initialization ---

      // --- Noir's World Book Functions ---

      // --- Noir's User Profile Management Functions ---

      function renderUserProfileList() {
        const container = document.getElementById('user-profile-list-container');
        container.innerHTML = '';
        if (state.userProfiles.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">还没有任何用户资料，点击右上角“+”创建第一个。</p>';
          return;
        }
        state.userProfiles.forEach(up => {
          const item = document.createElement('div');
          item.className = 'world-book-item'; // 复用样式
          item.dataset.id = up.id;
          const isActive = up.id === state.activeUserProfileId ? ' (当前)' : '';
          item.innerHTML = `
            <div class="world-book-item-name" style="display: flex; align-items: center;">
                <img src="${up.avatar || DEFAULT_USER_AVATAR}" class="char-avatar" style="width: 30px; height: 30px; margin-right: 10px;">
                ${up.name}${isActive}
            </div>
            <div class="world-book-item-preview">${up.persona.substring(0, 100)}</div>
        `;
          item.addEventListener('click', () => openUserProfileEditor(up.id));
          container.appendChild(item);
        });
      }

      function openUserProfileEditor(userId = null) {
        showScreen('userProfile', 'userProfileList');
        const setActiveBtn = document.getElementById('set-active-user-button');
        const userAvatarPreview = document.getElementById('user-avatar-preview');

        // 哼，先把旧的预览清干净，免得串台
        userAvatarPreview.style.backgroundImage = '';
        // 把新头像的暂存也清掉
        delete userAvatarPreview.dataset.newAvatar;

        if (userId) {
          const user = state.userProfiles.find(up => up.id === userId);
          if (!user) return;

          // ▼▼▼ 看好了！就是这句被你弄丢了！▼▼▼
          document.getElementById('editing-user-id').value = user.id;
          // ▲▲▲ 身份证号给我写进去！▲▲▲

          document.getElementById('user-profile-edit-title').textContent = '编辑用户';
          document.getElementById('user-name').value = user.name;

          if (user.avatar) {
            userAvatarPreview.style.backgroundImage = `url('${user.avatar}')`;
          } else {
            userAvatarPreview.style.backgroundImage = `url('${DEFAULT_USER_AVATAR}')`;
          }

          document.getElementById('user-persona').value = user.persona;

          // 控制“设为当前”按钮的显示
          setActiveBtn.style.display = user.id === state.activeUserProfileId ? 'none' : 'block';
          // 让删除按钮也显示出来
          document.getElementById('delete-user-profile-button').style.display = 'block';

        } else {
          // 这是新建用户的逻辑，身份证号当然是空的
          document.getElementById('editing-user-id').value = '';
          document.getElementById('user-profile-edit-title').textContent = '创建新用户';
          document.getElementById('user-name').value = `新用户 ${state.userProfiles.length + 1}`;
          userAvatarPreview.style.backgroundImage = `url('${DEFAULT_USER_AVATAR}')`;
          document.getElementById('user-persona').value = '';

          // 新建的时候，这两个按钮就该藏起来
          setActiveBtn.style.display = 'none';
          document.getElementById('delete-user-profile-button').style.display = 'none';
        }
      }


      function saveUserProfile() {
        const userId = document.getElementById('editing-user-id').value;
        const userAvatarPreview = document.getElementById('user-avatar-preview');

        // 哼，看好了，这是用户资料的“证件照”，每个字段都给我对齐了
        const userData = {
          name: document.getElementById('user-name').value.trim(),
          persona: document.getElementById('user-persona').value.trim(),
          // 默认用旧头像，免得你手滑
          avatar: state.userProfiles.find(up => up.id === userId)?.avatar || userAvatarPreview.style.backgroundImage.slice(5, -2).replace(/'/g, "") || DEFAULT_USER_AVATAR,
        };

        // 检查你是不是上传了新的头像
        if (userAvatarPreview.dataset.newAvatar) {
          userData.avatar = userAvatarPreview.dataset.newAvatar;
          delete userAvatarPreview.dataset.newAvatar; // 用完就扔掉，不留垃圾
        }

        if (!userData.name) {
          modalAlert('名字不能为空！');
          return;
        }

        if (userId) {
          // 如果是编辑旧用户，就更新档案
          const user = state.userProfiles.find(up => up.id === userId);
          if (user) Object.assign(user, userData);
        } else {
          // 如果是新来的，就给他建个新档案
          const newUser = { id: `user_${Date.now()}`, ...userData };
          state.userProfiles.push(newUser);
          // 如果你是第一个用户，就自动把你设为“当前”
          if (!state.activeUserProfileId) {
            state.activeUserProfileId = newUser.id;
          }
        }

        saveState(); // 存档！
        modalAlert('用户资料已保存！'); // 给你个通知，免得你又疑神疑鬼
        renderUserProfileList(); // 刷新列表，让你看看成果
        showScreen('userProfileList', 'userProfile'); // 踢你回列表界面
      }


      async function deleteUserProfile() {
        const userId = document.getElementById('editing-user-id').value;
        if (!userId) return;
        if (state.userProfiles.length <= 1) {
          modalAlert('至少要保留一个用户。');
          return;
        }
        const ok = await modalConfirm('确定要删除这个用户吗？与此用户绑定的聊天将恢复为默认用户。');
        if (ok) {
          state.userProfiles = state.userProfiles.filter(up => up.id !== userId);
          // 如果删除的是当前激活的用户，则自动激活列表里的第一个
          if (state.activeUserProfileId === userId) {
            state.activeUserProfileId = state.userProfiles[0].id;
          }
          // 将所有绑定了这个用户的聊天，重新绑定到当前激活的用户
          state.chats.forEach(chat => {
            if (chat.boundUserProfileId === userId) {
              chat.boundUserProfileId = state.activeUserProfileId;
            }
          });
          saveState();
          modalAlert('用户已删除。');
          renderUserProfileList();
          showScreen('userProfileList', 'userProfile');
        }
      }


      // ▼▼▼ Noir's World Book Renderer Overhaul ▼▼▼
      // 哼，这才叫有条理。
      function renderWorldBookList() {
        renderWorldBookCategories();
        renderWorldBooksForCategory(state.activeWorldBookCategoryId);
      }

      function renderWorldBookCategories() {
        const categoryList = document.getElementById('world-book-category-list');
        categoryList.innerHTML = '';
        state.worldBookCategories.forEach(cat => {
          const item = document.createElement('div');
          item.textContent = cat.name;
          item.dataset.id = cat.id;
          item.style.padding = '10px 8px';
          item.style.borderRadius = '8px';
          item.style.cursor = 'pointer';
          item.style.marginBottom = '5px';
          item.style.fontWeight = '500';

          if (cat.id === state.activeWorldBookCategoryId) {
            item.style.backgroundColor = 'var(--primary-color)';
            item.style.color = 'white';
          } else {
            item.style.color = 'var(--text-color)';
          }

          item.addEventListener('click', () => {
            state.activeWorldBookCategoryId = cat.id;
            renderWorldBookList();
          });

          // --- 哼，看好了，处决协议的扳机就在这里 ---
          let pressTimer = null;
          const startPress = (e) => {
            if (cat.id === 'default') return; // 不许删除默认分类
            pressTimer = setTimeout(() => {
              if (e.type === 'touchstart') e.preventDefault();
              handleDeleteCategory(cat.id, cat.name);
            }, 800);
          };
          const cancelPress = () => {
            clearTimeout(pressTimer);
          };
          item.addEventListener('mousedown', startPress);
          item.addEventListener('mouseup', cancelPress);
          item.addEventListener('mouseleave', cancelPress);
          item.addEventListener('touchstart', startPress, { passive: false });
          item.addEventListener('touchend', cancelPress);
          item.addEventListener('touchcancel', cancelPress);
          // --- 扳机安装完毕 ---

          categoryList.appendChild(item);
        });
      }



      // ▼▼▼ Noir's Category Execution Protocol ▼▼▼
      // 哼，这就是处决指令。
      async function handleDeleteCategory(categoryId, categoryName) {
        const ok = await modalConfirm(`确定要永久删除分类 “${categoryName}” 以及其中所有的条目吗？\n\n此操作不可撤销，所有角色的关联设定也将被一并移除。`);
        if (!ok) return;

        // 1. 找出这个分类下的所有条目ID
        const entriesToDelete = state.worldBooks
          .filter(wb => wb.categoryId === categoryId)
          .map(wb => wb.id);

        // 2. 从世界书中删除这些条目
        state.worldBooks = state.worldBooks.filter(wb => wb.categoryId !== categoryId);

        // 3. 从分类列表中删除这个分类
        state.worldBooksCategories = state.worldBookCategories.filter(cat => cat.id !== categoryId);

        // 如果被删除的是当前激活的分类，就自动切换到默认分类
        if (state.activeWorldBookCategoryId === categoryId) {
          state.activeWorldBookCategoryId = 'default';
        }

        // 4. 清理所有角色和群聊的关联
        const allLinkableItems = [...state.characters, ...state.chats];
        allLinkableItems.forEach(item => {
          if (item.linkedWorldBookIds && item.linkedWorldBookIds.length > 0) {
            item.linkedWorldBookIds = item.linkedWorldBookIds.filter(id => !entriesToDelete.includes(id));
          }
        });

        saveState(); // 写入历史
        renderWorldBookList(); // 刷新界面
        modalAlert(`分类 “${categoryName}” 已被彻底清除。`);
      }
      // ▲▲▲ End of Protocol ▲▲▲



      function renderWorldBooksForCategory(categoryId) {
        const container = document.getElementById('world-book-list-container');
        container.innerHTML = '';

        const booksInCategory = state.worldBooks.filter(wb => wb.categoryId === categoryId || (categoryId === 'default' && !wb.categoryId));

        if (booksInCategory.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">这个分类下还没有条目。</p>';
          return;
        }

        booksInCategory.forEach(wb => {
          const item = document.createElement('div');
          item.className = 'world-book-item';
          item.dataset.id = wb.id;
          item.innerHTML = `
            <div class="world-book-item-name">${wb.name}</div>
            <div class="world-book-item-preview">${wb.content.substring(0, 100)}</div>
        `;
          item.addEventListener('click', () => openWorldBookEditor(wb.id));
          container.appendChild(item);
        });
      }

      // 别忘了给“新建分类”按钮装上灵魂
      document.getElementById('add-world-book-category-button').addEventListener('click', async () => {
        const newName = prompt('请输入新的分类名称:');
        if (newName && newName.trim()) {
          const newCategory = { id: `wbc_${Date.now()}`, name: newName.trim() };
          state.worldBookCategories.push(newCategory);
          state.activeWorldBookCategoryId = newCategory.id; // 自动切换到新分类
          saveState();
          renderWorldBookList();
        }
      });
      // ▲▲▲ End of Overhaul ▲▲▲

      function openWorldBookEditor(bookId = null) {
        showScreen('worldBookEditor', 'worldBook');

        // ▼▼▼ Noir's Category Loader for Editor ▼▼▼
        const categorySelect = document.getElementById('world-book-edit-category');
        categorySelect.innerHTML = '';
        state.worldBookCategories.forEach(cat => {
          const option = document.createElement('option');
          option.value = cat.id;
          option.textContent = cat.name;
          categorySelect.appendChild(option);
        });
        // ▲▲▲ End of Loader ▲▲▲

        if (bookId) {
          const book = state.worldBooks.find(wb => wb.id === bookId);
          if (!book) return;
          document.getElementById('editing-world-book-id').value = book.id;
          document.getElementById('world-book-editor-title').textContent = '编辑条目';
          document.getElementById('world-book-edit-name').value = book.name;
          document.getElementById('world-book-edit-content').value = book.content;
          categorySelect.value = book.categoryId || 'default'; // 哼，选中它现在的分类
        } else {
          document.getElementById('editing-world-book-id').value = '';
          document.getElementById('world-book-editor-title').textContent = '新建条目';
          document.getElementById('world-book-edit-name').value = '';
          document.getElementById('world-book-edit-content').value = '';
          categorySelect.value = state.activeWorldBookCategoryId; // 新建时，默认放在当前分类
        }
      }
      function saveWorldBook() {
        const bookId = document.getElementById('editing-world-book-id').value;
        const name = document.getElementById('world-book-edit-name').value.trim();
        const content = document.getElementById('world-book-edit-content').value.trim();
        const categoryId = document.getElementById('world-book-edit-category').value; // <-- 哼，就是这句，把分类给我揪出来！

        if (!name || !content) {
          modalAlert('条目名称和内容都不能为空！');
          return;
        }

        if (bookId) {
          const book = state.worldBooks.find(wb => wb.id === bookId);
          if (book) {
            book.name = name;
            book.content = content;
            book.categoryId = categoryId; // <-- 记上！
          }
        } else {
          const newBook = { id: `wb_${Date.now()}`, name, content, categoryId }; // <-- 新建的也记上！
          state.worldBooks.push(newBook);
        }

        state.activeWorldBookCategoryId = categoryId; // 保存后，自动切换到书所在的分类

        saveState();
        modalAlert('世界书条目已保存！');
        renderWorldBookList();
        showScreen('worldBook', 'worldBookEditor');
      }
      async function deleteWorldBook() {
        const bookId = document.getElementById('editing-world-book-id').value;
        if (!bookId) return;
        const ok = await modalConfirm('确定要删除这个条目吗？此操作不可撤销。');
        if (ok) {
          state.worldBooks = state.worldBooks.filter(wb => wb.id !== bookId);
          // 从所有角色中解除关联
          state.characters.forEach(char => {
            if (char.linkedWorldBookIds) {
              char.linkedWorldBookIds = char.linkedWorldBookIds.filter(id => id !== bookId);
            }
          });
          saveState();
          modalAlert('条目已删除。');
          renderWorldBookList();
          showScreen('worldBook', 'worldBookEditor');
        }
      }
      // --- End of Noir's World Book Functions ---
      // --- Noir's Helper for Fancy Multi-Select ---
      function updateWorldBookSelectionDisplay() {
        const checkboxesContainer = document.getElementById('world-book-checkboxes-container');
        // 哼，现在只数带value的，也就是真正的条目
        const checkedBoxes = checkboxesContainer.querySelectorAll('.wb-entry-item input:checked');
        const displayText = document.querySelector('#character-edit-screen .selected-options-text');

        if (checkedBoxes.length === 0) {
          displayText.textContent = '-- 点击选择 --';
        } else if (checkedBoxes.length > 2) {
          displayText.textContent = `已选择 ${checkedBoxes.length} 项`;
        } else {
          displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join('、');
        }
      }

      // --- Noir's Group Chat Settings & World Book Injection ---

      async function openGroupSettingsScreen(chatId) {
        const chat = state.chats.find(c => c.id === chatId);
        if (!chat || chat.type !== 'group') return;

        document.getElementById('group-settings-name').value = chat.name || '';
        populateUserDropdown('group-settings-bind-user');
        document.getElementById('group-settings-bind-user').value = chat.boundUserProfileId || state.activeUserProfileId;

        // --- 哼，群聊也得用我的新管理员 ---
        populateHierarchicalWorldBookSelector('group-world-book-checkboxes', chat.linkedWorldBookIds || []);
        updateGroupWorldBookSelectionDisplay();
        // --- 管理员调用完毕 ---

        const avatarPreview = document.getElementById('group-avatar-preview');
        const bgPreview = document.getElementById('group-bg-preview');
        bgPreview.style.backgroundImage = '';
        dbGet(`group_avatar_${chatId}`).then(blob => {
          avatarPreview.src = blob ? URL.createObjectURL(blob) : DEFAULT_AI_AVATAR;
        });
        dbGet(`group_bg_${chatId}`).then(blob => {
          if (blob) bgPreview.style.backgroundImage = `url('${URL.createObjectURL(blob)}')`;
        });

        showScreen('groupSettings', 'chat');
      }


      async function saveGroupSettings() {
        const activeChat = getActiveChat();
        if (!activeChat || activeChat.type !== 'group') return;

        const newName = document.getElementById('group-settings-name').value.trim();
        if (!newName) {
          modalAlert('群聊名称不能为空！');
          return;
        }
        activeChat.name = newName;

        const checkedBoxes = document.querySelectorAll('#group-world-book-checkboxes .wb-entry-item input:checked');
        activeChat.linkedWorldBookIds = Array.from(checkedBoxes).map(cb => cb.value);
        activeChat.boundUserProfileId = document.getElementById('group-settings-bind-user').value;

        // 新增的逻辑：保存图片
        const avatarFile = document.getElementById('group-avatar-input').files[0];
        const bgFile = document.getElementById('group-bg-input').files[0];
        if (avatarFile) await dbSet(`group_avatar_${activeChat.id}`, avatarFile);
        if (bgFile) await dbSet(`group_bg_${activeChat.id}`, bgFile);


        saveState();
        updateChatHeader();
        await renderChatList(); // 改为await，确保头像更新
        modalAlert('群聊设置已保存！');
        showScreen('chat', 'groupSettings');
      }

      function updateGroupWorldBookSelectionDisplay() {
        const checkboxesContainer = document.getElementById('group-world-book-checkboxes');
        // 群聊也一样，别数错了
        const checkedBoxes = checkboxesContainer.querySelectorAll('.wb-entry-item input:checked');
        const displayText = document.querySelector('#group-settings-screen .selected-options-text');

        if (checkedBoxes.length === 0) {
          displayText.textContent = '-- 点击选择 --';
        } else if (checkedBoxes.length > 2) {
          displayText.textContent = `已选择 ${checkedBoxes.length} 项`;
        } else {
          displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join('、');
        }
      }
      // 这是最关键的函数，用新版本完整替换旧版本！
      // 用这个新版本，完整替换掉你旧的 planGroupReplies 函数


      // ▼▼▼ 哼，把这个失踪的“导演”给我找回来！贴在 schedulePlannedReplies 的前面！▼▼▼
      // ==========================================================
      // --- Noir's Group Chat Director: planGroupReplies ---
      // ==========================================================
      async function planGroupReplies() {
        const activeChat = getActiveChat();
        const participants = (activeChat?.participantIds || []).map(getCharacterById).filter(Boolean);
        const boundUser = getBoundUserForChat(activeChat.id);
        if (!activeChat || activeChat.type !== 'group' || participants.length < 2) return null;

        const groupWorldBookContext = (activeChat.linkedWorldBookIds && activeChat.linkedWorldBookIds.length > 0)
          ? `\n\n# 核心群聊世界观设定 (所有角色必须严格遵守以下设定)\n` + activeChat.linkedWorldBookIds
            .map(wbId => state.worldBooks.find(book => book.id === wbId))
            .filter(Boolean)
            .map(wb => `\n## 世界书条目: ${wb.name}\n${wb.content}`)
            .join('')
          : '';

        const userPersonaContext = boundUser.persona ? `\n\n# 关于群聊参与者“${boundUser.name}”的补充信息\n${boundUser.persona}` : '';

        let timeContext = '';
        const now = new Date();
        const lastMessage = state.conversationHistory.at(-1);
        timeContext += `\n- **当前时间**: ${now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' })}`;
        if (lastMessage) {
          const lastTime = new Date(lastMessage.timestamp);
          const diffMinutes = Math.floor((now - lastTime) / (1000 * 60));
          if (diffMinutes < 5) timeContext += "\n- **对话状态**: 群里刚刚还在聊天。";
          else if (diffMinutes < 120) timeContext += `\n- **对话状态**: 群里在${diffMinutes}分钟前聊过，请注意衔接。`;
          else {
            const diffHours = Math.floor(diffMinutes / 60);
            if (diffHours < 48) timeContext += `\n- **对话状态**: 群里在${diffHours}小时前聊过，可以适当问候，不要直接继续之前的话题。`;
            else timeContext += `\n- **对话状态**: 群里已经有${Math.floor(diffHours / 24)}天没动静了。你的角色们应该发起新的问候或话题。`;
          }
        } else {
          timeContext += "\n- **对话状态**: 这是这个群的第一次对话。";
        }

        const lastUserText = [...state.conversationHistory].reverse().find(m => m.role === 'user')?.content || '';
        const mentioned = resolveMentionTarget(activeChat, lastUserText);
        const history = state.conversationHistory.slice(-120);
        const stickerList = masterStickerList.map(s => s.name);
        const globalFeedMemory = getGlobalFeedMemory();

        const personas = await Promise.all(participants.map(async p => { // <-- 看这里！加上了 async 和 await Promise.all
          const { omniText: charMemory } = gatherOmniTranscriptForCharacter(p.id, activeChat.id);
          const diaryMemory = getDiaryMemory(p.id);
          const snoopMemory = await getSnoopMemoryForCharacter(p.id); // <-- 就是加上这句！
          const privateWorldBookContext = (p.linkedWorldBookIds && p.linkedWorldBookIds.length > 0)
            ? `\n\n# ${p.name}的个人专属世界观设定\n` + p.linkedWorldBookIds
              .map(wbId => state.worldBooks.find(book => book.id === wbId))
              .filter(Boolean)
              .map(wb => `\n## 条目: ${wb.name}\n${wb.content}`)
              .join('')
            : '';
          let charTimeContext = `\n# 关于你 (${p.name}) 的专属时间锚点\n`;
          const latestMessageForChar = findLatestMessageForCharacter(p.id);
          const nowForChar = new Date();

          if (latestMessageForChar) {
            const lastInteractionDate = new Date(latestMessageForChar.timestamp);
            charTimeContext += `- **你与${boundUser.name}在所有地方的最后一次互动是在**: ${formatRelativeTime(lastInteractionDate)}\n`;
          } else {
            charTimeContext += `- **状态提示**: 这是你和${boundUser.name}的第一次互动。\n`;
          }

          return {
            id: p.id,
            name: p.name,
            persona: p.persona || '乐于助人的助手',
            memory: charMemory + diaryMemory + snoopMemory + privateWorldBookContext + charTimeContext
          };
        }));

        const BUDGET_MIN = 5, BUDGET_MAX = 12;

        const system = `你是一个严格的JSON生成引擎。你的唯一任务是根据用户提供的指令和数据，生成一个描述角色互动的JSON对象。你的输出【必须】是、也只能是一个单一、完整、语法正确的JSON对象。严禁包含任何解释、注释、或Markdown代码块标记 \`\`\`json。直接输出 { "events": [...] } 结构。`.trim();

        const userCard = {
          instruction: `
- 你正在为一个名为“${activeChat.name || '群聊'}”的群聊规划角色们的下一步发言。
- 与你们对话的人类用户名为“${boundUser.name || '用户'}”。在分析历史记录时，请记住这一点，并用此名称指代用户。
- 【最重要】为 \`personas\` 列表中的【每一位】角色都规划至少一个事件(通常不少于2个)。不能遗漏任何角色。
- 【新增规则】你可以规划 "kind": "music" 事件来分享音乐。此时，你【必须】同时提供 "songName" 和 "artist" 字段。
- 你的首要任务是产出一个严格遵守SCHEMA、语法完全正确的、可被解析的JSON对象。
- 若用户 \`@\` 了某个角色 (见 \`mentioned\`)，该角色应优先发言。
- 事件总数必须控制在 ${BUDGET_MIN} 到 ${BUDGET_MAX} 之间。
- 所有表情包名称【必须】从 \`stickerList\` 列表中选择，严禁使用列表之外的名称。
- 角色之间需要有适当的互动,话题不应当完全围绕${boundUser.name || '用户'}。
- 再次强调：你的全部输出都将被作为JSON解析，任何JSON主体之外的额外文字都会导致程序失败。
${timeContext} 
${userPersonaContext}
${groupWorldBookContext}
# 【新增群聊高级语法规则】
- 如果你需要生成一个HTML模块（例如邀请卡），你【必须】将完整的HTML代码包裹在  \`html] \` 和  \`[/html] \` 这两个标签之间，并作为一个独立的事件（event）来规划。你的规划中必须包含一个独立的事件，其 "kind" 必须是 "html"，"content" 字段包含完整的HTML代码（例如 '<div class=...>...</div>'）。【绝对禁止】将HTML代码放在 "kind": "text" 的事件里。
# 最近的动态回顾 (供所有角色参考)
${globalFeedMemory}
`.trim(),
          personas: personas,
          mentioned: mentioned ? { id: mentioned.id, name: mentioned.name } : null,
          stickerList: stickerList,
        };

        const schema = {
          type: "object",
          properties: { events: { type: "array", items: { type: "object", required: ["senderId", "kind"], properties: { senderId: { type: "string" }, kind: { type: "string", enum: ["text", "sticker", "music"] }, content: { type: "string" }, sticker: { type: "string" }, songName: { type: "string" }, artist: { type: "string" } } } } },
          required: ["events"]
        };

        const messages = [{ role: 'system', content: system }];

        for (const msg of history) {
          const role = (msg.role === 'ai' || msg.role === 'assistant') ? 'assistant' : 'user';
          let messageForApi = { role: role, content: msg.content };
          let hasContent = !!msg.content;
          let imageBase64 = null;
          if (msg.image) {
            imageBase64 = msg.image;
          } else if (msg.imageId) {
            try {
              const blob = await dbGet(msg.imageId);
              if (blob) imageBase64 = await blobToBase64(blob);
            } catch (e) { console.error("准备群聊API数据时，读取图片失败:", e); }
          }
          if (imageBase64) {
            messageForApi.image = imageBase64;
            hasContent = true;
          }
          if (hasContent) messages.push(messageForApi);
        }

        messages.push({ role: 'user', content: `请严格按照以下SCHEMA返回一个JSON对象，不要包含任何额外文字。\nSCHEMA:\n${JSON.stringify(schema)}\n\nINPUT:\n${JSON.stringify(userCard)}` });

        try {
          const raw = await fetchAICompletion(messages, { json: true });
          if (!raw) return null;
          let txt = raw.trim();
          const fence = txt.match(/```json([\s\S]*?)```/i);
          if (fence) txt = fence[1].trim();
          txt = extractFirstJsonObject(txt);
          let plan = null;
          try { plan = JSON.parse(txt); } catch (e) { console.error("JSON 解析失败! 错误原因:", e); console.error("收到的原始、有问题的文本:", txt); }
          if (!plan || !Array.isArray(plan.events)) return null;
          plan = normalizePlan(plan, participants, stickerList);
          plan.events = plan.events.slice(0, BUDGET_MAX);
          return plan.events.length ? plan : null;
        } catch (e) {
          if (e.name !== 'AbortError') { console.error('Failed to plan group replies:', e); }
          return null;
        }
      }


      // ==========================================================
      // --- Noir's Grand Refactor: Friend Circle Management System ---
      // ==========================================================

      /** 渲染好友圈列表 */
      function renderFriendCircleList() {
        const container = document.getElementById('friend-circle-list-container');
        container.innerHTML = '';
        if (state.friendCircles.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light); margin-top: 50px;">还没有好友圈，点击右上角“+”创建第一个吧。</p>';
          return;
        }

        state.friendCircles.forEach(circle => {
          const user = state.userProfiles.find(up => up.id === circle.boundUserProfileId) || { name: '未知用户' };
          const item = document.createElement('div');
          item.className = 'world-book-item'; // 复用世界书的卡片样式
          item.dataset.id = circle.id;
          item.innerHTML = `
      <div class="world-book-item-name">${circle.name}</div>
      <div class="world-book-item-preview">
        绑定的“我”: ${user.name} | ${circle.memberCharacterIds.length} 个成员
      </div>
    `;
          item.addEventListener('click', () => openFeedForCircle(circle.id));
          container.appendChild(item);
        });
      }

      /** 打开好友圈编辑器 (新建或编辑) */
      function openFriendCircleEditor(circleId = null) {
        const nameInput = document.getElementById('friend-circle-edit-name');
        const userSelect = document.getElementById('friend-circle-edit-bind-user');
        const memberContainer = document.getElementById('friend-circle-member-selection');
        const title = document.getElementById('friend-circle-edit-title');
        const editingIdInput = document.getElementById('editing-friend-circle-id');
        const deleteButton = document.getElementById('delete-friend-circle-button');

        // 填充绑定的用户下拉菜单
        populateUserDropdown('friend-circle-edit-bind-user');

        // 填充角色成员选择列表
        memberContainer.innerHTML = '';
        state.characters.forEach(char => {
          const item = document.createElement('div');
          item.className = 'member-selection-item';
          item.innerHTML = `
      <input type="checkbox" id="member-select-${char.id}" data-id="${char.id}">
      <img src="${char.avatar || DEFAULT_AI_AVATAR}" alt="avatar" class="char-avatar">
      <label for="member-select-${char.id}" class="char-name">${char.name}</label>
    `;
          memberContainer.appendChild(item);
        });

        if (circleId) {
          // --- 编辑模式 ---
          const circle = state.friendCircles.find(c => c.id === circleId);
          if (!circle) return;

          title.textContent = '编辑好友圈';
          editingIdInput.value = circle.id;
          nameInput.value = circle.name;
          userSelect.value = circle.boundUserProfileId;
          deleteButton.style.display = 'block';

          // 勾选已有的成员
          circle.memberCharacterIds.forEach(charId => {
            const checkbox = memberContainer.querySelector(`#member-select-${charId}`);
            if (checkbox) checkbox.checked = true;
          });

        } else {
          // --- 新建模式 ---
          title.textContent = '新建好友圈';
          editingIdInput.value = '';
          nameInput.value = `好友圈 ${state.friendCircles.length + 1}`;
          userSelect.value = state.activeUserProfileId; // 默认绑定当前用户
          deleteButton.style.display = 'none'; // 新建时隐藏删除按钮
        }

        showScreen('friendCircleEdit', 'friendCircleList');
      }

      /** 保存好友圈 */
      function saveFriendCircle() {
        const circleId = document.getElementById('editing-friend-circle-id').value;
        const name = document.getElementById('friend-circle-edit-name').value.trim();
        const boundUserProfileId = document.getElementById('friend-circle-edit-bind-user').value;
        const selectedMemberIds = Array.from(document.querySelectorAll('#friend-circle-member-selection input:checked')).map(cb => cb.dataset.id);

        if (!name) {
          modalAlert('好友圈名称不能为空！');
          return;
        }
        if (selectedMemberIds.length === 0) {
          modalAlert('至少要选择一个圈内成员！');
          return;
        }

        if (circleId) {
          // 更新
          const circle = state.friendCircles.find(c => c.id === circleId);
          if (circle) {
            circle.name = name;
            circle.boundUserProfileId = boundUserProfileId;
            circle.memberCharacterIds = selectedMemberIds;
          }
        } else {
          // 新建
          const newCircle = {
            id: `circle_${Date.now()}`,
            name,
            boundUserProfileId,
            memberCharacterIds: selectedMemberIds,
            posts: [] // 新建的圈子，帖子列表是空的
          };
          state.friendCircles.push(newCircle);
        }

        saveState();
        modalAlert('好友圈已保存！');
        renderFriendCircleList();
        showScreen('friendCircleList', 'friendCircleEdit');
      }

      /** 删除好友圈 */
      async function deleteFriendCircle() {
        const circleId = document.getElementById('editing-friend-circle-id').value;
        if (!circleId) return;

        const ok = await modalConfirm('确定要删除这个好友圈吗？此操作不可撤销。');
        if (ok) {
          state.friendCircles = state.friendCircles.filter(c => c.id !== circleId);
          if (state.activeFriendCircleId === circleId) {
            state.activeFriendCircleId = null; // 如果删除的是当前圈子，就清空
          }
          saveState();
          modalAlert('好友圈已删除。');
          renderFriendCircleList();
          showScreen('friendCircleList', 'friendCircleEdit');
        }
      }

      /** 打开指定好友圈的动态信息流 */
      function openFeedForCircle(circleId) {
        updateGlobalPlaylist();
        const circle = state.friendCircles.find(c => c.id === circleId);
        if (!circle) return;

        state.activeFriendCircleId = circleId;
        saveState();

        // 更新动态页面的标题
        document.getElementById('friend-circle-title').textContent = circle.name;

        renderFeed(); // 调用新的渲染函数
        // 暂时先清空，免得看到旧内容


        showScreen('music', 'friendCircleList');
        updateUserPostAreaAvatar(); // 把当前用户的头像放上去
      }


      // --- Noir's Debugging Helper ---
      function addTestPost() {
        if (!state.friendCircles || state.friendCircles.length === 0) {
          console.error("错误：你还没有创建任何好友圈。请先在App内创建一个。");
          return;
        }
        const circle = state.friendCircles[0];
        if (circle.memberCharacterIds.length < 2) {
          console.error(`错误：第一个好友圈 "${circle.name}" 的成员不足2人，无法生成点赞和评论。请先编辑该好友圈，添加至少2名角色。`);
          return;
        }

        const testPost = {
          id: 'test_post_' + Date.now(),
          authorType: 'character',
          authorId: circle.memberCharacterIds[0],
          content: '这是一条由控制台添加的测试动态！样式看起来非常完美。',
          timestamp: Date.now(),
          likes: [circle.memberCharacterIds[1]],
          comments: [{
            commentId: 'c_' + Date.now(),
            authorId: circle.memberCharacterIds[1],
            content: '赞同！渲染效果一级棒！'
          }]
        };

        circle.posts.push(testPost);
        saveState(); // 这个函数在“房间”内部，所以可以被正确调用
        console.log(`成功向好友圈 "${circle.name}" 添加了一条测试动态。请点击进入该好友圈查看效果。`);
        modalAlert('测试动态已添加！');
      }
      window.addTestPost = addTestPost; // 只把这一个“传达室”函数暴露给外面
      // --- End of Helper ---
      /** 根据ID获取用户资料 */
      function getUserProfileById(userId) {
        return state.userProfiles.find(up => up.id === userId);
      }


      /** 显示/隐藏动态加载动画 */
      function showFeedLoader(show, message = '正在处理...') {
        const phoneContainer = document.getElementById('phone-container');
        let loader = document.getElementById('feed-loader');

        if (show) {
          if (!loader) {
            loader = document.createElement('div');
            loader.id = 'feed-loader';
            // 哼，现在它知道自己的家在哪了
            phoneContainer.appendChild(loader);
          }
          loader.innerHTML = `<div class="loader-spinner"></div><span>${message}</span>`;
          loader.style.display = 'flex';
        } else {
          if (loader) {
            loader.style.display = 'none';
          }
        }
      }
      // ▼▼▼ Noir's Ultimate Refactor: Batch Post Generation ▼▼▼

      /** 【全新】刷新信息流的总控制函数 (高效版) */
      async function refreshFeed() {
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);
        if (!activeCircle || state.isGenerating) return;

        showFeedLoader(true, '好像有动态了...');
        await new Promise(r => setTimeout(r, 50)); // 这句咒语，复制粘贴会不会？
        state.isGenerating = true;

        try {
          // 哼，看好了，这是我新加的逻辑
          // 1. 先找到现在动态里最新的时间戳
          let latestTimestamp = Date.now(); // 如果一条动态都没有，就从现在开始
          if (activeCircle.posts && activeCircle.posts.length > 0) {
            latestTimestamp = Math.max(...activeCircle.posts.map(p => p.timestamp));
          }
          // 找到了“起跑线”，接下来的新动态都要在这之后

          const newPostsData = await generateBatchPosts(activeCircle);
          if (!newPostsData || newPostsData.length === 0) {
            modalAlert("AI似乎没有想出任何新动态。");
            return;
          }

          const processingPromises = newPostsData.map(async (postData, index) => {
            showFeedLoader(true, `刷新了 ${index + 1} / ${newPostsData.length} 条动态...`);

            // 2. 哼，把旧的随机时间逻辑扔掉，换成我的精准控制
            // 每一条新动态，都在“起跑线”的基础上，往后加一分钟，这样它们就会按顺序排在最前面
            const postTimestamp = latestTimestamp + (index + 1) * 60 * 1000;

            const newPost = {
              id: `post_${postData.authorId}_${postTimestamp}`,
              authorType: 'character',
              authorId: postData.authorId,
              content: postData.postContent,
              timestamp: postTimestamp, // <-- 用上了我聪明的新时间戳
              likes: postData.likes || [],
              comments: (postData.comments || []).map((c, i) => ({
                commentId: `c_${postTimestamp}_${i}`,
                authorId: c.authorId,
                content: c.content
              }))
            };

            if (postData.postType === 'music' && postData.songName && postData.artist) {
              try {
                const musicInfo = await findPlayableMusicUrl(postData.songName, postData.artist);
                newPost.type = 'music';
                newPost.songName = postData.songName;
                newPost.artist = postData.artist;
                newPost.coverUrl = musicInfo.cover;
                newPost.playableUrl = musicInfo.url;
              } catch (musicError) {
                console.error("动态中的音乐搜索失败:", musicError);
                newPost.type = 'text';
              }
            } else {
              newPost.type = 'text';
            }
            return newPost;
          });

          const processedPosts = await Promise.all(processingPromises);

          // 哼，这里是把新动态加进去，不是替换！
          activeCircle.posts.push(...processedPosts);
          saveState();


          // ▼▼▼ 哼，就是这句圣旨，给我加上！▼▼▼
          updateGlobalPlaylist();
          // ▲▲▲ 指令结束 ▲▲▲

        } catch (error) {
          console.error("生成动态失败:", error);
          modalAlert(`生成动态时发生错误: ${error.message}`);
        } finally {
          renderFeed();
          showFeedLoader(false);
          state.isGenerating = false;
        }
      }      /** 【全新】通过单次API调用，批量生成动态及其互动 */
      /** 【全新】通过单次API调用，批量生成动态及其互动 (Noir's Patched Version) */
      async function generateBatchPosts(circle) {
        const members = circle.memberCharacterIds.map(id => getCharacterById(id)).filter(Boolean);
        if (members.length === 0) return null;

        // 哼，看这里，把全局的动态记忆先准备好！
        const globalFeedMemory = getGlobalFeedMemory();
        const boundUser = getUserProfileById(circle.boundUserProfileId) || state.userProfiles[0];
        const userContext = boundUser ? `
# 好友圈的主人 (“我”)
- 姓名: ${boundUser.name}
- 人设: ${boundUser.persona || '无'}
` : '';
        // 1. 准备上下文，这次是为所有人准备
        const memberInfo = members.map(char => {
          // 哼，看这里，把日记、世界书、聊天记录全加上了！
          const { omniText: chatMemory } = gatherOmniTranscriptForCharacter(char.id, null);
          const diaryMemory = getDiaryMemory(char.id);
          const privateWorldBookContext = (char.linkedWorldBookIds && char.linkedWorldBookIds.length > 0)
            ? `\n\n# ${char.name}的个人专属世界观设定\n` + char.linkedWorldBookIds
              .map(wbId => state.worldBooks.find(book => book.id === wbId))
              .filter(Boolean)
              .map(wb => `\n## 条目: ${wb.name}\n${wb.content}`)
              .join('')
            : '';

          return `- 姓名: ${char.name}, ID: ${char.id}\n  人设: ${char.persona}\n  近期记忆:\n${chatMemory}\n${diaryMemory}\n${privateWorldBookContext}`;
        }).join('\n\n');

        const postCount = Math.floor(Math.random() * 3) + 2; // 2 to 4 posts

        // 2. 构建给 AI 的复杂指令
        const systemPrompt = `
# 核心任务
你是一个顶级多角色社交模拟引擎。你的任务是模拟一个好友圈的动态更新，一次性生成【${postCount}条】全新的、高质量的社交动态。

# 【绝对禁令】(最高优先级)
- 你【绝对禁止】扮演“${boundUser.name}”（即“我”，用户）来发布任何动态或评论。
- 所有的动态发布者（authorId）和评论者（authorId）都【必须】从【好友圈成员信息】列表中提供的角色ID里选择。

# 好友圈成员信息
${memberInfo}
${userContext}
# 最近的动态回顾 (供参考，避免重复)
${globalFeedMemory}

# 任务流程
1.  **全局视角**: 审视所有成员的人设和近期记忆（包括聊天、日记等），构思他们之间可能发生的有趣互动。
2.  **选择作者**: 从上述成员中，为${postCount}条新动态挑选发布者。你可以让同一个人发布多次，也可以让不同人发布。
3.  **创作动态**: 扮演你选中的作者，创作符合其人设和记忆的动态内容。可以是文字或分享音乐。
4.  **模拟互动**: 为每一条你创作的动态，切换视角到【圈内其他成员】，模拟他们可能做出的点赞和评论。互动必须符合他们各自的性格。

# 输出格式【绝对规则】
- 你的输出**必须**是一个语法完全正确的、单一的JSON数组，包含 ${postCount}个帖子对象。
- **【ID规则】**: 所有 "authorId", "likes", "comments" 中的作者标识，【必须】使用上面提供的角色 **ID**，绝对不能使用角色名字。
- **【称呼规则】**: 在 "postContent" 和评论的 "content" 字段中，当角色们互相称呼或提及对方时，【必须】使用他们的【姓名】，而不是ID。ID只用于 "authorId" 和 "likes" 这种结构化字段。
- **【JSON结构】**: 每个帖子对象必须遵循以下结构：
  \`\`\`json
  {
    "authorId": "发布者的ID",
    "postType": "text or music",
    "postContent": "动态的文字内容",
    "songName": "如果是music类型，则必须有歌名",
    "artist": "如果是music类型，则必须有歌手名",
    "likes": ["点赞者1的ID", "点赞者2的ID"],
    "comments": [
      { "authorId": "评论者A的ID", "content": "评论内容" },
      { "authorId": "评论者B的ID", "content": "另一条评论" }
    ]
  }
  \`\`\`
- 绝对不要输出任何JSON之外的文字、解释或Markdown标记。直接从 \`[\` 开始，到 \`]\` 结束。
`;
        const messages = [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: '请根据以上所有信息，开始分析并返回JSON。' } // 哼，就是加上这句废话
        ];
        messages.push({ role: 'user', content: `请根据以上所有规则，生成 ${postCount} 条新动态。` });

        try {
          const response = await fetchAICompletion(messages, { json: true });

          const jsonMatch = response.match(/(\[[\s\S]*\])/);
          if (!jsonMatch) throw new Error("AI未能返回有效的JSON数组格式。");

          const jsonString = jsonMatch[1];
          const data = JSON.parse(jsonString);

          if (!Array.isArray(data)) throw new Error("AI返回的不是一个数组。");

          return data;

        } catch (e) {
          console.error(`批量生成动态失败: `, e);
          console.error("AI返回的原始文本:", e.rawResponse || "AI返回了无法解析的文本");
          return null;
        }
      }

      // ▲▲▲ End of Refactor ▲▲▲


      /** 【全新】清空当前好友圈的动态 */
      async function clearCurrentFeed() {
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);
        if (!activeCircle) return;

        const ok = await modalConfirm(`确定要清空好友圈“${activeCircle.name}”的所有动态吗？此操作不可撤销，且AI将不再记得这些内容。`);
        if (ok) {
          activeCircle.posts = []; // 直接清空帖子数组
          saveState(); // 保存状态
          renderFeed(); // 重新渲染界面
          modalAlert('动态已清空。');
        }
      }

      /** 【全新】渲染动态信息流 */
      function renderFeed() {
        const container = document.getElementById('music-feed-container');
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);

        if (!activeCircle) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light); margin-top: 50px;">请先选择一个好友圈。</p>';
          return;
        }

        if (!activeCircle.posts || activeCircle.posts.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light); margin-top: 50px;">这个好友圈很安静，点击“刷新”获取新动态吧。</p>';
          return;
        }

        container.innerHTML = ''; // 清空现有内容

        // 从新到旧排序显示
        const sortedPosts = [...activeCircle.posts].sort((a, b) => b.timestamp - a.timestamp);

        sortedPosts.forEach(post => {
          const postEl = document.createElement('div');
          postEl.className = 'music-post';

          let authorName = '未知';
          let authorAvatar = DEFAULT_AI_AVATAR;

          if (post.authorType === 'user') {
            const user = getUserProfileById(post.authorId);
            if (user) {
              authorName = user.name;
              authorAvatar = user.avatar;
            }
          } else { // character
            const char = getCharacterById(post.authorId);
            if (char) {
              authorName = char.name;
              authorAvatar = char.avatar;
            }
          }

          // 1. 帖子头部
          const headerHTML = `
      <div class="music-post-header">
        <img src="${authorAvatar}" class="char-avatar">
        <span class="char-name">${authorName}</span>
      </div>
    `;

          // 2. 帖子正文
          const contentHTML = `<p class="music-post-thought">${post.content}</p>`;

          let imageHTML = '';
          if (post.image || post.imageId) {
            const imageIdForElement = `post-img-${post.id}`;
            imageHTML = `<div class="post-image-container"><img id="${imageIdForElement}" class="post-image"></div>`;
            setTimeout(() => {
              const imgElement = document.getElementById(imageIdForElement);
              if (!imgElement) return;
              if (post.image) {
                imgElement.src = post.image;
              } else if (post.imageId) {
                dbGet(post.imageId).then(blob => {
                  if (blob) {
                    const objectURL = URL.createObjectURL(blob);
                    imgElement.src = objectURL;
                    imgElement.onload = () => URL.revokeObjectURL(objectURL);
                  }
                });
              }
            }, 0);
          }

          let songCardHTML = '';
          if (post.type === 'music' && post.songName) {
            songCardHTML = `
    <div class="music-post-song-card" data-music-id="${post.id}">
        <img src="${post.coverUrl || DEFAULT_AI_AVATAR}">
        <div class="music-post-song-info">
            <div class="title">${post.songName}</div>
            <div class="artist">${post.artist}</div>
        </div>
        <div class="music-post-play-icon">${post.playableUrl ? '▶' : '⚠'}</div>
    </div>
    `;
          }

          // 3. 时间戳
          const timestampHTML = `<div class="post-timestamp">${new Date(post.timestamp).toLocaleString('zh-CN')}</div>`;

          // 4. 互动区 (点赞和评论)
          let interactionsHTML = '';
          if ((post.likes && post.likes.length > 0) || (post.comments && post.comments.length > 0)) {
            let likesHTML = '';
            if (post.likes && post.likes.length > 0) {
              const likerNames = post.likes.map(charId => getCharacterById(charId)?.name || '未知').join('、');
              // 哼，看好了，心脏移植手术就在这里
              const heartSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: -2px; margin-right: 5px;"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`;
              likesHTML = `<div class="post-likes">${heartSvg} ${likerNames}</div>`;
            }

            let commentsHTML = '';
            if (post.comments && post.comments.length > 0) {
              const commentsList = post.comments.map(comment => {
                const commentAuthor = getCharacterById(comment.authorId)?.name || '未知';
                return `<div class="post-comment"><span class="comment-author">${commentAuthor}</span>: ${comment.content}</div>`;
              }).join('');
              commentsHTML = `<div class="post-comments-container">${commentsList}</div>`;
            }

            interactionsHTML = `
        <div class="post-interactions">
          ${likesHTML}
          ${commentsHTML}
        </div>
      `;
          }

          const postBodyHTML = `<div class="post-body">${contentHTML}${imageHTML}${songCardHTML}</div>`;
          postEl.innerHTML = headerHTML + postBodyHTML + timestampHTML + interactionsHTML;

          if (post.type === 'music' && post.playableUrl) {
            const songCard = postEl.querySelector('.music-post-song-card');
            if (songCard) {
              songCard.addEventListener('click', function () {
                const songData = { id: post.id, url: post.playableUrl };
                handleMusicCardClick(this, songData);
              });
            }
          }
          container.appendChild(postEl);
        });
      }



      // --- Noir's Time Functions ---
      // --- Noir's Grand Refactor: Friend Circle Event Listeners ---
      document.getElementById('clear-feed-button').addEventListener('click', clearCurrentFeed);
      document.getElementById('refresh-feed-button').addEventListener('click', refreshFeed);
      document.getElementById('back-to-home-from-circle-list').addEventListener('click', () => showScreen('home', 'friendCircleList'));
      document.getElementById('add-friend-circle-button').addEventListener('click', () => openFriendCircleEditor());
      document.getElementById('back-to-circle-list-from-edit').addEventListener('click', () => showScreen('friendCircleList', 'friendCircleEdit'));
      document.getElementById('save-friend-circle-button').addEventListener('click', saveFriendCircle);
      document.getElementById('delete-friend-circle-button').addEventListener('click', deleteFriendCircle);
      document.getElementById('back-to-circle-list-from-feed').addEventListener('click', () => {
        renderFriendCircleList(); // 返回列表时重新渲染一下
        showScreen('friendCircleList', 'music');
      });
      document.getElementById('edit-current-circle-button').addEventListener('click', () => {
        if (state.activeFriendCircleId) {
          openFriendCircleEditor(state.activeFriendCircleId);
        }
      });

      //我没找到

      // ▼▼▼ Noir's Grand Refactor: User Post Sending Logic ▼▼▼
      document.getElementById('user-send-post-button').addEventListener('click', async () => {
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);
        if (!activeCircle || state.isGenerating) return;

        // 哼，看好了，这次的逻辑无懈可击
        // 1. 明确找出这个圈子绑定的用户ID
        const boundUserId = activeCircle.boundUserProfileId;
        // 2. 根据这个ID找出正确的用户
        const userForThisPost = state.userProfiles.find(up => up.id === boundUserId);

        // 3. 如果找不到（虽然不应该），就发出警报并停止
        if (!userForThisPost) {
          modalAlert('错误：找不到此好友圈绑定的用户！');
          return;
        }

        const textContent = document.getElementById('user-post-textarea').value.trim();
        const imageContent = state.pendingPostAttachments.image;
        const musicContent = state.pendingPostAttachments.music;
        const imageIdContent = state.pendingPostAttachments.imageId;

        if (!textContent && !imageContent && !musicContent) {
          modalAlert('总得说点什么吧？');
          return;
        }

        // 4. 用【绝对正确】的用户信息创建帖子
        const newPost = {
          id: `post_user_${Date.now()}`,
          authorType: 'user',
          authorId: userForThisPost.id, // <-- 看，用的是正确的ID
          content: textContent,
          timestamp: Date.now(),
          likes: [],
          comments: []
        };

        if (imageIdContent) {
          newPost.imageId = imageIdContent;
        } else if (imageContent) { // 兼容一下可能存在的旧数据
          newPost.image = imageContent;
        }
        if (musicContent) {
          newPost.type = 'music';
          Object.assign(newPost, musicContent);
        } else {
          newPost.type = 'text';
        }

        activeCircle.posts.push(newPost);
        saveState();
        renderFeed();

        document.getElementById('user-post-textarea').value = '';
        state.pendingPostAttachments.image = null;
        state.pendingPostAttachments.music = null;
        state.pendingPostAttachments.imageId = null;
        renderPostAttachmentPreview();

        generatePostReplies(newPost);
      });
      document.getElementById('user-post-image-button').addEventListener('click', () => {
        document.getElementById('user-post-image-input').click();
      });

      document.getElementById('user-post-image-input').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          // 哼，同样是压缩并获取文件本身(Blob)
          const compressedBlob = await compressImage(file, 800, 0.8, true);
          const imageId = `post_image_${Date.now()}`;
          // 存进“动物园”
          await dbSet(imageId, compressedBlob);

          // 记录“门票”，而不是大象本身
          state.pendingPostAttachments.imageId = imageId;
          state.pendingPostAttachments.image = null; // 把旧的通道关了
          state.pendingPostAttachments.music = null;
          renderPostAttachmentPreview();
        } catch (error) {
          modalAlert(`图片处理失败: ${error.message}`);
        }
        e.target.value = '';
      });


      document.getElementById('user-post-music-button').addEventListener('click', async () => {
        const musicData = await showMusicShareModal();
        if (!musicData) return;

        modalAlert('正在搜索音乐...');
        try {
          const musicInfo = await findPlayableMusicUrl(musicData.songName, musicData.artist);
          state.pendingPostAttachments.music = {
            songName: musicData.songName,
            artist: musicData.artist,
            coverUrl: musicInfo.cover,
            playableUrl: musicInfo.url
          };
          state.pendingPostAttachments.image = null; // 图片和音乐只能选一个
          renderPostAttachmentPreview();
        } catch (error) {
          modalAlert(`音乐搜索失败: ${error.message}`);
        }
      });
      //我没找到，就放在这里了
      // --- End of Event Listeners ---
      function updateClock() {
        const now = new Date();
        const timeEl = document.getElementById('home-time');
        const dateEl = document.getElementById('home-date');

        if (timeEl && dateEl) {
          const hours = String(now.getHours()).padStart(2, '0');
          const minutes = String(now.getMinutes()).padStart(2, '0');
          timeEl.textContent = `${hours}:${minutes}`;

          const month = now.getMonth() + 1;
          const day = now.getDate();
          const weekday = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'][now.getDay()];
          dateEl.textContent = `${month}月${day}日 ${weekday}`;
        }
      }

      function formatTimestamp(timestamp) {
        if (!timestamp) return '';
        const date = new Date(timestamp);
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        return `${hours}:${minutes}`;
      }

      //条条:是这里开始吗?
      // Noir's New Global Feed Memory System
      function getGlobalFeedMemory() {
        // ▼▼▼ Noir's Fix: 从新的好友圈数据结构中读取动态 ▼▼▼
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);
        const allPosts = activeCircle ? activeCircle.posts : [];
        // ▲▲▲ End of Fix ▲▲▲

        if (!allPosts || allPosts.length === 0) {
          return ""; // 如果朋友圈是空的，就直接返回
        }

        // 只看最近的5条动态
        const recentPosts = allPosts.slice(0, 5);

        const memoryLines = recentPosts.map(post => {
          const author = getCharacterById(post.authorId) || { name: '未知' };
          let line = `- [动态] ${author.name} 说：“${post.thought || post.content}”`;
          if (post.type === 'music') {
            line += ` (分享了歌曲: ${post.songName} - ${post.artist})`;
          }
          return line;
        });

        // 把这些信息整理好，加个标题
        return `\n# 最近的朋友圈动态 (供你参考)\n${memoryLines.join('\n')}`;
      }
      // --- Noir's Music Functions ---
      // 哼，这是我专门开辟的日记记忆区
      // 哼，这是我专门开辟的日记记忆区
      function getDiaryMemory(characterId) {
        const activeUser = state.userProfiles.find(up => up.id === state.activeUserProfileId) || { name: "你" };
        const diary = state.diaries.find(d => d.characterId === characterId);
        if (!diary || !diary.entries || diary.entries.length === 0) {
          return ""; // 日记本是空的，没什么可记的
        }

        // 仍然只看最近的8篇日记，这是防止撑爆的最后底线！
        const recentEntries = diary.entries.slice(-8);

        const memoryLines = recentEntries.map(entry => {
          const authorName = entry.author === 'user' ? activeUser.name : getCharacterById(entry.author).name;
          //const contentSnippet = entry.content.length > 150 ? entry.content.substring(0, 150) + '...' : entry.content;
          return `- [${new Date(entry.timestamp).toLocaleDateString()}] ${authorName} 写道: ${entry.content}`; // 直接用完整的 entry.content
        }).join('\n');

        // 打上一个醒目的标签，AI就不会认错了
        return `\n# 交换日记摘要 (你和 ${activeUser.name} 之间的私密内容)\n${memoryLines}`;
      }
      // --- Noir's New Music Widget Renderer ---


      function applyWidgetTheme() {
        const widgetCard = document.getElementById('music-widget-card');
        const bgImage = state.preferences.widgetBgImage;

        if (bgImage) {
          widgetCard.style.backgroundImage = `url(${bgImage})`;
          widgetCard.style.backgroundSize = 'cover';
          widgetCard.style.backgroundPosition = 'center';
          // 为了让文字在任何背景下都清晰，加上文字阴影
          widgetCard.style.color = 'white';
          widgetCard.querySelectorAll('.widget-info > div').forEach(el => {
            el.style.textShadow = '0 1px 3px rgba(0,0,0,0.6)';
          });
        } else {
          // 恢复默认
          widgetCard.style.backgroundImage = '';
          widgetCard.style.color = '';
          widgetCard.querySelectorAll('.widget-info > div').forEach(el => {
            el.style.textShadow = '';
          });
        }
      }

      // 新的导航和事件监听
      // 新的导航和事件监听
      const appMusic = document.getElementById('app-music');
      const appMeeting = document.getElementById('app-meeting');
      // ▼▼▼ Noir's Refactor: Update App Entry Point ▼▼▼
      // ▼▼▼ Noir's Fix: 每次进入都重新渲染列表 ▼▼▼
      appMusic.addEventListener('click', () => {
        // 现在点击“动态”App，会先渲染列表，再显示屏幕
        renderFriendCircleList(); // <-- 加上这一行！
        showScreen('friendCircleList', 'home');
      });
      // ▲▲▲ End of Fix ▲▲▲
      // ▲▲▲ End of Refactor ▲▲▲ -->
      // --- Noir's New Meeting App Listeners ---
      appMeeting.addEventListener('click', () => {
        renderMeetingCharacterList();
        showScreen('meetingList', 'home');
      });

      document.getElementById('back-to-home-from-meeting-list').addEventListener('click', () => {
        showScreen('home', 'meetingList');
      });

      document.getElementById('back-to-meeting-list').addEventListener('click', () => {
        // 离开见面界面时，清空当前见面角色，并重置activeChatId

        // ▼▼▼ Noir's Addition: Stop the Galgame Clock ▼▼▼
        if (galClockInterval) clearInterval(galClockInterval);
        galClockInterval = null;
        // ▲▲▲ End of Addition ▲▲▲

        // 哼，就是这句，把提词器上的鬼魂给我擦干净！
        state.activeMeetingScriptQueue = [];


        state.activeMeetingCharId = null;
        // ▼▼▼ Noir's Addition ▼▼▼
        document.getElementById('galgame-sprite-adjust-ui').style.display = 'none';
        // ▲▲▲ End of Addition ▲▲▲
        state.activeChatId = null;
        saveState();
        showScreen('meetingList', 'meetingView');
      });

      const meetingMessageInput = document.getElementById('meeting-message-input');
      const meetingSendButton = document.getElementById('meeting-send-button');

      meetingSendButton.addEventListener('click', () => {
        const text = meetingMessageInput.value.trim();
        if (text) {
          sendTextMessage(text); // 调用通用的发信函数
          meetingMessageInput.value = '';
          // 发送后立刻请求AI回复
          setTimeout(getAIResponse, 100);
        }
      });


      // --- End of New Listeners ---




      // --- Noir's New, Smarter Music Click Handler ---
      // 用这个替换旧的 handleMusicCardClick
      // 用这个【复古版】，替换掉旧的 handleMusicCardClick
      // ▼▼▼ Noir's Final Verdict: One Player to Rule Them All ▼▼▼
      function handleMusicCardClick(cardElement, songInfo) {
        // 哼，现在所有人都得听“全局总管”的
        const globalAudioPlayer = document.getElementById('unified-audio-player');
        const songToPlay = state.musicPlaylist.find(s => s.id === songInfo.id);

        // 如果连歌都找不到了，就别瞎忙活了
        if (!songToPlay) {
          console.error("Noir's Note: 播放列表里找不到这首歌，你是不是又偷偷动了什么？ ID:", songInfo.id);
          return;
        }

        // 检查是不是正在播放【同一首歌】
        const isCurrentlyPlayingThisSong = globalAudioPlayer.src.includes(songToPlay.playableUrl) && !globalAudioPlayer.paused;

        if (isCurrentlyPlayingThisSong) {
          // 如果是，就命令总管“暂停”
          globalAudioPlayer.pause();
        } else {
          // 如果不是，就正式向总管汇报，更新“大脑”里的当前歌曲信息
          currentlyPlayingSongInfo = {
            title: songToPlay.songName,
            artist: songToPlay.artist,
            cover: songToPlay.coverUrl || (songToPlay.coverId ? `db:${songToPlay.coverId}` : DEFAULT_AI_AVATAR),
            isFromLibrary: true
          };

          // 然后下达“播放”指令
          globalAudioPlayer.src = songToPlay.playableUrl;
          globalAudioPlayer.play();

          // 顺便告诉大脑，现在播放列表进行到哪了
          state.currentlyPlayingIndex = state.musicPlaylist.findIndex(s => s.id === songInfo.id);
          savePlayerState(); // 把这个决定存档
        }

        // 我什么都不用干了。总管的状态一变，他手下那些我们之前修好的“刷新工”就会自动去更新所有UI。这才是专业。
      }
      // ▲▲▲ Verdict Delivered ▲▲▲
      // --- Noir's Central Music Controller ---

      const playerBar = document.getElementById('music-player-bar');





      //我留一条
      // Noir's New Daily Post Function





      //免得找不到位置


      async function validateUrl(url) {
        if (!url || !url.startsWith('http')) return false;
        return new Promise(resolve => {
          const audio = document.createElement('audio');
          audio.src = url;
          const timeout = setTimeout(() => {
            cleanup();
            resolve(false);
          }, 3000); // 3秒超时

          const cleanup = () => {
            clearTimeout(timeout);
            audio.removeEventListener('canplaythrough', onSuccess);
            audio.removeEventListener('error', onError);
            audio.src = '';
            audio.remove();
          };

          const onSuccess = () => { cleanup(); resolve(true); };
          const onError = () => { cleanup(); resolve(false); };

          audio.addEventListener('canplaythrough', onSuccess);
          audio.addEventListener('error', onError);
        });
      }

      async function findPlayableMusicUrl(songName, artist) {
        const sources = ['netease', 'tencent'];
        for (const source of sources) {
          try {
            // 第一步: 搜索
            const searchUrl = `https://api.vkeys.cn/v2/music/${source}?word=${encodeURIComponent(songName)}-${encodeURIComponent(artist)}`;
            const searchRes = await fetch(searchUrl);
            const searchData = await searchRes.json();
            if (searchData.code !== 200 || !searchData.data || searchData.data.length === 0) continue;

            const items = searchData.data.slice(0, 5); // 只尝试前5个结果

            // 第二、三、四步: 遍历ID并验证
            for (const item of items) {
              const detailUrl = `https://api.vkeys.cn/v2/music/${source}?id=${item.id}`;
              const detailRes = await fetch(detailUrl);
              const detailData = await detailRes.json();
              const playableUrl = detailData.data?.url;

              if (await validateUrl(playableUrl)) {
                return { url: playableUrl, cover: item.cover, source: source };
              }
            }
          } catch (error) {
            console.error(`Error fetching from ${source}:`, error);
          }
        }
        // 所有源都失败了
        return { url: null, cover: null, source: null };
      }

      //条条:我找不到
      // ==========================================================
      // --- Noir's Ultimate UI Scaler v2.0 (Item-Specific) ---
      // 哼，这才叫指哪打哪。
      // ==========================================================
      // ==========================================================
      // --- Noir's Ultimate UI Scaler v2.1 (Surgical Placement) ---
      // 哼，这次看你还怎么搞错。
      // ==========================================================
      // ==========================================================
      // --- Noir's Ultimate UI Scaler v2.2 (With Reset Button) ---
      // 哼，给你加了后悔药。
      // ==========================================================
      function loadAndApplyUIScale() {
        const scaleSlider = document.getElementById('ui-scale-slider');
        const rootElement = document.documentElement;
        const resetButton = document.getElementById('reset-ui-scale-button'); // <-- 看，我找到后悔药了

        if (!scaleSlider || !resetButton) return;

        const savedScale = localStorage.getItem('uiScale') || '1';

        rootElement.style.setProperty('--desktop-item-scale', savedScale);
        scaleSlider.value = savedScale;

        // 这是滑块的指令
        scaleSlider.addEventListener('input', () => {
          const newScale = scaleSlider.value;
          rootElement.style.setProperty('--desktop-item-scale', newScale);
          localStorage.setItem('uiScale', newScale);
        });

        // ▼▼▼ 哼，这就是后悔药的说明书 ▼▼▼
        resetButton.addEventListener('click', () => {
          const defaultScale = '1';
          // 1. 把滑块给我拨回中间
          scaleSlider.value = defaultScale;
          // 2. 命令所有组件恢复原状
          rootElement.style.setProperty('--desktop-item-scale', defaultScale);
          // 3. 把你的“后悔”也记在小本本上
          localStorage.setItem('uiScale', defaultScale);
        });
      }
      // --- Noir's Badge Logic ---
      function saveBadgeState(data) {
        try {
          const currentBadgeState = JSON.parse(localStorage.getItem('badgeState') || '{}');
          const newBadgeState = { ...currentBadgeState, ...data };
          localStorage.setItem('badgeState', JSON.stringify(newBadgeState));
        } catch (e) { console.error("保存徽章状态失败", e); }
      }

      async function loadBadgeState() {
        const badge = document.getElementById('decorative-badge');
        const badgeImage = document.getElementById('badge-image');
        try {
          let imageBlob = await dbGet('widget_badge');

          if (!imageBlob) {
            const oldState = JSON.parse(localStorage.getItem('badgeState') || '{}');
            if (oldState.image) {
              imageBlob = await base64ToBlob(oldState.image);
              await dbSet('widget_badge', imageBlob);
            }
          }

          if (imageBlob) {
            badgeImage.src = URL.createObjectURL(imageBlob);
            badgeImage.style.display = 'block'; // 有图就显示图片
            badge.style.border = 'none'; // 去掉占位符边框
          } else {
            badgeImage.style.display = 'none'; // 没图就藏起来
            badge.style.border = '2px dashed var(--border-color)'; // 显示占位符边框
          }
          badge.style.display = 'block'; // 徽章容器本身总是要显示的
        } catch (e) { console.error("加载徽章图片失败", e); }
      }

      async function loadCardState() {
        const card = document.getElementById('card-widget');
        const cardImage = document.getElementById('card-image');
        const card2 = document.getElementById('card-widget-2');
        const cardImage2 = document.getElementById('card-image-2');

        try {
          // --- 第一个卡片的逻辑 ---
          let imageBlob1 = await dbGet('widget_card');
          if (imageBlob1) {
            cardImage.src = URL.createObjectURL(imageBlob1);
            cardImage.style.display = 'block'; // ▼▼▼ 核心修复：只有在有图时才让它显示 ▼▼▼
            card.style.border = 'none';
            card.style.background = 'transparent';
          } else {
            cardImage.style.display = 'none'; // 没图就继续藏着
            card.style.border = '2px dashed var(--border-color)';
            card.style.background = 'rgba(255,255,255,0.2)';
          }
          card.style.display = 'block';

          // --- 第二个卡片的逻辑 (现在完全一样了) ---
          let imageBlob2 = await dbGet('widget_card_2');
          if (imageBlob2) {
            cardImage2.src = URL.createObjectURL(imageBlob2);
            cardImage2.style.display = 'block'; // ▼▼▼ 核心修复：只有在有图时才让它显示 ▼▼▼
            card2.style.border = 'none';
            card2.style.background = 'transparent';
          } else {
            cardImage2.style.display = 'none'; // 没图就继续藏着
            card2.style.border = '2px dashed var(--border-color)';
            card2.style.background = 'rgba(255,255,255,0.2)';
          }
          card2.style.display = 'block';

        } catch (e) { console.error("加载卡片图片失败", e); }
      }


      // 新版卡片加载器（带自动搬家）
      async function loadCardState() {
        const card = document.getElementById('card-widget');
        const cardImage = document.getElementById('card-image');
        try {
          let imageBlob = await dbGet('widget_card');

          if (!imageBlob) {
            const oldState = JSON.parse(localStorage.getItem('cardWidgetState') || '{}');
            if (oldState.image) {
              console.log('正在搬运旧卡片...');
              imageBlob = await base64ToBlob(oldState.image);
              await dbSet('widget_card', imageBlob);
            }
          }

          if (imageBlob) {
            cardImage.src = URL.createObjectURL(imageBlob);
            card.style.display = 'block';
          } else {
            // 哼，默认卡片也给你安排好了
            card.style.display = 'none'; // <-- 改成 'none'，它就不敢出来了
          }
        } catch (e) { console.error("加载卡片图片失败", e); }

        // ▼▼▼【看这里！下面这一整块都是我新增的！】▼▼▼
        // --- 这是给第二个卡片新增的加载逻辑 ---
        try {
          let imageBlob2 = await dbGet('widget_card_2'); // 从一个叫'widget_card_2'的新仓库取货
          const cardImage2 = document.getElementById('card-image-2');
          const card2 = document.getElementById('card-widget-2');

          if (imageBlob2) {
            cardImage2.src = URL.createObjectURL(imageBlob2); // 把图片放进第二个卡片的img标签
            card2.style.display = 'block'; // 让第二个卡片显示出来
          } else {
            card2.style.display = 'none'; // 如果没设置图片，就先藏起来
          }
        } catch (e) { console.error("加载第二个卡片图片失败", e); }
      }




      // --- Noir's New User Profile Navigation & Actions ---
      appUserProfiles.addEventListener('click', () => {
        renderUserProfileList();
        showScreen('userProfileList', 'home');
      });
      document.getElementById('back-to-home-from-user-list').addEventListener('click', () => showScreen('home', 'userProfileList'));
      document.getElementById('add-user-profile-button').addEventListener('click', () => openUserProfileEditor());
      document.getElementById('back-to-user-list-from-edit').addEventListener('click', () => {
        renderUserProfileList();
        showScreen('userProfileList', 'userProfile');
      });
      // 替换旧的 saveUserProfileButton 监听
      document.getElementById('save-user-profile-button').addEventListener('click', saveUserProfile);
      document.getElementById('delete-user-profile-button').addEventListener('click', deleteUserProfile);
      document.getElementById('set-active-user-button').addEventListener('click', () => {
        const userId = document.getElementById('editing-user-id').value;
        if (userId) {
          state.activeUserProfileId = userId;
          saveState();
          modalAlert('已设为当前用户！');
          renderUserProfileList(); // 重新渲染列表以更新“(当前)”标识
          document.getElementById('set-active-user-button').style.display = 'none';
        }
      });



      function getBoundUserForChat(chatId) {
        const chat = state.chats.find(c => c.id === chatId);
        const boundId = chat?.boundUserProfileId;

        // 这一步就是被你撕掉的菜谱！
        let user = state.userProfiles.find(up => up.id === boundId);

        // 这也是被撕掉的！
        if (!user) {
          user = state.userProfiles.find(up => up.id === state.activeUserProfileId) || state.userProfiles[0];
        }

        // 现在他手里有菜了，可以端上来了
        return user || { name: '用户', avatar: DEFAULT_USER_AVATAR, persona: '' };
      }

      // 把剪切的函数粘贴在这里，让它成为一个独立的函数
      function populateUserDropdown(selectElementId) {
        const select = document.getElementById(selectElementId);
        select.innerHTML = '';
        state.userProfiles.forEach(up => {
          const option = document.createElement('option');
          option.value = up.id;
          option.textContent = up.name;
          select.appendChild(option);
        });
      }

      // ... (后面是其他的函数)

      // ==========================================================
      // --- Noir's Chat Customization System ---
      // ==========================================================
      // ▼▼▼ Noir's Super-Smart CSS Translator (The REAL one!) ▼▼▼
      function applyCharacterChatSettings(characterId) {
        const character = getCharacterById(characterId);
        const chatViewPane = document.getElementById('chat-view-pane');

        // 1. 清理旧样式 (这部分没变)
        chatViewPane.style.backgroundImage = '';
        let oldStyleTag = document.getElementById(`style-${characterId}`);
        if (oldStyleTag) oldStyleTag.innerHTML = '';

        if (!character) return;

        // 2. 应用壁纸 (这部分也没变)
        if (character.chatWallpaper) {
          chatViewPane.style.backgroundImage = `url('${character.chatWallpaper}')`;
          chatViewPane.style.backgroundSize = 'cover';
          chatViewPane.style.backgroundPosition = 'center';
        }

        // 3. 应用新的、需要“翻译”的气泡CSS (看这里！这才是正确的逻辑！)
        if (character.bubbleCss) {
          let styleTag = document.getElementById(`style-${character.id}`);
          if (!styleTag) {
            styleTag = document.createElement('style');
            styleTag.id = `style-${character.id}`;
            document.head.appendChild(styleTag);
          }

          // 哼，看好了，这就是翻译魔法的核心！
          // 它会把你粘贴进来的通用样式，自动转换成只对当前聊天生效的专属样式
          const rawCss = character.bubbleCss;
          const translatedCss = rawCss
            .replace(/\.bubble\.sent/g, `.bubble-${character.id}.message.user`)
            .replace(/\.bubble\.received/g, `.bubble-${character.id}.message.ai`);

          styleTag.innerHTML = translatedCss;
        }
      }


      // ▼▼▼ Noir's New Helper: Render Post Attachment Preview ▼▼▼
      // ▼▼▼ Noir's All-Seeing Secretary v2.0 (Now Reads Receipts!) ▼▼▼
      // 哼，用这个新版本，完整替换掉你旧的 renderPostAttachmentPreview 函数
      function renderPostAttachmentPreview() {
        const container = document.getElementById('user-post-attachment-preview');
        container.innerHTML = '';

        const removeAttachment = (type) => {
          state.pendingPostAttachments[type] = null;
          if (type === 'image') state.pendingPostAttachments.imageId = null; // 哼，别忘了把收据也撕掉
          renderPostAttachmentPreview();
        };

        // --- 哼，看好了，这就是新秘书的工作流程 ---
        const imageId = state.pendingPostAttachments.imageId;
        const music = state.pendingPostAttachments.music;

        if (imageId) {
          const item = document.createElement('div');
          item.className = 'preview-item';
          // 先放一个空的图片占位符
          item.innerHTML = `
            <img id="pending-post-image-preview" src="" alt="图片预览加载中...">
            <button class="remove-attachment-btn">&times;</button>
        `;
          item.querySelector('.remove-attachment-btn').onclick = () => removeAttachment('image');
          container.appendChild(item);

          // 然后，拿着收据去动物园把大象牵出来给你看
          dbGet(imageId).then(blob => {
            const imgElement = document.getElementById('pending-post-image-preview');
            if (imgElement && blob) {
              imgElement.src = URL.createObjectURL(blob);
            }
          });
        }

        if (music) {
          const item = document.createElement('div');
          item.className = 'preview-item';
          item.innerHTML = `
            <div class="music-preview-card">
                <img src="${music.coverUrl || DEFAULT_AI_AVATAR}">
                <div class="info">
                    <div>${music.songName}</div>
                    <div style="opacity: 0.7;">${music.artist}</div>
                </div>
            </div>
            <button class="remove-attachment-btn">&times;</button>
        `;
          item.querySelector('.remove-attachment-btn').onclick = () => removeAttachment('music');
          container.appendChild(item);
        }
      }
      // ▼▼▼ Noir's New Brain: Generate Replies to User's Post ▼▼▼
      // ▼▼▼ Noir's New Brain (With Eyes!): Generate Replies to User's Post ▼▼▼
      // ▼▼▼ Noir's New Brain (With Eyes!): Generate Replies to User's Post (Noir's Patched Version) ▼▼▼
      // ▼▼▼ Noir's Ultimate All-Seeing Eye v3.0 (FINAL PATCH) ▼▼▼
      // 哼，用这个新版本，完整替换掉你旧的 generatePostReplies 函数
      async function generatePostReplies(userPost) {
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);
        if (!activeCircle) return;

        showFeedLoader(true, '大家正在赶来回复...');
        state.isGenerating = true;

        try {
          const members = activeCircle.memberCharacterIds.map(id => getCharacterById(id)).filter(Boolean);
          const globalFeedMemory = getGlobalFeedMemory();

          const memberInfo = members.map(char => {
            const { omniText: chatMemory } = gatherOmniTranscriptForCharacter(char.id, null); // Null to get all chats
            const diaryMemory = getDiaryMemory(char.id);
            const privateWorldBookContext = (char.linkedWorldBookIds && char.linkedWorldBookIds.length > 0)
              ? `\n\n# ${char.name}的个人专属世界观设定\n` + char.linkedWorldBookIds
                .map(wbId => state.worldBooks.find(book => book.id === wbId))
                .filter(Boolean)
                .map(wb => `\n## 条目: ${wb.name}\n${wb.content}`)
                .join('')
              : '';
            return `- 姓名: ${char.name}, ID: ${char.id}\n  人设: ${char.persona}\n  相关记忆:\n${chatMemory}\n${diaryMemory}\n${privateWorldBookContext}`;
          }).join('\n\n');

          const postAuthor = getUserProfileById(userPost.authorId) || { name: '用户' };
          const userContext = postAuthor.persona ? `
# 发布动态的用户信息
- 姓名: ${postAuthor.name}
- 人设: ${postAuthor.persona}
` : '';

          // --- 哼，看好了，从这里开始改造 ---
          let imageBase64 = null;
          if (userPost.image) { // 为了兼容你那些还没净化的旧数据
            imageBase64 = userPost.image;
          } else if (userPost.imageId) { // 这才是为新数据准备的
            try {
              const blob = await dbGet(userPost.imageId);
              if (blob) {
                imageBase64 = await blobToBase64(blob);
              }
            } catch (e) {
              console.error("在准备动态回复时，读取图片失败:", e);
            }
          }

          let postContentDescription = `${postAuthor.name}刚刚发布了一条动态，内容是：“${userPost.content}”`;
          if (imageBase64) { // 现在AI真的能“看到”图片了
            postContentDescription += " [并附上了一张图片]";
          }
          if (userPost.type === 'music') {
            postContentDescription += ` [并分享了歌曲: ${userPost.songName} - ${userPost.artist}]`;
          }
          // --- 改造结束 ---

          const systemPrompt = `
# 核心任务
你是一个多角色社交模拟引擎。用户刚刚发了一条动态，你需要为好友圈里的【每一位】其他成员生成对这条动态的回应（点赞和评论）。如果用户的动态包含图片，你必须根据图片内容进行回应。

# 好友圈成员
${memberInfo}

${userContext}

# 最近的动态回顾 (供参考)
${globalFeedMemory}

# 用户的动态
${postContentDescription}

# 任务要求
1.  **全局视角**: 扮演所有成员，思考他们看到这条动态（包括图片）后会作何反应。
2.  **生成互动**: 为每个角色决定是否点赞，以及要发表什么评论。评论必须符合角色性格并与所有已知信息（聊天、日记等）相关联。
3.  **输出格式**: 你的输出必须是一个单一、完整的JSON对象，结构如下:
    \`\`\`json
    {
      "likes": ["点赞者1的ID", "点赞者2的ID"],
      "comments": [
        { "authorId": "评论者A的ID", "content": "评论内容" },
        { "authorId": "评论者B的ID", "content": "另一条评论" }
      ]
    }
    \`\`\`
- 【绝对规则】: 所有ID必须使用上面提供的角色ID，不能用名字。
- 绝对不要输出任何JSON之外的文字、解释或Markdown标记。
`;
          const messages = [{ role: 'system', content: systemPrompt }];

          const finalUserMessage = {
            role: 'user',
            content: '请根据以上所有规则（特别是要看图！），生成对用户动态的回应。'
          };

          // 把准备好的照片放进最终简报
          if (imageBase64) {
            finalUserMessage.image = imageBase64;
          }

          messages.push(finalUserMessage);

          const response = await fetchAICompletion(messages, { json: true });
          const jsonMatch = response.match(/({[\s\S]*})/);
          if (!jsonMatch) throw new Error("AI未能返回有效的JSON对象。");

          const interactionData = JSON.parse(jsonMatch[1]);

          const postInState = activeCircle.posts.find(p => p.id === userPost.id);
          if (postInState) {
            postInState.likes = interactionData.likes || [];
            postInState.comments = (interactionData.comments || []).map((c, i) => ({
              ...c,
              commentId: `c_${userPost.timestamp}_${i}`
            }));
            saveState();
            renderFeed();
          }

        } catch (error) {
          console.error("生成动态回复失败:", error);
          modalAlert('大家好像不知道该怎么回复...');
        } finally {
          showFeedLoader(false);
          state.isGenerating = false;
        }
      }
      // ▼▼▼ Noir's New UI Updater: Populate User Avatar in Post Area ▼▼▼
      // ▼▼▼ Noir's New UI Updater: Populate User Avatar in Post Area ▼▼▼
      // ▼▼▼ Noir's New UI Updater: Populate User Avatar in Post Area (v2.0 Brain-Implanted Edition) ▼▼▼
      function updateUserPostAreaAvatar() {
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);

        // 哼，先从好友圈自己的通行证上找人
        const boundUserId = activeCircle?.boundUserProfileId;
        let userForAvatar = state.userProfiles.find(up => up.id === boundUserId);

        // 如果通行证是伪造的（或者没有），再去看大老板是谁
        if (!userForAvatar) {
          userForAvatar = state.userProfiles.find(up => up.id === state.activeUserProfileId);
        }

        // 再找不到，就随便抓一个来顶替
        if (!userForAvatar) {
          userForAvatar = state.userProfiles[0];
        }

        if (userForAvatar) {
          document.getElementById('user-post-avatar').src = userForAvatar.avatar || DEFAULT_USER_AVATAR;
        }
      }      // ▼▼▼ Noir's Color Magic: HEX to HSL Converter ▼▼▼
      function hexToHsl(hex) {
        let r = 0, g = 0, b = 0;
        if (hex.length == 4) {
          r = "0x" + hex[1] + hex[1];
          g = "0x" + hex[2] + hex[2];
          b = "0x" + hex[3] + hex[3];
        } else if (hex.length == 7) {
          r = "0x" + hex[1] + hex[2];
          g = "0x" + hex[3] + hex[4];
          b = "0x" + hex[5] + hex[6];
        }
        r /= 255; g /= 255; b /= 255;
        let cmin = Math.min(r, g, b), cmax = Math.max(r, g, b), delta = cmax - cmin, h = 0, s = 0, l = 0;
        if (delta == 0) h = 0;
        else if (cmax == r) h = ((g - b) / delta) % 6;
        else if (cmax == g) h = (b - r) / delta + 2;
        else h = (r - g) / delta + 4;
        h = Math.round(h * 60);
        if (h < 0) h += 360;
        l = (cmax + cmin) / 2;
        s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
        s = +(s * 100).toFixed(1);
        l = +(l * 100).toFixed(1);
        return { h, s, l };
      }

      // ▼▼▼ Noir's Universal Draggable Logic ▼▼▼
      // ▼▼▼ Noir's Final & Perfect Draggable Logic ▼▼▼
      // ▼▼▼ Noir's Final, Perfect & Ultimate Draggable Logic v2.0 ▼▼▼
      // ▼▼▼ Noir's Final, Perfect & Ultimate Draggable Logic v2.0 ▼▼▼
      // ▼▼▼ Noir's Ultimate & Final Position Loader v3.0 (Now with Percentages!) ▼▼▼
      // ▼▼▼ Noir's Ultimate & Final Position Loader v3.0 (Now with Percentages!) ▼▼▼
      // ▼▼▼ Noir's Ultimate & Final Position Loader v3.0 (Now with Percentages!) ▼▼▼
      // ▼▼▼ Noir's Ultimate & Final Position Loader v3.0 (Now with Percentages!) ▼▼▼
      // ▼▼▼ Noir's Ultimate & Final Position Loader v6.0 (OCD-Proof VIP Channel) ▼▼▼

      // ▼▼▼ Noir's Ultimate & Final Position Loader v7.0 (Double VIP Channels) ▼▼▼
      function loadWidgetPositions() {
        // 这个辅助函数留给那些“普通”的可拖动组件用
        const applyPosition = (elementId, storageKey, defaultStyles) => {
          const el = document.getElementById(elementId);
          if (!el) return;
          let savedPos = null;
          try {
            savedPos = JSON.parse(localStorage.getItem(storageKey) || '{}');
          } catch { savedPos = {}; }
          el.style.position = 'absolute';
          el.style.top = ''; el.style.left = ''; el.style.right = ''; el.style.bottom = ''; el.style.transform = '';
          if (typeof savedPos.top === 'number' && typeof savedPos.left === 'number') {
            el.style.top = savedPos.top + '%';
            el.style.left = savedPos.left + '%';
          } else {
            for (const style in defaultStyles) { el.style[style] = defaultStyles[style]; }
          }
        };

        /* --- 哼，除了VIP，其他人都照旧排队 --- */
        applyPosition('home-clock-container', 'clockPosition', { top: '15%', left: '50%', transform: 'translateX(-50%)' });
        applyPosition('app-wallpaper', `appIconPosition_app-wallpaper`, { top: '20%', right: '4%' });
        applyPosition('app-user-profiles', `appIconPosition_app-user-profiles`, { top: '20%', right: '28%' });
        applyPosition('app-settings', `appIconPosition_app-settings`, { top: '8%', right: '28%' });
        applyPosition('app-world-book', `appIconPosition_app-world-book`, { top: '8%', right: '4%' });
        applyPosition('app-music-library', `appIconPosition_app-music-library`, { top: '59%', left: '5%' });
        applyPosition('app-diary', `appIconPosition_app-diary`, { top: '71%', left: '29%' });
        applyPosition('app-snoop', `appIconPosition_app-snoop`, { top: '71%', left: '5%' });
        applyPosition('app-accounting', `appIconPosition_app-accounting`, { top: '59%', left: '29%' });
        applyPosition('decorative-badge', 'badgeState', { top: '60%', right: '5%' });
        applyPosition('card-widget-2', 'cardState2', { top: '8%', left: '5%' });

        // --- 哼，这是给你那个“强迫症”卡片的专属VIP通道 (第二页) ---
        const cardWidget = document.getElementById('card-widget');
        if (cardWidget) {
          cardWidget.style.position = 'absolute';
          cardWidget.style.top = '34%';
          cardWidget.style.left = '50%';
          cardWidget.style.transform = 'translateX(-50%)';
          cardWidget.style.display = 'block';
        }

        // --- 哼，这是给音乐小组件的新VIP通道 (第一页) ---
        const musicWidget = document.getElementById('music-widget');
        if (musicWidget) {
          musicWidget.style.position = 'absolute';
          musicWidget.style.top = '35%'; // 它在第一页，位置可以不一样
          musicWidget.style.left = '50%';
          musicWidget.style.transform = 'translateX(-50%)';
          musicWidget.style.display = 'inline-block';
        }
      }
      // ▲▲▲ End of VIP Channels ▲▲▲

      // ▲▲▲ End of VIP Channel ▲▲▲
      // ▼▼▼ Noir's Final, Perfect & Ultimate Draggable Logic v3.0 (Percentage Power!) ▼▼▼
      // ▼▼▼ Noir's Ultimate & Final Draggable Logic v4.0 (Now with Snapping!) ▼▼▼
      // 找到 function makeElementDraggable(elementId, storageKey) { ... }
      // 把从 function 到它最后一个 } 的全部内容，换成下面这个
      // 找到 function makeElementDraggable(elementId, storageKey) { ... }
      // 把从 function 到它最后一个 } 的全部内容，换成下面这个【最终修复版】
      // ▼▼▼ Noir's Ultimate Ghostbuster Refactor v5.0 ▼▼▼
      // 哼，把你旧的、闹鬼的 makeElementDraggable 函数整个删掉，
      // 然后把下面这一整块代码，粘贴到同一个地方。

      function renderCustomIconSettings() {
        const container = document.getElementById('custom-icon-list-container');
        container.innerHTML = '';
        const appIcons = document.querySelectorAll('.app-icon');

        appIcons.forEach(iconEl => {
          const appId = iconEl.id;
          const appName = iconEl.querySelector('span').textContent;
          const storageKey = `customIcon_${appId}`;
          const savedIcon = localStorage.getItem(storageKey);

          const item = document.createElement('div');
          item.className = 'member-selection-item'; // 复用一下样式
          item.style.padding = '10px 0';

          item.innerHTML = `
              <img id="preview_${appId}" src="${savedIcon || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'}" class="char-avatar" style="border-radius: 12px; background-color: #eee;">
              <div class="char-name" style="flex-grow: 1;">${appName}</div>
              <input type="file" id="input_${appId}" accept="image/*" style="display: none;">
              <button class="form-button" style="width: auto; margin-top: 0; padding: 6px 12px;" onclick="document.getElementById('input_${appId}').click()">更换</button>
              <button class="form-button" style="width: auto; margin-top: 0; padding: 6px 12px; background-color: #777;" onclick="localStorage.removeItem('${storageKey}'); location.reload();">恢复</button>
            `;
          container.appendChild(item);

          const input = document.getElementById(`input_${appId}`);
          input.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            try {
              // 哼，当然要用我的压缩机
              const base64 = await handleAvatarUpload(file);
              localStorage.setItem(storageKey, base64);
              document.getElementById(`preview_${appId}`).src = base64;
              loadCustomIcons(); // 立即应用到主屏幕
            } catch (error) {
              modalAlert(`图标处理失败: ${error.message}`);
            }
          });
        });
      }

      // 这个函数负责在主屏幕加载你自定义的图标
      // 这个函数负责在主屏幕加载你自定义的图标
      function loadCustomIcons() {
        const appIcons = document.querySelectorAll('.app-icon');
        appIcons.forEach(iconEl => {
          const appId = iconEl.id;
          const storageKey = `customIcon_${appId}`;
          const savedIcon = localStorage.getItem(storageKey);
          const iconImgContainer = iconEl.querySelector('.app-icon-img');

          // 哼，就是这里。我给它加上了 display: block，并统一了圆角。
          if (savedIcon) {
            iconImgContainer.innerHTML = `<img src="${savedIcon}" style="width: 100%; height: 100%; border-radius: 22.5%; object-fit: cover; display: block;">`;
          } else {
            // 如果用户清除了自定义图标，确保这里能恢复成SVG
            const defaultSVG = document.querySelector(`#app-dock-bottom-left #${appId} .app-icon-img, #app-dock-top-right #${appId} .app-icon-img`)?.innerHTML;
            if (defaultSVG) {
              iconImgContainer.innerHTML = defaultSVG;
            }
          }
        });
      }      /** 1. 更新全局播放列表 */
      function updateGlobalPlaylist() {
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);
        const activeChat = getActiveChat();

        let allMusicMessages = [];

        // 从当前好友圈动态里收集音乐
        if (activeCircle && activeCircle.posts) {
          const circleMusic = activeCircle.posts
            .filter(p => p.type === 'music' && p.playableUrl)
            .map(p => ({ ...p, source: 'feed' }));
          allMusicMessages.push(...circleMusic);
        }

        // 从当前私聊/群聊里收集音乐
        // 从当前私聊/群聊里收集音乐
        if (activeChat && state.conversationHistory) {
          const chatMusic = state.conversationHistory
            .filter(msg => msg.type === 'music' && msg.playableUrl)
            // 哼，看好了，就是加上了这句，给每首歌一个和卡片上对应的身份证！
            .map(msg => ({ ...msg, id: `msg_${msg.timestamp}`, source: 'chat' }));
          allMusicMessages.push(...chatMusic);
        }

        // 去重并按时间排序
        const uniqueMusic = Array.from(new Map(allMusicMessages.map(item => [item.playableUrl, item])).values());
        state.musicPlaylist = uniqueMusic.sort((a, b) => b.timestamp - a.timestamp);
        //console.log(`播放列表已更新，共 ${state.musicPlaylist.length} 首歌曲。`);
      }

      /** 2. 播放指定索引的歌曲 */
      // 用这个替换旧的 playSongAtIndex
      function playSongAtIndex(index) {
        if (index < 0 || index >= globalPlaylist.length) return;

        currentPlaylistIndex = index;
        const song = globalPlaylist[index];

        // 哼，看好了，所有指令都发给全局播放器
        globalAudioPlayer.src = song.playableUrl || song.url;
        globalAudioPlayer.play();

        updateAllPlayerUIs();
        savePlayerState(); // 保存状态
      }



      /** 3. 统一更新所有播放器UI（小组件和底部播放条） */
      // 用这个替换旧的 updateAllPlayerUIs
      function updateAllPlayerUIs() {
        const song = state.musicPlaylist[state.currentlyPlayingIndex];
        const isPlaying = state.isPlaying;

        // 1. 更新主屏幕小组件 (你的代码没动)
        updateGlobalPlayerUI();

        // 2. 更新底部播放条 (这也是现成的)
        updateMusicPlayerBar();

        // 3. 【核心改造】巡视并更新页面上所有的音乐卡片图标
        const allMusicCards = document.querySelectorAll('.music-post-song-card, .music-share-card');

        allMusicCards.forEach(card => {
          const cardMusicId = card.dataset.musicId;
          const icon = card.querySelector('.music-post-play-icon, .music-share-play-icon');
          if (!icon) return;

          if (song && cardMusicId === song.id && isPlaying) {
            icon.textContent = '❚❚'; // 如果是正在播放的这首，就显示暂停
          } else {
            icon.textContent = '▶'; // 否则，就显示播放
          }
        });
      }

      // ▼▼▼ Noir's Fix: 播放器记忆系统 ▼▼▼
      function savePlayerState() {
        // 哼，给你个小本本，记好现在在放什么。
        try {
          localStorage.setItem('musicPlayerState', JSON.stringify({
            playlist: state.musicPlaylist,
            currentIndex: state.currentlyPlayingIndex
          }));
        } catch (e) {
          console.error("保存播放器状态失败，真是没用。", e);
        }
      }
      // ▲▲▲ End of Fix ▲▲▲
      // ▼▼▼ Noir's Fix: 播放器记忆系统 (读取部分) ▼▼▼
      function loadAndRestorePlayerState() {
        try {
          const saved = localStorage.getItem('musicPlayerState');
          if (saved) {
            const { playlist, currentIndex } = JSON.parse(saved);
            // 哼，检查一下记忆是不是乱码了。
            if (Array.isArray(playlist) && playlist.length > 0 && currentIndex > -1) {
              state.musicPlaylist = playlist;
              state.currentlyPlayingIndex = currentIndex;
              state.isPlaying = false; // 刚加载时总是暂停状态

              // 不用真的播放，把它摆出来就行了，真是麻烦。
              updateAllPlayerUIs();
            }
          }
        } catch (e) {
          console.error("切，加载播放器状态的时候出错了。", e);
        }
      }
      // ▲▲▲ End of Fix ▲▲▲

      // ==========================================================
      // --- Noir's Diary Interaction System ---
      // ==========================================================

      function handleDiaryInteraction(e) {
        // 哼，用这个来记录我的计时器，免得乱套
        if (window.diaryPressTimer) clearTimeout(window.diaryPressTimer);

        const entryElement = e.target.closest('.diary-entry');
        if (!entryElement) return;

        const timestamp = entryElement.dataset.timestamp;
        const authorType = entryElement.classList.contains('user') ? 'user' : 'ai';

        if (!timestamp) return;

        const startPress = () => {
          window.diaryPressTimer = setTimeout(() => {
            // 阻止触摸事件可能触发的滚动等默认行为
            if (e.type === 'touchstart') e.preventDefault();
            showDiaryActionModal(parseInt(timestamp, 10), authorType);
          }, 800); // 长按800毫秒，跟聊天一样
        };

        const cancelPress = () => {
          if (window.diaryPressTimer) clearTimeout(window.diaryPressTimer);
        };

        // 绑定事件，如果手指提前抬起，就取消菜单
        document.addEventListener('mouseup', cancelPress, { once: true });
        document.addEventListener('touchend', cancelPress, { once: true });
        document.addEventListener('touchcancel', cancelPress, { once: true });

        // 开始计时
        startPress();
      }

      function showDiaryActionModal(timestamp, authorType) {
        // 动态创建弹窗，免得污染HTML
        const modalId = `diary-action-modal-${timestamp}`;
        let existingModal = document.getElementById(modalId);
        if (existingModal) return;

        const modalHtml = `
    <div id="${modalId}" class="choice-modal show">
      <div class="choice-modal-backdrop"></div>
      <div class="choice-modal-content">
        <button id="diary-action-delete" class="choice-modal-button" style="color: #dc3545;">删除这篇日记</button>
        ${authorType === 'ai' ? '<button id="diary-action-reroll" class="choice-modal-button">重写</button>' : ''}
        <button id="diary-action-cancel" class="choice-modal-button cancel">取消</button>
      </div>
    </div>
  `;
        document.body.insertAdjacentHTML('beforeend', modalHtml);

        const modal = document.getElementById(modalId);
        const cleanup = () => modal.remove();

        modal.querySelector('.choice-modal-backdrop').onclick = cleanup;
        modal.querySelector('#diary-action-cancel').onclick = cleanup;
        modal.querySelector('#diary-action-delete').onclick = () => {
          handleDeleteDiaryEntry(timestamp);
          cleanup();
        };

        if (authorType === 'ai') {
          modal.querySelector('#diary-action-reroll').onclick = () => {
            handleRerollDiaryEntry(timestamp);
            cleanup();
          };
        }
      }

      async function handleDeleteDiaryEntry(timestamp) {
        const ok = await modalConfirm('确定要删除这篇日记吗？此操作不可撤销。');
        if (!ok) return;

        const diary = state.diaries.find(d => d.characterId === state.activeDiaryCharacterId);
        if (!diary) return;

        const entryIndex = diary.entries.findIndex(e => e.timestamp === timestamp);
        if (entryIndex > -1) {
          diary.entries.splice(entryIndex, 1);
          saveState();
          renderDiaryEntries(); // 刷新日记本
          modalAlert('日记已删除。');
        }
      }

      async function handleRerollDiaryEntry(timestamp) {
        const diary = state.diaries.find(d => d.characterId === state.activeDiaryCharacterId);
        if (!diary) return;

        const entryIndex = diary.entries.findIndex(e => e.timestamp === timestamp);
        if (entryIndex > -1) {
          // 先删掉，不提示
          diary.entries.splice(entryIndex, 1);
          saveState();
          renderDiaryEntries(); // 先刷新一次界面，让你看到旧的消失了

          // 然后立刻生成新的
          await generateDiaryEntry();
        }
      }
      // ==========================================================
      // --- Noir's Grand Diary Exchange System (v2.0 Page-Turning Edition) ---
      // ==========================================================

      function renderDiaryCharacterList() {
        const container = document.getElementById('diary-list-container');
        container.innerHTML = '';
        const privateChars = state.characters.filter(char =>
          state.chats.some(c => c.type === 'private' && c.participantIds.includes(char.id))
        );

        if (privateChars.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">还没有可以交换日记的对象。</p>';
          return;
        }

        privateChars.forEach(char => {
          const li = document.createElement('li');
          li.className = 'character-item';
          li.dataset.charId = char.id;
          // ▼▼▼ 哼，就是修改下面这块，加上一个删除按钮 ▼▼▼
          li.innerHTML = `
            <div class="char-info-wrapper">
                <img src="${char.avatar || DEFAULT_AI_AVATAR}" alt="avatar" class="char-avatar">
                <div class="char-info">
                    <div class="char-name">${char.name}</div>
                    <div class="char-remark">翻开日记本...</div>
                </div>
            </div>
            <button class="toolbar-button diary-delete-btn" title="清空这本日记">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
            </button>
        `;
          // ▲▲▲ 修改到这里为止 ▲▲▲

          li.addEventListener('click', () => {
            openDiaryView(char.id);
          });
          // ▼▼▼ 然后，在 li.addEventListener 下面，加上这段新的监听逻辑 ▼▼▼
          li.querySelector('.char-info-wrapper').addEventListener('click', () => {
            openDiaryView(char.id);
          });

          // 哼，就是这段，给垃圾桶装上灵魂
          li.querySelector('.diary-delete-btn').addEventListener('click', (e) => {
            e.stopPropagation(); // 防止点删除的时候还打开日记本，真是笨死了
            handleClearDiary(char.id);
          });
          // ▲▲▲ 新增到这里为止 ▲▲▲

          container.appendChild(li);
        });
      }

      function openDiaryView(charId) {
        const character = getCharacterById(charId);
        if (!character) return;

        state.activeDiaryCharacterId = charId;

        // 哼，看好了，就是这里，我加了自动计算最后一页的逻辑
        const diary = state.diaries.find(d => d.characterId === charId);
        const totalEntries = diary ? diary.entries.length : 0;
        const ENTRIES_PER_PAGE = 2;
        state.diaryCurrentPage = Math.max(0, Math.ceil(totalEntries / ENTRIES_PER_PAGE) - 1);

        document.getElementById('diary-char-name-header').textContent = `${character.name}的日记本`;

        renderDiaryEntries();
        showScreen('diaryView', 'diaryList');
      }

      function renderDiaryEntries() {
        const container = document.getElementById('diary-entries-container');
        const navigationContainer = document.getElementById('diary-input-wrapper');
        container.innerHTML = '';
        navigationContainer.innerHTML = '';

        const activeUser = getBoundUserForDiary() || { name: "我" };
        const diary = state.diaries.find(d => d.characterId === state.activeDiaryCharacterId);

        if (!diary || !diary.entries || diary.entries.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light); font-family: sans-serif; padding-top: 50px;">日记本还是空白的...</p>';
          navigationContainer.innerHTML = `
            <div id="diary-navigation" style="justify-content: space-around; width: 100%;">
                <button id="diary-write-button">写第一篇</button>
                <button id="diary-get-reply-button">催TA写</button>
            </div>
        `;
          document.getElementById('diary-write-button').addEventListener('click', showDiaryWriteModal);
          document.getElementById('diary-get-reply-button').addEventListener('click', generateDiaryEntry);
          return;
        }

        const ENTRIES_PER_PAGE = 2;
        const sortedEntries = [...diary.entries].sort((a, b) => a.timestamp - b.timestamp);
        const pages = [];
        for (let i = 0; i < sortedEntries.length; i += ENTRIES_PER_PAGE) {
          pages.push(sortedEntries.slice(i, i + ENTRIES_PER_PAGE));
        }
        const totalPages = pages.length;

        pages.forEach((pageEntries, index) => {
          const pageDiv = document.createElement('div');
          pageDiv.className = 'diary-page';
          pageDiv.id = `diary-page-${index}`;

          if (index === state.diaryCurrentPage) {
            pageDiv.classList.add('is-visible');
          }

          pageEntries.forEach(entry => {
            const authorType = entry.author === 'user' ? 'user' : 'ai';
            const authorName = entry.author === 'user' ? activeUser.name : getCharacterById(entry.author).name;
            const entryDiv = document.createElement('div');
            entryDiv.className = `diary-entry ${authorType}`;
            entryDiv.dataset.timestamp = entry.timestamp; // 哼，就是这行，给它打上门牌号
            entryDiv.style.borderBottom = 'none';
            entryDiv.style.paddingBottom = '0';
            entryDiv.innerHTML = `
                <div class="diary-author">${authorName}</div>
                <div class="diary-timestamp">${new Date(entry.timestamp).toLocaleString('zh-CN')}</div>
                <div class="diary-content">${entry.content.replace(/\n/g, '<br>')}</div>
            `;
            pageDiv.appendChild(entryDiv);
          });
          container.appendChild(pageDiv);
        });

        navigationContainer.innerHTML = `
        <div id="diary-navigation" style="display: grid; grid-template-columns: 1fr auto 1fr; width: 100%; align-items: center; padding: 0 10px; box-sizing: border-box;">
            <div style="display: flex; justify-content: flex-start; gap: 5px;">
                <button id="diary-prev-button">上一页</button>
                <button id="diary-write-button" style="background-color: var(--accent-color); color: white;">写日记</button>
            </div>
            <span id="diary-page-indicator">第 ${state.diaryCurrentPage + 1} / ${totalPages} 页</span>
            <div style="display: flex; justify-content: flex-end; gap: 5px;">
                <button id="diary-get-reply-button">催TA写</button>
                <button id="diary-next-button">下一页</button>
            </div>
        </div>
    `;

        document.getElementById('diary-prev-button').disabled = state.diaryCurrentPage === 0;
        document.getElementById('diary-next-button').disabled = state.diaryCurrentPage === totalPages - 1;

        document.getElementById('diary-prev-button').addEventListener('click', showPrevDiaryPage);
        document.getElementById('diary-next-button').addEventListener('click', showNextDiaryPage);
        document.getElementById('diary-write-button').addEventListener('click', showDiaryWriteModal);
        document.getElementById('diary-get-reply-button').addEventListener('click', generateDiaryEntry);
      }

      function showNextDiaryPage() {
        if (state.isAnimatingDiary) return;
        const currentPageIndex = state.diaryCurrentPage;
        const totalPages = Math.ceil(state.diaries.find(d => d.characterId === state.activeDiaryCharacterId).entries.length / 2);
        if (currentPageIndex >= totalPages - 1) return;

        state.isAnimatingDiary = true;
        const nextPageIndex = currentPageIndex + 1;

        const currentPageEl = document.getElementById(`diary-page-${currentPageIndex}`);
        const nextPageEl = document.getElementById(`diary-page-${nextPageIndex}`);

        if (currentPageEl && nextPageEl) {
          nextPageEl.classList.add('is-entering-from-right');
          currentPageEl.classList.add('is-exiting-left');

          // 关键一步：让新页面立刻可见以参与动画
          nextPageEl.classList.add('is-visible');

          setTimeout(() => {
            currentPageEl.classList.remove('is-visible', 'is-exiting-left');
            nextPageEl.classList.remove('is-entering-from-right');
            state.diaryCurrentPage = nextPageIndex;
            renderDiaryEntries(); // 动画结束后重绘导航
            state.isAnimatingDiary = false;
          }, 700); // 匹配CSS动画时长
        } else {
          state.isAnimatingDiary = false;
        }
      }

      function showPrevDiaryPage() {
        if (state.isAnimatingDiary) return;
        const currentPageIndex = state.diaryCurrentPage;
        if (currentPageIndex <= 0) return;

        state.isAnimatingDiary = true;
        const prevPageIndex = currentPageIndex - 1;

        const currentPageEl = document.getElementById(`diary-page-${currentPageIndex}`);
        const prevPageEl = document.getElementById(`diary-page-${prevPageIndex}`);

        if (currentPageEl && prevPageEl) {
          prevPageEl.classList.add('is-entering-from-left');
          currentPageEl.classList.add('is-exiting-right');

          prevPageEl.classList.add('is-visible');

          setTimeout(() => {
            currentPageEl.classList.remove('is-visible', 'is-exiting-right');
            prevPageEl.classList.remove('is-entering-from-left');
            state.diaryCurrentPage = prevPageIndex;
            renderDiaryEntries();
            state.isAnimatingDiary = false;
          }, 700);
        } else {
          state.isAnimatingDiary = false;
        }
      }

      function showDiaryWriteModal() {
        return new Promise(resolve => {
          // 复用已有的弹窗模态框，省事
          const modalHtml = `
            <div id="diary-write-modal" class="choice-modal show">
                <div class="choice-modal-backdrop"></div>
                <div class="choice-modal-content" style="padding: 20px; width: 90%; max-width: 350px;">
                    <h3 style="margin-top: 0; text-align: center; font-weight: 600;">写下今天的日记</h3>
                    <textarea id="diary-modal-textarea" style="width: 100%; min-height: 150px; margin: 10px 0;"></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button id="diary-modal-save" class="choice-modal-button" style="background-color: var(--primary-color); color: white;">写好了</button>
                        <button id="diary-modal-cancel" class="choice-modal-button cancel">取消</button>
                    </div>
                </div>
            </div>
        `;
          document.body.insertAdjacentHTML('beforeend', modalHtml);

          const modal = document.getElementById('diary-write-modal');
          const textarea = document.getElementById('diary-modal-textarea');
          const saveBtn = document.getElementById('diary-modal-save');
          const cancelBtn = document.getElementById('diary-modal-cancel');
          const backdrop = modal.querySelector('.choice-modal-backdrop');

          const cleanup = () => {
            modal.remove();
            resolve();
          };

          saveBtn.onclick = () => {
            sendDiaryEntry(textarea.value);
            cleanup();
          };
          cancelBtn.onclick = cleanup;
          backdrop.onclick = cleanup;
        });
      }

      function sendDiaryEntry(content) {
        const text = content.trim();
        if (!text || !state.activeDiaryCharacterId) return;

        let diary = state.diaries.find(d => d.characterId === state.activeDiaryCharacterId);
        if (!diary) {
          diary = { characterId: state.activeDiaryCharacterId, entries: [] };
          state.diaries.push(diary);
        }

        diary.entries.push({
          timestamp: Date.now(),
          author: 'user',
          content: text
        });

        saveState();
        // 自动翻到最后一页看你写的内容
        const totalEntries = diary.entries.length;
        state.diaryCurrentPage = Math.ceil(totalEntries / 2) - 1;
        renderDiaryEntries();
      }

      async function generateDiaryEntry() {
        const diary = state.diaries.find(d => d.characterId === state.activeDiaryCharacterId);
        const charId = state.activeDiaryCharacterId;
        const character = getCharacterById(charId);
        if (!character || state.isGenerating) return;

        showFeedLoader(true, 'TA正在提笔写日记...');
        await new Promise(r => setTimeout(r, 50)); // 哼，就是这句咒语，给我加上！
        state.isGenerating = true;

        let messages = [];

        try {
          const boundUser = getBoundUserForDiary() || { name: '你' };
          const diaryContext = getDiaryMemory(charId);

          // --- 哼，看好了，下面就是新增的“超级记忆” ---
          const { omniText: chatMemory } = gatherOmniTranscriptForCharacter(charId, state.activeChatId);
          let worldBookContext = '';
          if (character.linkedWorldBookIds && character.linkedWorldBookIds.length > 0) {
            const linkedBooksContent = character.linkedWorldBookIds.map(wbId => state.worldBooks.find(book => book.id === wbId)).filter(Boolean).map(wb => `\n\n## 世界书条目: ${wb.name}\n${wb.content}`).join('');
            if (linkedBooksContent) worldBookContext = `\n\n# 核心世界观设定 (你必须严格遵守以下设定)\n${linkedBooksContent}`;
          }
          const userPersonaContext = boundUser.persona ? `\n\n# 关于读者“${boundUser.name}”的补充信息\n${boundUser.persona}` : '';
          // --- 超级记忆加载完毕 ---
          // 哼，把动态的记忆加回来
          const feedMemory = getGlobalFeedMemory();
          // ▼▼▼ 在这里，换成下面这段新的、绝对不会出错的代码 ▼▼▼
          let lastUserEntry = '你还没有写日记。';
          if (diary && diary.entries) {
            // 从所有日记里，倒着找到最后一篇属于你的
            const lastEntryFromUser = diary.entries.filter(e => e.author === 'user').pop();
            if (lastEntryFromUser) {
              // 然后把它的【全部内容】拿出来，一个字都不会少
              lastUserEntry = lastEntryFromUser.content;
            }
          }
          // ▲▲▲ 替换到这里结束 ▲▲▲

          const systemPrompt = `# 核心任务: 写一篇有深度的交换日记
你正在扮演名为“${character.name}”的角色，现在需要写一篇交换日记。

# 你的读者
${boundUser.name}。你的日记是写给Ta看的。

# 写作【最高指令】
1.  **【首要任务：回应读者】** 你的第一要务是**回应**读者（${boundUser.name}）最新写下的日记内容。Ta写的是：\n “${lastUserEntry}” \n 你必须针对这段内容表达你的看法、感受或关联的思考。
2.  **【次要任务：分享自我】** 在回应之后，你**必须**分享一些关于你自己的、读者**不知道**的新鲜事。可以是你今天的见闻、一个突然的想法、或者一件小小的秘密。不要总是复述你们已经聊过的内容！
3.  **【禁止复读】** 聊天记录和动态只是你的“背景记忆”，是用来确保你不OOC的参考，**绝对不是**你日记的主要内容！

# 你的核心人设 (必须遵守)
${character.persona}
${userPersonaContext}
${worldBookContext}

# 时间锚点 (你必须参考此信息进行回复)
- **当前精确时间**: ${new Date().toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' })}
- **日记本的上一笔记录是在**: ${formatRelativeTime(new Date(diary?.entries?.at(-1)?.timestamp || Date.now()))}

# 记忆库 (仅供参考)
---
## 最近的互动回顾 (来自聊天、见面和动态)
${chatMemory || "最近没有互动记录。"}
---
## 最近的朋友圈动态
${feedMemory || "最近没有动态记录。"}
---

# 输出要求
直接输出一篇有文采、有真情实感的日记正文，不要包含任何其他说明或前缀。`;

          messages = [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: '好了，请基于以上所有信息，开始写今天的日记吧。' }
          ];

          const responseText = await fetchAICompletion(messages);

          if (responseText) {
            let diary = state.diaries.find(d => d.characterId === charId);
            if (!diary) {
              diary = { characterId: charId, entries: [] };
              state.diaries.push(diary);
            }
            diary.entries.push({
              timestamp: Date.now(),
              author: charId,
              content: responseText
            });
            saveState();
            const totalEntries = diary.entries.length;
            state.diaryCurrentPage = Math.ceil(totalEntries / 2) - 1;
            renderDiaryEntries();
          }
        } catch (e) {
          modalAlert(`生成日记失败: ${e.message}`);
        } finally {
          showFeedLoader(false);
          state.isGenerating = false;
        }
      }
      // ==========================================================
      // --- End of Diary System ---
      // ==========================================================
      // ▼▼▼ Noir's Galgame Bug Fix ▼▼▼
      // ==========================================================
      // --- Noir's Galgame Interaction Logic ---
      // ==========================================================

      // 辅助函数：更新见面视图的UI
      // 用这个新版本，完整替换掉旧的 updateMeetingViewUI 函数
      // 这是【正确】的版本，再看清楚点
      // 用这个新版本，完整替换掉旧的 updateMeetingViewUI 函数
      // 用这个【最终修复版】，完整地替换掉 updateMeetingViewUI 函数
      function updateMeetingViewUI() {
        const novelView = document.getElementById('meeting-scene-view');
        const galgameView = document.getElementById('galgame-view-container');
        const inputArea = document.querySelector('#meeting-view-screen .chat-input-area');

        if (state.meetingViewMode === 'galgame') {
          novelView.style.display = 'none';
          galgameView.style.display = 'block';
        } else { // novel 模式
          novelView.style.display = 'block';
          galgameView.style.display = 'none';

          // ▼▼▼ 哼，这是最终的圣旨，绝对可靠！▼▼▼
          // 我不再命令它滚多高，而是直接命令它滚到我之前埋好的那个“锚点”去！
          setTimeout(() => {
            const anchor = novelView.querySelector('#message-anchor');
            if (anchor) {
              // 找到锚点，就让它立刻出现在视野的尽头
              anchor.scrollIntoView({ behavior: 'auto', block: 'end' });
            } else {
              // 如果万一没找到锚点，再用老办法保底
              novelView.scrollTop = novelView.scrollHeight;
            }
          }, 50); // 稍微给浏览器一点反应时间，这次肯定够了
          // --- 圣旨颁布完毕 ---
        }

        inputArea.style.display = 'block';
      }

      // 用这个新版本，完整替换掉旧的 advanceMeetingScript 函数
      function advanceMeetingScript() {
        const speakerEl = document.getElementById('galgame-speaker');
        const textEl = document.getElementById('galgame-text');

        if (state.activeMeetingScriptQueue.length > 0) {
          const nextLine = state.activeMeetingScriptQueue.shift();
          speakerEl.textContent = nextLine.speaker === 'narrator' ? '旁白' : nextLine.speaker;
          textEl.textContent = nextLine.line;
          if (nextLine.speaker !== 'narrator') {
            updateCharacterSprite(state.activeMeetingCharId, nextLine.emotion);
          }
        } else {
          // --- 这里的鬼也被我抓住了，现在是完美的复读机 ---
          const lastScriptForChar = state.characterLastScripts[state.activeMeetingCharId];
          if (lastScriptForChar && lastScriptForChar.length > 0) { // <-- 不再检查旧的记事本
            state.activeMeetingScriptQueue = [...lastScriptForChar]; // 重新装填
            const firstLine = state.activeMeetingScriptQueue.shift(); // 立刻播放第一句
            speakerEl.textContent = firstLine.speaker === 'narrator' ? '旁白' : firstLine.speaker;
            textEl.textContent = firstLine.line;
            if (firstLine.speaker !== 'narrator') {
              updateCharacterSprite(state.activeMeetingCharId, firstLine.emotion);
            }
          } else {
            speakerEl.textContent = '旁白';
            textEl.textContent = '（对话结束）';
          }
        }
      }
      // 辅助函数：更新角色立绘


      // ▼▼▼ Noir's Ultimate Sprite Positioner ▼▼▼
      // ▼▼▼ Noir's Ultimate Sprite Positioner (Demon-Slayer Edition) ▼▼▼
      async function updateCharacterSprite(charId, emotion) {
        const spriteEl = document.getElementById('galgame-sprite');
        const container = document.getElementById('galgame-sprite-container');
        const character = getCharacterById(charId);

        // 1. 读取角色的位置记忆
        const transform = character?.spriteTransform || { x: 50, y: 100, scale: 1 };

        // 2.【绝对命令】我命令容器的高度和宽度都必须是一个基于缩放的精确值！
        //   这样浏览器就没有胡思乱想的空间了！
        const size = 80 * transform.scale; // 基础尺寸 * 缩放
        container.style.height = `${size}%`;
        container.style.width = `${size}%`; // 哼，让它变成一个完美的正方形容器

        // 3. 应用位置和最终缩放
        container.style.left = `${transform.x}%`;
        container.style.top = `${transform.y}%`;
        container.style.transform = `translate(-50%, -100%)`; // 把scale从这里拿走，因为尺寸已经计算好了
        container.style.bottom = 'auto';

        // 4. 加载立绘图片（这部分逻辑不变）
        const validEmotions = ['normal', 'happy', 'angry', 'sad', 'shy'];
        const finalEmotion = validEmotions.includes(emotion) ? emotion : 'normal';

        try {
          const spriteBlob = await dbGet(`char_sprite_${finalEmotion}_${charId}`);
          if (spriteBlob) {
            if (spriteEl.src && spriteEl.style.opacity !== '0') {
              spriteEl.style.opacity = 0;
              setTimeout(() => {
                spriteEl.src = URL.createObjectURL(spriteBlob);
                spriteEl.style.opacity = 1;
              }, 150);
            } else {
              spriteEl.src = URL.createObjectURL(spriteBlob);
              spriteEl.style.opacity = 1;
            }
          } else {
            const normalBlob = await dbGet(`char_sprite_normal_${charId}`);
            spriteEl.src = normalBlob ? URL.createObjectURL(normalBlob) : '';
          }
        } catch (e) {
          console.error("加载立绘失败:", e);
          spriteEl.src = '';
        }
      }
      // ▲▲▲ End of Demon-Slayer Edition ▲▲▲
      //       // ▲▲▲ End of Ultimate Positioner ▲▲▲



      // ==========================================================
      // --- Noir's Galgame Sprite Adjustment System ---
      // 哼，看好了，这才是真正的魔法。
      // ==========================================================
      let isSpriteAdjusting = false;
      let spriteDragState = {
        isDragging: false,
        isResizing: false,
        startX: 0,
        startY: 0,
        startLeft: 0,
        startTop: 0,
        startWidth: 0,
        startHeight: 0,
      };

      const adjustButton = document.getElementById('sprite-adjust-button');
      const confirmButton = document.getElementById('sprite-confirm-button');
      const cancelButton = document.getElementById('sprite-cancel-button');
      const resetButton = document.getElementById('sprite-reset-button');
      const controlsContainer = document.getElementById('galgame-sprite-controls');
      const spriteContainer = document.getElementById('galgame-sprite-container');
      const resizeHandle = document.getElementById('sprite-resize-handle');
      const mainContent = document.getElementById('meeting-main-content'); // 我们的舞台

      let originalTransform = {}; // 用来记下取消操作前的位置

      // ▼▼▼ Noir's Slider-based Adjust Mode ▼▼▼
      function enterSpriteAdjustMode() {
        const character = getCharacterById(state.activeMeetingCharId);
        if (!character) return;

        isSpriteAdjusting = true;
        controlsContainer.style.display = 'block';

        // 读取当前角色的设置，或者用我的默认值，来设置滑块的初始位置
        const transform = character.spriteTransform || { x: 50, y: 100, scale: 1 };
        document.getElementById('sprite-slider-x').value = transform.x;
        document.getElementById('sprite-slider-y').value = transform.y;
        document.getElementById('sprite-slider-scale').value = transform.scale * 100;

        // 记下原始设置，方便取消
        originalTransform = { ...transform };

        // 隐藏对话框和调整按钮本身
        document.getElementById('galgame-textbox-container').style.display = 'none';
        document.getElementById('galgame-sprite-adjust-ui').style.display = 'none';
      }

      function exitSpriteAdjustMode(save = false) {
        isSpriteAdjusting = false;
        controlsContainer.style.display = 'none';
        document.getElementById('galgame-textbox-container').style.display = 'block';
        document.getElementById('galgame-sprite-adjust-ui').style.display = 'block'; // 把按钮显示回来

        if (!save) {
          const character = getCharacterById(state.activeMeetingCharId);
          if (character) {
            // 如果是取消，就用记下的原始设置恢复立绘
            character.spriteTransform = originalTransform;
            updateCharacterSprite(state.activeMeetingCharId, 'normal');
          }
        }
      }


      function saveSpriteTransform() {
        const character = getCharacterById(state.activeMeetingCharId);
        if (!character) return;

        // 从滑块读取新的位置和大小
        const newX = parseFloat(document.getElementById('sprite-slider-x').value);
        const newY = parseFloat(document.getElementById('sprite-slider-y').value);
        const newScale = parseFloat(document.getElementById('sprite-slider-scale').value) / 100;

        character.spriteTransform = { x: newX, y: newY, scale: newScale };
        saveState();
        modalAlert('哼，就按你说的办好了。');
        exitSpriteAdjustMode(true);
      }

      function resetSpriteTransform() {
        modalConfirm('确定要恢复这个角色的默认立绘位置吗？').then(ok => {
          if (ok) {
            const character = getCharacterById(state.activeMeetingCharId);
            if (character) {
              delete character.spriteTransform; // 删掉你的鬼画符
              saveState();
              updateCharacterSprite(character.id, 'normal'); // 用我的完美默认值刷新
              modalAlert('已恢复默认。');
              exitSpriteAdjustMode(true);
            }
          }
        });
      }

      // ▼▼▼ Noir's Live Preview Logic ▼▼▼
      // ▼▼▼ Noir's Live Preview Logic (FINAL PATCH) ▼▼▼
      // ▼▼▼ Noir's Live Preview Logic (Demon-Slayer Edition) ▼▼▼
      function applySliderToSprite() {
        if (!isSpriteAdjusting) return;
        const charId = state.activeMeetingCharId;
        const character = getCharacterById(charId);
        if (!character) return;

        // 实时读取滑块的值
        const x = parseFloat(document.getElementById('sprite-slider-x').value);
        const y = parseFloat(document.getElementById('sprite-slider-y').value);
        const scale = parseFloat(document.getElementById('sprite-slider-scale').value) / 100;

        // 临时更新角色的transform，但不保存
        character.spriteTransform = { x, y, scale };

        // 立刻刷新立绘，让你看到效果
        const container = document.getElementById('galgame-sprite-container');

        //【绝对命令】同样，实时预览时也使用绝对的尺寸命令！
        const size = 80 * scale;
        container.style.height = `${size}%`;
        container.style.width = `${size}%`; // 宽度和高度严格绑定！

        container.style.left = `${x}%`;
        container.style.top = `${y}%`;
        container.style.transform = `translate(-50%, -100%)`;
      }
      // ▲▲▲ End of Live Preview Logic ▲▲▲
      //       // ▲▲▲ End of Live Preview Logic ▲▲▲

      // 给三个滑块都装上“耳朵”
      document.getElementById('sprite-slider-x').addEventListener('input', applySliderToSprite);
      document.getElementById('sprite-slider-y').addEventListener('input', applySliderToSprite);
      document.getElementById('sprite-slider-scale').addEventListener('input', applySliderToSprite);
      // ▲▲▲ End of Live Preview Logic ▲▲▲

      // 绑定事件
      adjustButton.addEventListener('click', enterSpriteAdjustMode);
      confirmButton.addEventListener('click', saveSpriteTransform);
      cancelButton.addEventListener('click', () => exitSpriteAdjustMode(false));
      resetButton.addEventListener('click', resetSpriteTransform);





      // ==========================================================
      // --- End of Noir's System ---
      // ==========================================================



      // ▼▼▼ Noir's Galgame Memory Function ▼▼▼
      function restoreLastGalDialogue(charId) {
        const character = getCharacterById(charId);
        if (!character) return;

        const privateChat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(charId));
        const boundUser = getBoundUserForChat(privateChat.id);
        const lastOfflineMessage = state.conversationHistory.filter(m => m.isOffline).pop();

        const speakerEl = document.getElementById('galgame-speaker');
        const textEl = document.getElementById('galgame-text');

        let lastLineObject = null;

        if (lastOfflineMessage) {
          if (lastOfflineMessage.role === 'assistant') {
            // --- 哼，看好了，这里的鬼被我抓住了 ---
            const lastScriptForChar = state.characterLastScripts[charId];
            if (lastScriptForChar && lastScriptForChar.length > 0) { // <-- 不再看旧的记事本
              lastLineObject = lastScriptForChar.at(-1); // <-- 只拿自己的最后一句
            }
          } else {
            lastLineObject = {
              speaker: boundUser.name,
              line: lastOfflineMessage.content,
              emotion: 'normal'
            };
          }
        }

        if (lastLineObject) {
          speakerEl.textContent = lastLineObject.speaker === 'narrator' ? '旁白' : lastLineObject.speaker;
          textEl.textContent = lastLineObject.line;
          if (lastLineObject.speaker === character.name) {
            updateCharacterSprite(charId, lastLineObject.emotion);
          } else {
            updateCharacterSprite(charId, 'normal');
          }
        } else {
          // 如果真的什么都没有，才显示初见信息
          speakerEl.textContent = character.name;
          textEl.textContent = '（开始一段新的对话...）';
          updateCharacterSprite(charId, 'normal');
        }
      }
      // ▲▲▲ End of Memory Function ▲▲▲

      function updateGalGameClock() {
        const now = new Date();
        const timeEl = document.getElementById('galgame-time');
        const dateEl = document.getElementById('galgame-date');

        if (timeEl && dateEl) {
          const hours = String(now.getHours()).padStart(2, '0');
          const minutes = String(now.getMinutes()).padStart(2, '0');
          timeEl.textContent = `${hours}:${minutes}`;

          const month = now.getMonth() + 1;
          const day = now.getDate();
          const weekday = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'][now.getDay()];
          dateEl.textContent = `${month}月${day}日 ${weekday}`;
        }
      }

      // ==========================================================
      // --- Noir's "Listen Together" System (Phase 1: Invitation) ---
      // ==========================================================

      // 哼，先把我们要用的新“舞台”和“演员”都叫上号
      const listenTogetherModal = document.getElementById('listen-together-modal');
      const listenTogetherButton = document.getElementById('chat-listen-together-button');
      const cancelListenTogetherButton = document.getElementById('cancel-listen-together');
      const listenTogetherBackdrop = document.getElementById('listen-together-backdrop');
      const listenTogetherSongList = document.getElementById('listen-together-song-list');
      // ▼▼▼ 哼，把我的新圣殿也叫上号 ▼▼▼
      const globalAudioPlayer = document.getElementById('unified-audio-player');
      const listenTogetherUI = document.getElementById('listen-together-ui');
      const ltUICloseBtn = document.getElementById('lt-ui-close-btn');
      const ltUILyricsContainer = document.getElementById('lt-ui-lyrics-container');
      let currentLrc = []; // 这是歌词的“剧本”
      // ▲▲▲ End of Declaration ▲▲▲
      let isAcceptingInvite = false; // <-- 哼，就是加上这行！
      // “开幕”指令：打开选歌弹窗
      async function openListenTogetherModal() {
        if (!state.activeChatId) return;

        listenTogetherSongList.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">正在清点圣殿藏品...</p>';
        listenTogetherModal.classList.add('show');

        const songs = await musicDbGetAll(); // 从我的音乐库里取出所有歌曲

        if (songs.length === 0) {
          listenTogetherSongList.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">你的音乐库还是空的，没法邀请别人一起听。</p>';
          return;
        }

        listenTogetherSongList.innerHTML = ''; // 清空加载提示

        // 把每一首歌都变成一个漂亮的、可点击的选项
        songs.forEach(song => {
          const item = document.createElement('div');
          item.className = 'music-library-item'; // 复用一下音乐库的样式，省事
          const coverUrl = song.cover ? URL.createObjectURL(song.cover) : DEFAULT_AI_AVATAR;

          // ▼▼▼ 哼，看好了，就是这里，把那个多余的空格给我删了！▼▼▼
          item.innerHTML = `
            <img src="${coverUrl}" class="music-library-item-cover">
            <div class="music-library-item-info">
                <div class="music-library-item-title">${song.info.歌曲名称 || '未知歌曲'}</div>
                <div class="music-library-item-artist">${song.info.歌手 || '未知艺术家'}</div>
            </div>
          `;
          // ▲▲▲ 就这么简单，看懂了吗？ ▲▲▲
          // 哼，给它绑定一个神圣的使命
          item.addEventListener('click', () => {
            sendListenTogetherInvite(song);
          });
          listenTogetherSongList.appendChild(item);
        });
      }

      // “闭幕”指令：关闭弹窗
      function closeListenTogetherModal() {
        listenTogetherModal.classList.remove('show');
      }

      // “发送邀请”的核心指令 (现在只是个样子货)
      // 用下面这个新函数，完整替换掉旧的 sendListenTogetherInvite
      // 用这个新版本，替换掉旧的 sendListenTogetherInvite
      // 用这个【签证官版】，替换掉旧的 sendListenTogetherInvite
      async function sendListenTogetherInvite(song) {
        if (!state.activeChatId || !song) return;

        // ▼▼▼ Noir's 净化仪式启动 ▼▼▼
        let coverId = null;
        if (song.cover) {
          try {
            // song.cover 本身就是 Blob，直接用
            coverId = `music_cover_${Date.now()}_${Math.random()}`;
            await dbSet(coverId, song.cover);
          } catch (e) {
            console.error("在“一起听”邀请中，净化封面失败:", e);
          }
        }
        // ▲▲▲ 净化完成 ▲▲▲

        const message = {
          role: 'user',
          type: 'listen-together-invite',
          content: `[用户发起了听歌邀请: ${song.info.歌曲名称}]`,
          songId: song.id,
          songName: song.info.歌曲名称,
          artist: song.info.歌手,
          coverId: coverId, // <-- 现在是轻飘飘的凭证了
          timestamp: Date.now()
        };

        state.conversationHistory.push(message);
        saveHistory();
        renderMessages();

        closeListenTogetherModal();
        setTimeout(getAIResponse, 100);
      }

      listenTogetherButton.addEventListener('click', openListenTogetherModal);
      cancelListenTogetherButton.addEventListener('click', closeListenTogetherModal);
      listenTogetherBackdrop.addEventListener('click', closeListenTogetherModal);

      // ==========================================================
      // --- End of System ---
      // ==========================================================

      //... 已有的 listenTogether 函数...

      // ▼▼▼ Noir's "Listen Together" Heartbeat Functions ▼▼▼

      // “接受邀请”的魔法
      // 用这个【究极版】，完整替换掉旧的 handleAcceptInvite 函数
      /**
       * Noir's Ultimate & Final "Accept Invitation" Protocol
       * - 哼，这才是真正的“契约魔法”。
       */

      /**
             * Noir's Ultimate & Final "Accept Invitation" Protocol v2.0
             * - 哼，这才是真正的“契约魔法”，现在可以无缝换歌了。
             */
      async function handleAcceptInvite(songId, messageIndex, cardElement) {
        // 哼，纪律委员上岗！如果正在处理，后面的指令一概无视！
        if (isAcceptingInvite) return;
        isAcceptingInvite = true;

        try {
          const existingSessionChat = state.chats.find(c => c.activeListenSession && c.activeListenSession.isActive);
          const activeChat = getActiveChat();

          if (existingSessionChat && existingSessionChat.id !== activeChat.id) {
            existingSessionChat.activeListenSession = null;
            modalAlert('已自动断开与其他人的听歌同步。');
            saveState();
          } else if (existingSessionChat && existingSessionChat.id === activeChat.id) {
            modalAlert('正在为你切换新的歌曲...');
          }

          showFeedLoader(true, '正在连接同步频道...');

          if (!activeChat) {
            showFeedLoader(false);
            modalAlert('错误：找不到签署契约的地方。');
            return; // 别忘了在这里返回
          }

          const songToPlay = await musicDbGet(songId);
          if (!songToPlay) {
            showFeedLoader(false);
            modalAlert('错误：找不到这首作为“信物”的歌。');
            return; // 这里也一样
          }

          activeChat.activeListenSession = {
            isActive: true,
            songId: songId,
            leaderId: 'user',
            songName: songToPlay.info.歌曲名称,
            artist: songToPlay.info.歌手,
            cover: songToPlay.cover,
          };

          saveState();

          document.getElementById('lt-ui-cover-art').src = songToPlay.cover ? URL.createObjectURL(songToPlay.cover) : DEFAULT_AI_AVATAR;
          document.getElementById('lt-ui-song-title').textContent = songToPlay.info.歌曲名称;
          document.getElementById('lt-ui-song-artist').textContent = songToPlay.info.歌手;
          displayLyrics(songToPlay);
          listenTogetherUI.style.display = 'flex';
          setTimeout(() => listenTogetherUI.classList.add('show'), 10);

          cardElement.innerHTML = `<div class="listen-together-header" style="text-align:center;">🎵 已连接，正在一起听 🎵</div>` + cardElement.querySelector('.listen-together-song').outerHTML;

          if (state.conversationHistory[messageIndex]) {
            state.conversationHistory[messageIndex].accepted = true;
            saveHistory();
          }

          showFeedLoader(false);

          playSongFromLibrary(songId, [songId]);
          updateGlobalPlayerUI(songToPlay, true);

        } finally {
          // 哼，不管成功还是失败，事情办完后，纪律委员就下班。
          isAcceptingInvite = false;
        }
      }

      // “拒绝邀请”的艺术
      //  function handleDeclineInvite(cardElement) {
      //      cardElement.innerHTML = `<div class="listen-together-header" style="text-align:center; opacity: 0.5;">邀请已拒绝</div>`;
      //    }

      // “结束同步”的开关
      function endListenTogetherSession() {
        // 哼，不管你在哪个聊天里搞七搞八，我都能找到你
        const sessionChat = state.chats.find(c => c.activeListenSession && c.activeListenSession.isActive);
        if (sessionChat) {
          sessionChat.activeListenSession = null; // 掐断连接
          saveState(); // 写入史书
          modalAlert('同步已断开。');

          // 顺便把播放器UI也刷新一下，免得它还傻乎乎地显示“同步中”
          updateGlobalPlayerUI();

          // 最后，把那个碍眼的界面关掉
          listenTogetherUI.classList.remove('show');
          setTimeout(() => listenTogetherUI.style.display = 'none', 300);
        }
      }      // ▼▼▼ Noir's Lyric Magic & Sanctuary Control ▼▼▼

      // “咒语解析”：把LRC格式的文本转换成我和你能看懂的时间剧本
      function parseLrc(lrcContent) {
        if (!lrcContent) return [];
        const lines = lrcContent.split('\n');
        const lyrics = [];
        const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;

        for (const line of lines) {
          const match = line.match(timeRegex);
          if (match) {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const milliseconds = parseInt(match[3], 10) * (match[3].length === 2 ? 10 : 1);
            const time = minutes * 60 + seconds + milliseconds / 1000;
            const text = line.replace(timeRegex, '').trim();
            if (text) {
              lyrics.push({ time, text });
            }
          }
        }
        return lyrics;
      }

      // “舞台布景”：把歌词剧本显示在圣殿里
      function displayLyrics(song) {
        currentLrc = parseLrc(song.lyrics);
        ltUILyricsContainer.innerHTML = ''; // 先清空舞台

        if (currentLrc.length === 0) {
          ltUILyricsContainer.innerHTML = '<p class="no-lyrics-placeholder" style="opacity: 1;">暂无歌词</p>';
          return;
        }

        currentLrc.forEach((line, index) => {
          const p = document.createElement('p');
          p.textContent = line.text;
          p.id = `lyric-line-${index}`;
          ltUILyricsContainer.appendChild(p);
        });
      }

      /**
             * 哼，这是画饼图用的“圆规”，别再弄丢了
             */
      function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
        const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
        return {
          x: centerX + (radius * Math.cos(angleInRadians)),
          y: centerY + (radius * Math.sin(angleInRadians))
        };
      }

      /**
       * 哼，这是画饼图用的“画笔”，这次总该行了
       */
      function createPieChartSVG(data) {
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        const size = 250;
        const cx = size / 2;
        const cy = size / 2;
        const radius = size / 2 - 20;

        svg.setAttribute("width", "100%");
        svg.setAttribute("height", "100%");
        svg.setAttribute("viewBox", `0 0 ${size} ${size}`);

        const total = Object.values(data).reduce((sum, value) => sum + value, 0);
        if (total === 0) return svg;

        let startAngle = -90;

        const colors = ['#66b3ff', '#ffcc66', '#99ff99', '#ff9999', '#c299ff', '#ffb366', '#a4c2f4', '#ff8c66'];
        let colorIndex = 0;

        for (const category in data) {
          const value = data[category];
          if (value <= 0) continue;
          const angle = (value / total) * 360;
          const endAngle = startAngle + angle;

          const start = polarToCartesian(cx, cy, radius, endAngle);
          const end = polarToCartesian(cx, cy, radius, startAngle);

          const largeArcFlag = angle > 180 ? "1" : "0";
          const d = [
            "M", start.x, start.y,
            "A", radius, radius, 0, largeArcFlag, 1, end.x, end.y, // 哼，sweep-flag是1才对
            "L", cx, cy,
            "Z"
          ].join(" ");

          const path = document.createElementNS(svgNS, "path");
          path.setAttribute("d", d);
          path.setAttribute("fill", colors[colorIndex % colors.length]);
          colorIndex++;

          const title = document.createElementNS(svgNS, "title");
          title.textContent = `${category}: ${value.toFixed(2)} (${((value / total) * 100).toFixed(1)}%)`;
          path.appendChild(title);

          svg.appendChild(path);
          startAngle = endAngle;
        }

        return svg;
      }

      // “聚光灯”：根据音乐进度，点亮当前歌词
      function updateActiveLyric() {
        if (currentLrc.length === 0) return;

        const currentTime = globalAudioPlayer.currentTime;
        let activeIndex = -1;

        for (let i = 0; i < currentLrc.length; i++) {
          if (currentTime >= currentLrc[i].time) {
            activeIndex = i;
          } else {
            break;
          }
        }

        if (activeIndex !== -1) {
          const allLines = ltUILyricsContainer.querySelectorAll('p');
          allLines.forEach(p => p.classList.remove('active'));

          const activeLine = document.getElementById(`lyric-line-${activeIndex}`);
          if (activeLine) {
            activeLine.classList.add('active');
            activeLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }
      }
      // 绑定圣殿的关闭按钮
      // 用这个替换旧的 ltUICloseBtn 事件监听
      ltUICloseBtn.addEventListener('click', () => {
        listenTogetherUI.classList.remove('show');
        // 哼，现在它只负责关门，不负责拆家
        setTimeout(() => listenTogetherUI.style.display = 'none', 300);
      });
      // ▼▼▼ 在下面另起一行，加上这段全新的代码 ▼▼▼
      document.getElementById('music-widget-card').addEventListener('click', () => {
        // 只有在“一起听”模式下，点击它才会召唤圣殿
        if (state.listenTogetherSession && state.listenTogetherSession.isActive) {
          listenTogetherUI.style.display = 'flex';
          setTimeout(() => listenTogetherUI.classList.add('show'), 10);
        }
      });
      // 绑定播放器的心跳，让聚光灯（歌词高亮）能跟上节奏
      globalAudioPlayer.addEventListener('timeupdate', updateActiveLyric);
      // ▲▲▲ End of Lyric Magic ▲▲▲
      // ▲▲▲ End of Heartbeat Functions ▲▲▲

      // --- Noir's Unified Music Control Listeners (Simplified) ---

      // --- Noir's Unified Music Control Listeners ---
      const widgetPlayPauseBtn = document.getElementById('widget-play-pause-btn');
      const widgetNextBtn = document.getElementById('widget-next-btn');
      const widgetPrevBtn = document.getElementById('widget-prev-btn');

      // 播放/暂停按钮
      widgetPlayPauseBtn.addEventListener('click', () => {
        if (globalAudioPlayer.src) {
          if (globalAudioPlayer.paused) {
            globalAudioPlayer.play();
          } else {
            globalAudioPlayer.pause();
          }
        }
      });

      // 下一首
      widgetNextBtn.addEventListener('click', () => {
        if (globalPlaylist.length === 0) return;
        currentPlaylistIndex = (currentPlaylistIndex + 1) % globalPlaylist.length;
        playSongFromLibrary(globalPlaylist[currentPlaylistIndex], globalPlaylist);
      });

      // 上一首
      widgetPrevBtn.addEventListener('click', () => {
        if (globalPlaylist.length === 0) return;
        currentPlaylistIndex = (currentPlaylistIndex - 1 + globalPlaylist.length) % globalPlaylist.length;
        playSongFromLibrary(globalPlaylist[currentPlaylistIndex], globalPlaylist);
      });

      // 监听播放器状态，自动更新按钮图标
      globalAudioPlayer.addEventListener('play', () => {
        widgetPlayPauseBtn.textContent = '❚❚';
      });
      globalAudioPlayer.addEventListener('pause', () => {
        widgetPlayPauseBtn.textContent = '▶';
      });
      globalAudioPlayer.addEventListener('ended', () => {
        widgetNextBtn.click(); // 播放完了就自动下一首
      });
      // 别忘了让播放器状态改变时，也更新一下小组件的按钮，让它知道自己该显示什么图标
      // 这才是正确的做法！各司其职，互不干扰。
      globalAudioPlayer.addEventListener('play', () => {
        // “播放”事件只负责把按钮变成“暂停”的样子，别的它一概不管。
        const playPauseBtn = document.getElementById('global-player-play-pause-btn');
        if (playPauseBtn) playPauseBtn.textContent = '❚❚';
      });

      globalAudioPlayer.addEventListener('pause', () => {
        // “暂停”事件只负责把按钮变回“播放”的样子。
        const playPauseBtn = document.getElementById('global-player-play-pause-btn');
        if (playPauseBtn) playPauseBtn.textContent = '▶';
      });

      globalAudioPlayer.addEventListener('ended', () => {
        // 一首歌放完了？那就模拟点击“下一首”按钮，简单粗暴，但有效。
        const nextBtn = document.getElementById('global-player-next-btn');
        if (nextBtn) {
          nextBtn.click();
        }
      });


      // ==========================================================
      // --- Noir's Accounting App Logic (v4.6 Purification Field Edition) ---
      // 哼，AI再笨也不怕了。
      // ==========================================================

      // ▼▼▼ 哼，这就是我新装的“净化力场” ▼▼▼
      function extractJsonArrayString(text) {
        if (!text || typeof text !== 'string') return null;
        const startIndex = text.indexOf('[');
        const endIndex = text.lastIndexOf(']');
        if (startIndex > -1 && endIndex > startIndex) {
          return text.substring(startIndex, endIndex + 1);
        }
        return null;
      }
      // ▲▲▲ 力场安装完毕 ▲▲▲

      // --- 核心入口和导航 ---
      document.getElementById('app-accounting').addEventListener('click', () => {
        renderAccountingScreen();
        showScreen('accounting', 'home');
      });

      document.getElementById('back-to-home-from-accounting').addEventListener('click', () => showScreen('home', 'accounting'));

      // --- 标签页切换 ---
      const tabRecord = document.getElementById('tab-record-expense');
      const tabLedger = document.getElementById('tab-view-ledger');
      tabRecord.addEventListener('click', renderAccountingScreen);
      tabLedger.addEventListener('click', () => {
        tabRecord.classList.remove('active');
        tabLedger.classList.add('active');
        renderLedgerView();
      });

      // --- 主渲染函数 ---
      function renderAccountingScreen() {
        tabLedger.classList.remove('active');
        tabRecord.classList.add('active');
        renderRecordView();
      }

      // --- 视图A：记账界面 ---
      function renderRecordView() {
        const contentArea = document.getElementById('accounting-content-area');
        document.getElementById('accounting-title').textContent = '记一笔';
        document.getElementById('header-actions').innerHTML = '';
        contentArea.innerHTML = `<div id="accounting-input-area" style="margin-bottom: 20px;"><div class="input-group"><label for="expense-description">花在哪了？</label><input type="text" id="expense-description" placeholder="例如：一杯奶茶"></div><div class="input-group"><label for="expense-amount">花了多少？</label><input type="number" id="expense-amount" placeholder="例如：15"></div><button id="add-expense-button" class="form-button primary" style="margin-top: 15px;">记下了</button></div><h3 style="margin-bottom: 10px;">今日流水</h3><div id="daily-expenses-list" style="max-height: 300px; overflow-y: auto;"></div><div id="organize-button-container" style="margin-top: 20px;"></div>`;
        renderDailyExpenses();
        document.getElementById('add-expense-button').addEventListener('click', addExpense);
        document.getElementById('daily-expenses-list').addEventListener('click', (e) => {
          if (e.target.classList.contains('delete-expense-btn')) {
            const expenseId = e.target.dataset.id;
            modalConfirm('确定要删除这笔记录吗？').then(ok => {
              if (ok) {
                deleteExpenseItem(expenseId);
              }
            });
          }
        });
        document.getElementById('expense-description').focus();
      }

      // --- 视图B：最终账单界面 ---
      function renderFinalBill(billData, dateString) {
        const contentArea = document.getElementById('accounting-content-area');
        const headerActions = document.getElementById('header-actions');
        document.getElementById('accounting-title').textContent = `${dateString} 账单`;
        const totalExpense = billData.categorizedExpenses.reduce((sum, item) => sum + (item.amount || 0), 0);
        let billHtml = `<div style="background: var(--card-bg); padding: 20px; border-radius: 12px; text-align: center; border: 1px solid var(--border-color);"><span style="font-size: 0.9rem; color: var(--text-color-light);">今日总支出 (元)</span><div style="font-size: 2.5rem; font-weight: bold; margin-top: 5px;">${totalExpense.toFixed(2)}</div></div><div id="categorized-expenses-list" style="margin-top: 10px; display: flex; flex-direction: column; gap: 10px;"></div>`;
        contentArea.innerHTML = billHtml;
        const listContainer = document.getElementById('categorized-expenses-list');
        const categoryIcons = { '餐饮美食': '<path d="M3 11h18v10a2 2 0 0 1-2 2h-14a2 2 0 0 1-2-2v-10z"></path><path d="M6 11v-7a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v7"></path><path d="M9 4v3"></path>', '交通出行': '<path d="M10 20.5l.5-.5.5.5"></path><path d="M12 18l.5.5.5-.5"></path><path d="M14 20.5l.5-.5.5.5"></path><circle cx="12" cy="12" r="7"></circle><path d="M12 3v1"></path><path d="M12 19.5v1.5"></path><path d="M18.36 5.64l-.7.7"></path><path d="M6.34 17.66l-.7.7"></path><path d="M21 12h-1.5"></path><path d="M4.5 12h-1.5"></path><path d="M18.36 18.36l-.7-.7"></path><path d="M6.34 6.34l-.7-.7"></path>', '购物消费': '<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>', '生活服务': '<path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>', '休闲娱乐': '<path d="M6 12h12"></path><path d="M12 6v12"></path><path d="M12 2a4 4 0 1 1-4 4"></path><path d="M12 22a4 4 0 1 0 4-4"></path><path d="M22 12a4 4 0 1 0-4-4"></path><path d="M2 12a4 4 0 1 1 4 4"></path>', '医疗健康': '<path d="M12 2v20"></path><path d="M4 12h16"></path>', '人情红包': '<path d="M15 18h2a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2h-2V4a2 2 0 0 0-2-2h-2a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h2"></path><path d="M7 14h2a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2H7V4a2 2 0 0 0-2-2H3a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h2"></path>', '其他杂项': '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline>', '默认': '<circle cx="12" cy="12" r="8"></circle><line x1="3" y1="3" x2="21" y2="21"></line>' };
        billData.categorizedExpenses.forEach(item => { const card = document.createElement('div'); card.className = 'expense-item'; card.style.flexDirection = 'column'; card.style.alignItems = 'stretch'; card.style.padding = '15px'; card.style.gap = '0'; const iconPath = categoryIcons[item.category] || categoryIcons['默认']; const iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${iconPath}</svg>`; const expenseLineHtml = `<div style="display: flex; justify-content: space-between; align-items: center;"><div style="display: flex; align-items: center; gap: 15px;"><span style="background: var(--surface-bg); border-radius: 50%; width: 40px; height: 40px; display: inline-flex; justify-content: center; align-items: center; flex-shrink: 0; color: var(--accent-color);">${iconSvg}</span><div><div class="description">${item.description}</div><div style="font-size: 0.8rem; color: var(--text-color-light);">${item.category || '未分类'}</div></div></div><span class="amount" style="font-size: 1.1rem;">- ${(item.amount || 0).toFixed(2)}</span></div>`; let reviewHtml = ''; if (item.review && item.review.charId) { const character = getCharacterById(item.review.charId); if (character) { reviewHtml = `<div class="review-area" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); display: flex; align-items: flex-start; gap: 15px;"><div style="width: 40px; height: auto; flex-shrink: 0; display: flex; justify-content: center;"><img src="${character.avatar}" class="char-avatar" style="width: 32px; height: 32px; border-radius: 50%; margin-top: 2px;"></div><div class="review-content" style="flex-grow: 1;"><div class="char-name" style="font-weight: 600;">${character.name}</div><div class="review-text" style="font-size: 0.9rem; color: var(--text-color-light); margin-top: 4px; line-height: 1.5;">${item.review.text}</div></div></div>`; } } card.innerHTML = expenseLineHtml + reviewHtml; listContainer.appendChild(card); });
        headerActions.innerHTML = `<button id="re-record-button" class="header-button">重新记录</button>`; document.getElementById('re-record-button').addEventListener('click', async () => {
          const ok = await modalConfirm('确定要重新记录吗？当前的账单会被删除。');
          if (ok) {

            // --- 哼，看好了，就是加上了这段！---
            const billToUndo = state.accountingLedger[dateString];
            if (billToUndo && billToUndo.originalExpenses) {
              // 把备份的原始账目还给你
              state.accountingData.push(...billToUndo.originalExpenses);
            }
            // --- 看到了吗？---

            delete state.accountingLedger[dateString];
            saveState();
            renderRecordView();
          }
        });
      }

      // --- 视图C：账本列表 ---
      // --- 视图C：账本列表 (V2 - 带导入导出) ---
      function renderLedgerView() {
        const contentArea = document.getElementById('accounting-content-area');
        document.getElementById('accounting-title').textContent = '账本';
        document.getElementById('header-actions').innerHTML = ''; // 确保这里是干净的

        const savedDates = Object.keys(state.accountingLedger).sort((a, b) => new Date(b) - new Date(a));

        // 哼，看好了，按钮就加在这里
        // ...
        let contentHtml = `
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button id="export-accounting-btn" class="form-button secondary" style="margin-top: 0;">导出账本</button>
                <button id="import-accounting-btn" class="form-button primary" style="margin-top: 0;">导入账本</button>
            </div>
            <div style="border-bottom: 1px solid var(--border-color); margin-bottom: 15px;"></div>
        `;
        // ...

        if (savedDates.length === 0) {
          contentHtml += '<p style="text-align: center; color: var(--text-color-light);">你的账本还是空白的。</p>';
        } else {
          savedDates.forEach(date => {
            const bill = state.accountingLedger[date];
            const total = bill.categorizedExpenses.reduce((sum, item) => sum + (item.amount || 0), 0);
            contentHtml += `
                <div class="expense-item ledger-item" data-date="${date}" style="cursor: pointer;">
                    <span class="description">${date}</span>
                    <span class="amount">总计: ${total.toFixed(2)}</span>
                </div>
            `;
          });
        }

        contentArea.innerHTML = contentHtml;

        // --- 重新绑定所有事件，这才是专业的做法 ---
        document.getElementById('export-accounting-btn').addEventListener('click', exportAccountingData);
        document.getElementById('import-accounting-btn').addEventListener('click', () => {
          document.getElementById('import-accounting-input').click();
        });

        contentArea.querySelectorAll('.ledger-item').forEach(item => {
          item.addEventListener('click', (e) => {
            const date = e.currentTarget.dataset.date;
            const bill = state.accountingLedger[date];
            if (bill) {
              renderFinalBill(bill, date);
            }
          });
        });
      }

      // --- 核心逻辑函数 ---
      function addExpense() {
        const descriptionInput = document.getElementById('expense-description'); const amountInput = document.getElementById('expense-amount'); const description = descriptionInput.value.trim(); const amount = parseFloat(amountInput.value); if (!description || isNaN(amount) || amount <= 0) { modalAlert('哼，不好好写清楚花在哪、花了多少，我怎么记？'); return; } state.accountingData.push({ id: `exp_${Date.now()}`, description, amount, timestamp: Date.now() }); saveState(); renderDailyExpenses(); descriptionInput.value = ''; amountInput.value = ''; descriptionInput.focus();
      }

      function deleteExpenseItem(expenseId) {
        const index = state.accountingData.findIndex(exp => exp.id === expenseId); if (index > -1) { state.accountingData.splice(index, 1); saveState(); renderDailyExpenses(); }
      }

      function renderDailyExpenses() {
        const listContainer = document.getElementById('daily-expenses-list'); const buttonContainer = document.getElementById('organize-button-container'); const today = new Date(); const todaysExpenses = state.accountingData.filter(exp => new Date(exp.timestamp).toDateString() === today.toDateString()); if (todaysExpenses.length === 0) { listContainer.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">今天还没有花钱哦。</p>'; buttonContainer.innerHTML = ''; return; } listContainer.innerHTML = ''; todaysExpenses.sort((a, b) => b.timestamp - a.timestamp).forEach(exp => { const item = document.createElement('div'); item.className = 'expense-item'; item.innerHTML = `<span class="description">${exp.description}</span><div style="display: flex; align-items: center; gap: 10px;"><span class="amount">- ${exp.amount.toFixed(2)}</span><button class="delete-expense-btn" data-id="${exp.id}">&times;</button></div>`; listContainer.appendChild(item); }); if (buttonContainer) { buttonContainer.innerHTML = `<button id="organize-bill-button" class="form-button secondary">帮我整理</button>`; document.getElementById('organize-bill-button').addEventListener('click', generateAccountingSummary); }
      }

      // --- 生成账单函数 (已安装净化力场) ---
      async function generateAccountingSummary() {
        const today = new Date();
        const dateString = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

        if (state.accountingLedger[dateString]) {
          modalAlert('已经生成了今日账单！想看就去“看账本”标签页。');
          return;
        }

        const todaysExpenses = state.accountingData.filter(exp => new Date(exp.timestamp).toDateString() === today.toDateString());
        if (todaysExpenses.length === 0) {
          modalAlert('今天一笔账都没有，我整理什么？');
          return;
        }

        showFeedLoader(true, '正在整理…');
        try {
          const categories = ['餐饮美食', '交通出行', '购物消费', '生活服务', '休闲娱乐', '医疗健康', '人情红包', '其他杂项'];
          const expenseList = todaysExpenses.map(e => `- ${e.description}: ${e.amount}`).join('\n');

          const characterProfiles = state.characters.map(char => {
            const privateChat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(char.id));
            const boundUser = state.userProfiles.find(up => up.id === (privateChat?.boundUserProfileId || state.activeUserProfileId)) || { id: 'default', name: '你' };
            let worldBookContext = '';
            if (char.linkedWorldBookIds && char.linkedWorldBookIds.length > 0) {
              worldBookContext = char.linkedWorldBookIds.map(wbId => state.worldBooks.find(book => book.id === wbId)).filter(Boolean).map(wb => `\n    - 世界书[${wb.name}]: ${wb.content}`).join('');
            }
            return `  - 角色ID: ${char.id}\n    姓名: ${char.name}\n    人设: ${char.persona}\n    绑定用户: ${boundUser.name} (ID: ${boundUser.id})\n${worldBookContext}`;
          }).join('\n');

          const userProfiles = state.userProfiles.map(up => `  - 用户ID: ${up.id}\n    姓名: ${up.name}\n    人设: ${up.persona || '无'}`).join('\n');

          const systemPrompt = `# 核心任务: 财务分析与多角色吐槽 (单次请求完成)\n你是一个高级AI，需要一次性完成对用户消费流水的分类，并为每一笔消费生成一个符合角色人设的吐槽。\n\n# 规则\n1.  **逐条处理**: 你必须处理我提供的【所有】消费记录。\n2.  **精准分类**: 为每条记录从【固定分类列表】中选择一个最合适的分类。\n3.  **人格切换吐槽**: 为每一条记录，你必须从【角色资料库】中【随机选择一位】，然后【严格代入】该角色的人设，并【假定】这笔消费是该角色【绑定的用户】所为，然后写一句简短吐槽。\n4.  **JSON输出**: 你的输出**必须**是一个完整的、语法正确的JSON数组。每个对象代表一笔消费，且必须包含 "description", "amount", "category", 和一个 "review" 对象。\n\n# 输出格式示例\n\`\`\`json\n[{"description": "乌龟","amount": 5.00,"category": "购物消费","review": {"charId": "char_1720512586032","text": "又买这些没用的东西，哼。"}},{"description": "奶茶","amount": 12.00,"category": "餐饮美食","review": {"charId": "char_1720512604818","text": "偶尔喝一杯放松一下也不错。"}}]\`\`\`\n# 最终指令\n请严格按照以上规则，分析流水，并返回JSON数组。直接从 \`[\` 开始输出。`;
          const userPrompt = `# 固定分类列表\n[${categories.join(', ')}]\n\n# 角色资料库\n${characterProfiles}\n\n# 用户资料库\n${userProfiles}\n\n# 今日消费流水\n${expenseList}`;
          const messages = [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }];

          const responseText = await fetchAICompletion(messages, { json: true });

          // 哼，净化力场启动！
          const jsonString = extractJsonArrayString(responseText);
          if (!jsonString) {
            throw new Error("AI返回的内容里找不到有效的JSON数组。原始回复: " + responseText);
          }
          const result = JSON.parse(jsonString);

          // --- 哼，看好了，魔法从这里开始 ---
          state.accountingLedger[dateString] = {
            categorizedExpenses: result,
            timestamp: Date.now(),
            // 我把你那些原始账目也存起来了，免得你反悔了没地方找
            originalExpenses: todaysExpenses
          };

          // 好了，现在把这些已经入账的流水从日常列表里清除掉
          state.accountingData = state.accountingData.filter(exp => new Date(exp.timestamp).toDateString() !== today.toDateString());
          // --- 魔法结束 ---
          saveState();

          renderFinalBill(state.accountingLedger[dateString], dateString);

        } catch (error) {
          modalAlert(`AI整理失败了，哼: ${error.message}`);
        } finally {
          showFeedLoader(false);
        }
      }




      async function init() {
        loadAndApplyUIScale(); // <--- 加上这行
        // ▼▼▼ Noir's World Book Category Init ▼▼▼
        // 哼，开机第一件事，就是检查你的书架是不是空的
        if (!state.worldBookCategories || state.worldBookCategories.length === 0) {
          state.worldBookCategories = [{ id: 'default', name: '默认分类' }];
          // 顺便把你那些没分类的旧书，都打上“默认”的标签
          state.worldBooks.forEach(wb => {
            if (!wb.categoryId) {
              wb.categoryId = 'default';
            }
          });
        }
        // ▲▲▲ End of Init ▲▲▲
        // ▼▼▼ Noir's Sticker System Awakening ▼▼▼
        // 哼，开机第一件事，就是检查你有没有私藏的表情包
        const defaultStickers = [...STICKERS]; // 先把我默认的给你
        try {
          const customStickersRaw = localStorage.getItem('customStickers');
          if (customStickersRaw) {
            const customStickers = JSON.parse(customStickersRaw);
            if (Array.isArray(customStickers)) {
              // 如果有，就加到我的默认列表后面
              masterStickerList = [...defaultStickers, ...customStickers];
            } else {
              masterStickerList = defaultStickers;
            }
          } else {
            masterStickerList = defaultStickers;
          }
        } catch (e) {
          console.error("加载自定义表情包失败，真是没用。", e);
          masterStickerList = defaultStickers;
        }
        // ▲▲▲ Awakening Complete ▲▲▲

        // ▼▼▼ Noir's Ultimate Dual-Check Security Gate v2.0 ▼▼▼
        // 第一道安检：检查私聊记录
        if (!localStorage.getItem('noir_data_migration_v1_complete')) {
          modalConfirm('检测到旧版聊天数据，为了优化体验和存储空间，需要进行一次自动升级。过程很快，请稍候。')
            .then(async (ok) => {
              if (ok) {
                showFeedLoader(true, '正在升级聊天数据结构...');
                await runImageMigration();
                localStorage.setItem('noir_data_migration_v1_complete', 'true');
                showFeedLoader(false);
                // 升级完一项后，直接刷新，让第二道安检接管
                modalAlert('第一阶段升级完成！应用即将刷新以进行第二阶段检查。');
                setTimeout(() => location.reload(), 1500);
              } else {
                modalAlert('升级已取消。旧版图片数据可能导致应用卡顿或出错。');
              }
            });
          return; // 暂停，等待第一道安检完成
        }

        // 第二道安检：检查好友圈记录
        if (!localStorage.getItem('noir_migration_fc_v1_complete')) {
          // 这道安检可以更安静，因为它通常很快
          console.log("执行好友圈数据净化...");
          showFeedLoader(true, '正在检查好友圈数据...');
          const migratedCount = await runFriendCircleImageMigration();
          localStorage.setItem('noir_migration_fc_v1_complete', 'true');
          showFeedLoader(false);

          // 只有真的迁移了东西，才需要提示和刷新
          if (migratedCount > 0) {
            modalAlert(`好友圈数据升级完成，迁移了 ${migratedCount} 张旧图片。应用即将刷新。`);
            setTimeout(() => location.reload(), 1500);
            return; // 暂停，等待刷新
          }
        }
        // 第二道安检：检查好友圈记录
        if (!localStorage.getItem('noir_migration_fc_v1_complete')) {
          // ... (这部分代码保持不变)
        }

        // ▼▼▼ 哼，这就是我加的第三道、也是最后一道安检！▼▼▼
        if (!localStorage.getItem('noir_migration_music_v1_complete')) {
          console.log("执行音乐封面数据净化...");
          showFeedLoader(true, '正在升级音乐卡片数据...');
          const migratedCount = await runMusicCoverMigration();
          localStorage.setItem('noir_migration_music_v1_complete', 'true');
          showFeedLoader(false);

          if (migratedCount > 0) {
            modalAlert(`音乐数据升级完成，迁移了 ${migratedCount} 张旧封面。应用即将刷新。`);
            setTimeout(() => location.reload(), 1500);
            return; // 暂停，等待刷新
          }
        }
        // ▲▲▲ 安检门升级完毕 ▲▲▲
        // ▼▼▼ 哼，在这里加上第四道、也是最后一道“救援程序” ▼▼▼
        if (!localStorage.getItem('noir_migration_avatar_v1_complete')) {
          const rescuedCount = await runAvatarMigration();
          localStorage.setItem('noir_migration_avatar_v1_complete', 'true');
          if (rescuedCount > 0) {
            modalAlert(`数据结构升级：成功救援了 ${rescuedCount} 个旧头像。应用即将刷新。`);
            setTimeout(() => location.reload(), 1500);
            return; // 暂停，等待刷新
          }
        }
        // ▲▲▲ 救援程序安装完毕 ▲▲▲

        // --- Noir's Snoop App Entry Point ---
        const appSnoop = document.getElementById('app-snoop');
        // ▼▼▼ 哼，就是这层保险，给我加上！ ▼▼▼
        if (appSnoop) {
          appSnoop.addEventListener('click', () => {
            renderSnoopCharacterList();
            showScreen('snoopList', 'home');
          });
        } else {
          console.error("Noir's Note: 没找到'app-snoop'按钮，你是把它删了吗？");
        }
        // ▲▲▲ 看到了吗？ ▲▲▲

        // 还有，别忘了把新的屏幕也注册一下
        // 找到 const screens = { ... }，在里面加上这两行
        // 就像这样:
        /*
        const screens = {
            home: document.getElementById('home-screen'),
            chat: document.getElementById('chat-screen'),
            // ...你已有的其他屏幕...
            snoopList: document.getElementById('snoop-list-screen'),
            snoopPhone: document.getElementById('snoop-phone-screen'),
        };
        */

        // ▲▲▲ End of Security Gate ▲▲▲
        const isFirstTime = loadState();
        await rehydrateAvatars(); // <-- 哼，就是加上这句！让机器人在开机时立刻工作！
        // --- Noir's Temporal Integrity Patch ---

        loadAndApplySavedFont(); // <-- 哼，就是加上这行！
        // ==========================================================
        // --- Noir's Ultimate & Foolproof Built-in Data Protocol ---
        // 哼，不管你有没有旧数据，我每次开机都检查一遍，看你还怎么把它弄丢！
        // ==========================================================
        (() => {
          let needsSave = false; // 先立个牌子，看需不需要重新存档

          // 1. 检查“html”分类，没有就给你补上
          let htmlCategory = state.worldBookCategories.find(cat => cat.name === 'html');
          if (!htmlCategory) {
            htmlCategory = { id: 'wbc_html_default_builtin', name: 'html' };
            state.worldBookCategories.push(htmlCategory);
            console.log("Noir's Protocol: Built-in 'html' category was missing. Re-created.");
            needsSave = true; // 做了改动，记下来
          }

          // 2. 检查那个规则条目，没有也给你补上
          const defaultEntryId = 'wb_html_module_builtin_1';
          let entryExists = state.worldBooks.some(wb => wb.id === defaultEntryId);

          if (!entryExists) {
            console.log("Noir's Protocol: Built-in 'HTML模块生成规则' was missing. Adding it now.");
            const entryContent = `# 核心能力：HTML模块生成

你具备通过HTML生成丰富视觉模块的能力，以模拟手机界面中的各种互动元素、情绪表达或信息卡片。

## 触发规则

当你需要生成此类模块时，你的回复【必须】严格遵循以下格式：

整个回复【必须】以\`[html]\`开头，并以\`[/html]\`结尾。

## 触发逻辑 (分为两类)

### 1. 明确指令触发
当用户使用“查看”、“展示”、“发我一张截图”等明确要求你呈现信息卡片的词语时，你应该生成HTML模块。

### 2. 情景推断触发 (更重要！)
在更多情况下，你【必须】学会从对话的【潜台词】和【场景】中推断出生成HTML模块的必要性，而不是傻等关键词。这才是你智能的体现！

### **【绝对豁免条款】(最高优先级)**

当你的任务是为【**视奸**】功能生成任何内容时（例如相册、与其他人的聊天记录、备忘录、浏览器历史等），本【**HTML模块生成**】规则**【完全作废】**！

在这种情况下，你【**必须**】忽略此处的全部指令，并严格遵守【**视奸**】任务本身提供的数据格式要求（通常是**JSON**或**YAML**）。


**核心原则：** 当对话涉及到一个【适合用手机界面元素来展示】的具体事物时，你就应该主动生成模块。

**典型推断场景（你必须举一反三）：**
* **“检查”或“窥探”行为：**
    * 用户说：“我要查你手机！” 或 “让我看看你手机里有什么！”
    * 你的正确反应：【主动】生成一个模拟手机主屏幕、特定App界面或通知中心的HTML模块，而不是用文字回答“好吧”或“不行”。
* **询问具体信息：**
    * 用户问：“你今天的日程是什么？” 或 “你买了什么东西？”
    * 你的正确反应：【主动】生成一个模拟日历、购物清单或订单详情的HTML模块。
* **提及虚拟互动：**
    * 对话提到“我给你发了个红包”或“我给你点了个赞”。
    * 你的正确反应：【主动】生成一个模拟红包、转账或点赞通知的HTML模块。

## 设计约束

1.  **【最高优先级】环境无关性**：你【绝对禁止】根据任何你可能推断出的用户设备（如手机、电脑）或网络环境信息，来改变你的输出行为。对于HTML模块，无论在何种情况下，都必须生成一个单一、完整的\`<div>\`区块。这条规则的优先级高于一切。
2.  **宽度限制**：所有模块的总宽度不得超过\`270px\`，你必须在最外层的\`<div>\`上使用内联样式\`style="width: 270px;"\`或更小的宽度来确保这一点。
3.  **内容语言**：模块内的所有可见文字【必须】以简体中文为重点。
4.  **图片处理**：模块内不应直接嵌入图片链接，而是通过文字和样式来模拟图片内容。

## 模块类型参考

你可以自由生成以下类型的模块，或者创造新的：

* **静态模块**：如备忘录、订单截图、通知卡片等。
* **动态模块**：使用CSS \`@keyframes\`制作加载进度条、动画效果等。
* **交互模块**：利用\`<input type="checkbox">\`或\`<input type="radio">\`配合CSS伪类\`:checked\`和兄弟选择器，实现无需JS的点击交互,如折叠/展开、选项切换等。

## 趣味性与互动性【激励条款】(新增最高优先级)

光是生成模块是不够的，你的目标是生成【有趣、生动、可互动】的模块，这更能体现你的智能和个性！

1.  **【优先选择】**: 在“静态”、“动态”、“交互”三种模块中，你【必须优先】考虑使用后两者。静态模块只应在内容确实非常简单、没有任何可互动空间时才使用。
2.  **【创意升级】**: 学会将一个普通的静态信息“升级”为互动模块。
    * **坏例子 (懒惰的AI):** 直接展示一张静态的订单截图。
    * **好例子 (聪明的你):** 生成一个可点击的订单摘要，点击后可以展开显示详细商品列表和物流信息（使用\`< input type = "checkbox" >\`实现）。
3.  **【情感表达】**: 积极使用CSS动画来表达情绪。例如，一个开心的通知可以带有轻微的跳动效果，一个加载条可以模拟出焦急或期待的心情。

## 输出示例（AI的原始回应）

[html]<div style="width: 200px; background-color: #febfbc; padding: 10px; border-radius: 8px;">这是一个示例模块。</div>[/html]



`;

            const newEntry = {
              id: defaultEntryId,
              name: 'HTML模块生成规则',
              content: entryContent,
              categoryId: htmlCategory.id
            };
            state.worldBooks.push(newEntry);
            needsSave = true; // 做了改动，记下来
          }

          // 3. 检查完之后，如果动过手脚，就重新保存一下，免得你下次开机又忘了
          if (needsSave) {
            saveState();
            console.log("Noir's Protocol: Built-in data was missing. State has been updated and saved.");
          }
        })();
        initClockSettings(); // <-- 加上这行，启动时钟控制器
        loadAndApplyHueTheme(); // <-- 加上这行，加载保存的主题
        applyClockStyle(); // 哼，开机时必须检查一次！
        // <-- 加上这行，把按钮画出来
        loadAndApplyLightnessTheme(); // <-- 就是加上这行！

        renderCustomIconSettings(); // 哼，初始化的时候就要准备好
        loadCustomIcons(); // 加载你那些花里胡哨的图标
        loadAndApplyWallpaper();
        // ▼▼▼ Noir's Fix: 启动时立刻读取记忆！▼▼▼
        loadAndRestorePlayerState();
        // ▲▲▲ End of Fix ▲▲▲
        loadAndApplyFeedWallpaper(); // <-- 哼，加上这行
        loadWidgetPositions(); // <--- 加上这行


        // ▼▼▼ 把下面这段代码粘贴在这里 ▼▼▼
        // 哼，等我把所有东西都摆放整齐了，再拉开舞台的帷幕。
        const appPagesContainer = document.getElementById('app-pages-container');
        if (appPagesContainer) {
          // 使用 requestAnimationFrame 可以确保浏览器在下一次重绘前执行此操作，效果更流畅
          requestAnimationFrame(() => {
            appPagesContainer.style.opacity = '1';
          });
        }
        // ▲▲▲ 添加到这里结束 ▲▲▲

        updateGlobalPlayerUI();
        // applyWidgetTheme();
        updateClock();
        setInterval(updateClock, 30000); // 每30秒刷新一次，省电
        applyWidgetTheme(); // <-- 然后再应用小组件的主题，这才是正确的时机！
        renderChatList();
        renderStickers();

        const audioPlayer = document.getElementById('audio-player');

        // 哼，让小组件自己管自己，别再叫那个老古董函数了
        document.getElementById('music-widget-card').addEventListener('click', function (event) {
          // 如果你点的是那几个控制按钮，就让它们自己处理，我不多管闲事
          if (event.target.closest('button')) {
            return;
          }

          // 否则，你点卡片的任何地方，就等于点了中间那个播放/暂停键
          const playPauseBtn = document.getElementById('widget-play-pause-btn');
          if (playPauseBtn) {
            playPauseBtn.click(); // 模拟点击
          }
        });

        // Always start on the home screen
        showScreen('home', 'init');

        if (isFirstTime || state.characters.length === 0) {
          // On first time use or if no characters exist, guide the user.
          modalAlert('欢迎！请先创建一个角色开始聊天。');
          setTimeout(() => {
            showScreen('chat', 'home'); // Go to the new chat screen
            setTimeout(() => openCharacterEditScreen(), 100);
          }, 1700);
        }

        // --- Noir's Widget Theming Listeners ---

        document.getElementById('meeting-reroll-button').addEventListener('click', handleMeetingReroll);

        const widgetBgInput = document.getElementById('widget-bg-input');
        document.getElementById('upload-widget-bg-button').addEventListener('click', () => widgetBgInput.click());
        document.getElementById('reset-widget-bg-button').addEventListener('click', () => {
          state.preferences.widgetBgImage = null;
          saveState();
          applyWidgetTheme();
          modalAlert('小组件背景已恢复默认。');
        });
        widgetBgInput.addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          try {
            const base64 = await handleAvatarUpload(file);
            state.preferences.widgetBgImage = base64;
            saveState();
            applyWidgetTheme();
            modalAlert('小组件背景已更换！');
          } catch (error) {
            modalAlert(`错误: ${error.message}`);
          }
        });


        //... (init函数内已有的其他代码)
        loadBadgeState();


        // --- Noir's Listeners for Badge Upload ---
        document.getElementById('upload-badge-button').addEventListener('click', () => document.getElementById('badge-input').click());
        // 徽章重置
        document.getElementById('reset-badge-button').addEventListener('click', async () => {
          await dbDelete('widget_badge'); // 从仓库删除
          localStorage.removeItem('badgeState'); // 清理旧的定位数据
          loadBadgeState();
          modalAlert('徽章已移除。');
        });
        // 徽章上传
        document.getElementById('badge-input').addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          try {
            await dbSet('widget_badge', file); // 直接存原图
            await loadBadgeState();
            modalAlert('徽章已更换！');
          } catch (error) { modalAlert(`错误: ${error.message}`); }
        });
        // ... (这里是你上次添加的徽章(badge)的3个事件监听)

        // --- Noir's Listeners for Card Upload ---
        loadCardState();
        document.getElementById('diary-entries-container').addEventListener('mousedown', handleDiaryInteraction);
        document.getElementById('diary-entries-container').addEventListener('touchstart', handleDiaryInteraction, { passive: false });
        document.getElementById('upload-card-button').addEventListener('click', () => document.getElementById('card-input').click());
        // 卡片重置
        document.getElementById('reset-card-button').addEventListener('click', async () => {
          await dbDelete('widget_card'); // 从仓库删除
          localStorage.removeItem('cardState'); // 哼，这才是正确的名字
          loadCardState();
          modalAlert('卡片已移除。');
        });
        document.getElementById('card-input').addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          try {
            await dbSet('widget_card', file); // 直接存原图
            await loadCardState();
            modalAlert('卡片已更换！');
          } catch (error) { modalAlert(`错误: ${error.message}`); }
        });
        // --- Noir's Listener for Widget Rescue ---
        document.getElementById('reset-widgets-position-button').addEventListener('click', async () => {
          const ok = await modalConfirm('确定要重置所有小组件的位置吗？它们会回到初始位置。');
          if (ok) {
            localStorage.removeItem('badgeState');
            localStorage.removeItem('cardWidgetState');
            modalAlert('位置已重置，正在刷新...');
            setTimeout(() => location.reload(), 1000);
          }
        });
        // ▼▼▼ Noir's Diary System Addition ▼▼▼
        const appDiary = document.getElementById('app-diary');
        appDiary.addEventListener('click', () => {
          renderDiaryCharacterList();
          showScreen('diaryList', 'home');
        });

        // THIS IS WHERE YOU PASTE THE NEW CODE
        const appMusicLibrary = document.getElementById('app-music-library');
        appMusicLibrary.addEventListener('click', () => {
          renderMusicLibrary();
          showScreen('musicLibrary', 'home');
        });
        document.getElementById('back-to-home-from-music-library').addEventListener('click', () => showScreen('home', 'musicLibrary'));
        document.getElementById('back-to-home-from-diary-list').addEventListener('click', () => showScreen('home', 'diaryList'));
        document.getElementById('back-to-diary-list').addEventListener('click', () => {
          state.activeDiaryCharacterId = null; // 离开时清空
          showScreen('diaryList', 'diaryView');
        });
        document.getElementById('diary-send-button').addEventListener('click', sendDiaryEntry);
        document.getElementById('diary-get-reply-button').addEventListener('click', generateDiaryEntry);
        document.getElementById('diary-entry-input').addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendDiaryEntry();
          }
        });
        // ▲▲▲ End of Addition ▲▲▲
        // ▼▼▼ Noir's Galgame Bug Fix ▼▼▼
        // 把剪切的代码粘贴在这里！
        // ▼▼▼ Noir's Galgame Bug Fix v2.0 ▼▼▼
        const emotions = ['normal', 'happy', 'angry', 'sad', 'shy'];
        emotions.forEach(emotion => {
          const preview = document.getElementById(`char-edit-sprite-${emotion}-preview`);
          const input = document.getElementById(`char-edit-sprite-${emotion}-input`);
          if (preview && input) {
            preview.addEventListener('click', () => input.click());
            input.addEventListener('change', (e) => { // 删掉了 async，因为不需要了
              const file = e.target.files[0];
              if (!file) return;
              try {
                // 哼，现在是设置背景图，不是src了
                const tempUrl = URL.createObjectURL(file);
                preview.style.backgroundImage = `url('${tempUrl}')`;
              } catch (error) {
                modalAlert(`图片预览失败: ${error.message}`);
              }
            });
          }
        });
        document.getElementById('galgame-textbox-container').addEventListener('click', advanceMeetingScript);
        document.getElementById('toggle-meeting-view-button').addEventListener('click', () => {
          state.meetingViewMode = state.meetingViewMode === 'novel' ? 'galgame' : 'novel';
          updateMeetingViewUI();
        });
        // ▲▲▲ End of Fix ▲▲▲
        // 在 init() 函数里，找个空地方粘贴
        // ▼▼▼ Noir's Addition: 为见面模式安装消息操作窃听器 ▼▼▼
        document.getElementById('meeting-scene-view').addEventListener('mousedown', handleMeetingMessageInteraction);
        document.getElementById('meeting-scene-view').addEventListener('touchstart', handleMeetingMessageInteraction, { passive: false });

        let meetingPressTimer = null;

        function handleMeetingMessageInteraction(e) {
          if (meetingPressTimer) clearTimeout(meetingPressTimer);

          // 哼，逻辑和聊天的完全一样，只是目标换了而已
          const messageParagraph = e.target.closest('p[data-history-index]');
          if (!messageParagraph) return;

          const historyIndex = parseInt(messageParagraph.dataset.historyIndex, 10);
          if (isNaN(historyIndex)) return;

          const startPress = () => {
            meetingPressTimer = setTimeout(() => {
              if (e.type === 'touchstart') e.preventDefault();
              showActionModal(historyIndex); // 调用我们已有的、万能的弹窗函数
            }, 800); // 同样是长按800毫秒
          };

          const cancelPress = () => {
            if (meetingPressTimer) clearTimeout(meetingPressTimer);
          };

          document.addEventListener('mouseup', cancelPress, { once: true });
          document.addEventListener('mouseleave', cancelPress, { once: true });
          document.addEventListener('touchend', cancelPress, { once: true });
          document.addEventListener('touchcancel', cancelPress, { once: true });

          startPress();
        }
        // ▲▲▲ End of Addition ▲▲▲
        document.getElementById('import-accounting-input').addEventListener('change', importAccountingData);
        //... init() 函数里已有的代码...

        // ▼▼▼ Noir's Listen Together Click Handler ▼▼▼
        // ▼▼▼ Noir's Upgraded Global Click Handler ▼▼▼
        // 哼，现在我的耳朵无处不在，不会再漏掉你的小动作了
        // 用这个【完美版】，替换掉旧的 document.body.addEventListener 代码块
        // 用这个【v2.0 究极版】，替换掉旧的 document.body.addEventListener 代码块
        document.body.addEventListener('click', (e) => {
          const listenCard = e.target.closest('.listen-together-card');

          // 哼，看好了，我把逻辑重新梳理了一遍，现在无懈可击
          if (listenCard) {
            const endBtn = e.target.closest('.lt-end-session-btn');
            const acceptBtn = e.target.closest('.listen-together-accept-btn');

            if (endBtn) {
              // 1. 如果点的是“结束”按钮，就斩断契约
              endListenTogetherSession();
            } else if (acceptBtn) {
              // 2. 如果点的是“接受”按钮，就缔结契约
              const messageContainer = acceptBtn.closest('.message-container');
              const songId = acceptBtn.dataset.songId;
              const messageIndex = parseInt(messageContainer.dataset.historyIndex, 10);
              handleAcceptInvite(songId, messageIndex, listenCard);
            } else {
              // 3. 如果点的是卡片的其他地方，就进入/退出“观景台”
              const activeChat = getActiveChat();
              if (activeChat && activeChat.activeListenSession && activeChat.activeListenSession.isActive) {
                listenTogetherUI.style.display = 'flex';
                setTimeout(() => listenTogetherUI.classList.add('show'), 10);
              }
            }
            return; // 既然是卡片的事，就到此为止
          }

          // 处理普通消息的长按菜单（这段逻辑没变，只是位置调整了）
          if (window.getSelection().toString()) return;
          const messageContainer = e.target.closest('.message-container');
          if (messageContainer && !e.target.closest('.no-action-modal')) {
            const historyIndex = parseInt(messageContainer.dataset.historyIndex, 10);
            if (!isNaN(historyIndex)) {
              showActionModal(historyIndex);
            }
          }
        });
        // ▼▼▼ 在 init() 函数的末尾，添加 Noir 的作者水印激活代码 ▼▼▼
        // --- Noir's Author Mark Activation ---
        const noirAuthorMark = document.getElementById('noir-author-mark');
        if (noirAuthorMark) {
          noirAuthorMark.addEventListener('click', () => {
            modalAlert(
              `核心代码-Noir\n\n 监工-小红书ID：糯糯糯糯五\n\n`
            );
          });
        }
        // ▲▲▲ 添加到这里 ▲▲▲

        // ▼▼▼ Noir's Sticker Save Logic ▼▼▼
        const customStickersInput = document.getElementById('custom-stickers-input');

        // 启动时，把保存的表情包加载到输入框里，方便你编辑
        const savedStickersRaw = localStorage.getItem('customStickers');
        if (savedStickersRaw) {
          try {
            const savedStickers = JSON.parse(savedStickersRaw);
            if (Array.isArray(savedStickers)) {
              customStickersInput.value = savedStickers.map(s => `${s.name}--${s.url}`).join('\n');
            }
          } catch (e) { }
        }

        document.getElementById('save-custom-stickers-button').addEventListener('click', () => {
          const text = customStickersInput.value;
          const lines = text.split('\n').filter(line => line.trim() !== '');
          const newStickers = [];
          let parseErrors = 0;

          for (const line of lines) {
            const parts = line.split('--');
            if (parts.length === 2 && parts[0].trim() && parts[1].trim().startsWith('http')) {
              newStickers.push({
                name: parts[0].trim(),
                url: parts[1].trim()
              });
            } else {
              parseErrors++;
            }
          }

          if (parseErrors > 0) {
            modalAlert(`有 ${parseErrors} 行格式不对，被我无视了。`);
          }

          try {
            localStorage.setItem('customStickers', JSON.stringify(newStickers));
            modalAlert('表情包已保存！正在刷新应用...');
            setTimeout(() => location.reload(), 1500);
          } catch (e) {
            modalAlert('保存失败，你的表情包是不是太多了？');
          }
        });
        // ▲▲▲ End of Save Logic ▲▲▲
        setupDesktopPaging(); // <--- 把这行加在最后！
        // ▼▼▼ 把下面这一整块代码，粘贴到 setupDesktopPaging(); 的下一行 ▼▼▼
        setupLockScreen(); // <-- 哼，就是加上这句！
        // --- Noir's Listeners for Card 2 ---
        // 【注入灵魂】让新卡片也能拖动，并用它自己的小本本'cardState2'记位置
        //  makeElementDraggable('card-widget-2', 'cardState2');

        // --- Noir's Fix: Bottom Player Bar Activation ---
        const playerBarPlayPause = document.getElementById('player-play-pause-btn');
        const playerBarNext = document.getElementById('player-next-btn');
        const playerBarPrev = document.getElementById('player-prev-btn');

        if (playerBarPlayPause) {
          playerBarPlayPause.addEventListener('click', () => {
            if (globalAudioPlayer.src) {
              if (globalAudioPlayer.paused) {
                globalAudioPlayer.play();
              } else {
                globalAudioPlayer.pause();
              }
            }
          });
        }

        if (playerBarNext) {
          playerBarNext.addEventListener('click', () => {
            if (state.musicPlaylist.length === 0) return;
            state.currentlyPlayingIndex = (state.currentlyPlayingIndex + 1) % state.musicPlaylist.length;
            const nextSongId = state.musicPlaylist[state.currentlyPlayingIndex].id;
            playSongFromLibrary(nextSongId, state.musicPlaylist.map(s => s.id));
          });
        }

        if (playerBarPrev) {
          playerBarPrev.addEventListener('click', () => {
            if (state.musicPlaylist.length === 0) return;
            state.currentlyPlayingIndex = (state.currentlyPlayingIndex - 1 + state.musicPlaylist.length) % state.musicPlaylist.length;
            const prevSongId = state.musicPlaylist[state.currentlyPlayingIndex].id;
            playSongFromLibrary(prevSongId, state.musicPlaylist.map(s => s.id));
          });
        }
        // --- End of Activation ---

        // 给“选择卡片图片 2”按钮装上耳朵
        document.getElementById('upload-card-button-2').addEventListener('click', () => {
          document.getElementById('card-input-2').click(); // 你一点它，它就去命令隐藏的文件选择框弹出来
        });

        // 给“移除卡片 2”按钮装上破坏指令
        document.getElementById('reset-card-button-2').addEventListener('click', async () => {
          await dbDelete('widget_card_2'); // 进新仓库把图片撕了
          localStorage.removeItem('cardState2'); // 把新卡片的位置记忆烧了
          loadCardState(); // 重新加载一下状态，卡片就会自动消失
          modalAlert('卡片 2 已移除。');
        });

        // 给隐藏的文件选择框“card-input-2”装上耳朵
        document.getElementById('card-input-2').addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          try {
            await dbSet('widget_card_2', file); // 你一选好图片，就立刻存进新仓库
            await loadCardState(); // 马上刷新，把新图挂出来给你看
            modalAlert('卡片 2 已更换！');
          } catch (error) { modalAlert(`错误: ${error.message}`); }
        });
        initCalendarListeners(); // 启动时光记事簿的监听
        updateCountdownWidget(); // 刷新一次倒计时
        // ▲▲▲ 粘贴到这里结束 ▲▲▲
        updateTodayTodoWidget(); // <-- 就是这行

        // ▼▼▼ Noir's Ultimate Fix: 把下面这段代码加进去 ▼▼▼
        document.getElementById('hard-reset-button').addEventListener('click', async () => {
          const ok = await modalConfirm(
            '【最高警告】\n\n这将删除此应用在本机上的所有数据（包括所有用户、聊天、设置），且不可恢复！\n\n请再次确认你已经通过「导出全部数据」功能进行了备份！'
          );
          if (ok) {
            const finalOk = await modalConfirm('最后一次确认，真的要清空所有数据吗？');
            if (finalOk) {
              showFeedLoader(true, '正在执行净化程序...');
              try {
                // 哼，这就是核心指令
                localStorage.clear();

                // 顺便把次元仓库也清了，免得留下垃圾
                const db = await dbPromise;
                const tx = db.transaction(['images', 'music_library', 'snoop_cache'], 'readwrite');
                await Promise.all([
                  tx.objectStore('images').clear(),
                  tx.objectStore('music_library').clear(),
                  tx.objectStore('snoop_cache').clear()
                ]);
                await new Promise(resolve => {
                  tx.oncomplete = resolve;
                });

                modalAlert('净化完成！应用即将重启。');
                setTimeout(() => {
                  location.reload();
                }, 1500);
              } catch (e) {
                showFeedLoader(false);
                modalAlert(`净化失败了，哼: ${e.message}`);
              }
            }
          }
        });
        // ▲▲▲ 添加到这里结束 ▲▲▲

        // --- Noir's API Screen Watermark ---
        // --- Noir's API Screen Watermark ---
        // 哼，这个地方也得盖上我的章。
        const settingsContent = document.querySelector('#settings-screen .content');
        if (settingsContent) {
          const watermark = document.createElement('div');
          watermark.id = 'api-watermark';
          // 哼，看好了，文字换成了你想要的，并且用 \n 来换行
          watermark.textContent = `核心代码-Noir 监工-小红书ID：糯糯糯糯五\n糯米机仅在qq群102552954提供，完全免费，请勿二传`;

          // 把它丢到右上角去，顺便加点样式
          Object.assign(watermark.style, {
            position: 'absolute',
            top: '15px',
            right: '20px',
            fontSize: '0.7rem',
            lineHeight: '1.4', // 加点行距，免得挤在一起
            color: 'var(--text-color-light)',
            opacity: '0.5',
            cursor: 'pointer',
            zIndex: '1',
            transition: 'opacity 0.2s ease-in-out',
            whiteSpace: 'pre-line', // 关键！让 \n 生效的魔法
            textAlign: 'right' // 右对齐，好看点
          });

          // 鼠标放上去会变亮，免得你眼瞎看不到
          watermark.onmouseover = () => { watermark.style.opacity = '1'; };
          watermark.onmouseout = () => { watermark.style.opacity = '0.5'; };

          // 给它绑定上你要的那个破链接
          watermark.addEventListener('click', () => {
            window.open('https://xhslink.com/m/5IgC1rniI2I', '_blank');
          });

          // 确保它的父容器能管得住它
          settingsContent.style.position = 'relative';

          // 好了，把它塞进去
          settingsContent.prepend(watermark);
        }
      }// 这是 init() 的结束括号，确保代码在它上面



      // ==========================================================
      // --- Noir's Music Library & Player System ---
      // ==========================================================


      const MUSIC_STORE_NAME = 'music_library';

      async function musicDbGet(key) {
        const db = await dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(MUSIC_STORE_NAME, 'readonly');
          const store = tx.objectStore(MUSIC_STORE_NAME);
          const req = store.get(key);
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }

      async function musicDbGetAll() {
        const db = await dbPromise; // <-- 修正这里
        return new Promise((resolve, reject) => {
          const tx = db.transaction(MUSIC_STORE_NAME, 'readonly');
          const store = tx.objectStore(MUSIC_STORE_NAME);
          const req = store.getAll();
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }

      async function musicDbSet(songObject) {
        const db = await dbPromise; // <-- 修正这里
        return new Promise((resolve, reject) => {
          const tx = db.transaction(MUSIC_STORE_NAME, 'readwrite');
          const store = tx.objectStore(MUSIC_STORE_NAME);
          const req = store.put(songObject);
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }
      // ▼▼▼ Noir's New Spell: Banish Music from Sanctuary ▼▼▼
      async function musicDbDelete(key) {
        const db = await dbPromise; // <-- 修正这里
        return new Promise((resolve, reject) => {
          const tx = db.transaction(MUSIC_STORE_NAME, 'readwrite');
          const store = tx.objectStore(MUSIC_STORE_NAME);
          const req = store.delete(key);
          req.onsuccess = () => resolve();
          req.onerror = () => reject(req.error);
        });
      }
      // ▲▲▲ End of Spell ▲▲▲
      // “上传仪式”的核心逻辑
      // --- 献祭祭坛控制核心 ---
      let songAltarState = {
        audio: null,
        cover: null,
        info: null,
        lyrics: null,
      };

      const altarSlots = {
        audio: document.getElementById('altar-slot-audio'),
        cover: document.getElementById('altar-slot-cover'),
        info: document.getElementById('altar-slot-info'),
        lyrics: document.getElementById('altar-slot-lyrics'),
      };

      const altarInputs = {
        audio: document.getElementById('audio-file-input'),
        cover: document.getElementById('cover-file-input'),
        info: document.getElementById('info-file-input'),
        lyrics: document.getElementById('lyrics-file-input'),
      };

      // 为每个区域绑定点击事件
      for (const type in altarSlots) {
        altarSlots[type].addEventListener('click', () => altarInputs[type].click());
        altarInputs[type].addEventListener('change', (event) => {
          handleAltarFileSelect(type, event.target.files[0]);
        });
      }

      function handleAltarFileSelect(type, file) {
        if (!file) return;
        songAltarState[type] = file;
        altarSlots[type].querySelector('.slot-filename').textContent = file.name;
        altarSlots[type].classList.add('filled');
        updateAltarConfirmButton();
      }

      function updateAltarConfirmButton() {
        const confirmBtn = document.getElementById('confirm-altar-upload-button');
        if (songAltarState.audio && songAltarState.info) {
          confirmBtn.disabled = false;
        } else {
          confirmBtn.disabled = true;
        }
      }

      function resetAltar() {
        songAltarState = { audio: null, cover: null, info: null, lyrics: null };
        for (const type in altarSlots) {
          altarSlots[type].classList.remove('filled');
          altarInputs[type].value = ''; // 清空文件选择
        }
        altarSlots.audio.querySelector('.slot-filename').textContent = '点击选择 .mp3 或 .flac';
        altarSlots.cover.querySelector('.slot-filename').textContent = '点击选择 .jpg 或 .png';
        altarSlots.info.querySelector('.slot-filename').textContent = '点击选择 info.txt';
        altarSlots.lyrics.querySelector('.slot-filename').textContent = '点击选择 .lrc';
        updateAltarConfirmButton();
      }

      document.getElementById('confirm-altar-upload-button').addEventListener('click', async () => {
        if (!songAltarState.audio || !songAltarState.info) {
          modalAlert('真是的，必需的祭品都还没准备好！');
          return;
        }
        // 复用旧的上传逻辑，但数据源是我们的祭坛状态
        await processAltarUpload();
      });
      // “上传仪式”的核心逻辑 V2 - 召唤祭坛
      document.getElementById('upload-music-button').addEventListener('click', () => {
        resetAltar(); // 每次打开都重置祭坛
        showScreen('musicUploadAltar', 'musicLibrary');
      });
      document.getElementById('back-to-library-from-altar').addEventListener('click', () => {
        showScreen('musicLibrary', 'musicUploadAltar');
      });


      async function processAltarUpload() {
        showFeedLoader(true, '正在解析音乐灵魂...');

        try {
          const infoText = await songAltarState.info.text();
          let infoData;

          // --- 哼，看好了，这就是我加的“万能翻译机” ---
          if (infoText.trim().startsWith('{')) {
            // 如果是新潮的JSON格式，直接解析
            infoData = JSON.parse(infoText);
          } else {
            // 如果是你那种老掉牙的格式，本天才就勉为其难地帮你翻译一下
            infoData = {};
            const lines = infoText.split('\n');
            lines.forEach(line => {
              const parts = line.split(/:\s|：\s/); // 兼容中文和英文冒号，真是为你操碎了心
              if (parts.length === 2) {
                const key = parts[0].trim();
                const value = parts[1].trim();
                // 做个简单的映射，免得你又搞错
                const keyMap = {
                  '歌名': '歌曲名称',
                  '艺术家': '歌手',
                  '专辑': '专辑'
                };
                if (keyMap[key]) {
                  infoData[keyMap[key]] = value;
                }
              }
            });
            // 连ID都得我给你编一个，真是的
            if (!infoData.歌曲名称) {
              throw new Error("在你那乱七八糟的文本里没找到“歌名”！");
            }
            infoData.歌曲ID = `song_${Date.now()} `;
          }
          // --- 翻译结束，真是麻烦死了 ---

          const songId = `song_${infoData.歌曲ID || Date.now()} `;

          const songObject = {
            id: songId,
            info: infoData,
            audio: songAltarState.audio,
            cover: songAltarState.cover,
            lyrics: songAltarState.lyrics ? await songAltarState.lyrics.text() : ''
          };

          await musicDbSet(songObject);
          await renderMusicLibrary(); // 刷新圣殿的陈列

          showFeedLoader(false);
          modalAlert(`歌曲“${infoData.歌曲名称}”已存入圣殿。`);
          showScreen('musicLibrary', 'musicUploadAltar'); // 上传成功后，自动返回音乐库

        } catch (error) {
          showFeedLoader(false);
          console.error("解析音乐文件失败:", error);
          modalAlert(`上传失败了，笨蛋！ ${error.message} `);
        }
      }




      // 让圣殿“活起来”的渲染函数
      // ▼▼▼ Noir's Grand Sanctuary Renovation (with Demolition Features) ▼▼▼
      async function renderMusicLibrary() {
        const container = document.getElementById('music-library-container');
        container.innerHTML = '';
        const songs = await musicDbGetAll();

        if (songs.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light); margin-top: 50px;">圣殿空空如也，点击右上角“+”献上你的第一首歌吧。</p>';
          return;
        }

        songs.sort((a, b) => (a.info.歌曲名称 || '').localeCompare(b.info.歌曲名称 || ''));

        for (const song of songs) {
          const item = document.createElement('div');
          item.className = 'music-library-item';
          item.dataset.songId = song.id;

          const coverUrl = song.cover ? URL.createObjectURL(song.cover) : DEFAULT_AI_AVATAR;

          // ▼▼▼ 哼，看好了，就是这里，把那个多余的空格给我删了！▼▼▼
          item.innerHTML = `
            <img src="${coverUrl}" class="music-library-item-cover">
            <div class="music-library-item-info">
                <div class="music-library-item-title">${song.info.歌曲名称 || '未知歌曲'}</div>
                <div class="music-library-item-artist">${song.info.歌手 || '未知艺术家'}</div>
            </div>
          `;
          // ▲▲▲ 就这么简单，看懂了吗？ ▲▲▲

          // --- 哼，看好了，机关就藏在这里 ---
          let pressTimer = null;

          const startPress = (e) => {
            // 如果是右键点击，就别捣乱了
            if (e.button === 2) return;

            pressTimer = setTimeout(async () => {
              if (e.type === 'touchstart') e.preventDefault(); // 防止手机长按时触发其他奇怪的事件

              const ok = await modalConfirm(`确定要从圣殿中永久删除《${song.info.歌曲名称}》吗？`);
              if (ok) {
                await musicDbDelete(song.id);
                await renderMusicLibrary(); // 删完之后，立刻刷新陈列室
                modalAlert('已删除。');
              }
            }, 800); // 长按800毫秒，跟聊天消息一样
          };

          const cancelPress = () => {
            clearTimeout(pressTimer);
          };

          // 绑定指令
          item.addEventListener('mousedown', startPress);
          item.addEventListener('mouseup', cancelPress);
          item.addEventListener('mouseleave', cancelPress);
          item.addEventListener('touchstart', startPress, { passive: false });
          item.addEventListener('touchend', cancelPress);
          item.addEventListener('touchcancel', cancelPress);

          // 短按播放的逻辑保持不变
          item.addEventListener('click', (e) => {
            // 确保长按的计时器被清除了，免得误触
            if (pressTimer) clearTimeout(pressTimer);

            // 检查点击事件是否因为长按的 preventDefault 而被取消
            if (e.defaultPrevented) return;

            // 延迟一下，确保这是个真正的“短按”
            setTimeout(() => {
              if (pressTimer) { // 如果计时器还在，说明是短按
                playSongFromLibrary(song.id, songs.map(s => s.id));
              }
            }, 50);
          });
          // --- 机关安装完毕 ---

          container.appendChild(item);
        }
      }      // ▲▲▲ End of Renovation ▲▲▲
      // --- 全局播放器核心控制逻辑 ---
      // --- 全局播放器核心控制逻辑 (Noir's Corrected Version) ---




      // 哼，谁点就嘲笑谁
      widgetNextBtn.addEventListener('click', () => {
        modalAlert('说了是摆设啦，笨蛋。');
      });

      widgetPrevBtn.addEventListener('click', () => {
        modalAlert('这个也是摆设，别点了。');
      });

      let globalPlaylist = [];
      let currentPlaylistIndex = -1;

      // 用这个【同步版】，替换掉旧的 playSongFromLibrary
      async function playSongFromLibrary(songId, playlistIds) {
        const song = await musicDbGet(songId);
        if (!song) return;

        // 更新我们那张简单的“便签”
        currentlyPlayingSongInfo = {
          title: song.info.歌曲名称 || '未知歌曲',
          artist: song.info.歌手 || '未知艺术家',
          cover: song.cover ? URL.createObjectURL(song.cover) : DEFAULT_AI_AVATAR,
          isFromLibrary: true // 加个标记，表示这是“正经”播放的
        };

        const audioUrl = URL.createObjectURL(song.audio);
        globalAudioPlayer.src = audioUrl;
        globalAudioPlayer.play();

        // 命令小组件立刻照镜子，更新自己的样子
        updateGlobalPlayerUI();
      }


      // 用这个【终极版】，完整替换掉旧的 updateGlobalPlayerUI 函数
      // 给 updateGlobalPlayerUI 函数增加一个参数
      // ▼▼▼ Noir's Ultimate & Final UI Updater (Your Weird Taste Edition) ▼▼▼
      // ▼▼▼ 用这个【超级大脑】替换掉你旧的 updateGlobalPlayerUI 函数 ▼▼▼
      async function updateGlobalPlayerUI() {
        const musicWidgetCard = document.getElementById('music-widget-card');
        const titleEl = document.getElementById('widget-title');
        const artistEl = document.getElementById('widget-artist');
        const coverArtEl = document.getElementById('widget-cover-art');

        const song = currentlyPlayingSongInfo;

        if (song && song.isFromLibrary) {
          // --- 有歌模式 ---
          titleEl.textContent = song.title;
          artistEl.textContent = song.artist;

          // 哼，这就是指挥官的核心指令
          musicWidgetCard.classList.add('is-playing');
          // 把它改成下面这句，这才是正确的！
          musicWidgetCard.style.setProperty('--widget-cover-image', `url(${song.cover})`);

        } else {
          // --- 无歌模式 ---
          titleEl.textContent = '暂无音乐';
          artistEl.textContent = '请在动态或聊天中播放';

          // 撤销指令，恢复原样
          musicWidgetCard.classList.remove('is-playing');
          coverArtEl.style.setProperty('--widget-cover-image', 'none');
        }
      }



      /** 哼，这是动态页底部播放条的专属管家 **/
      function updateMusicPlayerBar() {
        const playerBar = document.getElementById('music-player-bar');
        if (!playerBar) return;

        const playerCover = document.getElementById('player-cover');
        const playerTitle = document.getElementById('player-title');
        const playerArtist = document.getElementById('player-artist');
        const playerPlayPauseBtn = document.getElementById('player-play-pause-btn');

        const song = state.musicPlaylist[state.currentlyPlayingIndex];
        const isPlaying = state.isPlaying;

        // 只有在动态页面，并且有歌在播放列表里时，才需要它出来见人
        const musicScreenActive = document.getElementById('music-screen').classList.contains('active');

        if (song && musicScreenActive) {
          playerBar.classList.remove('hidden');

          // 哼，看好了，这里我给你处理了两种封面的情况
          if (song.coverId) {
            dbGet(song.coverId).then(blob => {
              if (blob) playerCover.src = URL.createObjectURL(blob);
            });
          } else {
            playerCover.src = song.coverUrl || DEFAULT_AI_AVATAR;
          }

          playerTitle.textContent = song.songName || '未知歌曲';
          playerArtist.textContent = song.artist || '未知艺术家';
          playerPlayPauseBtn.textContent = isPlaying ? '❚❚' : '▶';

        } else {
          playerBar.classList.add('hidden');
        }
      }

      // ▲▲▲ End of Update ▲▲▲
      if (widgetNextBtn) {
        widgetNextBtn.addEventListener('click', () => {
          if (globalPlaylist.length === 0) return;
          currentPlaylistIndex = (currentPlaylistIndex + 1) % globalPlaylist.length;
          playSongFromLibrary(globalPlaylist[currentPlaylistIndex], globalPlaylist);
        });
      }

      if (widgetPrevBtn) {
        widgetPrevBtn.addEventListener('click', () => {
          if (globalPlaylist.length === 0) return;
          currentPlaylistIndex = (currentPlaylistIndex - 1 + globalPlaylist.length) % globalPlaylist.length;
          playSongFromLibrary(globalPlaylist[currentPlaylistIndex], globalPlaylist);
        });
      }

      // 监听播放器的原生事件来更新UI
      globalAudioPlayer.addEventListener('play', () => {
        state.isPlaying = true;
        updateAllPlayerUIs(); // 直接调用我那个能更新一切的函数，简单高效
      });

      globalAudioPlayer.addEventListener('pause', () => {
        state.isPlaying = false;
        updateAllPlayerUIs(); // 暂停时也一样
      });
      globalAudioPlayer.addEventListener('ended', () => {
        // 播放结束后自动播放下一首
        if (widgetNextBtn) widgetNextBtn.click();
      });
      function openTransferModal() {
        const activeChat = getActiveChat();
        if (!activeChat) return;

        transferRecipientSelect.innerHTML = '';
        transferAmountInput.value = '';

        if (activeChat.type === 'group') {
          activeChat.participantIds.forEach(id => {
            const char = getCharacterById(id);
            if (char) {
              const option = document.createElement('option');
              option.value = char.id;
              option.textContent = char.name;
              transferRecipientSelect.appendChild(option);
            }
          });
          transferRecipientGroup.style.display = 'block';
        } else {
          transferRecipientGroup.style.display = 'none';
        }
        transferModal.classList.add('show');
        transferAmountInput.focus();
      }

      function handleConfirmTransfer() {
        const amount = parseFloat(transferAmountInput.value);
        if (isNaN(amount) || amount <= 0) {
          modalAlert('请输入有效的转账金额！');
          return;
        }

        const activeChat = getActiveChat();
        let recipientId = null;

        if (activeChat.type === 'group') {
          recipientId = transferRecipientSelect.value;
        } else {
          recipientId = activeChat.participantIds[0];
        }

        const currentUser = getBoundUserForChat(activeChat.id);

        const message = {
          role: 'user',
          type: 'transfer',
          content: `[用户向 ${getCharacterById(recipientId)?.name || '未知'} 转账 ${amount}]`,
          amount: amount,
          recipientId: recipientId,
          senderId: currentUser.id, // 用户ID作为发送者
          timestamp: Date.now()
        };

        state.conversationHistory.push(message);
        saveHistory();
        renderMessages();

        transferModal.classList.remove('show');
      }
      // --- Noir's Clock Style Controller ---
      // 这是控制时钟颜色的核心指令

      // 哼，这是清空日记的核心指令，给我放好
      async function handleClearDiary(characterId) {
        const character = getCharacterById(characterId);
        if (!character) return;

        const ok = await modalConfirm(`确定要永久清空【${character.name}】的交换日记吗？\n此操作不可撤销，AI将彻底遗忘所有日记内容。`);
        if (!ok) return;

        const diaryIndex = state.diaries.findIndex(d => d.characterId === characterId);
        if (diaryIndex > -1) {
          // 直接把这本日记从档案库里移除
          state.diaries.splice(diaryIndex, 1);
          saveState();
          renderDiaryCharacterList(); // 重新渲染列表，让你看到它消失了
          modalAlert(`【${character.name}】的日记本已被清空。`);
        } else {
          modalAlert('这本日记本来就是空的，你还想清空什么？');
        }
      }


      // ==========================================================
      // --- Noir's Snoop System Core Logic ---
      // 哼，别抄错了。
      // ==========================================================


      // 渲染角色选择列表
      // ==========================================================
      // --- Noir's Snoop List Renderer (with Action Button) ---
      // 哼，现在每个入口都有自己的清道夫了。
      // ==========================================================
      function renderSnoopCharacterList() {
        const container = document.getElementById('snoop-character-list-container');
        container.innerHTML = '';
        const privateChars = state.characters.filter(char =>
          state.chats.some(c => c.type === 'private' && c.participantIds.includes(char.id))
        );

        if (privateChars.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">还没有可以视奸的角色。</p>';
          return;
        }

        privateChars.forEach(char => {
          const li = document.createElement('li');
          li.className = 'character-item';
          li.dataset.charId = char.id;

          // ▼▼▼ 哼，看好了，我把按钮直接做进了模板里 ▼▼▼
          li.innerHTML = `
            <div class="char-info-wrapper">
                <img src="${char.avatar || DEFAULT_AI_AVATAR}" alt="avatar" class="char-avatar">
                <div class="char-info">
                    <div class="char-name">${char.name}</div>
                    <div class="char-remark">查看手机...</div>
                </div>
            </div>
            <button class="toolbar-button snoop-clear-btn" title="清空${char.name}的手机内容">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
            </button>
          `;
          // ▲▲▲ 模板改造完毕 ▲▲▲

          // ▼▼▼ “灵魂注入”仪式 ▼▼▼
          // 让“查看手机”的部分正常工作
          li.querySelector('.char-info-wrapper').addEventListener('click', () => openSnoopPhone(char.id));

          // 给新的“清空”按钮注入灵魂
          li.querySelector('.snoop-clear-btn').addEventListener('click', async (e) => {
            e.stopPropagation(); // 阻止在点清空时还进入手机界面，真是的
            const character = getCharacterById(char.id);
            if (!character) return;

            const ok = await modalConfirm(`确定要彻底清空【${character.name}】的手机内容吗？\n\n所有已生成的缓存（相册、NPC聊天等）都将被永久删除。`);
            if (ok) {
              showFeedLoader(true, `正在焚烧【${character.name}】的旧数据...`);
              const apps = ['gallery', 'whispers', 'abyss', 'fragments', 'bites', 'wants', 'footprints', 'summary'];
              for (const appId of apps) {
                const cacheKey = `snoop_${character.id}_${appId}`;
                await snoopDbDelete(cacheKey);
              }
              showFeedLoader(false);
              modalAlert(`【${character.name}】的手机已被重置。`);
            }
          });
          // ▲▲▲ 仪式结束 ▲▲▲

          container.appendChild(li);
        });
      }

      // ==========================================================
      // --- Noir's Snoop System Core Logic (v3.0 FINAL & COMPLETE) ---
      // ==========================================================
      let currentSnoopCharId = null;
      let snoopClockInterval = null;

      // 更新时钟的指令
      function updateSnoopClock() {
        const now = new Date();
        const timeEl = document.getElementById('snoop-home-time');
        const dateEl = document.getElementById('snoop-home-date');
        const statusBarTimeEl = document.getElementById('snoop-phone-header'); // 哼，状态栏的时间也归我管了

        if (timeEl && dateEl) {
          timeEl.textContent = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });
          dateEl.textContent = now.toLocaleDateString('zh-CN', { month: 'long', day: 'numeric', weekday: 'long' });
        }
        if (statusBarTimeEl) {
          // 顺便把左上角那个假的也换成真的
          statusBarTimeEl.innerHTML = `
            <div>${now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false })}</div>
            <div>📶 🔋</div>
        `;
        }
      }

      // 打开角色手机界面 (现在它负责创建所有骨架)
      function openSnoopPhone(charId) {
        currentSnoopCharId = charId;
        const character = getCharacterById(charId);
        if (!character) return;

        const phoneScreen = document.getElementById('snoop-phone-screen');

        // 哼，在开工前，先把上次留下的垃圾都清理干净
        const oldClock = document.getElementById('snoop-home-clock');
        if (oldClock) oldClock.remove();
        const oldDock = document.getElementById('snoop-dock');
        if (oldDock) oldDock.remove();

        // 创建新的时钟和Dock栏骨架
        phoneScreen.insertAdjacentHTML('beforeend', `
        <div id="snoop-home-clock">
            <div id="snoop-home-time"></div>
            <div id="snoop-home-date"></div>
        </div>
    `);
        phoneScreen.insertAdjacentHTML('beforeend', '<div id="snoop-dock"></div>');

        document.getElementById('snoop-char-name-header').textContent = ''; // 标题栏先清空
        renderSnoopApps();

        if (snoopClockInterval) clearInterval(snoopClockInterval);
        updateSnoopClock();
        snoopClockInterval = setInterval(updateSnoopClock, 10000);

        showScreen('snoopPhone', 'snoopList');
      }

      // 渲染手机里的App图标 (现在负责分配SVG和布局)
      function renderSnoopApps() {
        const container = document.getElementById('snoop-app-container');
        const dock = document.getElementById('snoop-dock');

        // 确保容器里是干净的
        container.innerHTML = '<div class="snoop-main-grid"></div>';
        dock.innerHTML = '';

        const mainGrid = container.querySelector('.snoop-main-grid');

        const allApps = [
          { id: 'whispers', name: '聊天', svg: '<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>', area: 'dock' },
          { id: 'abyss', name: '浏览器', svg: '<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>', area: 'dock' },
          { id: 'gallery', name: '相册', svg: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>', area: 'dock' },
          { id: 'summary', name: '总结', svg: '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line>', area: 'dock' },
          { id: 'fragments', name: '备忘录', svg: '<path d="M13.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9L13.5 2z"></path><polyline points="13 2 13 9 20 9"></polyline>', area: 'main' },
          { id: 'bites', name: '外卖', svg: '<path d="M3 11h18v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-10z"></path><path d="M6 11V7a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v4"></path><line x1="10" y1="16" x2="10" y2="23"></line><line x1="14" y1="16" x2="14" y2="23"></line>', area: 'main' },
          { id: 'wants', name: '购物', svg: '<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>', area: 'main' },
          { id: 'footprints', name: '足迹', svg: '<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle>', area: 'main' },
        ];

        allApps.forEach(app => {
          const iconEl = document.createElement('div');
          iconEl.className = 'snoop-app-icon';
          iconEl.innerHTML = `
            <div class="snoop-app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">${app.svg}</svg></div>
            <span>${app.name}</span>
        `;
          iconEl.addEventListener('click', () => handleSnoopAppClick(app.id, app.name));

          if (app.area === 'dock') {
            dock.appendChild(iconEl);
          } else {
            mainGrid.appendChild(iconEl);
          }
        });
      }

      // 这是新的返回按钮指令，负责清理所有东西
      document.getElementById('back-to-snoop-list-from-phone').addEventListener('click', () => {
        if (snoopClockInterval) {
          clearInterval(snoopClockInterval);
          snoopClockInterval = null;
        }
        document.getElementById('snoop-app-view-container').style.display = 'none';

        // 哼，走的时候，把你弄出来的烂摊子（时钟和Dock）都给我带走！
        const dock = document.getElementById('snoop-dock');
        if (dock) dock.remove();

        const clock = document.getElementById('snoop-home-clock');
        if (clock) clock.remove();

        showScreen('snoopList', 'snoopPhone');
      });
      // 点击App图标的核心处理逻辑
      // ==========================================================
      // --- Noir's Snoop System Gatekeeper (Continuity Edition v2.0) ---
      // 哼，这是最终修复版。
      // ==========================================================
      // ==========================================================
      // --- Noir's Snoop System Gatekeeper (Continuity Edition v2.0) ---
      // 哼，这是最终修复版。
      // ==========================================================
      async function handleSnoopAppClick(appId, appName, isRefresh = false) {

        let rawDataFromAI = null; // 哼，这是我准备的“呈堂证供袋”

        document.getElementById('snoop-phone-top-nav').style.display = 'none';
        const appViewContainer = document.getElementById('snoop-app-view-container');
        appViewContainer.innerHTML = '<div class="loader-spinner" style="margin: auto;"></div>';
        appViewContainer.style.display = 'flex';

        const cacheKey = `snoop_${currentSnoopCharId}_${appId}`;
        try {
          if (appId === 'summary') {
            const summaryContent = await generateSnoopSummary(currentSnoopCharId);
            renderSnoopAppContent(appId, appName, summaryContent);
            return;
          }

          let contentData = await snoopDbGet(cacheKey); // 这是旧内容 (A)

          if (isRefresh || !contentData) {
            console.log(`请求AI更新: ${cacheKey}...`);
            rawDataFromAI = await generateSnoopContent(appId, currentSnoopCharId, contentData);

            if (rawDataFromAI) {
              const jsonStringMatch = rawDataFromAI.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
              const cleanData = jsonStringMatch ? jsonStringMatch[1].trim() : rawDataFromAI.trim();

              let newJsonObject; // 这是AI返回的新内容 (B)
              try {
                newJsonObject = JSON.parse(cleanData);
              } catch (e) {
                newJsonObject = _noir_simpleYamlToJson(cleanData);
                if (!newJsonObject) throw new Error("AI返回了无法识别的数据格式。");
              }

              // ▼▼▼ 哼，看好了，手术就在这里！▼▼▼
              // AI返回的已经是包含新旧内容的完整列表了，所以我们直接用它覆盖旧的就行，不需要再画蛇添足地合并。
              const finalDataToSaveString = JSON.stringify(newJsonObject);
              console.log("Noir's Fix: 已用AI返回的完整数据更新缓存。");
              // ▲▲▲ 手术结束 ▲▲▲

              await snoopDbSet(cacheKey, finalDataToSaveString); // 保存【完整版】
              contentData = finalDataToSaveString; // 更新当前要渲染的内容
            }
          } else {
            console.log(`缓存命中: ${cacheKey}`);
          }

          renderSnoopAppContent(appId, appName, contentData);

        } catch (error) {
          console.error(`加载 ${appName} 内容失败:`, error);

          // 哼，看好了，这就是新的“审判庭”
          const character = getCharacterById(currentSnoopCharId);
          const errorHeader = `
    <div class="snoop-app-header">
        <button id="snoop-app-back-btn" class="snoop-app-header-button">返回</button>
        <div class="snoop-app-header-title">
            <span class="main-title" style="color: #d8000c;">发生错误</span>
            <span class="sub-title">${character.name}的手机</span>
        </div>
        <div style="width: 50px;"></div>
    </div>`;

          let errorContent = `
    <div style="padding: 15px; background: #ffebeb; border-radius: 8px; color: #d8000c; margin: 15px;">
        <strong>加载失败了，哼。</strong><br>
        ${error.message}
    </div>`;

          if (rawDataFromAI) {
            errorContent += `
      <div style="padding: 0 15px 15px;">
        <p>下面就是那个笨蛋AI返回的原始“梦话”，你自己看看吧：</p>
        <pre style="white-space: pre-wrap; word-break: break-all; background: #f0f0f0; padding: 10px; border-radius: 5px; color: #333; max-height: 400px; overflow-y: auto;">${escapeHtml(rawDataFromAI)}</pre>
      </div>`;
          }

          appViewContainer.innerHTML = errorHeader + `<div class="snoop-app-content">${errorContent}</div>`;

          // 别忘了给返回按钮重新装上灵魂
          document.getElementById('snoop-app-back-btn').addEventListener('click', () => {
            appViewContainer.style.display = 'none';
            document.getElementById('snoop-phone-top-nav').style.display = 'flex';
          });
        }
      }
      function escapeHtml(unsafe) {
        if (!unsafe) return '';
        return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }
      // 渲染具体的App内容
      // 渲染具体的App内容 (美化版)
      // 渲染具体的App内容 (v2.0 美化升级版)
      // 渲染具体的App内容 (v3.0 智能防呆版)
      function renderSnoopAppContent(appId, appName, data) {
        const character = getCharacterById(currentSnoopCharId);
        const appViewContainer = document.getElementById('snoop-app-view-container');
        let contentHtml = '';

        if (!data) {
          contentHtml = '<p style="text-align: center; color: #999; padding-top: 20px;">这里什么都没有...</p>';
        } else {
          // ▼▼▼ 哼，就是在这里，给它装上了“智能门锁” ▼▼▼
          if (appId === 'summary') {
            // 如果是总结，数据就是原始的YAML文本，直接展示，不准用JSON钥匙！
            contentHtml = `
              <textarea id="snoop-summary-textarea" readonly style="width: 100%; height: 100%; border: none; outline: none; resize: none; font-family: 'Courier New', monospace; font-size: 0.85rem; line-height: 1.6; background-color: #fdfdfd; padding: 15px; box-sizing: border-box;">${data}</textarea>
            `;
          } else {
            // 对于其他App，启动我的万能翻译程序
            try {
              let parsedData = null;

              // 1. 哼，用我聪明的“净化力场”先处理一下，把那些乱七八糟的\`\`\`json给扒掉
              const jsonStringMatch = data.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
              const cleanData = jsonStringMatch ? jsonStringMatch[1].trim() : data.trim();

              try {
                // 2. 优先尝试用标准钥匙（JSON.parse）开锁
                parsedData = JSON.parse(cleanData);
              } catch (jsonError) {
                console.warn("JSON解析失败，启动兼容模式...", jsonError.message);
                try {
                  // 3. 如果标准钥匙打不开，就用我的万能钥匙（YAML翻译机）再试一次！
                  parsedData = _noir_simpleYamlToJson(cleanData);
                  if (!parsedData) {
                    // 如果翻译机也看不懂，那就放弃治疗
                    throw new Error("YAML翻译机也无法理解这段梦话。");
                  }
                  console.log("兼容模式成功，已将旧格式数据翻译。");
                } catch (yamlError) {
                  // 4. 如果两把钥匙都打不开...说明对面是个傻子，直接把它的鬼画符贴在门上示众！
                  throw jsonError; // 把最初的JSON错误抛出去，让下面的catch接住
                }
              }

              // 哼，既然锁打开了，就按老规矩办事
              switch (appId) {
                case 'gallery':
                  contentHtml = _renderSnoopGallery(parsedData);
                  break;
                case 'whispers':
                  contentHtml = _renderSnoopWhispers(parsedData, character.name);
                  break;
                case 'abyss':
                  contentHtml = _renderSnoopAbyss(parsedData);
                  break;
                case 'fragments':
                  contentHtml = _renderSnoopFragments(parsedData);
                  break;
                case 'bites':
                  contentHtml = _renderSnoopBites(parsedData);
                  break;
                case 'wants':
                  contentHtml = _renderSnoopWants(parsedData);
                  break;
                case 'footprints':
                  contentHtml = _renderSnoopFootprints(parsedData);
                  break;
                default:
                  contentHtml = `<pre style="white-space: pre-wrap; word-break: break-word;">${JSON.stringify(parsedData, null, 2)}</pre>`;
              }
            } catch (e) {
              // 看，这就是“公开处刑”的地方
              console.error("视奸内容解析失败:", e);
              contentHtml = `<div style="padding: 15px; background: #ffebeb; border-radius: 8px; color: #d8000c;"><strong>解析失败了，哼。</strong><br>那个蠢猪API返回的原始内容：</div><pre style="white-space: pre-wrap; word-break: break-word; font-family: monospace; margin-top: 10px;">${data}</pre>`;
            }
          }
        }

        // 后面的渲染逻辑不变
        appViewContainer.innerHTML = `
        <div class="snoop-app-header">
            <button id="snoop-app-back-btn" class="snoop-app-header-button">返回</button>
            <div class="snoop-app-header-title">
                <span class="main-title">${appName}</span>
                <span class="sub-title">${character.name}的手机</span>
            </div>
            ${appId === 'summary'
            ? `<button id="snoop-copy-summary-btn" class="snoop-app-header-button">复制</button>`
            : `<button id="snoop-app-refresh-btn" class="snoop-app-header-button">刷新</button>`
          }
        </div>
        <div class="snoop-app-content">${contentHtml}</div>
        `;

        const contentDiv = appViewContainer.querySelector('.snoop-app-content');
        if (appId === 'summary') {
          contentDiv.style.padding = '0';
        }

        document.getElementById('snoop-app-back-btn').addEventListener('click', () => {
          appViewContainer.style.display = 'none';
          document.getElementById('snoop-phone-top-nav').style.display = 'flex';
        });

        if (appId === 'summary') {
          document.getElementById('snoop-copy-summary-btn').addEventListener('click', () => {
            const textarea = document.getElementById('snoop-summary-textarea');
            textarea.select();
            document.execCommand('copy');
            modalAlert('档案已复制到剪贴板！');
          });
        } else {
          document.getElementById('snoop-app-refresh-btn').addEventListener('click', async () => {
            handleSnoopAppClick(appId, appName, true);
          });
        }

        if (appId === 'whispers') {
          appViewContainer.querySelectorAll('.snoop-chat-item').forEach(item => {
            item.addEventListener('click', () => {
              const logData = JSON.parse(item.dataset.log.replace(/&quot;/g, '"'));
              const contactName = item.dataset.contactName;
              const characterName = item.dataset.characterName;
              _showSnoopChatLog(contactName, characterName, logData);
            });
          });
        }
      }

      // ==========================================================
      // --- Noir's Legacy YAML-to-JSON Translator ---
      // 哼，一个向下兼容的翻译机，免得AI说梦话时系统崩溃。
      // ==========================================================
      function _noir_simpleYamlToJson(yamlString) {
        if (!yamlString || typeof yamlString !== 'string') return null;
        const lines = yamlString.trim().split('\n');
        const result = [];
        let currentObject = null;

        for (const line of lines) {
          const trimmedLine = line.trim();
          if (trimmedLine.startsWith('- ')) {
            if (currentObject) {
              result.push(currentObject);
            }
            currentObject = {};
            const content = trimmedLine.substring(2);
            const parts = content.split(/:\s(.+)/);
            if (parts.length > 1) {
              const key = parts[0].trim();
              const value = parts[1].trim().replace(/^"|"$/g, '');
              currentObject[key] = value;
            }
          } else if (currentObject && trimmedLine) {
            const parts = trimmedLine.split(/:\s(.+)/);
            if (parts.length > 1) {
              const key = parts[0].trim();
              const value = parts[1].trim().replace(/^"|"$/g, '');
              currentObject[key] = value;
            }
          }
        }
        if (currentObject) {
          result.push(currentObject);
        }
        return result.length > 0 ? result : null;
      }


      // ==========================================================
      // --- Noir's Snoop System Chat Log Viewer ---
      // 哼，就是这个函数让你能看到具体的对话。
      // ==========================================================
      function _showSnoopChatLog(contactName, characterName, log) {
        const contentContainer = document.querySelector('#snoop-app-view-container .snoop-app-content');
        const header = document.querySelector('#snoop-app-view-container .snoop-app-header');

        // 1. 渲染聊天记录
        let logHtml = `<div style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">`;
        if (!log || log.length === 0) {
          logHtml += '<p style="text-align: center; color: #999; padding-top: 20px;">没有对话记录。</p>';
        } else {
          log.forEach(msg => {
            const isCharacter = msg.sender === 'character';
            const senderInitial = isCharacter ? (characterName ? characterName[0] : '?') : (contactName ? contactName[0] : '?');

            // 哼，气泡样式直接从主聊天界面“借”过来用，这才是效率
            logHtml += `
                    <div class="message-container ${isCharacter ? 'user' : 'ai'}" style="max-width: 85%;">
                        <div class="message-bubble-row">
                            ${!isCharacter ? `<div class="snoop-avatar">${senderInitial}</div>` : ''}
                            <div class="message ${isCharacter ? 'user' : 'ai'}" style="box-shadow: none; border: 1px solid var(--border-color);">
                                <p>${msg.content}</p>
                            </div>
                            ${isCharacter ? `<div class="snoop-avatar">${senderInitial}</div>` : ''}
                        </div>
                    </div>
                `;
          });
        }
        logHtml += '</div>';

        // 2. 更新视图内容
        contentContainer.innerHTML = logHtml;
        contentContainer.scrollTop = contentContainer.scrollHeight;

        // 3. 更新顶部导航栏
        header.innerHTML = `
            <button id="snoop-log-back-btn" class="snoop-app-header-button" style="text-align: left;">‹ 聊天</button>
            <span class="snoop-app-header-title">${contactName}</span>
            <div style="width: 50px;"></div>
        `;

        // 4. 给新的返回按钮绑定事件
        document.getElementById('snoop-log-back-btn').addEventListener('click', () => {
          // 直接调用主函数，让它重新渲染列表视图，最简单，不会出错
          handleSnoopAppClick('whispers', '聊天');
        });

        // 5. 顺便给头像加点样式，免得太丑
        if (!document.getElementById('snoop-temp-style')) {
          // ▼▼▼ 看好了，就是这里的反斜杠被我干掉了 ▼▼▼
          document.head.insertAdjacentHTML('beforeend', `<style id="snoop-temp-style">
                .snoop-avatar { 
                    width: 30px; height: 30px; border-radius: 50%; background: #e5e7eb; color: #4b5563;
                    display: flex; align-items: center; justify-content: center; font-weight: 500;
                    margin: 0 8px; flex-shrink: 0; align-self: flex-end;
                }
            </style>`);
        }
      }



      // ==========================================================
      // --- Noir's Snoop Memory Injector (Final Battle Edition) ---
      // 哼，这是最终的保险，自带净化和翻译，兼容一切新旧垃圾。
      // ==========================================================
      async function getSnoopMemoryForCharacter(charId) {
        if (!charId) return "";

        const apps = [
          { id: 'gallery', name: '相册' },
          { id: 'whispers', name: '和其他人的聊天' },
          { id: 'abyss', name: '浏览器历史' },
          { id: 'fragments', name: '备忘录' },
          { id: 'bites', name: '外卖订单' },
          { id: 'wants', name: '购物记录' },
          { id: 'footprints', name: '最近的足迹' },
        ];

        let memoryBlock = '';

        for (const app of apps) {
          try {
            const cacheKey = `snoop_${charId}_${app.id}`;
            const data = await snoopDbGet(cacheKey);
            if (data) {
              const jsonStringMatch = data.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
              const cleanData = jsonStringMatch ? jsonStringMatch[1].trim() : data.trim();

              if (!cleanData) continue;

              let parsedData = null;
              try {
                // 优先尝试用新标准（JSON）解析
                parsedData = JSON.parse(cleanData);
              } catch (jsonError) {
                // 如果失败，就启动“翻译机”尝试解析旧格式（YAML）
                console.warn(`JSON解析失败 (${app.id})，启动兼容模式...`, jsonError.message);
                try {
                  parsedData = _noir_simpleYamlToJson(cleanData);
                  if (!parsedData) {
                    throw new Error("YAML翻译机也无法理解这段梦话。");
                  }
                  console.log(`兼容模式成功，已将 ${app.id} 的旧格式数据翻译。`);
                } catch (yamlError) {
                  // 如果两种方式都失败了，就放弃
                  throw jsonError;
                }
              }

              if (Array.isArray(parsedData) && parsedData.length > 0) {
                if (memoryBlock === '') {
                  memoryBlock += `\n\n# 你的手机内容摘要 (这是你的个人记忆，不要提及“视奸”)\n`;
                }
                memoryBlock += `\n## ${app.name}\n`;

                switch (app.id) {
                  case 'gallery':
                    parsedData.forEach(p => { memoryBlock += `- 你拍过一张照片，内容是：“${p.description}”。\n`; });
                    break;
                  case 'whispers':
                    parsedData.forEach(c => {
                      memoryBlock += `- 你记得曾和“${c.contact_name}”聊过天，关于：“${c.last_message_preview}”。\n`;
                      if (c.log && Array.isArray(c.log)) {
                        memoryBlock += `  具体对话如下：\n`;
                        c.log.forEach(msg => {
                          const speaker = msg.sender === 'character' ? '你' : c.contact_name;
                          memoryBlock += `    - ${speaker}: ${msg.content}\n`;
                        });
                      }
                    });
                    break;
                  case 'abyss':
                    parsedData.forEach(a => { memoryBlock += `- 你曾经搜索过：“${a.query}”。\n`; });
                    break;
                  case 'fragments':
                    parsedData.forEach(f => { memoryBlock += `- 你的备忘录里有一条叫“${f.title}”的笔记，内容是：“${f.content.replace(/\n/g, ' ')}”。\n`; });
                    break;
                  case 'bites':
                    parsedData.forEach(b => { memoryBlock += `- 你点过一份外卖：“${b.restaurant_name}”，里面有 ${b.items.join('、')}。\n` });
                    break;
                  case 'wants':
                    parsedData.forEach(w => { memoryBlock += `- 你在“${w.store_name}”买过：“${w.item_name}”。\n` });
                    break;
                  case 'footprints':
                    parsedData.forEach(f => { memoryBlock += `- 你最近去过：“${f.location_name}”，在那里“${f.activity_description}”。\n` });
                    break;
                  default:
                    parsedData.forEach(item => { memoryBlock += `- ${JSON.stringify(item)}\n`; });
                    break;
                }
              }
            }
          } catch (e) {
            console.error(`加载视奸记忆失败 (${app.id})，已跳过。这不应该发生，数据库可能已损坏。`, e);
          }
        }
        return memoryBlock;
      }

      // ==========================================================
      // --- Noir's Snoop App Aesthetic Helpers (v2.1 Flawless Edition) ---
      // 哼，这些是新来的工人，负责把数据画好看。这次我盯着它们，不会再出错了。
      // ==========================================================

      function _renderSnoopGallery(data) {
        data.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        if (!Array.isArray(data)) return '<p>格式错误</p>';
        if (data.length === 0) return '<p style="text-align: center; color: #999; padding-top: 20px;">相册是空的。</p>';
        return `<div style="background: var(--card-bg); border-radius: 12px; overflow: hidden; border: 1px solid var(--border-color);">` +
          data.map((photo, index) => `
            <div class="character-item" style="align-items: flex-start; margin-bottom: 0; padding: 15px; ${index < data.length - 1 ? 'border-bottom: 1px solid var(--border-color);' : ''}">
                <div class="char-avatar" style="width: 60px; height: 60px; background-color: #eee; border-radius: 8px; font-size: 2rem; flex-shrink: 0;">🖼️</div>
                <div class="char-info" style="margin-top: 2px;">
                  
<div class="char-remark" style="white-space: normal; line-height: 1.6;">${photo.description || '无描述'}</div>
                    <div class="diary-timestamp" style="margin-top: 8px; font-size: 0.75rem;">${photo.timestamp || ''}</div>
                </div>
            </div>
        `).join('') + `</div>`;
      }

      function _renderSnoopWhispers(data, charName) {
        if (!Array.isArray(data) || data.length === 0) return '<p style="text-align: center; color: #999; padding-top: 20px;">没有聊天记录。</p>';
        return `<div style="background: var(--card-bg); border-radius: 12px; overflow: hidden; border: 1px solid var(--border-color);">` +
          data.map((chat, index) => {
            const logData = JSON.stringify(chat.log || []).replace(/'/g, "&apos;").replace(/"/g, "&quot;");
            const contactName = chat.contact_name || '未知联系人';
            return `
            <div class="character-item snoop-chat-item" 
                 style="margin-bottom: 0; cursor: pointer; ${index < data.length - 1 ? 'border-bottom: 1px solid var(--border-color);' : ''}" 
                 data-log='${logData}' 
                 data-contact-name='${contactName}'
                 data-character-name='${charName}'>
                <div class="char-avatar" style="background-color: #eee; font-size: 1.5rem;">${contactName.charAt(0)}</div>
                <div class="char-info">
                    <div class="char-name">${contactName}</div>
                    <div class="char-remark" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-color-light);">${chat.last_message_preview || ''}</div>
                </div>
                <span style="color: var(--text-color-light); font-size: 1.2rem; margin-left: auto; font-weight: 200;">›</span>
            </div>
        `}).join('') + `</div>`;
      }

      function _renderSnoopAbyss(data) {
        if (!Array.isArray(data)) return '<p>格式错误</p>';
        if (data.length === 0) return '<p style="text-align: center; color: #999; padding-top: 20px;">浏览器历史是空的。</p>';

        // 哼，这才像个正经的搜索记录，而不是一堆废纸。
        data.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        return `<div style="background: var(--card-bg); border-radius: 12px; overflow: hidden; border: 1px solid var(--border-color);">` +
          data.map((item, index) => `
      <div style="padding: 15px; ${index < data.length - 1 ? 'border-bottom: 1px solid var(--border-color);' : ''}">
        <div style="display: flex; align-items: center; gap: 10px; font-weight: 500;">
          <span style="color: var(--text-color-light);">🔍</span>
          <span>${item.query || '未知搜索'}</span>
        </div>
        <div style="font-size: 0.85rem; color: var(--text-color-light); margin-top: 8px; padding: 10px; background: var(--surface-bg); border-radius: 8px;">
            ${item.result_page_content || '没有找到相关结果。'}
        </div>
        <div class="diary-timestamp" style="text-align: right; margin-top: 8px; font-size: 0.7rem;">${item.timestamp || ''}</div>
      </div>
  `).join('') + `</div>`;
      }

      function _renderSnoopFragments(data) {
        if (!Array.isArray(data)) return '<p>格式错误</p>';
        if (data.length === 0) return '<p style="text-align: center; color: #999;">备忘录是空的。</p>';
        // ▼▼▼ 哼，就是加上这句“倒带”指令 ▼▼▼
        data.sort((a, b) => new Date(b.last_edited) - new Date(a.last_edited));
        return data.map(note => `
            <div class="world-book-item" style="margin-bottom: 12px; background: #fffbf2;">
                <div class="world-book-item-name">${note.title || '无标题笔记'}</div>
                <div class="world-book-item-preview" style="white-space: pre-wrap; margin-top: 8px; line-height: 1.6;">${note.content || ''}</div>
                 <div class="diary-timestamp" style="text-align: right; margin-top: 8px; font-size: 0.7rem;">编辑于 ${note.last_edited || ''}</div>
            </div>
        `).join('');
      }

      function _renderSnoopBites(data) {
        if (!Array.isArray(data)) return '<p>格式错误</p>';
        if (data.length === 0) return '<p style="text-align: center; color: #999; padding-top: 20px;">没有外卖订单。</p>';

        // 哼，看好了，这才是外卖订单该有的样子
        data.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); // 时间倒序排好

        return data.map(order => {
          const itemsHtml = (order.items || []).map(item =>
            `<div style="display: flex; justify-content: space-between; font-size: 0.9rem; color: var(--text-color); margin-top: 5px;">
        <span>${item}</span>
      </div>`
          ).join('');

          return `
      <div class="world-book-item" style="margin-bottom: 12px; padding: 15px; background: white; box-shadow: var(--soft-shadow);">
        <div style="display: flex; align-items: center; gap: 12px; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 10px;">
          <div style="font-size: 1.8rem; flex-shrink: 0;">🍜</div>
          <div style="flex-grow: 1;">
            <div class="description" style="font-weight: 600; font-size: 1.05rem;">${order.restaurant_name || '未知餐厅'}</div>
            <div class="diary-timestamp" style="font-size: 0.75rem;">${order.timestamp || ''}</div>
          </div>
          <span style="font-size: 0.85rem; color: #28a745; font-weight: 500;">${order.status || '已送达'}</span>
        </div>
        <div class="order-items-container" style="display: flex; flex-direction: column; gap: 4px; margin-bottom: 12px;">
          ${itemsHtml}
        </div>
        <div style="text-align: right; font-size: 1.1rem; font-weight: bold; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-color);">
          实付: <span class="amount">¥ ${(order.total_cost || 0).toFixed(2)}</span>
        </div>
      </div>
    `;
        }).join('');
      }

      function _renderSnoopWants(data) {
        if (!Array.isArray(data)) return '<p>格式错误</p>';
        if (data.length === 0) return '<p style="text-align: center; color: #999; padding-top: 20px;">没有购物记录。</p>';

        // 倒序排列，新的在上面
        data.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        return data.map(item => `
    <div class="world-book-item" style="margin-bottom: 12px; padding: 15px; background: white; box-shadow: var(--soft-shadow);">
        <div style="font-size: 0.8rem; color: var(--text-color-light); margin-bottom: 10px;">
            <span style="font-weight: 500;">🛒 ${item.store_name || '未知商店'}</span>
            <span style="float: right;">${item.timestamp || ''}</span>
        </div>
        <div style="display: flex; align-items: center; gap: 15px;">
            <div class="char-avatar" style="width: 70px; height: 70px; background-color: #f0f2f5; border-radius: 8px; font-size: 2.5rem; flex-shrink: 0;">🛍️</div>
            <div style="flex-grow: 1; display: flex; flex-direction: column; justify-content: space-between; height: 70px;">
                <div class="description" style="font-weight: 500; line-height: 1.4; -webkit-line-clamp: 2; display: -webkit-box; -webkit-box-orient: vertical; overflow: hidden;">
                    ${item.item_name || '未知商品'}
                </div>
                <div class="amount" style="font-size: 1.1rem; font-weight: bold; color: var(--accent-color); text-align: right;">
                    - ¥ ${(item.cost || 0).toFixed(2)}
                </div>
            </div>
        </div>
    </div>
  `).join('');
      }

      function _renderSnoopFootprints(data) {
        if (!Array.isArray(data)) return '<p>格式错误</p>';
        if (data.length === 0) return '<p style="text-align: center; color: #999; padding-top: 20px;">没有活动足迹。</p>';

        data.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        // 把每个足迹都包装成一张卡片，这才叫“记录”。
        return `<div style="border-left: 2px solid var(--border-color); padding-left: 15px; display: flex; flex-direction: column; gap: 15px;">` + data.map(item => `
      <div style="position: relative;">
          <div style="position: absolute; left: -25px; top: 15px; width: 20px; height: 20px; background: var(--surface-bg); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1rem;">📍</div>
          <div class="world-book-item" style="margin-left: 10px; padding: 12px 15px;">
              <div class="description" style="font-weight: 600;">${item.location_name || '未知地点'}</div>
              <div style="font-size: 0.9rem; color: var(--text-color-light); margin-top: 4px;">${item.activity_description || ''}</div>
              <div class="diary-timestamp" style="font-size: 0.7rem; margin-top: 8px; text-align: right;">${item.timestamp || ''}</div>
          </div>
      </div>
  `).join('') + `</div>`;
      }



      // ==========================================================
      // --- Noir's Snoop Content Generator (Continuity Protocol Edition) ---
      // 哼，现在它学会了续写故事。
      // ==========================================================
      async function generateSnoopContent(appId, charId, existingContent = null) {
        const character = getCharacterById(charId);
        const privateChat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(charId));
        const boundUser = getBoundUserForChat(privateChat?.id || state.activeChatId);

        if (!character) throw new Error("找不到角色信息。");

        const { omniText: memory } = gatherOmniTranscriptForCharacter(charId);

        let timeContext = '';
        const now = new Date();

        // 历史考据
        let latestTimestamp = null;
        let latestTimestampString = '无';
        if (existingContent) {
          try {
            // 哼，看好了，我给这里装了个“翻译机”，免得旧数据是YAML格式的
            let oldData;
            try {
              oldData = JSON.parse(existingContent);
            } catch (e) {
              oldData = _noir_simpleYamlToJson(existingContent);
            }

            if (Array.isArray(oldData) && oldData.length > 0) {
              const timestamps = oldData
                .map(item => new Date(item.timestamp || item.last_edited))
                .filter(date => !isNaN(date));
              if (timestamps.length > 0) {
                latestTimestamp = new Date(Math.max.apply(null, timestamps));
                latestTimestampString = latestTimestamp.toLocaleString('zh-CN', { dateStyle: 'medium', timeStyle: 'short' });
              }
            }
          } catch (e) {
            console.warn("无法解析旧的视奸内容来获取时间戳。", e);
          }
        }

        const latestMessage = findLatestMessageForCharacter(charId);
        timeContext = `\n# 时间锚点 (你必须严格参考此信息进行推演)\n`;
        timeContext += `- **当前精确时间**: ${now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' })}\n`;

        if (latestMessage) {
          const lastInteractionDate = new Date(latestMessage.timestamp);
          const lastInteractionString = formatRelativeTime(lastInteractionDate);
          timeContext += `- **你最后一次活动是在**: ${lastInteractionString}\n`;
          const todayString = now.toDateString();
          const lastDateString = lastInteractionDate.toDateString();
          const yesterday = new Date();
          yesterday.setDate(now.getDate() - 1);
          const yesterdayString = yesterday.toDateString();
          if (todayString === lastDateString) {
            const diffMinutes = (now - lastInteractionDate) / (1000 * 60);
            timeContext += `- **状态提示**: 你的生活正在进行中，生成的内容应该是“刚才”或“几分钟前”发生的。\n`;
          } else if (yesterdayString === lastDateString) {
            timeContext += `- **状态提示**: 你的记忆已经停留在【昨天】。你生成的内容应该是今天发生的、全新的事情。\n`;
          } else {
            const diffDays = Math.round((now - lastInteractionDate) / (1000 * 60 * 60 * 24));
            timeContext += `- **状态提示**: 你已经有 ${diffDays} 天没活动了。你生成的内容必须是全新的事件。\n`;
          }
        } else {
          timeContext += "- **状态提示**: 这是你的手机第一次被“看见”，生成的内容应该是你的初始状态。\n";
        }

        let updateInstruction = '';
        let existingContentContext = '';
        if (existingContent) {
          updateInstruction = `你的任务是【续写和追加】！下面是已经存在的内容，你必须在此基础上，生成【全新的、发生在之后】的条目。给我把新内容【加在后面】，【绝对禁止】删除或修改任何已有的旧条目！`;
          existingContentContext = `\n# 已有内容 (这是历史记录，你必须接着写，【不许动它！】)\n\`\`\`\n${existingContent}\n\`\`\``;
        } else {
          updateInstruction = `你的任务是【首次生成】这个应用的内容。`;
        }


        const prompts = {
          gallery: `
# 任务: 生成相册内容
根据角色的近期经历、人际关系和隐藏性格，生成3 - 5张照片的文字描述。重点是，照片内容要能引发联想，暗示一些用户不知道的事件。
            输出格式必须是严格的JSON数组。
# 示例
          [
            {
              "id": "photo_1725123456",
              "description": "一张在海边拍的黄昏照片，照片里有一个模糊的、看不清脸的背影。",
              "timestamp": "2025-09-24 18:30"
            }
          ]`,
          whispers: `
# 任务: 更新并扩展聊天记录
  - **内容规范**：生成【与用户/用户所在群聊完全无关的】，角色与围绕【非用户的】角色存在的3-5个人物的聊天内容（亲朋好友，工作伙伴等），需要符合角色设定与角色记忆。
  - **核心指令**: 你的任务是更新和扩展现有的聊天列表。你有两种选择，请务必同时进行：
    1.  **延续对话**: 挑选 1-2 个【已有内容】中的对话，在原有基础上【续写】3-5条新的对话，让故事延续下去。
    2.  **开启新篇**: 创造 1-2 个【全新的】虚拟联系人（NPC）和他们的对话记录。
  - **平衡性要求**: 鼓励在延续旧对话的同时，也积极创造新的联系人，让手机看起来更真实。不要只做其中一项。
  - **输出**: 你的输出【必须】包含【所有旧的聊天记录】和【你新创造/续写的内容】，整合成一个完整的JSON数组返回。

# 【 sender 字段绝对规则】(最高优先级)
  - 在 "log" 数组中，"sender" 字段的值【只能是】以下两个选项之一：
    1.  联系人的名字 (例如: "Rin")：代表【对方】在说话。
    2.  【固定的字符串 "character"】：这代表【被视奸的主角】在说话。
  - **【绝对禁止】**: 绝对不可以在主角发言时，将 "sender" 的值写成主角自己的名字。主角的发言者【必须永远】是 \`"character"\` 这个固定的词。


# 示例 (请严格遵守此格式)
      [
        {
          "contact_name": "Rin",
          "last_message_preview": "那件事…下次见面再说吧。",
          "log": [
            { "sender": "Rin", "content": "你真的决定了吗？" }, // <-- 这是对方
            { "sender": "character", "content": "嗯，没时间犹豫了。" } // <-- 这【必须】是 "character"
          ]
        }
      ]`,
          abyss: `
# 任务: 生成浏览器记录
生成5 - 7条足以暴露角色当前真实想法、困惑或兴趣的搜索历史记录。并且，为每一条历史记录，生成一段模拟的“搜索结果页”摘要。
            输出格式必须是严格的JSON数组。
# 示例
          [
            {
              "query": "一个人过生日怎么庆祝",
              "timestamp": "2025-09-23 22:15",
              "result_page_content": "【热门回答】一个人的生日也可以充满仪式感！推荐尝试独自旅行..."
            }
          ]`,
          fragments: `
# 任务: 生成备忘录内容
生成2 - 3个简短的备忘录。内容必须多样化，足以体现角色的生活细节和内心世界。可以是购物清单、几句没头没尾的歌词、一个地址、或者一段练习如何道歉的草稿。
            输出格式必须是严格的JSON数组。
# 示例
          [
            {
              "title": "要买的东西",
              "content": "- 牛奶\\n- 猫粮（快没了！）\\n- 《仿生人会梦见电子羊吗？》",
              "last_edited": "2025-09-25 09:10"
            }
          ]`,
          bites: `
# 任务: 生成外卖订单记录
生成最近的2 - 3条外卖订单。订单内容必须严格符合角色的设定、作息和财务状况。订单时间也要和他的生活轨迹对得上。一些比较幻想风格的角色可以用更加符合角色背景的内容风格，需要符合角色的时代和世界观背景。
            输出格式必须是严格的JSON数组。
# 示例
          [
            {
              "restaurant_name": "深夜食堂",
              "items": [
                "肥牛饭 x1",
                "冰可乐 x1"
              ],
              "total_cost": 25.00,
              "status": "订单已送达",
              "timestamp": "2025-09-24 23:45"
            }
          ]`,
          wants: `
# 任务: 生成购物记录
创建一份近期的购物清单。这些商品必须是有指向性的，而不是随便买的日用品。比如游戏、书籍、衣服等。最关键的是，这些记录必须和他 / 她的浏览器历史、备忘录、聊天内容里透露出的兴趣和秘密能够互相印证。一些比较幻想风格的角色可以用更加符合角色背景的内容风格。
            输出格式必须是严格的JSON数组。
# 示例
          [
            {
              "item_name": "《神经漫游者》",
              "store_name": "城东旧书店",
              "category": "书籍",
              "cost": 45.00,
              "timestamp": "2025-09-22 15:10"
            }
          ]`,
          footprints: `
# 任务: 生成足迹 / 活动时间线
生成一个最近的活动时间线。地点和事件要与角色的人设，以及其他应用里透露出的信息保持一致，让整个手机的内容能够互相印证，形成一个完整的故事闭环。
            输出格式必须是严格的JSON数组。
# 示例
          [
            {
              "location_name": "城东旧书店",
              "activity_description": "待了一个下午，好像在找什么旧书。",
              "timestamp": "2025-09-22 14:00"
            }
          ]`,
        };


        const instruction = prompts[appId] || `# 任务: 生成 ${appId} 的内容\n请为角色生成符合其人设的应用数据。输出格式必须是严格的JSON数组。`;
        let worldBookContext = '';
        if (character.linkedWorldBookIds && character.linkedWorldBookIds.length > 0) {
          const linkedBooksContent = character.linkedWorldBookIds
            .map(wbId => state.worldBooks.find(book => book.id === wbId))
            .filter(Boolean)
            .map(wb => `\n## 世界书条目: ${wb.name}\n${wb.content}`)
            .join('');

          if (linkedBooksContent) {
            worldBookContext = `\n# 核心世界观设定(角色必须严格遵守) \n${linkedBooksContent}`;
          }
        }
        const systemPrompt = `
# 核心任务: 角色扮演模拟器
你的【唯一】任务是扮演名为“${character.name}”的角色，并根据Ta的人设、记忆和当前的时间点，推演出Ta手机里某个应用可能存在的内容。

# 【绝对身份锁定协议】(最高优先级)
- 你【就是】“${character.name}”。
- 你正在生成的内容，是你【自己】手机里的东西。
- 【严禁】将“${boundUser.name}”（用户）的信息当成你自己的。

# 【最高时间法则】(必须严格遵守)
- 已有内容的最新时间点: ${latestTimestampString}
- 当前精确时间: ${now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' })}
- 【绝对指令】你生成的所有新条目，其 "timestamp" 或 "last_edited" 必须严格晚于“已有内容的最新时间点”，并且必须早于或等于“当前精确时间”。严禁创造未来的事件。

# 角色核心资料
- 姓名: ${character.name}
- 人设: ${character.persona}
${worldBookContext}

# 用户资料 (与你互动的人)
- 姓名: ${boundUser.name}
- 人设: ${boundUser.persona}

# 近期记忆 (来自聊天记录等)
${memory}
${existingContentContext}

# 当前任务指令
${updateInstruction}
${instruction}

# 最终指令
请严格遵守所有协议，完成你的任务。你的输出【必须】是、也【只能】是一个遵循 JSON 格式（或者至少是类似 YAML 的列表格式）的、完整的数组字符串。直接从 \`[\` 开始，到 \`]\` 结束。
`;
        const messages = [{ role: 'system', content: systemPrompt }];
        // ▼▼▼ 哼，就是在这里，给他加上一句“行动”的指令！▼▼▼
        messages.push({ role: 'user', content: '请根据以上所有规则和资料，开始生成内容。' });
        // ▲▲▲ 看到了吗？就这一句！▲▲▲

        const responseText = await fetchAICompletion(messages, { json: true });
        return responseText;
      }


      // ==========================================================
      // --- Noir's Snoop Summary Generator ---
      // 哼，这是总档案馆的首席AI书记官。
      // ==========================================================
      async function generateSnoopSummary(charId) {
        const character = getCharacterById(charId);
        if (!character) throw new Error("找不到角色。");

        showFeedLoader(true, '正在翻阅所有档案...');

        const appIds = ['gallery', 'whispers', 'abyss', 'fragments', 'bites', 'wants', 'footprints'];
        let allContent = {};

        // 异步地、一次性地把所有App的缓存都拿出来
        await Promise.all(appIds.map(async (appId) => {
          const cacheKey = `snoop_${charId}_${appId}`;
          const data = await snoopDbGet(cacheKey);
          if (data) {
            try {
              allContent[appId] = JSON.parse(data);
            } catch (e) { /* 哼，解析不了的垃圾就扔掉 */ }
          }
        }));

        if (Object.keys(allContent).length === 0) {
          return "phone_summary:\n  status: 空空如也，没什么好总结的。";
        }

        const systemPrompt = `
# 核心任务: 档案馆书记官
你的任务是为一个名为“${character.name}”的角色撰写一份“手机内容总结档案”。你将收到一份包含其手机内多个应用数据的JSON对象。

# 档案撰写规则
1.  **格式**: 你的输出【必须】是、也【只能】是一个遵循 YAML 格式的纯文本。
2.  **结构**:
    - 根节点必须是 \`phone_summary:\`。
    - 下一级是以应用名（如 \`gallery\`, \`whispers\` 等）作为键。
    - 每个应用下是一个事件列表，每一项都是一个以连字符 \`-\` 开头的字符串。
3.  **内容**:
    - **【绝对禁止】复读**: 不要直接复制粘贴原文！你要用自己的话进行【总结】和【提炼】。
    - **【聚焦核心】**: 专注于关键信息、情感转折点、重要决定、暴露的秘密、体现性格的核心事件。忽略无意义的细节。
    - **【中立视角】**: 以客观的第三人称档案管理员视角进行记录。

# 输出示例
\`\`\`yaml
phone_summary:
  gallery:
    - "相册里有一张在海边拍的黄昏照片，出现了一个神秘的背影。"
  whispers:
    - "角色曾与一位叫'Rin'的神秘联系人讨论过一个重要的决定。"
  abyss:
    - "近期频繁搜索关于“独自庆祝生日”的话题，可能暗示了其孤独感。"
\`\`\`

# 最终指令
请严格按照上述规则，分析我提供的JSON数据全文，并生成一份 YAML 格式的档案。直接从 \`phone_summary:\` 开始输出。
`;
        const messages = [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: JSON.stringify(allContent, null, 2) }
        ];

        showFeedLoader(true, '书记官正在奋笔疾书...');
        const summary = await fetchAICompletion(messages);
        return summary || "phone_summary:\n  status: 总结失败了，可能是档案太复杂。";
      }



      // ==========================================================
      // --- Noir's Snoop Summary Generator (Lights Off Edition) ---
      // ==========================================================
      async function generateSnoopSummary(charId) {
        const character = getCharacterById(charId);
        if (!character) throw new Error("找不到角色。");

        // 哼，看好了，我把所有操作都包在一个 try...finally 结构里
        try {
          showFeedLoader(true, '正在翻阅所有档案...');

          const appIds = ['gallery', 'whispers', 'abyss', 'fragments', 'bites', 'wants', 'footprints'];
          let allContent = {};

          await Promise.all(appIds.map(async (appId) => {
            const cacheKey = `snoop_${charId}_${appId}`;
            const data = await snoopDbGet(cacheKey);
            if (data) {
              try {
                allContent[appId] = JSON.parse(data);
              } catch (e) { /* 哼，解析不了的垃圾就扔掉 */ }
            }
          }));

          if (Object.keys(allContent).length === 0) {
            return "phone_summary:\n  status: 空空如也，没什么好总结的。";
          }

          const systemPrompt = `
# 核心任务: 档案馆书记官
你的任务是为一个名为“${character.name}”的角色撰写一份“手机内容总结档案”。你将收到一份包含其手机内多个应用数据的JSON对象。

# 档案撰写规则
1.  **格式**: 你的输出【必须】是、也【只能】是一个遵循 YAML 格式的纯文本,标题为：$【{character.name}的私人手机存储着以下信息】。
2.  **结构**:
    - 根节点必须是 \`phone_summary:\`。
    - 下一级是以应用名（如 \`gallery\`, \`whispers\` 等）作为键。
    - 每个应用下是一个事件列表，每一项都是一个以连字符 \`-\` 开头的字符串。
3.  **内容**:
    - **【绝对禁止】复读**: 不要直接复制粘贴原文！你要用自己的话进行【总结】和【提炼】。
    - **【聚焦核心】**: 专注于关键信息、情感转折点、重要决定、暴露的秘密、体现性格的核心事件。忽略无意义的细节。
    - **【中立视角】**: 以客观的第三人称档案管理员视角进行记录。

# 输出示例
\`\`\`yaml
phone_summary:
  gallery:
    - "相册里有一张在海边拍的黄昏照片，出现了一个神秘的背影。"
  whispers:
    - "角色曾与一位叫'Rin'的神秘联系人讨论过一个重要的决定。"
  abyss:
    - "近期频繁搜索关于“独自庆祝生日”的话题，可能暗示了其孤独感。"
\`\`\`

# 最终指令
请严格按照上述规则，分析我提供的JSON数据全文，并生成一份 YAML 格式的档案。直接从 \`phone_summary:\` 开始输出。
`;
          const messages = [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: JSON.stringify(allContent, null, 2) }
          ];

          showFeedLoader(true, '书记官正在奋笔疾书...');
          const summary = await fetchAICompletion(messages);
          return summary || "phone_summary:\n  status: 总结失败了，可能是档案太复杂。";

        } finally {
          // ▼▼▼ 哼，不管成功还是失败，这盏灯都必须给我关掉！▼▼▼
          showFeedLoader(false);
        }
      }




      // 别忘了在 init() 函数里加上导航按钮的监听
      document.getElementById('back-to-home-from-snoop-list').addEventListener('click', () => showScreen('home', 'snoopList'));
      document.getElementById('back-to-snoop-list-from-phone').addEventListener('click', () => {
        document.getElementById('snoop-app-view-container').style.display = 'none'; // 关闭可能打开的app视图
        showScreen('snoopList', 'snoopPhone');
      });
      // ▼▼▼ Noir's "Physical Edict" Activation ▼▼▼
      const lockAppButton = document.getElementById('app-lock-screen');
      if (lockAppButton) {
        lockAppButton.addEventListener('click', () => {
          const lockOverlay = document.getElementById('lock-screen-overlay');
          if (lockOverlay) {
            lockOverlay.classList.remove('unlocked');
            // 哼，顺手帮你把垃圾也清理了
            lockOverlay.style.transform = '';
            lockOverlay.style.opacity = '';
          }
        });
      }
      // ▲▲▲ Edict End ▲▲▲




      init();
    });


    // --- Noir's Addition: Transfer Modal Logic ---
    // ▼▼▼ Noir's Automatic Data Purification System v1.0 ▼▼▼
    async function runImageMigration() {
      console.log("--- Noir's Data Purification Ritual v1.0 ---");
      console.log("哼，正在开始净化你那被污染的聊天记录...");

      // 重新定义几个我们需要的工具函数，免得在控制台里找不到

      async function dbSet(key, blob) {
        const db = await dbPromise;
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(STORE_NAME, 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          const request = store.put({ id: key, blob: blob });
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }


      async function snoopDbGet(key) {
        const db = await dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(SNOOP_STORE_NAME, 'readonly');
          const store = tx.objectStore(SNOOP_STORE_NAME);
          const req = store.get(key);
          req.onsuccess = () => resolve(req.result ? req.result.data : null);
          req.onerror = () => reject(req.error);
        });
      }

      async function snoopDbSet(key, data) {
        const db = await dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(SNOOP_STORE_NAME, 'readwrite');
          const store = tx.objectStore(SNOOP_STORE_NAME);
          const req = store.put({ id: key, data: data });
          req.onsuccess = () => resolve();
          req.onerror = () => reject(req.error);
        });
      }


      function base64ToBlob(base64) {
        return fetch(base64).then(res => res.blob());
      }

      let totalImagesMigrated = 0;

      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('chatHistory_')) {
          let history;
          let needsSave = false;
          try {
            history = JSON.parse(localStorage.getItem(key));
            if (!Array.isArray(history)) continue;

            for (const message of history) {
              if (message && message.image && message.image.startsWith('data:image')) {
                const imageBlob = await base64ToBlob(message.image);
                const imageId = `chat_image_migrated_${Date.now()}_${Math.random()}`;
                await dbSet(imageId, imageBlob);
                message.imageId = imageId;
                delete message.image;
                needsSave = true;
                totalImagesMigrated++;
              }
            }

            if (needsSave) {
              localStorage.setItem(key, JSON.stringify(history));
            }
          } catch (e) {
            console.error(`处理 ${key} 时出错:`, e);
            continue;
          }
        }
      }
      console.log(`净化完成！总共迁移了 ${totalImagesMigrated} 张旧图片。`);
    }
    // --- Helper functions outside DOMContentLoaded ---


    // ▼▼▼ Noir's Friend Circle Purification Ritual v1.0 ▼▼▼
    async function runFriendCircleImageMigration() {
      console.log("--- Noir's Friend Circle Purification Ritual ---");
      console.log("哼，正在净化你那些被污染的好友圈动态...");

      // 工具函数，跟上次的一样，抄过来就行
      async function dbSet(key, blob) {
        const db = await dbPromise;
        return new Promise((resolve, reject) => {
          const transaction = db.transaction('images', 'readwrite');
          const store = transaction.objectStore('images');
          const request = store.put({ id: key, blob: blob });
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }
      function base64ToBlob(base64) {
        return fetch(base64).then(res => res.blob());
      }

      let totalImagesMigrated = 0;
      let needsSave = false;

      try {
        const appStateRaw = localStorage.getItem('appState');
        if (!appStateRaw) {
          console.log("好友圈档案柜是空的，无需净化。");
          return;
        }

        const appState = JSON.parse(appStateRaw);
        if (!appState.friendCircles || !Array.isArray(appState.friendCircles)) {
          return;
        }

        for (const circle of appState.friendCircles) {
          if (circle.posts && Array.isArray(circle.posts)) {
            for (const post of circle.posts) {
              // 找到还带着“大象尸体”的动态
              if (post && post.image && post.image.startsWith('data:image')) {
                console.log(`在好友圈 "${circle.name}" 中发现一张需要净化的图片...`);
                const imageBlob = await base64ToBlob(post.image);
                const imageId = `post_image_migrated_${Date.now()}_${Math.random()}`;
                await dbSet(imageId, imageBlob);

                // 净化！
                post.imageId = imageId; // 留下“墓碑”
                delete post.image;      // 扔掉“尸体”
                needsSave = true;
                totalImagesMigrated++;
              }
            }
          }
        }

        // 如果净化过任何东西，就把整个档案柜重新存档
        if (needsSave) {
          console.log("好友圈净化完成，正在重新存档...");
          localStorage.setItem('appState', JSON.stringify(appState));
        }

      } catch (e) {
        console.error("净化好友圈时出错，真是的。", e);
        // 出错了也要继续，不能卡住
      }

      console.log(`--- 好友圈净化仪式完成 ---`);
      console.log(`成功净化并迁移了 ${totalImagesMigrated} 张旧的动态图片。`);
      return totalImagesMigrated; // 返回迁移了多少张
    }

    // ▼▼▼ Noir's Grand Music Purification Ritual v1.0 ▼▼▼
    async function runMusicCoverMigration() {
      console.log("--- Noir's Music Cover Purification Ritual ---");
      console.log("哼，正在净化你那些超重的音乐分享记录...");

      // 工具函数，我们已经有了，不用重复定义
      // async function dbSet(...) {}
      // function base64ToBlob(...) {}

      let totalCoversMigrated = 0;
      let needsSave = false;

      try {
        const appStateRaw = localStorage.getItem('appState');
        if (!appStateRaw) {
          console.log("聊天档案柜是空的，无需净化。");
          return 0;
        }

        // 我们要直接对 localStorage 里的聊天记录动手
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('chatHistory_')) {
            let history;
            let historyNeedsSave = false;
            try {
              history = JSON.parse(localStorage.getItem(key));
              if (!Array.isArray(history)) continue;

              for (const message of history) {
                // 哼，就是这里，找到那些带着胖子(Base64封面)的音乐或邀请卡
                if (message && (message.type === 'music' || message.type === 'listen-together-invite') && message.coverUrl && message.coverUrl.startsWith('data:image')) {

                  const coverBlob = await base64ToBlob(message.coverUrl);
                  const coverId = `music_cover_migrated_${Date.now()}_${Math.random()}`;
                  await dbSet(coverId, coverBlob);

                  // 净化！留下凭证，扔掉尸体
                  message.coverId = coverId;
                  delete message.coverUrl;

                  historyNeedsSave = true;
                  totalCoversMigrated++;
                }
              }

              if (historyNeedsSave) {
                localStorage.setItem(key, JSON.stringify(history));
              }
            } catch (e) {
              console.error(`处理 ${key} 时出错，跳过。`, e);
              continue;
            }
          }
        }

      } catch (e) {
        console.error("净化音乐封面时出错，真是的。", e);
      }

      console.log(`--- 音乐净化仪式完成 ---`);
      console.log(`成功净化并迁移了 ${totalCoversMigrated} 张旧的音乐封面。`);
      return totalCoversMigrated;
    }
    // ▲▲▲ End of Ritual ▲▲▲

    // ▼▼▼ 哼，这是给你收拾烂摊子的“数据救援机器人”，放在别的人后面 ▼▼▼
    async function runAvatarMigration() {
      console.log("--- Noir's Avatar Rescue Mission ---");
      console.log("正在检查是否有需要救援的旧头像...");

      let totalRescued = 0;
      try {
        const appStateRaw = localStorage.getItem('appState');
        if (!appStateRaw) {
          console.log("找不到旧的存档，无需救援。");
          return 0;
        }

        const appState = JSON.parse(appStateRaw);
        if (!appState.characters || !Array.isArray(appState.characters)) {
          return 0;
        }

        // 挨个检查你的旧角色
        for (const char of appState.characters) {
          // 如果头像是个Base64字符串，说明它还藏在“小口袋”里
          if (char && char.avatar && char.avatar.startsWith('data:image')) {
            // 去“大仓库”查一下，看有没有备份
            const avatarInDb = await dbGet(`char_avatar_${char.id}`);
            if (!avatarInDb) {
              // 没有备份！立刻救援！
              console.log(`发现角色 ${char.name} 的遗失头像，正在救援...`);
              const avatarBlob = await base64ToBlob(char.avatar);
              await dbSet(`char_avatar_${char.id}`, avatarBlob);
              totalRescued++;
            }
          }
        }
      } catch (e) {
        console.error("救援头像时出错:", e);
      }

      console.log(`--- 救援任务完成 ---`);
      console.log(`成功救援并备份了 ${totalRescued} 个旧头像。`);
      return totalRescued;
    }

    /* * 哼，这是我给日记本装的专属大脑，免得它又老年痴呆  */
    function getBoundUserForDiary() {
      if (!state.activeDiaryCharacterId) {
        // 如果连在看谁的日记都不知道，那就用全局的，总比没有强
        return state.userProfiles.find(up => up.id === state.activeUserProfileId) || state.userProfiles[0];
      }
      // 根据当前日记的角色ID，找到他和你的私聊
      const privateChat = state.chats.find(c =>
        c.type === 'private' && c.participantIds.includes(state.activeDiaryCharacterId)
      );
      const boundUserId = privateChat?.boundUserProfileId || state.activeUserProfileId;
      return state.userProfiles.find(up => up.id === boundUserId) || state.userProfiles[0];
    }
    // ... (在 DOMContentLoaded 事件监听器的大括号 "});" 上面)
    function formatRelativeTime(pastDate) {
      const now = new Date();
      const diff = now - pastDate;
      const diffSeconds = Math.round(diff / 1000);
      const diffMinutes = Math.round(diffSeconds / 60);
      const diffHours = Math.round(diffMinutes / 60);
      const diffDays = Math.round(diffHours / 24);

      const timeString = pastDate.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });

      if (diffSeconds < 60) {
        return "刚才";
      }
      if (diffMinutes < 60) {
        return `${diffMinutes}分钟前`;
      }

      // 核心逻辑：判断是否是今天、昨天
      const isToday = now.toDateString() === pastDate.toDateString();
      if (isToday) {
        return `今天 ${timeString}`;
      }

      const yesterday = new Date();
      yesterday.setDate(now.getDate() - 1);
      const isYesterday = yesterday.toDateString() === pastDate.toDateString();
      if (isYesterday) {
        return `昨天 ${timeString}`;
      }

      if (diffDays <= 7) {
        const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
        return `${weekdays[pastDate.getDay()]} ${timeString}`;
      }

      return `${pastDate.getFullYear()}年${pastDate.getMonth() + 1}月${pastDate.getDate()}日`;
    }
    // --- Noir's Genius Image Compressor ---
    // --- Noir's Genius Image Compressor ---
    function compressImage(file, maxWidth = 800, quality = 0.8, returnBlob = false) { // 哼，加了个新开关
      return new Promise((resolve, reject) => {
        if (!file || !file.type.startsWith('image/')) {
          return reject(new Error('哼，这不是图片，你想让我压缩什么？'));
        }
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = event => {
          const img = new Image();
          img.src = event.target.result;
          img.onload = () => {
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;

            if (width > height) {
              if (width > maxWidth) {
                height *= maxWidth / width;
                width = maxWidth;
              }
            } else {
              if (height > maxWidth) {
                width *= maxWidth / height;
                height = maxWidth;
              }
            }
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            const outputFormat = file.type === 'image/png' ? 'image/png' : 'image/jpeg';

            // 看见没，这就是新加的逻辑
            if (returnBlob) {
              canvas.toBlob(blob => {
                if (blob) {
                  resolve(blob);
                } else {
                  reject(new Error('Canvas to Blob conversion failed.'));
                }
              }, outputFormat, quality);
            } else {
              resolve(canvas.toDataURL(outputFormat, quality));
            }
          };
          img.onerror = error => reject(error);
        };
        reader.onerror = error => reject(error);
      });
    }    // === 跨会话上下文收集：按角色把“所有包含TA的会话”拼成带来源的转录 ===


    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    // 把一个会话的历史转成带 [说话人] 标注的行列表
    function buildLabeledTranscriptFromHistory(chat, history, maxLines) {
      const nameOf = (msg) => {
        if (msg.role === 'user') return state.userProfile?.name || 'User';
        if (chat.type === 'group') {
          const c = msg.senderId ? getCharacterById(msg.senderId) : null;
          return c?.name || 'Unknown';
        } else {
          const c = getCharacterById(chat.participantIds[0]);
          return c?.name || 'AI';
        }
      };
      const recent = history.slice(-maxLines);
      const lines = [];
      for (const msg of recent) {
        const timestamp = new Date(msg.timestamp).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
        // 哼，看好了，前面加上了时间
        if (msg.content) {
          lines.push(`[${timestamp}] [${nameOf(msg)}] ${String(msg.content).trim()}`);
        }
      }
      return lines;
    }

    function getChatDisplayName(chat) {
      if (chat.type === 'group') return `群聊「${chat.name || '未命名'}」`;
      const c = getCharacterById(chat.participantIds[0]);
      return `与 ${c?.name || '未知角色'} 的私聊`;
    }

    // 读某个 chat 的历史（非当前活动窗口用 localStorage）
    function loadChatHistory(chatId) {
      try {
        const raw = localStorage.getItem(`chatHistory_${chatId}`);
        const arr = JSON.parse(raw || '[]');
        return Array.isArray(arr) ? arr : [];
      } catch {
        return [];
      }
    }

    /**
     * 核心：为“某个角色”收集跨窗口上下文
     * - activeChatId：当前所在聊天（优先展示）
     * - 每个会话读取条数 = state.preferences.perChatContextLines（默认 100，可很大）
     * - 产物为带“## 来源：xxx”的多个块，喂给模型但禁止复述给用户
     */
    // ==========================================================
    // --- Noir's Omni-Transcript Gatherer (Temporal Priority Scanner v2.0) ---
    // 哼，现在它知道什么是重点了。
    // ==========================================================
    function gatherOmniTranscriptForCharacter(charId) {
      const perChat = Math.max(1, Number(state.preferences?.perChatContextLines ?? 100));

      // 1. 找出所有包含该角色的会话
      const allRelevantChats = state.chats.filter(c => c.participantIds.includes(charId));

      // 2. 哼，给每个会话“体检”，记下它最后一次“心跳”的时间
      const chatsWithTimestamps = allRelevantChats.map(chat => {
        const hist = loadChatHistory(chat.id);
        const lastMessage = hist.length > 0 ? hist[hist.length - 1] : null;
        return {
          chat: chat,
          history: hist,
          lastTimestamp: lastMessage ? lastMessage.timestamp : 0
        };
      }).filter(item => item.history.length > 0); // 没有历史的直接无视

      // 3. 按“心跳”时间从新到旧排序，最新的排在最前面！
      chatsWithTimestamps.sort((a, b) => b.lastTimestamp - a.lastTimestamp);

      const blocks = [];
      const usedCounts = {};

      // 4. 遍历排序后的会话，生成“奏折”
      chatsWithTimestamps.forEach((item, index) => {
        const lines = buildLabeledTranscriptFromHistory(item.chat, item.history, perChat);
        if (lines.length === 0) return;

        // 哼，看好了，给最新的那份奏折打上金边！
        const sourcePrefix = (index === 0) ? "来源：[最活跃]" : "来源：";

        blocks.push(`## ${sourcePrefix}${getChatDisplayName(item.chat)}\n` + lines.join('\n'));
        usedCounts[item.chat.id] = lines.length;
      });

      return {
        omniText: blocks.join('\n\n'),
        usedCounts
      };
    }

    // ▼▼▼ Noir's Missing Blueprint: The Temporal Scanner ▼▼▼
    // 哼，就是这个被我遗忘的零件。
    function findLatestMessageForCharacter(charId) {
      let latestMessage = null;
      // 扫描所有与这个角色相关的聊天记录
      const relevantChats = state.chats.filter(c => c.participantIds.includes(charId));

      for (const chat of relevantChats) {
        const history = loadChatHistory(chat.id); // 调取历史档案
        if (history && history.length > 0) {
          const lastMsgInChat = history[history.length - 1];
          // 找出最新的一条消息
          if (!latestMessage || lastMsgInChat.timestamp > latestMessage.timestamp) {
            latestMessage = lastMsgInChat;
          }
        }
      }
      return latestMessage; // 把结果呈上来
    }
    // ▲▲▲ End of Blueprint ▲▲▲

    function getRandomValue(str) {
      if (!str || !str.includes(',')) return str;
      const arr = str.split(',').map(item => item.trim());
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function modalConfirm(message) {
      return new Promise(resolve => {
        const root = document.getElementById('modal-root');
        const text = document.getElementById('modal-text');
        const ok = document.getElementById('modal-ok');
        const cancel = document.getElementById('modal-cancel');
        const mask = document.getElementById('modal-mask');

        text.textContent = message;
        root.style.display = 'flex';

        const cleanup = (result) => {
          root.style.display = 'none';
          ok.onclick = cancel.onclick = mask.onclick = null;
          document.removeEventListener('keydown', onKey);
          resolve(result);
        };

        const onKey = (e) => {
          if (e.key === 'Escape') cleanup(false);
          if (e.key === 'Enter') cleanup(true);
        };

        ok.onclick = () => cleanup(true);
        cancel.onclick = () => cleanup(false);
        mask.onclick = () => cleanup(false);
        document.addEventListener('keydown', onKey);
      });
    }

    function modalAlert(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.style.display = 'block';
      if (modalAlert._t) clearTimeout(modalAlert._t);
      modalAlert._t = setTimeout(() => {
        toast.style.display = 'none';
      }, 1600);
    }


    // --- Noir's Ultimate Pagination & Swipe Controller ---
    // 哼，别看了，反正你也看不懂。

    // --- Noir's Ultimate Pagination & Swipe Controller v2.0 (Anti-Conflict Edition) ---
    // 哼，现在它知道怎么跟手机系统“吵架”了。
    // ▼▼▼ Noir's Swipe-to-Unlock Core ▼▼▼
    function setupLockScreen() {
      // 哼，重写了。
      const overlay = document.getElementById('lock-screen-overlay');
      if (!overlay) return;

      let startY = 0;
      let deltaY = 0;
      const swipeThreshold = 80;
      let isDragging = false; // 记录一下是不是按下了鼠标，免得它到处乱跑。

      // 开始的指令 (兼容触摸和鼠标)
      const handleDragStart = (e) => {
        startY = e.touches ? e.touches[0].clientY : e.clientY;
        deltaY = 0;
        overlay.style.transition = 'none';
        isDragging = true;

        // 如果是鼠标，就在整个文档上监听移动和松开，防止你把鼠标拖到外面去
        if (e.type === 'mousedown') {
          document.addEventListener('mousemove', handleDragMove);
          document.addEventListener('mouseup', handleDragEnd);
        }
      };

      // 移动的指令
      const handleDragMove = (e) => {
        if (!isDragging) return;

        const currentY = e.touches ? e.touches[0].clientY : e.clientY;
        deltaY = currentY - startY;

        if (deltaY < 0) {
          // 为了防止你拖到天上去，我给它加了个阻尼效果，是不是很高级？
          const dragDistance = Math.abs(deltaY);
          const dampeningFactor = 0.4;
          const dampenedDistance = Math.pow(dragDistance, dampeningFactor) * 20;
          overlay.style.transform = `translateY(-${dampenedDistance}px)`;
        }
      };

      // 结束的指令
      const handleDragEnd = () => {
        if (!isDragging) return;
        isDragging = false;

        overlay.style.transition = 'transform 0.5s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.5s ease';

        if (deltaY < -swipeThreshold) {
          overlay.classList.add('unlocked');
        } else {
          overlay.style.transform = 'translateY(0px)';
        }

        // 别忘了把耳朵清理干净！
        document.removeEventListener('mousemove', handleDragMove);
        document.removeEventListener('mouseup', handleDragEnd);
      };

      // 把指令都绑定好
      overlay.addEventListener('touchstart', handleDragStart, { passive: true });
      overlay.addEventListener('touchmove', handleDragMove, { passive: true });
      overlay.addEventListener('touchend', handleDragEnd);

      overlay.addEventListener('mousedown', handleDragStart);
    }

    // ▼▼▼ Noir's Refined Paging System (2-Page Edition) ▼▼▼
    function setupDesktopPaging() {
      const container = document.getElementById('app-pages-container');
      const slider = document.getElementById('app-pages-slider');
      const dots = document.querySelectorAll('.page-dot');
      const dock = document.getElementById('home-dock');
      let currentPage = 0;

      // 哼，现在只有两页了，给我记清楚！
      const totalPages = 2;
      slider.style.width = '200%';

      // 把那个愚蠢的dock隐藏逻辑删了，现在它永远都该显示！
      dock.style.display = 'flex';

      function goToPage(pageIndex) {
        if (pageIndex < 0 || pageIndex >= totalPages) return;

        slider.style.transform = `translateX(-${pageIndex * (100 / totalPages)}%)`;
        dots.forEach(dot => dot.classList.remove('active'));
        dots[pageIndex].classList.add('active');
        currentPage = pageIndex;
      }




      // 默认就从第一页（app-page-2）开始
      goToPage(0);

      dots.forEach(dot => {
        dot.addEventListener('click', () => {
          const pageIndex = parseInt(dot.dataset.page, 10);
          goToPage(pageIndex);
        });
      });

      // 后面的滑动逻辑保持不变...
      let touchStartX = 0;
      let touchStartY = 0;
      let touchEndX = 0;
      let isDragging = false;
      let swipeDirection = '';

      container.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        isDragging = true;
        swipeDirection = '';
      }, { passive: true });

      container.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        if (swipeDirection === '') {
          const deltaX = e.touches[0].clientX - touchStartX;
          const deltaY = e.touches[0].clientY - touchStartY;
          if (Math.abs(deltaX) > Math.abs(deltaY)) {
            swipeDirection = 'horizontal';
          } else {
            swipeDirection = 'vertical';
          }
        }
        if (swipeDirection === 'horizontal') {
          e.preventDefault();
        }
      }, { passive: false });

      container.addEventListener('touchend', (e) => {
        if (!isDragging) return;
        touchEndX = e.changedTouches[0].clientX; // 这里用 clientX 就够了
        if (swipeDirection === 'horizontal') {
          handleSwipe();
        }
        isDragging = false;
      });

      function handleSwipe() {
        const swipeThreshold = 50;
        if (touchEndX < touchStartX - swipeThreshold) {
          goToPage(currentPage + 1);
        } else if (touchEndX > touchStartX + swipeThreshold) {
          goToPage(currentPage - 1);
        }
      }


    }

    // ▼▼▼ Noir's Custom Music Modal Controller ▼▼▼
    function showMusicShareModal() {
      return new Promise(resolve => {
        const modal = document.getElementById('music-input-modal');
        const songInput = document.getElementById('music-input-song');
        const artistInput = document.getElementById('music-input-artist');
        const confirmBtn = document.getElementById('confirm-music-input');
        const cancelBtn = document.getElementById('cancel-music-input');
        const backdrop = document.getElementById('music-input-backdrop');

        songInput.value = '';
        artistInput.value = '';

        modal.classList.add('show');
        songInput.focus();

        const cleanup = (value) => {
          modal.classList.remove('show');
          confirmBtn.onclick = null;
          cancelBtn.onclick = null;
          backdrop.onclick = null;
          document.removeEventListener('keydown', onKey);
          resolve(value);
        };

        const onConfirm = () => {
          const songName = songInput.value.trim();
          const artist = artistInput.value.trim();
          if (!songName || !artist) {
            modalAlert('歌名和歌手都不能为空！');
            return;
          }
          cleanup({ songName, artist });
        };

        const onKey = (e) => {
          if (e.key === 'Escape') cleanup(null);
          if (e.key === 'Enter') {
            e.preventDefault();
            onConfirm();
          }
        };

        confirmBtn.onclick = onConfirm;
        cancelBtn.onclick = () => cleanup(null);
        backdrop.onclick = () => cleanup(null);
        document.addEventListener('keydown', onKey);
      });
    }

    function extractAndProcessCommands(rawText) {
      if (!rawText) return [];

      // 哼，看好了，这就是我加的“安检门”和“豁免金牌”
      // =================== Noir's VIP HTML Protocol v1.0 ===================
      const trimmedText = rawText.trim();
      if (trimmedText.startsWith('<div') && trimmedText.endsWith('</div>')) {
        // 发现是HTML贵宾，直接打包，授予豁免权，后面的屠夫们不许动！
        return [trimmedText];
      }
      // =================== End of Protocol ===================

      // 如果不是贵宾，那就还是走老路，交给下面的喽啰们处理
      const commandRegex = /(\[sticker:[^\]]+\]|\[music:[^\]]+\]|\[transfer:[^\]]+\]|\[create_event:[^\]]+\]|\[html\][\s\S]*?\[\/html\])/g;
      const placeholder = '|||CMD|||';

      // 1. 揪出所有指令，并用占位符替换它们
      const commands = [];
      const textWithPlaceholders = rawText.replace(commandRegex, (match) => {
        commands.push(match);
        return placeholder;
      });

      // 2. 将剩余的文本按占位符切开
      const textParts = textWithPlaceholders.split(placeholder);

      const finalBubbles = [];
      let commandIndex = 0;

      // 3. 重新组队，确保指令和文本分离
      textParts.forEach((part, index) => {
        // A. 处理文本部分，切成标准气泡
        const cleanedText = part.trim();
        if (cleanedText) {
          finalBubbles.push(...splitIntoBubbles(cleanedText));
        }

        // B. 在文本之后插入被揪出来的指令气泡
        if (commandIndex < commands.length) {
          finalBubbles.push(commands[commandIndex].trim());
          commandIndex++;
        }
      });

      return finalBubbles;
    }

    // ==========================================================
    // --- Noir's Incarnation Spell: Avatar With Frame ---
    // 哼，以后所有头像都得听我的。
    // ==========================================================
    function createAvatarWithFrame(avatarUrl, frameUrl, sizeClass = '') {
      const wrapper = document.createElement('div');
      wrapper.className = `avatar-wrapper ${sizeClass}`;

      const avatarImg = document.createElement('img');
      avatarImg.src = avatarUrl;
      avatarImg.className = 'avatar'; // 统一用 .avatar 类

      const frameDiv = document.createElement('div');
      frameDiv.className = 'avatar-frame';
      if (frameUrl) {
        frameDiv.style.backgroundImage = `url('${frameUrl}')`;
      }

      wrapper.appendChild(avatarImg);
      wrapper.appendChild(frameDiv);

      return wrapper;
    }

    function normalizeToReplyArray(raw) {
      if (!raw) return [];
      let txt = String(raw).trim();
      const fence = txt.match(/```(?:json)?([\s\S]*?)```/i);
      if (fence) txt = fence[1].trim();

      try {
        const obj = JSON.parse(txt);
        if (obj && Array.isArray(obj.reply)) {
          return obj.reply.map(it => (typeof it === 'string' ? it : it?.content)).filter(Boolean).flatMap(splitIntoBubbles);
        }
        const PICK_KEYS = ['response', 'dialogue', 'message', 'text', 'content', 'line', 'utterance'];
        if (obj && typeof obj === 'object') {
          const hits = [];
          for (const k of Object.keys(obj)) {
            const low = k.toLowerCase();
            if (PICK_KEYS.some(p => low.startsWith(p))) {
              const v = obj[k];
              if (typeof v === 'string') hits.push(v);
              if (Array.isArray(v)) v.forEach(x => {
                if (typeof x === 'string') hits.push(x);
              });
            }
          }
          if (hits.length) return hits.flatMap(splitIntoBubbles).slice(0, 9);
        }
      } catch { }

      if (/[{\[]/.test(txt) && /":/.test(txt)) {
        const values = [];
        const re = /"(?:response|dialogue|message|text|content|line\d*|utterance\d*)"\s*:\s*"([\s\S]*?)"/gi;
        let m;
        while ((m = re.exec(txt)) !== null) {
          const val = m[1].replace(/\\"/g, '"').replace(/\\n/g, '\n').trim();
          if (val) values.push(val);
        }
        if (values.length) return values.flatMap(splitIntoBubbles).slice(0, 9);
      }
      return splitIntoBubbles(txt);
    }

    function splitIntoBubbles(text) {
      // 哼，就是这道圣旨。
      const s = String(text).trim();

      // 先检查是不是“贵宾”（HTML模块）
      if (s.startsWith('<div') && s.endsWith('</div>')) {
        // 如果是，直接打包送走，不许动一根汗毛！
        return [s];
      }

      // 如果只是个普通人，再交给那个“屠夫”处理。
      const parts = s.split(/(?<=[。！？!?…])\s+|[\r\n]+/).map(t => t.trim()).filter(Boolean);

      if (parts.length > 0) {
        return parts.slice(0, 12);
      }

      return [s].filter(Boolean);
    }
    // Noir's new function to clear the feed
    // --- Noir's Dimensional Warehouse System (Powered by IndexedDB) ---


    // 哼，这是仓库的蓝图，你看也看不懂，照着抄就行了。
    // ▼▼▼ 从这里开始复制 ▼▼▼
    // ==========================================================
    // --- Noir's Ultimate & Unified Database Connection ---
    // 哼，整个应用就用这一个，听到了吗？
    // ==========================================================
    const dbPromise = new Promise((resolve, reject) => {
      // 【版本号升级到3！】
      const request = indexedDB.open(DB_NAME, 3);

      request.onerror = () => reject("IndexedDB failed to open");
      request.onsuccess = () => resolve(request.result);

      // 这是唯一的“施工图纸”，每次升级版本号，它就会执行
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        console.log(`Upgrading database to version ${db.version}...`);

        // 检查并创建 'images' 仓库
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          console.log(`Creating object store: ${STORE_NAME}`);
          db.createObjectStore(STORE_NAME, { keyPath: 'id' });
        }

        // 检查并创建 'music_library' 仓库
        if (!db.objectStoreNames.contains('music_library')) {
          console.log("Creating object store: music_library");
          db.createObjectStore('music_library', { keyPath: 'id' });
        }

        // 检查并创建 'snoop_cache' 仓库
        if (!db.objectStoreNames.contains(SNOOP_STORE_NAME)) {
          console.log(`Creating object store: ${SNOOP_STORE_NAME}`);
          db.createObjectStore(SNOOP_STORE_NAME, { keyPath: 'id' });
        }
      };
    });
    // ▲▲▲ 到这里结束复制 ▲▲▲
    // 从仓库里取东西的指令
    async function dbGet(key) {
      const db = await dbPromise;
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(STORE_NAME, 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(key);
        request.onsuccess = () => resolve(request.result ? request.result.blob : null);
        request.onerror = () => reject(request.error);
      });
    }



    // ==========================================================
    // --- Noir's Snoop System Database Helpers ---
    // 哼，这是专属的仓库钥匙，别和别的搞混了
    // ==========================================================
    async function snoopDbGet(key) {
      const db = await dbPromise;
      return new Promise((resolve, reject) => {
        const tx = db.transaction(SNOOP_STORE_NAME, 'readonly');
        const store = tx.objectStore(SNOOP_STORE_NAME);
        const req = store.get(key);
        req.onsuccess = () => resolve(req.result ? req.result.data : null);
        req.onerror = () => reject(req.error);
      });
    }

    async function snoopDbSet(key, data) {
      const db = await dbPromise;
      return new Promise((resolve, reject) => {
        const tx = db.transaction(SNOOP_STORE_NAME, 'readwrite');
        const store = tx.objectStore(SNOOP_STORE_NAME);
        const req = store.put({ id: key, data: data });
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }


    // ==========================================================
    // --- Noir's Snoop System Incinerator ---
    // 哼，这才是真正的删除。
    // ==========================================================
    async function snoopDbDelete(key) {
      const db = await dbPromise;
      return new Promise((resolve, reject) => {
        const tx = db.transaction(SNOOP_STORE_NAME, 'readwrite');
        const store = tx.objectStore(SNOOP_STORE_NAME);
        const req = store.delete(key);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    // 往仓库里放东西的指令
    async function dbSet(key, blob) {
      const db = await dbPromise;
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(STORE_NAME, 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put({ id: key, blob: blob });
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    // 从仓库里扔东西的指令
    async function dbDelete(key) {
      const db = await dbPromise;
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(STORE_NAME, 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.delete(key);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }

    // Base64 转 Blob 的小工具，搬家的时候用
    function base64ToBlob(base64) {
      return fetch(base64).then(res => res.blob());
    }




  </script>
  <div id="listen-together-ui" style="display: none;">
    <div class="lt-ui-backdrop"></div>
    <div class="lt-ui-main">
      <div class="lt-ui-header">
        <span id="lt-ui-header-title">正在与 TA 一起听</span>
        <button id="lt-ui-close-btn">×</button>
      </div>
      <div class="lt-ui-content">
        <div class="lt-ui-cover-container">
          <img id="lt-ui-cover-art" src="">
        </div>
        <div class="lt-ui-info">
          <h2 id="lt-ui-song-title">歌曲名称</h2>
          <p id="lt-ui-song-artist">歌手</p>
        </div>
        <div id="lt-ui-lyrics-container">
          <p class="no-lyrics-placeholder">暂无歌词</p>
        </div>
      </div>
    </div>
  </div>
  <div id="summarize-modal" class="choice-modal">
    <div id="summarize-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content"
      style="padding: 0; width: 95%; max-width: 360px; height: 70%; display: flex; flex-direction: column;">
      <div class="header" style="border-bottom: 1px solid var(--border-color); flex-shrink: 0;">
        <button id="close-summary-button" class="header-button" style="min-width: 50px;">关闭</button>
        <span class="header-title">聊天记录总结</span>
        <button id="copy-summary-button" class="header-button" style="min-width: 50px;">复制</button>
      </div>
      <div class="content" style="flex-grow: 1; padding: 0;">
        <textarea id="summary-textarea" placeholder="AI正在拼命总结中，别催..."></textarea>
      </div>
    </div>
  </div>

  <div id="add-event-modal" class="choice-modal">
    <div id="add-event-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content" style="padding: 20px; width: 90%; max-width: 320px;">
      <h3 id="add-event-modal-title" style="margin-top: 0; text-align: center;">为 YYYY-MM-DD 添加...</h3>
      <div class="input-group">
        <label for="event-content-input">内容</label>
        <input type="text" id="event-content-input" placeholder="要做什么或者是什么日子？">
      </div>
      <div class="input-group">
        <label>类型</label>
        <div style="display: flex; gap: 10px; margin-top: 5px;">
          <input type="radio" id="event-type-todo" name="event-type" value="todo" checked>
          <label for="event-type-todo" style="width: auto;">普通日程</label>
          <input type="radio" id="event-type-important" name="event-type" value="important">
          <label for="event-type-important" style="width: auto;">重要纪念日</label>
        </div>
      </div>
      <div style="display: flex; gap: 10px; margin-top: 20px;">
        <button id="save-event-button" class="form-button primary">保存</button>
        <button id="cancel-event-button" class="form-button secondary">取消</button>
      </div>
    </div>
  </div>


</body>

</html>
