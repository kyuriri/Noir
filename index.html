<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

  <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;">

  <title>Noir搓的小手机</title>
  <style>
    .message p,
    .diary-content {
      user-select: none;
      -webkit-user-select: none;
    }

    .lt-end-session-btn {
      font-size: 1.5rem;
      color: inherit;
      /* 继承父元素的颜色 */
      opacity: 0.6;
      cursor: pointer;
      padding: 0 5px;
      line-height: 1;
      font-weight: bold;
    }

    .lt-end-session-btn:hover {
      opacity: 1;
    }

    /* --- Noir's Refactor: Feed Loader Style --- */
    #feed-loader {
      position: absolute;
      inset: 0;
      background: rgba(244, 248, 255, 0.85);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9000;
      color: var(--text-color);
      font-size: 1rem;
      flex-direction: column;
      gap: 10px;
    }

    .loader-spinner {
      width: 24px;
      height: 24px;
      border: 3px solid var(--border-color);
      border-top-color: var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* --- End of Refactor --- */
    /*
        Noir's Mizuiro Theme
        - 哼，看好了，这才是设计。
      */
    /*
          Noir's Mizuiro Theme
          - 哼，看好了，这才是设计。
        */
    :root {
      --phone-width: 375px;
      --phone-height: 812px;
      --user-bg-image: url('');

      /* === Noir's Ultimate Dynamic Theme Engine v2.0 === */
      /* 哼，现在所有的颜色都听从这三个总开关的指挥。*/
      --primary-hue: 35;
      --primary-saturation: 25%;
      --primary-lightness: 80%;

      /* 核心颜色 */
      --primary-color: hsl(var(--primary-hue), var(--primary-saturation), var(--primary-lightness));
      /* 强调色/用户气泡色，现在也是动态的 */
      --accent-color: hsl(var(--primary-hue), calc(var(--primary-saturation) * 1.2), calc(var(--primary-lightness) - 20%));

      /* 哼，看好了，这些就是被我重新接上线的“电灯” */

      /* 文字颜色：根据主题亮度自动变深或变浅 */
      --text-color: hsl(var(--primary-hue), 15%, calc(100% - var(--primary-lightness) / 1.1));
      --text-color-light: hsl(var(--primary-hue), 10%, calc(100% - var(--primary-lightness) / 1.3));

      /* 表面背景：半透明，亮度比主色高一点 */
      --surface-bg: hsla(var(--primary-hue), calc(var(--primary-saturation) / 2), calc(var(--primary-lightness) + 15%), 0.4);

      /* 卡片/AI气泡背景：比表面背景更亮一点 */
      --card-bg: hsla(var(--primary-hue), calc(var(--primary-saturation) / 1.5), calc(var(--primary-lightness) + 18%), 0.75);

      /* 边框颜色 */
      --border-color: hsla(var(--primary-hue), calc(var(--primary-saturation) / 2), calc(var(--primary-lightness)), 0.3);

      /* 阴影颜色 */
      --soft-shadow: 0 4px 12px hsla(var(--primary-hue), 40%, calc(var(--primary-lightness) - 10%), 0.15);

      /* 动态页的设置保持不变 */
      --feed-bg-image: none;
      --feed-overlay-opacity: 0.12;
      --feed-overlay-rotate: 22deg;
      --feed-overlay-speed: 48s;

      /* 气泡样式也完全动态化 */
      --bubble-radius: 18px;
      --bubble-outline: hsla(var(--primary-hue), var(--primary-saturation), calc(var(--primary-lightness) + 10%), 0.5);
      --bubble-user-bg: hsla(var(--primary-hue), calc(var(--primary-saturation) * 1.2), calc(var(--primary-lightness) - 20%), 0.75);
      /* <-- 哼，改成0.5，现在够“虚无”了吧 */
      --bubble-ai-bg: var(--card-bg);

      /* ▼▼▼ 把下面这两行加进去 ▼▼▼ */
      --dropdown-alpha: 0.9;
      /* 下拉菜单的透明度，0到1 */
      --feed-card-alpha: 0.7;
      /* 动态卡片的透明度，0到1 */


      /* ▲▲▲ 添加到这里结束 ▲▲▲ */

    }

    /* Noir's Font Decree */
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      /* 哼，看好了，就是这句！现在字体听从我的新变量指揮了！ */
      font-family: var(--custom-font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif);
      background-image: var(--user-bg-image);
      background-size: cover;
      background-position: center;
    }

    /* 让字体预览区也听话 */
    #font-preview-text {
      font-family: var(--custom-font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif);
    }

    #phone-container {
      width: 100%;
      /* 占满屏幕宽度 */
      height: 100vh;
      /* 占满屏幕高度 */
      background-color: white;
      background-image: var(--user-bg-image);
      background-size: cover;
      background-position: center;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      /* 是不是清爽多了？ */
      position: relative;
      /* <-- 就是这句，告诉它“你是个家长了，给我看好家里的东西！” */
    }

    .screen {
      flex-grow: 1;
      display: none;
      flex-direction: column;
      background-color: #f9f9f9;
      /* 哼，所有屏幕默认都给我变白 */
      /* 让背景透出来 */
      overflow: hidden;
      color: var(--text-color);
    }

    .screen.active {
      display: flex;
    }

    /* 这个是通用的头像预览样式 */
    .avatar-preview {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      object-fit: cover;
      border: 2px solid var(--border-color);
      margin-top: 5px;
      cursor: pointer;
    }

    /* --- 通用顶栏 --- */
    .header,
    #chat-list-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background-color: var(--surface-bg);
      /* backdrop-filter: blur(12px); */
      /* <-- 就这么简单，干掉它 */
      border-bottom: 1px solid var(--border-color);
      flex-shrink: 0;
    }

    .header-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-color);
    }

    .header-button {
      background: none;
      border: none;
      font-size: 1rem;
      cursor: pointer;
      color: var(--primary-color);
      font-weight: 500;
      min-width: 50px;
      text-align: center;
      /* ▼▼▼ 哼，加上这三句，给我立正站好 ▼▼▼ */
      display: flex;
      align-items: center;
      justify-content: center;
    }

  #chat-list-pane {
  position: absolute; /* 核心！改为绝对定位 */
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1; /* 在底层 */
  
  background-color: transparent;
  overflow-y: auto; /* 只有它自己滚动 */
  
  /* 动画相关 */
  transition: transform 0.35s cubic-bezier(0.33, 1, 0.68, 1), filter 0.35s ease;
  will-change: transform, filter;
  transform: translate3d(0, 0, 0);
}
    #chat-list-container {
      flex-grow: 1;
      flex-grow: 1;
      overflow-y: auto;
      padding: 10px;
    }

    #character-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .character-item {
      display: flex;
      align-items: center;
      padding: 12px;
      margin-bottom: 10px;
      background-color: var(--card-bg);
      /* backdrop-filter: blur(10px);*/
      border-radius: 16px;
      box-shadow: var(--soft-shadow);
      border: 1px solid rgba(255, 255, 255, 0.5);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .character-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(138, 180, 228, 0.2);
    }

    .char-info-wrapper {
      flex-grow: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      overflow: hidden;
    }

    .character-item .char-avatar {
      width: 45px;
      height: 45px;
      border-radius: 50%;
      margin-right: 12px;
      object-fit: cover;
      flex-shrink: 0;
    }

    .character-item .char-name {
      font-weight: 600;
      color: var(--text-color);
    }

    .character-item .char-remark {
      font-size: 0.85rem;
      color: var(--text-color-light);
    }

   /* 1. 容器：作为一个固定的画框 */
#chat-screen-container {
  position: relative;
  width: 100%;
  height: 100%;
  overflow: hidden; /* 锁死溢出 */
  background-color: #f9f9f9; /* 防止透视 */
}
    /* --- 聊天窗口 --- */


  /* --- Noir's Fixed Layout: 消除回弹抖动 --- */
/* 3. 聊天页：浮在顶层 */
#chat-view-pane {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 10;
  
  display: flex;
  flex-direction: column;
  
  background-color: #f9f9f9;
  box-shadow: -10px 0 25px -5px rgba(0, 0, 0, 0.1);
  
  /* 初始状态：推到右边 */
  transform: translate3d(100%, 0, 0);
  /* 核心：默认隐身，防止“左移一下”的残影 */
  visibility: hidden; 
  
  /* 动画曲线：加上 visibility 的延迟，确保滑走后才隐身 */
  transition: transform 0.35s cubic-bezier(0.33, 1, 0.68, 1), visibility 0s linear 0.35s;
  will-change: transform;
}

/* 当聊天打开时 */
#chat-screen.show-chat-view #chat-view-pane {
  transform: translate3d(0, 0, 0);
  visibility: visible; /* 现身 */
  /* 现身时不需要延迟 */
  transition: transform 0.35s cubic-bezier(0.33, 1, 0.68, 1), visibility 0s linear 0s;
}

/* 当聊天打开时：列表页原地变暗（不移动，防止抖动） */
#chat-screen.show-chat-view #chat-list-pane {
  filter: brightness(0.95); 
  pointer-events: none; /* 禁止点击底层 */
  transform: translate3d(0, 0, 0); /* 保持不动 */
}
    /* 在动画过渡期间禁用交互，防止卡在中间 */
    #chat-screen.transitioning #chat-list-pane,
    #chat-screen.transitioning #chat-view-pane {
      pointer-events: none;
    }




    .avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;

      object-fit: cover;
      border: 2px solid rgba(255, 255, 255, 0.7);
      flex-shrink: 0;
    }

    .message {
      padding: 10px 16px;
      border-radius: 20px;
      line-height: 1.5;
      word-break: break-word;
      box-shadow: var(--soft-shadow);
    }

    .message.user.sticker,
    .message.ai.sticker,
    .message.user.image,
    .message.ai.image {
      background-color: transparent;
      padding: 0;
      box-shadow: none;
    }

    .message.user {
      background-color: var(--accent-color);
      color: white;
      border-bottom-right-radius: 5px;
    }

    .message.ai {
      background-color: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0.8);
      color: var(--text-color);
      border-bottom-left-radius: 5px;
    }

    .message p {
      margin: 0;
    }

    .sticker-content,
    .message-image-content {
      max-width: 120px;
      border-radius: 8px;
      object-fit: cover;
      cursor: pointer;
    }

    .message-image-content {
      max-width: 160px;
    }

    /* --- 其他屏幕和组件 --- */
    /* --- Noir's Fix: API 模型列表的样式修正 --- */
    .model-input-container {
      position: relative;
      /* 关键！让里面的绝对定位元素有家可回 */
      display: flex;
      gap: 8px;
    }

    .custom-model-dropdown {
      display: none;
      /* 默认藏起来 */
      position: absolute;
      top: 100%;
      /* 精准定位到输入框正下方 */
      left: 0;
      right: 80px;
      /* 留出“获取”按钮的位置 */
      background: hsla(var(--primary-hue), calc(var(--primary-saturation) / 2), calc(var(--primary-lightness) + 15%), var(--dropdown-alpha));
      /*   backdrop-filter: blur(10px);*/
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin-top: 4px;
      max-height: 180px;
      overflow-y: auto;
      z-index: 100;
      /* 确保它在最上层 */
      box-shadow: var(--soft-shadow);
    }

    .checkboxes-container {
      display: none;
      position: absolute;
      left: 0;
      right: 0;
      top: 100%;
      max-height: 150px;
      overflow-y: auto;
      border: 1px solid var(--border-color);
      background: hsla(var(--primary-hue), calc(var(--primary-saturation) / 2), calc(var(--primary-lightness) + 15%), var(--dropdown-alpha));
      /*  backdrop-filter: blur(10px);*/
      z-index: 10;
      border-radius: 8px;
      margin-top: 4px;
    }

    .custom-model-dropdown.show {
      display: block;
      /* 需要的时候再显示 */
    }

    .custom-model-dropdown div {
      padding: 10px 12px;
      cursor: pointer;
      color: var(--text-color);
      font-size: 0.9rem;
    }

    .custom-model-dropdown div:hover {
      background-color: rgba(138, 180, 228, 0.2);
    }

    /* --- 其他屏幕和组件 --- */
    /* 在这个注释下面加上主屏幕的样式 */
    #home-screen {
      position: relative;
      /* <-- 就加上这一行！ */


      gap: 20px;
      /* 图标之间的距离 */

      /* 声明！这里现在是我的地盘！*/
      flex-direction: column;
      /* 里面的东西，全体给我垂直排队！*/
      justify-content: space-between;
      /* 核心！顶部和底部的元素给我贴边站好，中间的自动拉开距离！*/
      padding-bottom: 0;
      /* 把内边距去掉，让Dock栏能完美贴底 */
    }

    .app-icon {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      position: absolute;
      z-index: 40;
      box-sizing: border-box;
      margin: 0;
      /* ▼▼▼ 下面是手术刀切下来的新尺寸 ▼▼▼ */
      width: calc(75px * var(--desktop-item-scale, 1));
      height: calc(90px * var(--desktop-item-scale, 1));
      padding: calc(5px * var(--desktop-item-scale, 1));
    }

    .app-icon-img {
      border-radius: 22.5%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: var(--surface-bg);
      box-shadow: none;
      transition: transform 0.2s ease;
      /* ▼▼▼ 新尺寸 ▼▼▼ */
      width: calc(58px * var(--desktop-item-scale, 1));
      height: calc(58px * var(--desktop-item-scale, 1));
      margin-bottom: calc(2px * var(--desktop-item-scale, 1));
      font-size: calc(28px * var(--desktop-item-scale, 1));
    }

    .app-icon-img svg {
      stroke: currentColor;
      /* SVG的线条颜色会继承上面的 color */
    }

    .app-icon span {
      color: white;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      width: 100%;
      /* ▼▼▼ 新尺寸 ▼▼▼ */
      font-size: calc(0.75rem * var(--desktop-item-scale, 1));
    }

    .content {
      padding: 20px;
      overflow-y: auto;
      flex-grow: 1;
      /* <-- 加上这行代码，就是这行！ */
    }

    .form-button {
      width: 100%;
      padding: 12px;
      border: none;
      background-color: var(--primary-color);
      color: white;
      border-radius: 8px;
      font-size: 1.1rem;
      cursor: pointer;
      margin-top: 10px;
    }

    input,
    textarea,
    select {
      width: 100%;
      padding: 10px;
      box-sizing: border-box;
      background-color: rgba(255, 255, 255, 0.8);
      border: 1px solid var(--border-color);
      color: var(--text-color);
      border-radius: 8px;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(138, 180, 228, 0.3);
    }

    .chat-toolbar {
      display: flex;
      padding: 5px 10px;
      border-top: 1px solid var(--border-color);
      background-color: var(--surface-bg);
      /*   backdrop-filter: blur(10px);*/
      flex-shrink: 0;
    }

    /* ▼▼▼ 用下面这段，替换掉你旧的 .toolbar-button 样式 ▼▼▼ */
    .toolbar-button {
      background: none;
      border: none;
      font-size: 1.5rem;
      /* 这个保留，作为SVG尺寸的参考 */
      cursor: pointer;
      padding: 8px;
      /* 稍微增大点击区域 */
      color: var(--text-color-light);
      /* 让它默认是浅灰色 */
      border-radius: 50%;
      /* 让背景有个圆形轮廓 */
      width: 40px;
      height: 40px;
      display: flex;
      /* 使用flex布局让SVG完美居中 */
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s, color 0.2s;
      /* 加上顺滑的过渡效果 */
    }

    .toolbar-button:hover {
      background-color: var(--border-color);
      /* 鼠标悬停时给个背景 */
      color: var(--primary-color);
      /* 图标颜色变为主题色 */
    }

    /* ▲▲▲ 替换到这里为止 ▲▲▲ */


    /* ▼▼▼ 在下面新增这段SVG的专属样式 ▼▼▼ */
    .toolbar-button svg {
      width: 22px;
      /* SVG图标的尺寸 */
      height: 22px;
      stroke-width: 1.8;
      /* 线条粗细，可以微调 */
      stroke: currentColor;
      /* 核心！让SVG的颜色继承按钮的color属性 */
      fill: none;
      /* 确保是线稿风格 */
      pointer-events: none;
      /* 防止SVG本身干扰点击事件 */
    }

    /* ▲▲▲ 新增到这里为止 ▲▲▲ */

    .sticker-panel {
      display: none;
      /* 默认还是藏起来 */
      flex-direction: column;
      /* 哼，给我垂直排好队 */
      height: 220px;
      /* 稍微给管理条一点空间 */
      border-top: 1px solid var(--border-color);
      background-color: var(--surface-bg);
      flex-shrink: 0;
    }

    .sticker-panel.show {
      display: flex;
      /* 看见没，现在是 flex，不是 grid 了！*/
    }

    /* --- 输入区域 --- */
    /* --- 输入区域 --- */
    .chat-input-area {
      padding: 10px 12px calc(env(safe-area-inset-bottom, 0px) + 10px);
      background: var(--surface-bg);
      /*  backdrop-filter: saturate(1.2) blur(10px);*/
      border-top: 1px solid var(--border-color);
      flex-shrink: 0;
    }

    /* 这是我加的新容器，用来实现完美对齐 */
    #chat-input-wrapper {
      display: flex;
      /* Flex大法好，哼 */
      align-items: center;
      border: 1px solid var(--border-color);
      background: rgba(255, 255, 255, 0.9);
      border-radius: 24px;
      padding: 2px 5px;
      transition: border-color .2s, box-shadow .2s;
    }

    #chat-input-wrapper:focus-within {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(138, 180, 228, 0.3);
    }

    #chat-message-input {
      flex-grow: 1;
      /* 让输入框占满剩余空间 */
      border: none;
      background: transparent;
      padding: 9px 12px;
      font-size: .95rem;
      outline: none;
      color: var(--text-color);
    }

    #chat-send-button,
    #chat-get-reply-button {
      height: 38px;
      width: 38px;
      border: 0;
      border-radius: 50%;
      font-size: 1.2rem;
      font-weight: 600;
      color: #fff;
      cursor: pointer;
      transition: transform .1s ease, filter .15s ease;
      flex-shrink: 0;
      /* 防止被挤压 */
      margin-left: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #chat-send-button {
      background: var(--primary-color);
    }

    /* 回复按钮，给个不一样的颜色区分 */
    #chat-get-reply-button {
      background: var(--accent-color);
      font-size: 1.5rem;
      /* 让箭头更清晰 */
    }

    #chat-message-input {
      border: 1px solid var(--border-color);
      background: rgba(255, 255, 255, 0.9);
      border-radius: 20px;
      padding: 11px 16px;
      font-size: .95rem;
      outline: none;
      color: var(--text-color);
      transition: border-color .2s, box-shadow .2s;
    }

    #chat-message-input:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(138, 180, 228, 0.3);
    }

    #chat-send-button,
    #chat-get-reply-button {
      height: 40px;
      padding: 0 18px;
      border: 0;
      border-radius: 20px;
      font-size: .95rem;
      font-weight: 600;
      color: #fff;
      cursor: pointer;
      transition: transform .1s ease, filter .15s ease;
    }

    #chat-send-button {
      background: var(--primary-color);
    }

    #chat-get-reply-button {
      display: flex;
      /* 隐藏旧的回复按钮，样式统一到发送按钮 */
    }


    /* --- 引用样式 --- */
    .quote-preview {
      display: none;
      padding: 8px 12px;
      background-color: rgba(255, 255, 255, 0.5);
      border-left: 3px solid var(--primary-color);
      margin: 0 12px 8px;
      border-radius: 6px;
      position: relative;
    }

    #quote-preview-sender {
      font-weight: 600;
      font-size: 0.85rem;
      color: var(--primary-color);
    }

    #quote-preview-text {
      font-size: 0.9rem;
      color: var(--text-color-light);
    }

    .cancel-quote-btn {
      position: absolute;
      top: 50%;
      right: 10px;
      transform: translateY(-50%);
      background: none;
      border: none;
      font-size: 1.5rem;
      color: #999;
      cursor: pointer;
    }

    .quoted-message-in-bubble {
      background-color: rgba(0, 0, 0, 0.04);
      padding: 8px 10px;
      border-left: 3px solid var(--border-color);
      border-radius: 8px;
      margin-bottom: 6px;
    }

    .quoted-sender {
      font-weight: bold;
      font-size: 0.8rem;
      color: var(--text-color);
    }

    .quoted-content {
      font-size: 0.85rem;
      color: var(--text-color-light);
    }

    /* 这是弹窗的“骨架”，让它能居中浮动在屏幕上 */
    .choice-modal {
      position: fixed;
      inset: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.2s ease, visibility 0.2s ease;
    }

    .choice-modal.show {
      opacity: 1;
      visibility: visible;
    }


    /* --- 弹窗 --- */
    .choice-modal-backdrop {
      background: rgba(0, 0, 0, 0.2);
      /*  backdrop-filter: blur(4px);*/
    }

    .choice-modal-content {
      background: var(--surface-bg);
      /* backdrop-filter: blur(12px); */
      /* <-- 就这么简单，干掉它 */
      border: 1px solid rgba(255, 255, 255, 0.5);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
    }

    .choice-modal-button {
      color: var(--text-color);
      background: rgba(255, 255, 255, 0.5);
    }

    .choice-modal-button:hover {
      background-color: rgba(255, 255, 255, 1);
    }

    .choice-modal-button.cancel {
      color: var(--primary-color);
      background: transparent;
    }

    /* --- Noir's Fix: 让“添加”弹窗从底部滑出，更大气 --- */
    #add-choice-modal .choice-modal-content {
      width: 100%;
      max-width: var(--phone-width);
      /* 确保不会超出手机宽度 */
      margin: 0;
      border-radius: 20px 20px 0 0;
      /* 只留顶部圆角 */
      border-bottom-left-radius: 0;
      /* 覆盖通用样式 */
      border-bottom-right-radius: 0;
      /* 覆盖通用样式 */
      padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
      /* 适配iPhone底部安全区 */
      transform: translateY(100%);
      transition: transform 0.3s ease-out, opacity 0.3s ease-out;
    }

    #add-choice-modal.show .choice-modal-content {
      transform: translateY(0);
    }

    #add-choice-modal {
      align-items: flex-end;
      /* 让弹窗贴着底部 */
      justify-content: center;
    }

    /* 按钮也重新设计一下，让它们竖着排 */
    #add-choice-modal .choice-modal-button {
      width: calc(100% - 40px);
      margin: 5px 20px;
      padding: 14px;
      font-size: 1rem;
      border-radius: 12px;
      text-align: center;
    }

    /* --- Noir's Fix: 修正创建群聊时，成员选择列表的样式 --- */
    .member-selection-item {
      display: flex;
      align-items: center;
      padding: 10px 15px;
      border-bottom: 1px solid var(--border-color);
    }

    .member-selection-item:last-child {
      border-bottom: none;
    }

    /* 关键！就是这里，把头像大小锁死 */
    .member-selection-item .char-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin: 0 15px 0 10px;
      object-fit: cover;
    }

    .member-selection-item .char-name {
      font-weight: 500;
      color: var(--text-color);
    }

    .member-selection-item input[type="checkbox"] {
      width: 20px;
      height: 20px;
      flex-shrink: 0;
      accent-color: var(--primary-color);
      /* 让勾选框颜色也跟主题统一 */
    }

    /* --- Noir's World Book Styles --- */
    #world-book-list-container {
      padding: 10px;
    }

    .world-book-item {
      background-color: var(--card-bg);
      padding: 15px;
      border-radius: 12px;
      margin-bottom: 10px;
      box-shadow: var(--soft-shadow);
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.6);
    }

    .world-book-item-name {
      font-weight: 600;
      color: var(--primary-color);
      margin-bottom: 5px;
    }

    .world-book-item-preview {
      font-size: 0.9rem;
      color: var(--text-color-light);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* --- Noir's Fancy Multi-Select Styles --- */
    .custom-multiselect {
      position: relative;
      user-select: none;
    }

    .select-box {
      border: 1px solid var(--border-color);
      background: rgba(255, 255, 255, 0.8);
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .select-box.expanded .arrow {
      transform: rotate(180deg);
    }


    .checkboxes-container.visible {
      display: block;
    }

    .checkboxes-container label {
      display: block;
      padding: 10px 12px;
    }

    .checkboxes-container label:hover {
      background-color: rgba(138, 180, 228, 0.2);
    }

    .checkboxes-container input[type="checkbox"] {
      margin-right: 8px;
      width: auto;
      /* 覆盖掉全局的 input 样式 */
    }

    /* --- Noir's Clock & Timestamp Styles --- */
    /* --- Noir's Badge & App Dock Styles --- */
    #decorative-badge {
      filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.25));
      transform: rotate(-0deg);
      transition: transform 0.2s ease, filter 0.2s ease;
      user-select: none;
      z-index: 50;
      /* ▼▼▼ 新尺寸 ▼▼▼ */
      width: calc(160px * var(--desktop-item-scale, 1));
      height: calc(160px * var(--desktop-item-scale, 1));
    }


    #decorative-badge:active {

      transform: rotate(-2deg) scale(1.05);
      /* 抓起来的时候，摆正放大一点 */
      filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.3));
    }


    #decorative-badge img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      /* 保留这句，让你的图片能被很好地填充 */
    }

    /*  #a#app-dock-bottom-left,
    #app-dock-top-right {
      
      哼，现在你们只是幽灵了。
      不需要任何样式，你们的孩子（App图标）会自己找到回家的路。
      它们会相对于 #home-screen 定位。
    
    }
*/

    /* --- Noir's Author Mark: Pixel Chicken --- */
    /* 哼，这就是那个吵着要加的小鸡图标 */
    #noir-author-mark {
      position: absolute;
      /* 相对于父容器定位 */
      right: -30px;
      /* 调整它在时钟右边的位置 */
      top: 50%;
      /* 垂直居中 */
      transform: translateY(-50%);
      /* 精确对齐 */
      width: 20px;
      /* 小鸡的尺寸 */
      height: 20px;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="0"><path d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2zM12 4c.69 0 1.25.56 1.25 1.25S12.69 6.5 12 6.5s-1.25-.56-1.25-1.25S11.31 4 12 4zm0 2c-.69 0-1.25.56-1.25 1.25S11.31 8.5 12 8.5s1.25-.56 1.25-1.25S12.69 6 12 6zm-2 2c-.69 0-1.25.56-1.25 1.25S9.31 9.75 10 9.75s1.25-.56 1.25-1.25S10.69 8 10 8zm2 0c-.69 0-1.25.56-1.25 1.25S11.31 9.75 12 9.75s1.25-.56 1.25-1.25S12.69 8 12 8zm2 0c-.69 0-1.25.56-1.25 1.25S13.31 9.75 14 9.75s1.25-.56 1.25-1.25S14.69 8 14 8zM10 10c-.69 0-1.25.56-1.25 1.25S9.31 12.5 10 12.5s1.25-.56 1.25-1.25S10.69 10 10 10zm2 0c-.69 0-1.25.56-1.25 1.25S11.31 12.5 12 12.5s1.25-.56 1.25-1.25S12.69 10 12 10zm2 0c-.69 0-1.25.56-1.25 1.25S13.31 12.5 14 12.5s1.25-.56 1.25-1.25S14.69 10 14 10zM12 12c-.69 0-1.25.56-1.25 1.25S11.31 14.5 12 14.5s1.25-.56 1.25-1.25S12.69 12 12 12zm-2 2c-.69 0-1.25.56-1.25 1.25S9.31 15.75 10 15.75s1.25-.56 1.25-1.25S10.69 14 10 14zm4 0c-.69 0-1.25.56-1.25 1.25S13.31 15.75 14 15.75s1.25-.56 1.25-1.25S14.69 14 14 14zM12 16c-.69 0-1.25.56-1.25 1.25S11.31 18.5 12 18.5s1.25-.56 1.25-1.25S12.69 16 12 16zM6 10c-.69 0-1.25.56-1.25 1.25S5.31 12.5 6 12.5s1.25-.56 1.25-1.25S6.69 10 6 10zm12 0c-.69 0-1.25.56-1.25 1.25S17.31 12.5 18 12.5s1.25-.56 1.25-1.25S18.69 10 18 10zM12 20c-.69 0-1.25.56-1.25 1.25S11.31 22.5 12 22.5s1.25-.56 1.25-1.25S12.69 20 12 20zM6 14c-.69 0-1.25.56-1.25 1.25S5.31 15.75 6 15.75s1.25-.56 1.25-1.25S6.69 14 6 14zm12 0c-.69 0-1.25.56-1.25 1.25S17.31 15.75 18 15.75s1.25-.56 1.25-1.25S18.69 14 18 14z"/></svg>');
      /* 这是SVG小鸡的Data URI，白色像素风格 */
      background-size: contain;
      background-repeat: no-repeat;
      cursor: pointer;
      /* 提示可点击 */
      opacity: 0.6;
      /* 稍微透明一点，不那么突兀 */
      transition: opacity 0.2s ease-in-out;
      /* 鼠标悬停效果 */
      z-index: 100;
      /* 确保它在最上层 */
    }

    #noir-author-mark:hover {
      opacity: 1;
      /* 鼠标悬停时完全显示 */
    }

    /* 调整时钟容器，为小鸡留出空间并方便定位 */
    .home-clock-container {
      position: relative;
      /* 确保小鸡能相对它定位 */
      /* ... (保留你已有的其他时钟样式) ... */
      padding-right: 40px;
      /* 给小鸡留出一些右边距 */
    }

    #home-clock-container {
      color: white;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      text-align: center;
      position: absolute;
      z-index: 50;
      /* ▼▼▼ 新增的缩放指令 ▼▼▼ */
      transform-origin: center top;
      transform: scale(var(--desktop-item-scale, 1));
    }

    #home-time {
      font-size: 80px;
      font-weight: 360;
      /* <--- 我把字重从200加到了300，比原来粗，但又不会笨重，这才是高级感。 */
      letter-spacing: -1px;
      /* <--- 字间距也给你调紧了一点，看起来更整体。 */
    }

    #home-date {
      font-size: 1rem;
      /* <--- 稍微缩小一点，让时间更突出 */
      font-weight: 400;
      margin-top: 8px;
      opacity: 0.8;
      text-transform: uppercase;
      /* <--- 日期我给你换成了全大写，这才有那股‘性冷淡’的味道。 */
      letter-spacing: 1px;
      /* <--- 顺便拉开一点点间距，免得挤在一起。 */
    }

    /* 聊天气泡时间戳的样式 */
    .timestamp {
      font-size: 0.7rem;
      color: var(--text-color-light);
      padding: 0 5px;
      margin-bottom: 3px;
      /* 让它和气泡底部对齐 */
    }

    /* 第一段：这是消息容器的基础样式 */
    .message-container {
      display: flex;
      /* 启用flex布局 */
      flex-direction: column;
      /* 让气泡和时间戳垂直排列 */
      margin-bottom: 10px;
      max-width: 90%;
      /* 限制整个容器的最大宽度 */
    }

    /* 第二段：这是根据发言者进行左右对齐的样式 */
    .message-container.user {
      align-self: flex-end;
      /* 让用户方整个容器靠右 */
      align-items: flex-end;
      /* 让容器内部的元素（气泡、时间戳）也靠右 */
    }

    .message-container.ai {
      align-self: flex-start;
      /* 让AI方整个容器靠左 */
      align-items: flex-start;
      /* 让容器内部的元素（气泡、时间戳）也靠左 */
    }

   #chat-messages {
  flex-grow: 1;
  padding: 5px 15px;
  overflow-y: auto;
  overflow-x: hidden;
  display: flex;
  flex-direction: column;
  
  /* 核心修改：锁定宽度，防止滚动条挤占空间 */
  width: 100%; 
  box-sizing: border-box;
  
  /* 预留滚动条空间 */
  scrollbar-gutter: stable; 
  
  /* 增加底部内边距，防止最后一条消息贴底 */
  padding-bottom: 20px; 
}

    .message-bubble-row {
      display: flex;
      align-items: flex-end;
      width: 100%;
      gap: 10px;
      /* 头像和气泡之间，永远保持10px的距离 */
    }

    .message-container.user .message-bubble-row {
      justify-content: flex-end;
    }

    .message-container.ai .message-bubble-row {
      justify-content: flex-start;
    }



    /* 这是给表情选择面板里，每一个小表情图片用的样式 */
    .sticker-item {
      width: 100%;
      /* 自动填满网格单元格的宽度 */
      aspect-ratio: 1 / 1;
      /* 保持1:1的宽高比，让它变成正方形 */
      object-fit: cover;
      /* 图片会被裁剪以适应正方形，不变形 */
      border-radius: 8px;
      /* 加个小圆角 */
      cursor: pointer;
      transition: transform 0.15s ease;
    }

    .sticker-item:hover {
      transform: scale(1.1);
      /* 鼠标放上去时稍微放大，增加交互感 */
    }

    /* --- Noir's Offline Scene Styles --- */
    #meeting-scene-view {
      flex-grow: 1;
      /* <-- 核心：让它占满所有可用空间 */
      overflow-y: auto;
      /* <-- 核心：内容多了就内部滚动 */
      padding: 20px;
      font-family: 'Georgia', 'Times New Roman', 'KaiTi', 'STSong', serif;
      background-size: cover;
      background-position: center;
      color: white;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.7);
    }

    #chat-view-pane.offline-mode #offline-scene-view {
      display: block;
      /* 在线下模式时显示 */
    }

    #chat-view-pane.offline-mode #chat-messages {
      display: none;
      /* 在线下模式时隐藏气泡聊天 */
    }

    #offline-scene-view p {
      margin: 0 0 1em 0;
      line-height: 1.7;
      white-space: pre-wrap;
      /* 保留换行和空格，这对于小说格式至关重要 */
      font-size: 1rem;
    }

    /* --- Noir's Offline Scene Dialogue Box Style --- */
    #offline-scene-view p {
      margin: 0 0 1em 0;
      line-height: 1.7;
      white-space: pre-wrap;
      font-size: 1rem;

      /* <--- Noir's Addition: 为对话框添加半透明背景和内边距 */
      background-color: rgba(0, 0, 0, 0.4);
      /* 半透明黑色背景 */
      padding: 15px 20px;
      /* 内边距，让文字与边框有距离 */
      border-radius: 8px;
      /* 圆角边框，更柔和 */
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      /* 轻轻的阴影，增加立体感 */
    }

    #offline-scene-view .narrator {
      color: #d1d5db;
      /* 旁白用浅灰色 */
      font-style: italic;
    }

    #offline-scene-view .speaker-user {
      color: #a7c7e7;
      /* 用户的发言用一种柔和的蓝色 */
      font-weight: bold;
    }

    #offline-scene-view .speaker-ai {
      color: #f2b7c6;
      /* AI的发言用柔和的粉色，形成对比 */
      font-weight: bold;
    }

    /* --- Noir's Typing Indicator Style --- */
    /* --- Noir's "Sticky" Typing Indicator --- */
    /* 哼，用这个替换掉你旧的 .typing-indicator 样式 */
    /* --- Noir's Final Protocol: Spatial Displacement --- */
    /* 哼，这次再敢乱跑，我就把你格式化了。*/
    /* --- Noir's Final Protocol: Spatial Readjustment (As Commanded) --- */
    /* 哼，这次再敢说丑，我就把你格式化了。*/
    .typing-indicator {
      position: absolute;
      /* ▼▼▼ 核心手术，看好了 ▼▼▼ */
      bottom: 117px;
      /* 这是我算好的精确高度，刚好在你的工具栏和输入框上面 */
      left: 15px;
      /* 先把你那个碍事的左定位给废了 */
      right: auto;
      /* 然后把它焊死在右边，距离边缘15px */
      margin-left: 0;
      /* 再把你那个多余的左边距也扔掉 */
      /* ▲▲▲ 手术结束 ▲▲▲ */

      /* 下面这些是“整容”，让它看起来还像个气泡 */

    }

    #meeting-scene-view .typing-indicator,
    #offline-scene-view .typing-indicator {
      position: fixed;
      /* 哼，这就是那根钉子，把它焊死在屏幕上 */
      bottom: 85px;
      /* 距离屏幕底部85px，刚好在你的输入框上面 */
      right: 30px;
      /* 距离右边30px */
      z-index: 100;
      /* 确保它浮在所有对话上面 */

      /* 下面这些是给它做的“整容”，让它看起来像个高级卡片 */
      background: rgba(0, 0, 0, 0.45);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      border-radius: 12px;
      padding: 10px 15px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: #f0f2f5;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      margin: 0;
      /* 把它以前那些乱七八糟的边距都给我扔了 */
    }


    /* --- Noir's Final Alignment Fix --- */
    .message-container.ai .timestamp {
      /* 哼，给你加上头像宽度(40px) + 左右边距(10px)的距离 */
      margin-left: 50px;
    }

    .message-container.user .timestamp {
      /* 另一边也是一样，真是麻烦死了 */
      margin-right: 50px;
    }

    /* --- Noir's Music Feed & Player Styles --- */
    #music-feed-container {
      padding: 16px 16px 80px;
      contain: content;
      overflow-y: auto;
      height: 100%;
    }

    /* 动态页：默认白底；如设置 --feed-bg-image 则显示独立壁纸 + 轻动画叠层 */
    #music-screen {
      background-color: #fafafa;
      background-image: var(--feed-bg-image);
      background-size: cover;
      background-position: center;
      contain: paint;
      position: relative;
    }

    /* 轻动画彩雾叠层：仅图层，不拦点击 */
    #music-screen::before {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background-image:
        conic-gradient(from var(--feed-overlay-rotate),
          hsla(var(--primary-hue) 70% 60% / var(--feed-overlay-opacity)) 0%,
          transparent 20%,
          hsla(var(--primary-hue) 70% 60% / var(--feed-overlay-opacity)) 40%,
          transparent 60%,
          hsla(var(--primary-hue) 70% 60% / var(--feed-overlay-opacity)) 80%,
          transparent 100%);
      transform: translateZ(0);
      animation: feed-pan var(--feed-overlay-speed) linear infinite;
    }

    /* 超慢速平移旋转，基本不占 GPU */
    @keyframes feed-pan {
      0% {
        transform: translate3d(0, 0, 0) rotate(0deg) scale(1.02);
      }

      50% {
        transform: translate3d(1.2%, 0.8%, 0) rotate(2deg) scale(1.02);
      }

      100% {
        transform: translate3d(0, 0, 0) rotate(0deg) scale(1.02);
      }
    }

    /* 系统降低动画偏好时，自动停掉动画 */
    @media (prefers-reduced-motion: reduce) {
      #music-screen::before {
        animation: none;
      }
    }


    .music-post {
      background-color: hsla(var(--primary-hue), calc(var(--primary-saturation) / 1.5), calc(var(--primary-lightness) + 18%), var(--feed-card-alpha));
      border-radius: 16px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.7);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .music-post:hover {
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
      transform: translateY(-2px);
    }

    .music-post-header {
      display: flex;
      align-items: center;
      padding: 16px 18px 14px;
    }

    .music-post-header .char-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin-right: 12px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    .music-post-header .char-name {
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--text-color);
      letter-spacing: -0.01em;
    }

    .music-post-thought {
      padding: 0 18px 18px;
      font-size: 0.94rem;
      line-height: 1.65;
      white-space: pre-wrap;
      color: var(--text-color);
      letter-spacing: 0.01em;
    }

    .music-post-song-card {
      display: flex;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.02);
      padding: 14px 18px;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      margin: 0 12px 12px;
      border-radius: 10px;
    }

    .music-post-song-card:hover {
      background-color: rgba(0, 0, 0, 0.05);
      transform: scale(1.01);
    }

    .music-post-song-card img {
      width: 54px;
      height: 54px;
      border-radius: 8px;
      margin-right: 14px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    .music-post-song-info {
      flex-grow: 1;
      min-width: 0;
    }

    .music-post-song-info .title {
      font-weight: 600;
      font-size: 0.94rem;
      color: var(--text-color);
      letter-spacing: -0.01em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .music-post-song-info .artist {
      font-size: 0.82rem;
      color: var(--text-color-light);
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .music-post-play-icon {
      font-size: 1.6rem;
      color: var(--primary-color);
      opacity: 0.8;
      transition: opacity 0.2s ease;
      flex-shrink: 0;
    }

    .music-post-song-card:hover .music-post-play-icon {
      opacity: 1;
    }

    #music-player-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 70px;
      background: hsla(var(--primary-hue), calc(var(--primary-saturation) / 2), calc(var(--primary-lightness) + 17%), 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-top: 1px solid rgba(255, 255, 255, 0.4);
      display: flex;
      align-items: center;
      padding: 0 16px;
      transform: translateY(100%);
      transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 -2px 12px rgba(0, 0, 0, 0.05);
    }

    #music-player-bar:not(.hidden) {
      transform: translateY(0);
    }

    #music-player-bar.hidden {
      display: none;
    }


    #player-cover {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      margin-right: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
    }

    #player-info {
      flex-grow: 1;
      overflow: hidden;
      min-width: 0;
    }

    #player-title,
    #player-artist {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #player-title {
      font-weight: 600;
      font-size: 0.92rem;
      letter-spacing: -0.01em;
    }

    #player-artist {
      font-size: 0.78rem;
      margin-top: 2px;
      color: var(--text-color-light);
    }

    #player-controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    #player-controls button {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(0, 0, 0, 0.08);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      font-size: 1.1rem;
      cursor: pointer;
      color: var(--text-color);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #player-controls button:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: scale(1.05);
    }

    #player-controls button:active {
      transform: scale(0.95);
    }

    /* --- Noir's Music Share Bubble Styles --- */
    .message.music {
      background-color: transparent;
      padding: 0;
      box-shadow: none;
      max-width: 260px;
    }

    .music-share-card {
      display: flex;
      align-items: center;
      background-color: var(--card-bg);
      border-radius: 14px;
      padding: 14px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.7);
    }

    .music-share-card:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      transform: translateY(-1px);
    }

    .message-container.user .music-share-card {
      background-color: var(--accent-color);
      border: 1px solid rgba(255, 255, 255, 0.4);
    }

    .message-container.user .music-share-card .title,
    .message-container.user .music-share-card .artist,
    .message-container.user .music-share-card .play-icon {
      color: white;
    }


    .music-share-cover {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      margin-right: 12px;
      flex-shrink: 0;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    .music-share-info {
      flex-grow: 1;
      overflow: hidden;
      min-width: 0;
    }

    .music-share-info .title {
      font-weight: 600;
      font-size: 0.92rem;
      color: var(--text-color);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      letter-spacing: -0.01em;
    }

    .music-share-info .artist {
      font-size: 0.8rem;
      color: var(--text-color-light);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-top: 2px;
    }

    .music-share-play-icon {
      font-size: 1.5rem;
      color: var(--primary-color);
      margin-left: 12px;
      opacity: 0.8;
      transition: opacity 0.2s ease;
      flex-shrink: 0;
    }

    .music-share-card:hover .music-share-play-icon {
      opacity: 1;
    }

    #music-screen {
      position: relative;
      /* 就是这句，告诉里面的绝对定位元素，以我为界！ */
    }

    /* --- Enhanced Feed Header Styles --- */
    .feed-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px !important;
      gap: 12px;
    }

    .feed-actions {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .icon-button {
      min-width: 36px !important;
      height: 36px;
      padding: 0 !important;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.03);
      border: 1px solid rgba(0, 0, 0, 0.05);
      font-size: 1.1rem;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .icon-button:hover {
      background: rgba(0, 0, 0, 0.08);
      transform: scale(1.05);
    }

    .icon-button:active {
      transform: scale(0.95);
    }

    .icon-button.danger {
      color: #dc3545;
    }

    .icon-button.danger:hover {
      background: rgba(220, 53, 69, 0.1);
      border-color: rgba(220, 53, 69, 0.2);
    }

    .icon-button span {
      font-size: 1.15rem;
      display: block;
      line-height: 1;
    }

    /* --- Enhanced User Post Area Styles --- */
    #user-post-area {
      transition: all 0.3s ease !important;
    }

    #user-post-input-container {
      display: flex;
      gap: 12px;
    }

    #user-post-avatar {
      width: 38px !important;
      height: 38px !important;
      border-radius: 50%;
      flex-shrink: 0;
      margin-top: 3px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    }

    #user-post-main-area {
      flex-grow: 1;
    }

    #user-post-textarea {
      width: 100%;
      border: none;
      background: transparent;
      outline: none;
      resize: vertical;
      font-size: 0.94rem;
      color: var(--text-color);
      line-height: 1.5;
      font-family: inherit;
    }

    #user-post-textarea::placeholder {
      color: var(--text-color-light);
      opacity: 0.6;
    }

    #user-post-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
    }

    .user-post-actions {
      display: flex;
      gap: 6px;
    }

    .toolbar-button {
      background: none !important;
      border: none !important;
      font-size: 1.4rem;
      cursor: pointer;
      padding: 6px;
      border-radius: 8px;
      transition: all 0.2s ease;
      opacity: 0.7;
    }

    .toolbar-button:hover {
      opacity: 1;
      background: rgba(0, 0, 0, 0.04) !important;
    }

    #user-send-post-button {
      padding: 8px 20px !important;
      border-radius: 18px !important;
      border: none;
      background: var(--accent-color) !important;
      color: white !important;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    #user-send-post-button:hover {
      background: hsl(var(--primary-hue), calc(var(--primary-saturation) * 1.3), calc(var(--primary-lightness) - 25%)) !important;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
      transform: translateY(-1px);
    }

    #user-send-post-button:active {
      transform: translateY(0);
    }

    #user-post-attachment-preview {
      display: flex;
      gap: 10px;
      margin-top: 12px;
    }

    .preview-item {
      position: relative;
      max-width: 100px;
    }

    .preview-item img {
      width: 100%;
      border-radius: 10px;
      object-fit: cover;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    .preview-item .music-preview-card {
      display: flex;
      align-items: center;
      padding: 10px;
      background: rgba(0, 0, 0, 0.03);
      border-radius: 10px;
      width: 200px;
      border: 1px solid rgba(0, 0, 0, 0.05);
    }

    .preview-item .music-preview-card img {
      width: 32px;
      height: 32px;
      margin-right: 10px;
      border-radius: 6px;
    }

    .preview-item .music-preview-card .info {
      font-size: 0.8rem;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .remove-attachment-btn {
      position: absolute;
      top: -6px;
      right: -6px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: 2px solid white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .remove-attachment-btn:hover {
      background: rgba(220, 53, 69, 0.9);
      transform: scale(1.1);
    }

    /* --- Noir's Fancy Music Widget Styles --- */
    /* --- Noir's Music System Refactor --- */

    #music-widget:not(.hidden) {
      transform: translateY(0);
      /* 不隐藏时，滑上来 */
    }

    #music-widget.hidden {
      transform: translateY(150%);
      /* 隐藏时，滑下去 */
    }

    .widget-vinyl {
      width: 80px;
      height: 80px;
      background-color: #111;
      border-radius: 50%;
      position: relative;
      left: 20px;
      /* 向右移动，让卡片能盖住它 */
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      background-image:
        radial-gradient(circle at center, #555 10%, transparent 11%),
        radial-gradient(circle at center, #fff 12%, transparent 13%);
      animation: spin 8s linear infinite;
      z-index: 1;
    }

    @keyframes spin {
      from {
        transform: translate(-50%, -50%) rotate(0deg);
        /* <-- 看见没，把咒语合并了 */
      }

      to {
        transform: translate(-50%, -50%) rotate(360deg);
        /* <-- 这里也是 */
      }
    }

    .widget-card {
      width: 240px;
      padding: 15px;
      background-color: var(--card-bg);
      /*  backdrop-filter: blur(10px);*/
      border-radius: 12px;
      box-shadow: var(--soft-shadow);
      border: 1px solid rgba(255, 255, 255, 0.7);
      display: flex;
      align-items: center;
      z-index: 2;
      /* 让卡片在唱片上方 */
    }

    .widget-card img {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      margin-right: 12px;
      flex-shrink: 0;
    }

    .widget-info {
      flex-grow: 1;
      overflow: hidden;
    }

    #widget-title,
    #widget-artist {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #widget-title {
      font-weight: 600;
      color: var(--text-color);
      font-size: 0.9rem;
    }

    #widget-artist {
      font-size: 0.8rem;
      color: var(--text-color-light);
    }

    #widget-play-icon {
      font-size: 1.2rem;
      color: var(--primary-color);
      margin-left: 10px;
    }

    #card-widget {
      border-radius: 18px;
      background-color: rgba(255, 255, 255, 0.5);
      filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.2));
      transform: rotate(0deg);
      transition: transform 0.2s ease, filter 0.2s ease;
      user-select: none;
      z-index: 51;
      overflow: hidden;
      /* ▼▼▼ 新尺寸 ▼▼▼ */
      width: calc(335px * var(--desktop-item-scale, 1));
      height: calc(170px * var(--desktop-item-scale, 1));
    }


    /* --- End of Protocol --- */

    /* --- Noir's "Center Alignment" Protocol --- */

    /* --- End of Protocol --- */

    #card-widget:active {

      transform: rotate(1deg) scale(1.05);
      filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.3));
    }

    #card-widget img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* --- Noir's Ultimate Scrollbar Hider --- */
    /* For Webkit browsers like Chrome, Safari */
    ::-webkit-scrollbar {
      display: none;
    }

    /* For Firefox */
    * {
      scrollbar-width: none;
    }

    /* --- Noir's Fix: 美化消息操作弹窗 --- */
    #message-action-modal {
      align-items: flex-end;
      /* 让弹窗贴着底部 */
    }

    #message-action-modal .choice-modal-content {
      width: 100%;
      max-width: var(--phone-width);
      margin: 0;
      border-radius: 20px 20px 0 0;
      padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
      transform: translateY(100%);
      transition: transform 0.3s ease-out, opacity 0.3s ease-out;
    }

    #message-action-modal.show .choice-modal-content {
      transform: translateY(0);
    }

    #message-action-modal .choice-modal-button {
      width: calc(100% - 40px);
      margin: 5px 20px;
      padding: 14px;
      font-size: 1rem;
      border-radius: 12px;
      text-align: center;
    }

    /* --- End of Fix --- */
    /* --- Noir's Fix: Fancy User Post Area --- */
    #user-post-input-container {
      display: flex;
      gap: 10px;
    }

    #user-post-avatar {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      flex-shrink: 0;
      margin-top: 5px;
    }

    #user-post-main-area {
      flex-grow: 1;
    }

    #user-post-textarea {
      width: 100%;
      border: none;
      background: transparent;
      outline: none;
      resize: vertical;
      font-size: 1rem;
      color: var(--text-color);
    }

    #user-post-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 8px;
    }

    /* ... 你已有的 #user-post-toolbar 样式 ... */

    /* ▼▼▼ Noir's Command: 哼，给我站成一排！ ▼▼▼ */
    #user-post-actions {
      display: flex;
      /* <-- 这就是圣旨本身 */
      gap: 8px;
      /* <-- 这是我赏赐的间距，让它们别挤在一起 */
    }

    /* ▲▲▲ Command End ▲▲▲ */

    #user-send-post-button {
      padding: 6px 18px;
      border-radius: 16px;
      border: none;
      background: var(--primary-color);
      color: white;
      cursor: pointer;
      font-weight: 600;
    }

    /* 这是附件预览的样式 */
    #user-post-attachment-preview {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .preview-item {
      position: relative;
      max-width: 100px;
    }

    .preview-item img {
      width: 100%;
      border-radius: 8px;
      object-fit: cover;
    }

    .preview-item .music-preview-card {
      display: flex;
      align-items: center;
      padding: 8px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      width: 200px;
      /* 给音乐卡片宽一点 */
    }

    .preview-item .music-preview-card img {
      width: 30px;
      height: 30px;
      margin-right: 8px;
    }

    .preview-item .music-preview-card .info {
      font-size: 0.8rem;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .remove-attachment-btn {
      position: absolute;
      top: -5px;
      right: -5px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    /* --- Noir's Fix: Post Image Display Style --- */
    .post-image-container {
      padding: 0 15px 15px;
      /* 图片和文字之间留点空隙 */
    }

    .post-image {
      max-width: 100%;
      /* 图片最宽不能超过帖子宽度 */
      max-height: 400px;
      /* 最高400像素，防止长图刷屏 */
      border-radius: 8px;
      /* 加个小圆角，好看 */
      object-fit: cover;
      /* 保持图片比例，不变形 */
      display: block;
      /* 解决图片底部多余的空隙问题 */
    }

    /* --- Noir's Refactor: New Post Interaction Styles --- */
    .post-interactions {
      padding: 10px 15px;
      background-color: rgba(0, 0, 0, 0.02);
      border-top: 1px solid var(--border-color);
      font-size: 0.9rem;
    }

    .post-likes {
      color: var(--primary-color);
      margin-bottom: 8px;
    }

    .post-comments-container {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .post-comment {
      color: var(--text-color);
    }

    .post-comment .comment-author {
      font-weight: 600;
      color: var(--text-color);
    }

    .post-timestamp {
      font-size: 0.75rem;
      color: var(--text-color-light);
      padding: 0 15px 10px;
    }



    /* 覆盖：基础气泡体 */
    /* 覆盖：基础气泡体 */
    .message {
      border-radius: var(--bubble-radius);
      line-height: 1.55;
      padding: 10px 14px;
      box-shadow:
        0 1px 0 rgba(0, 0, 0, .03),
        0 4px 10px rgba(0, 0, 0, .06);
      /* 比你原先更浅，省功耗 */
      border: 1px solid var(--bubble-outline);
      backdrop-filter: none !important;
      /* 绝不启用重滤镜 */
      will-change: auto;
      /* 不抢 GPU 配额 */

      /* --- Noir's Fix: 就是下面这两行，哼 --- */
      user-select: none;
      /* 标准浏览器给我听话，不许选中 */
      -webkit-user-select: none;
      /* 那些老古董浏览器也一样 */
    }

    /* 你的气泡（右侧） */
    .message.user {
      color: #fff;
      background: var(--bubble-user-bg);
      border-bottom-right-radius: 6px;
      /* 微“角”保留你原味 */
      text-shadow: 0 1px 0 rgba(0, 0, 0, .12);
      /* 细腻但很轻 */
    }

    /* TA 的气泡（左侧） */
    .message.ai {
      color: var(--text-color);
      background: var(--bubble-ai-bg);
      border-bottom-left-radius: 6px;
    }

    /* 细节：图片/贴纸消息不套背景 */
    /* 细节：图片/贴纸/音乐卡片消息不套背景 */
    .message.user.sticker,
    .message.ai.sticker,
    .message.user.image,
    .message.ai.image,
    .message.user.music,
    /* <-- 哼，加上这两行 */
    .message.ai.music,
    .message.html-module {
      background: transparent;
      border: 0;
      box-shadow: none;
      padding: 0;
    }

    /* 轻触态：不使用阴影动画，避免合成层抖动 */
    .message:active {
      transform: scale(.996);
    }

    /* 引用块在气泡内的融合感 */
    .quoted-message-in-bubble {
      background: rgba(0, 0, 0, .045);
      border: 1px solid color-mix(in hsl, var(--primary-color) 18%, transparent);
      border-radius: 10px;
    }


    /* --- Noir's Transfer Bubble Style --- */
    .message.transfer {
      background: #F79232;
      /* 哼，一个温暖又醒目的橙色 */
      color: white;
      padding: 12px 16px;
      border-radius: 12px;
      width: 220px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    }

    /* 我还给左右两边做了区分，真是为你操碎了心 */
    .message-container.ai .message.transfer {
      background: #f9fafb;
      /* AI发来的转账用白色，更清爽 */
      color: #333;
      border: 1px solid #e5e7eb;
    }

    .transfer-content {
      display: flex;
      flex-direction: column;
    }

    .transfer-title {
      font-weight: 600;
      font-size: 1rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.5);
      padding-bottom: 8px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
    }

    .message-container.ai .transfer-title {
      border-bottom-color: rgba(0, 0, 0, 0.1);
    }

    .transfer-amount {
      font-size: 1.8rem;
      font-weight: bold;
    }

    .transfer-recipient {
      font-size: 0.8rem;
      opacity: 0.9;
      margin-top: 4px;
    }

    /* --- End of Refactor --- */



    /* --- Noir's Snap Guide Styles --- */
    .snap-guide {
      position: absolute;
      background-color: rgba(255, 105, 180, 0.85);
      /* 哼，一个足够醒目的颜色 */
      display: none;
      z-index: 999;
      box-shadow: 0 0 5px rgba(255, 105, 180, 0.7);
    }

    #snap-guide-v {
      width: 1px;
    }

    #snap-guide-h {
      height: 1px;
    }

    /* --- Noir's Galgame UI Beautification --- */
    /* Top-left Date & Time Widget */
    #galgame-overlay-ui {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border-radius: 12px;
      padding: 8px 15px;
      color: white;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      z-index: 10;
      border: 1px solid rgba(255, 255, 255, 0.2);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    #galgame-time {
      font-size: 1.2rem;
      font-weight: 600;
      text-align: center;
    }

    #galgame-date {
      font-size: 0.75rem;
      opacity: 0.8;
      text-align: center;
    }

    /* Main Text Box */
    /* Main Text Box */
    #galgame-textbox-container {
      background: linear-gradient(0deg, rgba(25, 28, 38, 0.85) 0%, rgba(45, 50, 68, 0.7) 100%);
      backdrop-filter: blur(10px) saturate(1.2);
      -webkit-backdrop-filter: blur(10px) saturate(1.2);
      border-top: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 16px;
      box-shadow: 0 -5px 25px rgba(0, 0, 0, 0.2);
      bottom: 85px;
      /* <-- 就是这里，往上抬了，满意了吗？ */
      left: 15px;
      right: 15px;
      padding: 12px 18px;
    }

    /* Speaker Name Tag */
    #galgame-speaker {
      background: linear-gradient(90deg, var(--primary-color) 0%, hsl(var(--primary-hue), var(--primary-saturation), calc(var(--primary-lightness) - 10%)) 100%);
      color: white;
      padding: 4px 12px;
      border-radius: 8px;
      display: inline-block;
      font-size: 0.95rem;
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
      margin-bottom: 12px;
    }

    /* Dialogue Text */
    #galgame-text {
      font-size: 1rem;
      line-height: 1.7;
      color: #f0f2f5;
    }

    /* User Input Area Container*/
    #meeting-view-screen .chat-input-area {
      background: transparent;
      border-top: none;
      padding: 0 15px 20px 15px;
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 20;
    }

    /* User Input Wrapper */
    #chat-input-wrapper-meeting {
      display: flex;
      align-items: center;
      background: linear-gradient(0deg, rgba(25, 28, 38, 0.9) 0%, rgba(45, 50, 68, 0.75) 100%);
      backdrop-filter: blur(10px) saturate(1.2);
      -webkit-backdrop-filter: blur(10px) saturate(1.2);
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 16px;
      padding: 5px 8px 5px 15px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.25);
    }

    #meeting-message-input {
      color: #f0f2f5;
    }

    #meeting-message-input::placeholder {
      color: rgba(240, 242, 245, 0.5);
      font-style: italic;
    }

    /* Send Button */
    #meeting-send-button {
      height: 40px;
      width: 40px;
      border-radius: 50%;
      font-size: 1.5rem;
      font-weight: 300;
      color: #fff;
      transition: all .2s ease;
      margin-left: 8px;
      background: var(--primary-color);
      box-shadow: 0 2px 5px hsla(var(--primary-hue), 50%, 50%, 0.4);
    }

    #meeting-send-button:hover {
      filter: brightness(1.1);
      transform: scale(1.05);
    }


    /* --- End of Beautification --- */
    /* --- Enhanced Diary Beautification v2 --- */
    #diary-entries-container {
      background: linear-gradient(to bottom, #fdfcf9 0%, #faf8f3 100%);
      padding: 30px 20px;
      line-height: 1.9;
      box-shadow: 
        inset 0 0 20px rgba(0, 0, 0, 0.03),
        0 2px 8px rgba(0, 0, 0, 0.05);
      position: relative;
    }

    #diary-entries-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: 
        repeating-linear-gradient(
          transparent,
          transparent 31px,
          rgba(220, 210, 190, 0.15) 31px,
          rgba(220, 210, 190, 0.15) 32px
        );
      pointer-events: none;
      opacity: 0.5;
    }

    .diary-entry {
      margin-bottom: 3em;
      position: relative;
      padding: 18px 20px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      transition: all 0.3s ease;
      border-left: 3px solid transparent;
    }

    .diary-entry:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      transform: translateX(2px);
    }

    .diary-entry.user {
      text-align: right;
      border-left-color: #7BA7D8;
      background: linear-gradient(135deg, rgba(123, 167, 216, 0.08) 0%, rgba(255, 255, 255, 0.6) 100%);
    }

    .diary-entry.ai {
      text-align: left;
      border-left-color: #D4A574;
      background: linear-gradient(135deg, rgba(212, 165, 116, 0.08) 0%, rgba(255, 255, 255, 0.6) 100%);
    }

    .diary-author {
      font-weight: 600;
      font-size: 1.05rem;
      margin-bottom: 4px;
      display: inline-block;
      padding: 2px 0;
    }

    .diary-entry.user .diary-author {
      color: #2874A6;
    }

    .diary-entry.ai .diary-author {
      color: #A66E3A;
    }

    .diary-timestamp {
      font-size: 0.75rem;
      color: #95876d;
      margin-bottom: 12px;
      font-family: 'Courier New', monospace;
      opacity: 0.8;
      letter-spacing: 0.3px;
    }

    .diary-content {
      white-space: pre-wrap;
      font-size: 0.96rem;
      line-height: 1.75;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', sans-serif;
    }

    .diary-entry.user .diary-content {
      color: #1a5c8e;
    }

    .diary-entry.ai .diary-content {
      color: #4a443b;
    }

    .diary-entry:last-child {
      margin-bottom: 1em;
    }

    /* --- End of Diary Beautification --- */
    /* --- Noir's Page-Turning Magic --- */
    #diary-entries-container {
      perspective: 1500px;
      /* 为3D效果设置视距 */
      position: relative;
      overflow: hidden;
    }

    .diary-page {
      position: absolute;
      inset: 0;
      padding: 25px 20px;
      background-color: #fdfaf2;
      transform-style: preserve-3d;
      backface-visibility: hidden;
      transition: transform 0.7s cubic-bezier(0.65, 0, 0.35, 1);
      display: none;
      /* 默认所有页面都藏起来 */
      flex-direction: column;
      gap: 2.5em;
      /* 页内日记的间距 */
      overflow-y: auto;
      /* 如果一页内容太多，允许滚动 */
    }

    .diary-page.is-visible {
      display: flex;
      /* 只有当前页显示 */
      transform: rotateY(0deg);
      z-index: 2;
    }

    /* 翻到下一页时，当前页向左翻出 */
    .diary-page.is-exiting-left {
      display: flex;
      transform: rotateY(-180deg);
      z-index: 1;
    }

    /* 翻到下一页时，新页面从右边翻入 */
    .diary-page.is-entering-from-right {
      display: flex;
      transform: rotateY(180deg);
      z-index: 2;
    }

    /* 翻到上一页时，当前页向右翻出 */
    .diary-page.is-exiting-right {
      display: flex;
      transform: rotateY(180deg);
      z-index: 1;
    }

    /* 翻到上一页时，新页面从左边翻入 */
    .diary-page.is-entering-from-left {
      display: flex;
      transform: rotateY(-180deg);
      z-index: 2;
    }


    #diary-navigation {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      padding: 0 10px;
      box-sizing: border-box;
    }

    #diary-navigation button {
      background: transparent;
      border: 1px solid var(--border-color);
      color: var(--primary-color);
      padding: 8px 16px;
      border-radius: 18px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    #diary-navigation button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    #diary-page-indicator {
      font-size: 0.9rem;
      color: var(--text-color-light);
      font-family: 'Courier New', monospace;
    }

    /* --- End of Magic --- */
    /* --- Noir's Universal Anti-Squash Protocol --- */
    /* 哼，就是下面这几条，给你那些被压扁的头像整整容 */

    /* 动态发布区的用户头像 */
    #user-post-avatar {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      flex-shrink: 0;
      margin-top: 5px;
      object-fit: cover;
      /* <-- 加上这句，它就不敢扁了 */
    }

    /* 好友圈动态里的角色头像 */
    .music-post-header .char-avatar {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      margin-right: 10px;
      object-fit: cover;
      /* <-- 还有这句，一个都别想跑 */
    }

    /* 顺便把所有叫 .char-avatar 的都统一一下，免得以后还有问题 */
    .char-avatar {
      object-fit: cover;
      /* ▼▼▼ 哼，加上这三句圣旨，给我立正站好！▼▼▼ */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* --- Noir's Music Library Styles --- */
    #music-library-container {
      padding: 10px;
    }

    .music-library-item {
      display: flex;
      align-items: center;
      padding: 12px;
      margin-bottom: 10px;
      background-color: var(--card-bg);
      border-radius: 12px;
      box-shadow: var(--soft-shadow);
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .music-library-item:hover {
      transform: translateY(-2px);
    }

    .music-library-item-cover {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      margin-right: 15px;
      object-fit: cover;
      flex-shrink: 0;
    }

    .music-library-item-info {
      flex-grow: 1;
      overflow: hidden;
    }

    .music-library-item-title {
      font-weight: 600;
      color: var(--text-color);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .music-library-item-artist {
      font-size: 0.9rem;
      color: var(--text-color-light);
    }

    /* --- Noir's "Time Memorandum" Styles --- */
    /* 哼，这才叫设计。*/

    /* 1. Home Screen Widget */
    #calendar-widget-main {
      width: 90%;
      height: 170px;
      /* 和你的卡片差不多高 */
      background: var(--surface-bg);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 22px;
      border: 1px solid hsla(var(--primary-hue), calc(var(--primary-saturation) / 2), calc(var(--primary-lightness) + 15%), 0.5);
      box-shadow: var(--soft-shadow);
      padding: 20px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: var(--text-color);
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    #calendar-widget-main:active {
      transform: scale(0.98) translateX(-50%);
    }

    #countdown-title {
      font-size: 1rem;
      font-weight: 500;
      opacity: 0.8;
    }

    #countdown-timer {
      font-size: 4rem;
      font-weight: 300;
      line-height: 1.2;
      color: var(--accent-color);
      display: flex;
      align-items: baseline;
    }

    #countdown-timer .unit {
      font-size: 1rem;
      font-weight: 500;
      margin-left: 8px;
      color: var(--text-color-light);
    }

    /* 2. Full Calendar Screen */
    #calendar-screen {
      justify-content: flex-start;
    }

    #calendar-view-container {
      padding: 10px 15px;
      flex-shrink: 0;
      border-bottom: 1px solid var(--border-color);
    }

    .calendar-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .calendar-nav button {
      background: none;
      border: 1px solid var(--border-color);
      color: var(--text-color);
      padding: 6px 12px;
      border-radius: 16px;
      cursor: pointer;
    }

    .calendar-weekdays,
    #calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      text-align: center;
    }

    .calendar-weekdays {
      font-size: 0.8rem;
      color: var(--text-color-light);
      margin-bottom: 5px;
    }

    #calendar-grid .calendar-day {
      padding: 5px 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1 / 1;
      cursor: pointer;
      position: relative;
    }

    .calendar-day .day-number {
      z-index: 1;
    }

    .calendar-day.other-month .day-number {
      opacity: 0.3;
    }

    .calendar-day.is-today .day-number {
      color: var(--accent-color);
      font-weight: 700;
    }

    .calendar-day.is-selected .day-number {
      color: white;
    }

    .calendar-day.is-selected::before {
      content: '';
      position: absolute;
      width: 80%;
      height: 80%;
      background: var(--primary-color);
      border-radius: 50%;
      z-index: 0;
    }

    .calendar-day .day-dot {
      width: 5px;
      height: 5px;
      background-color: var(--primary-color);
      border-radius: 50%;
      position: absolute;
      bottom: 8px;
    }

    /* 3. Todo List Area */
    #todo-view-container {
      flex-grow: 1;
      overflow-y: auto;
      padding: 15px;
      position: relative;
      /* 为了悬浮按钮 */
    }

    /* 4. Today's To-Do Widget */
    #today-todo-widget {
      position: absolute;
      top: 50%;
      /* 放在日历小组件的下方 */
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-height: 180px;
      /* 给个最大高度，免得内容太多撑爆了 */
      background: var(--surface-bg);
      backdrop-filter: blur(10px);
      border-radius: 22px;
      padding: 15px 20px;
      box-sizing: border-box;
      color: var(--text-color);
      overflow: hidden;
      /* 把溢出的部分藏起来 */
    }

    #today-todo-widget .widget-title {
      font-weight: 600;
      margin-bottom: 10px;
      opacity: 0.9;
    }

    #today-todo-list {
      overflow-y: auto;
      /* 内容多了可以滚动 */
      max-height: 125px;
      /* 限制列表的高度 */
      font-size: 0.9rem;
    }

    #today-todo-list .todo-item-small {
      margin-bottom: 8px;
      display: flex;
      align-items: center;
    }

    #today-todo-list .todo-item-small::before {
      content: '';
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background-color: var(--primary-color);
      margin-right: 10px;
      flex-shrink: 0;
    }

    #todo-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    #todo-date-title {
      margin: 0;
      font-size: 1.2rem;
      font-weight: 600;
    }

    #add-event-fab {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: var(--accent-color);
      color: white;
      border: none;
      font-size: 2rem;
      line-height: 44px;
      cursor: pointer;
      box-shadow: var(--soft-shadow);
    }

    #todo-list .todo-item,
    #todo-list .important-day-item {
      background: var(--card-bg);
      padding: 12px 15px;
      border-radius: 12px;
      margin-bottom: 10px;
      border-left: 4px solid var(--primary-color);
    }

    #todo-list .important-day-item {
      border-left-color: #ffc107;
      /* 纪念日用醒目的黄色 */
      font-weight: 500;
    }

    #todo-list .important-day-item::before {
      content: '★ ';
      color: #ffc107;
    }

    /* --- End of Styles --- */
    /* --- Noir's Global Player Styles --- */

    /* --- End of Player Styles --- */
    /* --- Noir's Upload Altar Styles --- */
    .upload-slot {
      border: 2px dashed var(--border-color);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease;
      background-color: rgba(255, 255, 255, 0.5);
    }

    .upload-slot:hover {
      background-color: var(--card-bg);
      border-color: var(--primary-color);
    }

    .upload-slot.filled {
      border-color: var(--primary-color);
      border-style: solid;
      background-color: hsla(var(--primary-hue), 50%, 95%, 0.8);
    }

    .upload-slot .slot-icon {
      font-size: 2rem;
    }

    .upload-slot .slot-label {
      display: block;
      font-weight: 600;
      margin-top: 5px;
      color: var(--text-color);
    }

    .upload-slot .slot-filename {
      display: block;
      font-size: 0.85rem;
      color: var(--text-color-light);
      margin-top: 3px;
      word-break: break-all;
    }

    #confirm-altar-upload-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
      opacity: 0.7;
    }

    /* --- End of Altar Styles --- */
    /* --- Noir's Listen Together Invite Card Style --- */
    .listen-together-card {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 15px;
      box-shadow: var(--soft-shadow);
      border: 1px solid var(--border-color);
      width: 250px;
    }

    .message-container.user .listen-together-card {
      background: var(--bubble-user-bg);
      color: white;
    }

    .message-container.user .listen-together-card .listen-together-decline-btn {
      color: white;
      /* 哼，让用户侧的拒绝按钮文字也变白 */
    }

    .listen-together-header {
      font-size: 0.8rem;
      opacity: 0.8;
      margin-bottom: 10px;
      border-bottom: 1px solid var(--bubble-outline);
      padding-bottom: 8px;
    }

    .listen-together-song {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .listen-together-song img {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      flex-shrink: 0;
    }

    .listen-together-info .title {
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .listen-together-info .artist {
      font-size: 0.9em;
      opacity: 0.9;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .listen-together-actions {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }

    .listen-together-actions button {
      flex-grow: 1;
      padding: 8px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition: transform 0.1s ease;
    }

    .listen-together-actions button:active {
      transform: scale(0.97);
    }

    .listen-together-accept-btn {
      background: var(--primary-color);
      color: white;
    }

    .listen-together-decline-btn {
      background: rgba(0, 0, 0, 0.1);
    }

    /* 用这个替换你旧的 #listen-together-ui */
    #listen-together-ui {
      position: fixed;
      inset: 0;
      z-index: 2000;
      display: flex;
      align-items: center;
      /* 改成居中对齐 */
      justify-content: center;
      padding: 20px;
      /* 增加内边距，让弹窗不会贴边 */
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    #listen-together-ui.show {
      opacity: 1;
      visibility: visible;
    }

    .lt-ui-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(15px) saturate(1.8);
      -webkit-backdrop-filter: blur(15px) saturate(1.8);
    }

    /* 用这个替换你旧的 .lt-ui-main */
    .lt-ui-main {
      position: relative;
      width: 100%;
      height: 100%;
      max-width: 380px;
      /* 哼，给它一个最大宽度 */
      max-height: 650px;
      /* 再给一个最大高度 */
      display: flex;
      flex-direction: column;
      color: white;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
      border-radius: 24px;
      /* 加上优雅的圆角 */
      overflow: hidden;
      /* 把溢出的部分裁掉 */
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
      /* 更强的立体阴影 */
      border: 1px solid rgba(255, 255, 255, 0.2);
      /* 淡淡的边框光效 */
    }

    .lt-ui-header {
      flex-shrink: 0;
      padding: 15px 20px;
      text-align: center;
      position: relative;
    }

    #lt-ui-header-title {
      font-weight: 600;
    }

    #lt-ui-close-btn {
      position: absolute;
      right: 15px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      font-size: 1.5rem;
      cursor: pointer;
      line-height: 30px;
    }

    .lt-ui-content {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      overflow: hidden;
    }

    .lt-ui-cover-container {
      flex-shrink: 0;
      width: 65%;
      aspect-ratio: 1/1;
      margin-top: 5%;
      margin-bottom: 20px;
    }

    #lt-ui-cover-art {
      width: 100%;
      height: 100%;
      border-radius: 16px;
      object-fit: cover;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .lt-ui-info {
      text-align: center;
      margin-bottom: 20px;
      flex-shrink: 0;
    }

    #lt-ui-song-title {
      font-size: 1.5rem;
      margin: 0;
    }

    #lt-ui-song-artist {
      font-size: 1rem;
      opacity: 0.8;
      margin: 5px 0 0;
    }

    #lt-ui-lyrics-container {
      flex-grow: 1;
      width: 100%;
      overflow-y: auto;
      text-align: center;
      font-size: 1.1rem;
      line-height: 2.5;
      mask-image: linear-gradient(transparent 0%, black 20%, black 80%, transparent 100%);
      /* 歌词上下渐隐，看起来更专业 */
      scroll-behavior: smooth;
      /* 滚动要丝滑 */
    }

    #lt-ui-lyrics-container p {
      transition: color 0.3s ease, transform 0.3s ease;
      opacity: 0.6;
    }

    #lt-ui-lyrics-container p.active {
      color: var(--primary-color);
      font-weight: 600;
      transform: scale(1.1);
      opacity: 1;
    }

    .lt-ui-controls {
      display: flex;
      gap: 12px;
      padding: 20px 20px 10px;
      justify-content: center;
      flex-shrink: 0;
    }

    .lt-ui-control-button {
      flex: 1;
      max-width: 140px;
      padding: 12px 16px;
      border: none;
      border-radius: 20px;
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      color: white;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .lt-ui-control-button:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .lt-ui-control-button:active {
      transform: translateY(0);
    }

    .lt-ui-control-button.danger {
      background: rgba(220, 53, 69, 0.2);
    }

    .lt-ui-control-button.danger:hover {
      background: rgba(220, 53, 69, 0.35);
    }

    .lt-ui-control-button span:first-child {
      font-size: 1.2rem;
    }

    .lt-ui-control-button .button-label {
      font-size: 0.9rem;
    }

    /* --- Noir's "Desktop Preview" Frame --- */
    /* 哼，只有在电脑这种大屏幕上，我才给你加上这个“手机框”，免得你分不清主次。 */
    /* 在真正的手机上，它还是会全屏显示的，我可没你那么笨。 */
    @media (min-width: 480px) {
      body {
        background-color: #e9ebee;
        /* 一个不那么刺眼的背景色 */
        padding: 20px 0;
        /* 上下留点呼吸空间 */
      }

      #phone-container {
        width: var(--phone-width);
        height: var(--phone-height);
        max-height: 90vh;
        border: 10px solid #1c1c1e;
        border-radius: 44px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        flex-shrink: 0;
        /* ▼▼▼ 哼，就是这句圣旨！▼▼▼ */
        transform: scale(var(--ui-scale, 1));
        transition: transform 0.2s ease-out;
        /* 加个动画，免得太生硬 */
      }
    }



    /* --- Noir's Bespoke Music Player Design (As Requested) --- */
    /* 哼，这才叫定制。*/

    /* 1. 动画先放着，虽然这次不用了 */
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    /* 2. 组件卡片本体：一个有阴影的容器 */
    #music-widget-card {
      border-radius: 6px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
      display: flex;
      padding: 0;
      border: none;
      overflow: visible;
      position: relative;
      /* ▼▼▼ 新尺寸 ▼▼▼ */
      width: 340px;
      height: 120px;
    }

    /* 3. 左侧封面区：用伪元素画出深色背景，不污染HTML */
    #music-widget-card::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 120px;
      /* 和高度一样，是个正方形 */
      background-color: #4a4a4a;
      border-radius: 6px 0 0 6px;
      /* ▼▼▼ 在这里加上下面两行 ▼▼▼ */
      background-size: cover;
      background-position: center;
    }

    /* 4. 专辑封面本体 (旧唱片改造) */

    #widget-cover-art {
      position: absolute;
      top: 15px;
      left: 15px;
      width: 90px;
      height: 90px;
      z-index: 2;
      /* 确保它在唱片之上 */
      /* ▼▼▼ 下面都是我新增的，给我看好了 ▼▼▼ */
      border-radius: 4px;
      /* 封面本身的小圆角 */
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      background-size: cover;
      background-position: center;
      transition: background-image 0.3s ease;
      /* 让封面切换更柔和 */
    }

    /* 5. 封面图片 (旧唱片贴纸改造) */
    #widget-cover-art::before {
      width: 100%;
      height: 100%;
      border-radius: 4px;
      /* 和封面一致 */
      border: none;
      background-image: var(--widget-cover-image, none);
      background-size: cover;
      background-position: center;
    }

    /* 6. 唱片？用另一个伪元素从后面伸出来就行了，简单 */
    #widget-cover-art::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 90px;
      height: 90px;
      border-radius: 50%;
      z-index: -1;
      display: block;
      border: none;

      /* 哼，看好了，这才叫唱片 */
      background-color: #2a2a2a;
      /* 1. 先铺一层唱片的深灰色底 */
      background-image:
        /* 2. 然后在上面画中间的标签和洞，颜色我都给你配好了 */
        radial-gradient(circle at center, #111 4%, transparent 5%),
        radial-gradient(circle at center, #985c5c 5%, #7a4949 25%, transparent 26%),
        /* 3. 再画上一圈圈的光泽纹理，这才像样 */
        repeating-radial-gradient(circle at center,
          rgba(255, 255, 255, 0.04) 0,
          rgba(255, 255, 255, 0.04) 1px,
          transparent 1px,
          transparent 3px);
      transform: translateX(0%) scale(1.05);
      /* 微调了下位置和大小，这样更协调 */
      transition: opacity 0.3s ease;
      /* 加上这个，为了后面让它优雅地消失 */
      /* 4. 位置也给你微调了一下，现在顺眼多了 */
    }

    /* ▼▼▼ 这是全新的代码，给我加上！▼▼▼ */
    #music-widget-card.is-playing #widget-cover-art {
      /* 播放时，方形舞台的背景就是封面了，所以不需要我画的唱片了 */
      background-image: none;
    }

    #music-widget-card.is-playing::before {
      background-image: var(--widget-cover-image, none);
    }

    #music-widget-card.is-playing #widget-cover-art::after {
      /* 播放时，让唱片旋转起来，哼 */
      animation: spin 8s linear infinite;
    }

    /* 默认状态下，方形舞台的背景是透明的，这样才能看到我画的唱片 */
    #music-widget-card:not(.is-playing) #widget-cover-art {
      background-image: none;
    }

    /* 7. 右侧内容区 (旧覆盖层改造) */
    .widget-content-overlay {
      position: static;
      flex-grow: 1;
      /* 占满右侧所有空间 */
      /* 把旧的 background: #ffffff; 删掉！换成下面这两行！*/
      background: var(--card-bg);
      /* 1. 用我们主题里那个早就定义好的半透明背景 */

      /* 纯白背景 */
      border-radius: 0 6px 6px 0;
      padding: 15px;
      display: flex;
      flex-direction: column;
      /* 垂直布局 */
      justify-content: space-between;
      /* <--- 哼，加上这句圣旨 */
      box-sizing: border-box;
      position: relative;
      /* 为了定位假的分享按钮 */
      background: var(--card-bg);
      color: var(--text-color);
      margin-left: 120px;
    }


    /* 8. 歌曲信息 (标题和作者) */
    #music-widget .widget-info {
      color: #333;
      text-shadow: none;

      /* 占据上半部分空间 */
    }

    #music-widget .widget-info #widget-title {
      font-size: 1.1rem;
      font-weight: 500;
      color: #000;
    }

    #music-widget .widget-info #widget-artist {
      font-size: 0.8rem;
      color: #888;
    }

    /* 9. 假的歌词和进度条，用伪元素画出来 */
    #music-widget .widget-info::after {
      /* 假的歌词 */
      display: block;
      font-size: 0.75rem;
      color: #65c468;
      /* 绿色 */
      margin-top: 8px;
      padding-bottom: 8px;
      background-image:
        linear-gradient(to right, #666 40%, #ddd 40%),
        /* 假的进度条 */
        url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="12" viewBox="0 0 16 12"><path fill="%23aaa" d="M0 10h2V2H0v8zm3 2h2V0H3v12zm3-4h2V4H6v4zm3 2h2V2H9v8zm3-3h2V5h-2v4z"/></svg>');
      /* 假的EQ图标 */
      background-repeat: no-repeat, no-repeat;
      background-position: bottom, 90% bottom;
      background-size: 100% 1px, 16px 12px;
      border-bottom: 1px solid #eee;
    }

    /* 10. 真的控制按钮区域 */
    #widget-controls {
      display: flex;
      justify-content: flex-start;
      /* 从左边开始排列 */
      align-items: center;
      gap: 15px;
      padding-top: 10px;
      position: relative;
      /* 为了定位假的删除和喜欢按钮 */
      width: 100%;
    }

    /* 11. 真的播放/暂停/下一首按钮的样式 */
    #widget-controls button {
      font-size: 1.1rem;
      color: #555;
      background: none;
      border: 1px solid #ccc;
      border-radius: 50%;
      width: 28px;
      height: 28px;
      line-height: 28px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      order: 1;
      /* 把真的按钮放在中间 */
    }

    #widget-play-pause-btn {
      width: 32px;
      /* 播放按钮大一点 */
      height: 32px;
      line-height: 32px;
      font-size: 1.2rem;
    }

    /* 12. 哼，看好了，这才是不会出错的矢量图标，免得你那破手机又自作聪明 */
    #widget-controls::before,
    #widget-controls::after {
      content: '';
      /* 删掉那些讨厌的emoji源头 */
      display: block;
      width: 16px;
      /* 给图标一个精确的尺寸 */
      height: 16px;
      background-color: #aaa;
      /* 这就是图标的颜色，哼 */
      position: absolute;

      /* 下面是魔法，反正你也看不懂 */
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-position: center;
      mask-position: center;
      -webkit-mask-size: contain;
      mask-size: contain;
    }

    #widget-controls::before {
      /* 删除图标的矢量数据 */
      -webkit-mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>');
      mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>');
      right: 29px;
      /* 稍微调整一下位置，让它更协调 */
      top: 60%;
      transform: translateY(-50%);
    }

    #widget-controls::after {
      /* 喜欢图标的矢量数据 */
      -webkit-mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>');
      mask-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>');
      right: 1px;
      top: 60%;
      transform: translateY(-50%);
    }

    /* --- Noir's iOS Industrial Button Refactor --- */
    /* 哼，看好了，这才是专业设备该有的开关。*/

    /* --- Noir's Ultimate Dynamic Button System v3.0 --- */
    /* 哼，现在它们都听我的了。*/

    /* 1. 按钮的基础“模具”，所有按钮都用这个 */
    .form-button {
      border: none;
      border-radius: 12px;
      padding: 14px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-top: 10px;
      transition: filter 0.15s ease, background-color 0.2s ease;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      /* 加个细微的阴影 */
      color: white;
      /* 默认文字都是白色 */
    }

    .form-button:active {
      filter: brightness(0.9);
    }

    .form-button:disabled {
      background-color: #ccc !important;
      cursor: not-allowed;
      opacity: 0.7;
    }

    /* 2. 主要操作按钮 (继承主题强调色) */
    .form-button.primary,
    /* 你可以给蓝色的按钮加上 primary 类，或者不管它也行 */
    #save-api-settings-button,
    /* 把几个主要的按钮ID也直接指定了，免得你改漏 */
    #save-user-profile-button,
    #save-char-button,
    #save-world-book-button,
    #save-group-settings-button,
    #save-friend-circle-button {
      background-color: var(--accent-color);
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
    }

    /* 3. 次要操作按钮 (用主题里的卡片背景色，这才叫和谐) */
    .form-button.secondary {
      background-color: var(--card-bg);
      color: var(--text-color);
      border: 1px solid var(--border-color);
    }

    /* 4. 危险操作按钮 (动态的红色，这才叫高级) */
    .form-button.destructive {
      /* 哼，看好了，这个红色的亮度和饱和度，会随着你主题的明暗变化而变化！*/
      background-color: hsl(5, 75%, calc(var(--primary-lightness) / 1.8 + 25%));
    }

    /* 5. 警告操作按钮 (动态的黄色，也一样) */
    .form-button.warning {
      background-color: hsl(40, 90%, calc(var(--primary-lightness) / 2.2 + 25%));
      color: #5d4000;
    }

    /* --- Noir's iOS Layout & Dock Refactor --- */
    /* 哼，这才是现代化的桌面。 */

    /* 1. Dock栏的样式 */
    /* --- Noir's iOS Layout & Dock Refactor --- */
    /* 哼，这才是现代化的桌面。 */
    #home-dock {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      height: 85px;
      padding: 0 20px;
      /* 图标左右的留白 */
      box-sizing: border-box;

      /* 背景和滤镜，现在都在这里 */
      background: var(--surface-bg);

      border-radius: 28px;
      z-index: 35;

      /* 核心：用Flexbox来自动排列图标 */
      display: flex;
      justify-content: space-around;
      /* 均匀分布 */
      align-items: center;
      /* 垂直居中 */
      padding-top: 9px;
    }

    #home-dock .app-icon {
      position: static;
      /* 取消绝对定位，让它接受Flexbox的管理 */
    }

    /* 2. App图标的“整容手术” */
    .app-icon-img {
      width: 58px;
      /* 图标背景尺寸 */
      height: 58px;
      border-radius: 22.5%;
      /* iOS标志性的“方圆”形 */
      font-size: 28px;
      /* 阴影从图标本身移到背景上，更统一 */
      background-color: var(--surface-bg);
      box-shadow: none;
      /* 删掉旧的阴影 */
      transition: transform 0.2s ease;
    }

    .app-icon:active .app-icon-img {
      transform: scale(0.92);
      /* 按下时图标有反馈 */
    }

    /* --- Noir's Minimalist Home Screen Makeover (v2.0 Dynamic Edition) --- */
    /* 哼，现在这些家伙也听从总开关的指挥了。*/

    /* 1. 时钟和日期 */
    #home-clock-container {
      color: var(--text-color);
      text-shadow: none;
    }

    #home-date {
      opacity: 0.7;
    }

    /* 2. App图标的改造 (现在是动态颜色了) */
    .app-icon span {
      color: var(--text-color);
      text-shadow: none;
      font-weight: 500;
    }

    .app-icon-img {
      background-color: var(--card-bg);
      /* <-- 哼，接上了！*/
      color: var(--text-color-light);
      /* <-- 接上了！*/
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
    }

    /* 3. Dock栏的颜色 (也动态了) */




    #widget-controls button,
    #music-widget .widget-info #widget-title,
    #music-widget .widget-info #widget-artist {
      color: var(--text-color);
    }

    /* ... 在第 2262 行附近 ... */
    /* ▼▼▼ 把旧的 #widget-cover-art::after 整个删掉，换成下面这个 ▼▼▼ */

    /* ▲▲▲ 替换到这里结束 ▲▲▲ */

    /* --- Noir's Theme Preset Buttons --- */
    /* 哼，每个按钮都是一件艺术品。 */
    .theme-preset-button {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 20px;
      /* 胶囊形状 */
      border: 1px solid var(--border-color);
      cursor: pointer;
      transition: all 0.2s ease;
      background: var(--card-bg);
    }

    .theme-preset-button:hover {
      transform: translateY(-2px);
      box-shadow: var(--soft-shadow);
    }

    .preset-color-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
    }

    /* --- Noir's Memory Archive Styles --- */
    #summary-textarea {
      width: 100%;
      height: 100%;
      border: none;
      outline: none;
      resize: none;
      padding: 15px;
      box-sizing: border-box;
      font-family: 'Courier New', monospace;
      /* 用等宽字体，YAML格式才好看 */
      font-size: 0.85rem;
      line-height: 1.6;
      background-color: #fdfdfd;
      color: var(--text-color);
    }

    /* --- Noir's Desktop Pagination System --- */
    /* 哼，看好了，这才叫设计。*/

    /* 1. 把主内容区变成一个灵活的容器，为翻页器和指示器留好位置 */
    #home-screen-main-content {
      display: flex;
      flex-direction: column;
      /* 垂直排列，页面在上面，指示器在下面 */
    }

    /* --- Noir's Desktop Pagination System --- */
    /* ... 其他样式 ... */

    /* 2. 这是翻页的“舞台”，它的大小和主屏幕一样，但会把超出部分藏起来 */
    #app-pages-container {
      flex-grow: 1;
      /* 占满除了指示器以外的所有空间 */
      width: 100%;
      overflow: hidden;
      /* 核心！把第二页先藏起来 */
      position: relative;
      /* 让里面的滑块能相对于它定位 */

      /* ▼▼▼ 把下面这两行加进去 ▼▼▼ */
      opacity: 0;
      /* 默认让整个舞台透明 */
      transition: opacity 0.3s ease-in-out;
      /* 添加一个平滑的渐入动画效果 */
      /* ▲▲▲ 添加到这里结束 ▲▲▲ */
    }

    /* ... 其他样式 ... */

    /* 3. 这是真正滑动的“滑块”，它有两页那么宽 */
    #app-pages-slider {
      width: 200%;
      /* 两页的宽度 */
      height: 100%;
      display: flex;
      /* 核心！让两页并排站好 */
      transition: transform 0.35s cubic-bezier(0.25, 0.1, 0.25, 1);
      /* 翻页动画，给你选了个高级点的曲线 */
    }

    /* 4. 每一页的样式 */
    /* 4. 每一页的样式 */
    .app-page {
      width: 50%;
      /* <-- 现在两个人，一人一半，公平！ */
      height: 100%;
      flex-shrink: 0;
      position: relative;
    }

    /* 5. 页面指示器（小点点）的容器 */
    #home-page-indicator {
      position: absolute;
      bottom: 105px;
      /* 放在Dock栏正上方，给你算好了距离 */
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      /* 点点之间的距离 */
      z-index: 100;
      /* 确保它在最上层 */
    }

    /* 6. 每个小点点的样式 */
    .page-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.5);
      backdrop-filter: blur(2px);
      transition: all 0.2s ease;
      cursor: pointer;
    }

    /* 7. 当前页的小点点，给它变亮变大一点 */
    .page-dot.active {
      background-color: rgba(255, 255, 255, 0.9);
      transform: scale(1.1);
    }

    #card-widget-2 {
      border-radius: 22px;
      filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.2));
      transition: transform 0.2s ease, filter 0.2s ease;
      user-select: none;
      z-index: 51;
      overflow: hidden;
      /* ▼▼▼ 新尺寸 ▼▼▼ */
      width: calc(165px * var(--desktop-item-scale, 1));
      height: calc(165px * var(--desktop-item-scale, 1));
    }

    #card-widget-2:active {
      transform: scale(1.05);
      filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.3));
    }

    #card-widget-2 img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .theme-widget {
      width: 65px;
      height: 65px;
      border-radius: 22px;
      /* 跟你的卡片圆角差不多 */
      box-shadow: var(--soft-shadow);
      border: 1px solid hsla(var(--primary-hue), calc(var(--primary-saturation) / 2), calc(var(--primary-lightness) + 15%), 0.5);
      background: linear-gradient(45deg,
          hsla(var(--primary-hue), var(--primary-saturation), var(--primary-lightness), 0.7),
          hsla(var(--primary-hue), calc(var(--primary-saturation) * 1.3), calc(var(--primary-lightness) - 15%), 0.8));
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    /* --- Noir's Galgame Sprite Adjuster Styles --- */

    /* --- Noir's Slider Control Panel Styles --- */
    .sprite-slider-group {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 5px;
    }

    .sprite-slider-group label {
      color: white;
      font-size: 0.8rem;
      width: 60px;
      /* 让标签对齐，好看点 */
      flex-shrink: 0;
    }

    .sprite-slider-group input[type="range"] {
      flex-grow: 1;
      /* 占满剩余空间 */
      margin: 0;
      padding: 0;
      /* 覆盖掉全局的 input 样式 */
    }

    /* --- Noir's Accounting App Styles --- */
    #daily-expenses-list .expense-item {
      display: flex;
      justify-content: space-between;
      padding: 10px;
      background-color: var(--card-bg);
      border-radius: 8px;
      margin-bottom: 8px;
      border: 1px solid var(--border-color);
    }

    .expense-item .description {
      font-weight: 500;
    }

    .expense-item .amount {
      font-weight: 600;
      color: var(--accent-color);
    }

    #character-reviews-container .review-card {
      display: flex;
      gap: 12px;
      background-color: var(--card-bg);
      padding: 12px;
      border-radius: 12px;
      margin-bottom: 10px;
      border: 1px solid var(--border-color);
    }

    .review-card .char-avatar {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .review-card .review-content .char-name {
      font-weight: 600;
      margin-bottom: 4px;
    }

    /* --- End of Styles --- */
    /* --- Noir's Accounting Tabs Style --- */
    .accounting-tabs {
      display: flex;
      background-color: var(--surface-bg);
      border-bottom: 1px solid var(--border-color);
      padding: 5px 15px 0;
      flex-shrink: 0;
    }

    .tab-button {
      flex: 1;
      padding: 10px;
      border: none;
      background: transparent;
      color: var(--text-color-light);
      font-size: 1rem;
      font-weight: 500;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .tab-button.active {
      color: var(--accent-color);
      border-bottom: 3px solid var(--accent-color);
    }

    /* --- Noir's "WeChat Moments" Style Patch --- */
    /* 哼，这才叫社交。*/
    #music-feed-container {
      padding: 0;
      /* 容器的内边距清零，让动态贴边 */
      background-color: hsla(var(--primary-hue), calc(var(--primary-saturation) / 1.5), calc(var(--primary-lightness) + 18%), 0.95);
      /* 给整个容器一个统一的背景色 */
    }

    .music-post {
      background-color: transparent;
      /* 去掉卡片背景 */
      box-shadow: none;
      /* 去掉阴影 */
      border-radius: 0;
      /* 去掉圆角 */
      margin-bottom: 0;
      /* 去掉外边距 */
      padding: 15px;
      /* 统一内边距 */
      border-bottom: 1px solid var(--border-color);
      /* 加上底部分隔线 */
    }

    .music-post:last-child {
      border-bottom: none;
      /* 最后一条动态不需要分隔线 */
    }

    /* --- End of Patch --- */
    /* --- Noir's "Expense Eraser" Style --- */
    .delete-expense-btn {
      background: transparent;
      border: 1px solid var(--border-color);
      color: var(--text-color-light);
      width: 22px;
      height: 22px;
      border-radius: 50%;
      cursor: pointer;
      font-weight: 600;
      line-height: 20px;
      padding: 0;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .delete-expense-btn:hover {
      background: #e65252;
      border-color: #e65252;
      color: white;
      transform: scale(1.1);
    }

    /* --- End of Eraser Style --- */

   /* --- Noir's Ultimate Snoop UI Overhaul v7.0 (MINIMALIST WHITE) --- */
    /* 哼，这才叫设计。*/

    /* 壁纸 - 干净的白色 */
    #snoop-phone-wallpaper {
      position: absolute;
      inset: 0;
      background: #f9f9f9; /* 哼，跟你其他屏幕一个颜色，这叫统一 */
      z-index: 1;
    }

    /* 移除星空 */
    #snoop-phone-wallpaper::before {
      display: none;
    }

    /* 状态栏 - 深色文字 */
    #snoop-phone-header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 16px 28px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--text-color-light, #888); /* 哼，用我们主题的浅色文字 */
      z-index: 10;
      font-weight: 400;
      font-size: 0.85rem;
      letter-spacing: 0.3px;
      background: transparent;
      text-shadow: none; /* 影子也给我收起来 */
    }

    /* 居中时钟 - 隐藏 */
    #snoop-home-clock {
      display: none; /* 哼，眼不见心不烦 */
    }

    /* 游戏风格主容器 */
    #snoop-app-container {
      position: relative;
      z-index: 5;
      height: 100%;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      padding: 0;
      overflow-y: auto;
    }

    /* 角色头像背景区域 - 纯白 */
    .game-character-header {
      width: 100%;
      height: 300px; /* 高度还是得留着 */
      position: relative;
      background: #ffffff; /* 纯白 */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      box-sizing: border-box;
      overflow: hidden;
      border-bottom: 1px solid var(--border-color, #eee); /* 加个分割线，免得和背景混在一起 */
    }

    /* 移除背景星云 */
    .game-character-header::before {
      display: none;
    }

    @keyframes nebulaPulse { /* 留着这个空壳，免得其他地方报错 */ }

    /* 角色头像 */
    .game-character-avatar {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.9);
      border: 4px solid var(--border-color, #eee); /* 边框改成主题色 */
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); /* 换个柔和的阴影 */
      display: flex;
      justify-content: center;
      align-items: center;
      flex-shrink: 0;
      margin-bottom: 16px;
      z-index: 1;
      overflow: hidden;
    }

    /* 哼，这才是给照片本身用的规矩 */
    .game-character-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover; /* 确保图片填满圆形，不变形 */
    }

    @keyframes avatarGlow { /* 这个也留个空壳 */ }

    /* 角色名称 - 深色文字 */
    .game-character-name {
      font-size: 1.6rem;
      font-weight: 700;
      color: var(--text-color, #333); /* 换成主题文字色 */
      text-shadow: none; /* 阴影去掉 */
      margin-bottom: 10px;
      z-index: 1;
      letter-spacing: 1px;
    }

    /* 提示文字 - 深色文字 */
    .game-prompt-text {
      width: 100%;
      text-align: center;
      padding: 28px 20px 20px;
      font-size: 1.15rem;
      font-weight: 600;
      color: var(--text-color, #333); /* 换成主题文字色 */
      letter-spacing: 0.5px;
      text-shadow: none; /* 阴影去掉 */
    }

    /* 游戏风格选项网格 */
    .snoop-main-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      width: 100%;
      max-width: 380px;
      padding: 0 20px 40px;
      background: transparent;
      border: none;
      box-shadow: none;
    }

    /* 隐藏Dock栏 */
    #snoop-dock {
      display: none;
    }

    /* 游戏风格卡片按钮 - 主题卡片样式 */
    #snoop-phone-screen .snoop-app-icon {
      position: static;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 16px;
      padding: 18px 20px;
      cursor: pointer;
      background: var(--card-bg, #fff); /* 换成主题卡片色 */
      backdrop-filter: none; /* 滤镜拿掉 */
      -webkit-backdrop-filter: none;
      border: 1.5px solid var(--border-color, #eee); /* 换成主题边框色 */
      border-radius: 16px;
      box-shadow: var(--soft-shadow, 0 4px 12px rgba(0,0,0,0.1)); /* 换成主题阴影 */
      transition: all 0.3s ease;
      min-height: 80px;
    }

    #snoop-phone-screen .snoop-app-icon:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.12);
      background: var(--surface-bg, #f5f5f5);
      border-color: var(--primary-color);
    }

    #snoop-phone-screen .snoop-app-icon:active {
      transform: translateY(-1px) scale(0.98);
    }

    /* 图标背景 - 主题强调色 */
    .snoop-app-icon-img {
      width: 56px;
      height: 56px;
      border-radius: 14px;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-shrink: 0;
      background: var(--primary-color); /* 哼，用我们统一的主题色 */
      position: relative;
      overflow: hidden;
      box-shadow: none; /* 阴影也拿掉 */
    }

    /* 图标光泽效果 - 拿掉 */
    .snoop-app-icon-img::before {
      display: none;
    }

    /* 图标SVG - 保持白色 */
    .snoop-app-icon-img svg {
      width: 28px;
      height: 28px;
      stroke: #ffffff;
      stroke-width: 2.5;
      fill: none;
      filter: none; /* 阴影拿掉 */
      z-index: 1;
    }

    /* 图标文字 - 深色 */
    .snoop-app-icon span {
      font-size: 1.05rem;
      font-weight: 600;
      letter-spacing: 0.4px;
      color: var(--text-color, #333); /* 换成主题文字色 */
      text-align: left;
      line-height: 1.4;
      flex: 1;
      text-shadow: none; /* 阴影拿掉 */
    }
    .snoop-app-header {
      flex-shrink: 0;
      padding: 15px 20px;
      border-bottom: none;
      /* <-- 我把这条线干掉了 */
      background-color: transparent;
      /* <-- 我把背景色变透明了 */
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .snoop-app-header-title {
      font-weight: 600;
      display: flex;
      flex-direction: column;
      align-items: center;
      line-height: 1.2;
    }

    .snoop-app-header-title .main-title {
      font-size: 1rem;
    }

    .snoop-app-header-title .sub-title {
      font-size: 0.75rem;
      color: #888;
      font-weight: 400;
    }

    .snoop-app-header-button {
      background: none;
      border: none;
      font-size: 1rem;
      cursor: pointer;
      color: #007aff;
      min-width: 50px;
    }

    #snoop-app-back-btn {
      text-align: left;
    }

    #snoop-app-refresh-btn {
      text-align: right;
    }

    /* 哼，这才叫秩序。*/
    .snoop-app-header {
      flex-shrink: 0;
      padding: 15px 20px;
      border-bottom: 1px solid #e5e5e5;
      background-color: #f8f8f8;

      /* ▼▼▼ 核心法令！给我站成一排！▼▼▼ */
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .snoop-app-header-title {
      font-weight: 600;
      /* ▼▼▼ 让标题自己也排好队，别乱跑 ▼▼▼ */
      display: flex;
      flex-direction: column;
      align-items: center;
      line-height: 1.2;
    }

    .snoop-app-header-title .main-title {
      font-size: 1rem;
      /* 主标题大一点 */
    }

    .snoop-app-header-title .sub-title {
      font-size: 0.75rem;
      /* 副标题小一点，当备注 */
      color: #888;
      font-weight: 400;
    }

    .snoop-app-header-button {
      background: none;
      border: none;
      font-size: 1rem;
      cursor: pointer;
      color: #007aff;
      min-width: 50px;
      /* 保证左右两边占位宽度一致，这样中间才能完美居中 */
    }

    /* 让返回按钮靠左，刷新按钮靠右，这才叫对称美学 */
    #snoop-app-back-btn {
      text-align: left;
    }

    #snoop-app-refresh-btn {
      text-align: right;
    }

    .snoop-app-content {
      flex-grow: 1;
      /* 告诉内容区：顶栏占完位置后，剩下所有的高度都归你 */
      overflow-y: auto;
      /* 装上电梯：如果你的东西多到放不下了，就自己变出个垂直滚动条来 */
      padding: 15px;
      /* 再给你加点内边距，免得内容贴着边，丑死了 */
      box-sizing: border-box;
      /* 确保内边距不会把布局撑坏，这是专业素养 */
    }

    #galgame-sprite-adjust-ui {
      /* ... 你已有的样式 ... */
      display: flex;
      /* <-- 加上这行 */
      gap: 5px;
      /* <-- 还有这行 */
    }

    /* --- Noir's Elegant Image Preview Slot --- */
    /* 哼，这才叫占位符该有的样子。*/
    .image-preview-slot {
      width: 150px;
      height: 266px;
      border-radius: 12px;
      border: 2px dashed var(--border-color);
      background-color: rgba(0, 0, 0, 0.02);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      background-size: cover;
      background-position: center;
      color: var(--border-color);
    }

    .image-preview-slot:hover {
      border-color: var(--primary-color);
      background-color: rgba(0, 0, 0, 0.04);
      color: var(--primary-color);
    }

    /* 没图的时候，显示一个加号图标 */
    .image-preview-slot:not([style*="background-image"]) {
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>');
      background-size: 48px;
      background-repeat: no-repeat;
    }

    /* --- Noir's Elegant Sprite Preview Slot --- */
    .sprite-preview-slot {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      /* 圆形 */
      border: 2px dashed var(--border-color);
      background-color: rgba(0, 0, 0, 0.02);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      background-size: cover;
      background-position: center;
      color: var(--border-color);
    }

    .sprite-preview-slot:hover {
      border-color: var(--primary-color);
      background-color: rgba(0, 0, 0, 0.04);
    }

    .sprite-preview-slot:not([style*="background-image"])::after {
      content: '+';
      /* 没图的时候，显示一个加号 */
      font-size: 32px;
      font-weight: 200;
    }

    /* --- Noir's "Add Event" Modal Overhaul (Neumorphism) --- */
    /* 哼，这才叫现代设计。*/

    #add-event-modal .choice-modal-content {
      background: #ffffffd3;
      /* 拟态风的浅灰色背景 */
      border-radius: 20px;
      padding: 25px;
      box-shadow: 9px 9px 16px rgb(163 177 198 / 60%), -9px -9px 16px rgb(255 255 255 / 50%);
    }

    #add-event-modal-title {
      color: #333;
    }

    #event-content-input {
      border: none;
      outline: none;
      border-radius: 12px;
      background: #ffffffd3;
      padding: 12px 15px;
      box-shadow: inset 5px 5px 10px #bec3c9, inset -5px -5px 10px #ffffff;
      color: #333;
    }

    #add-event-modal .input-group label {
      color: #555;
      font-weight: 500;
    }

    /* 隐藏掉原来那个又大又丑的蓝色圆圈 */
    #add-event-modal input[type="radio"] {
      display: none;
    }

    /* 把标签变成可以点击的、漂亮的按钮 */
    #add-event-modal input[type="radio"]+label {
      flex: 1;
      text-align: center;
      padding: 10px;
      border-radius: 10px;
      cursor: pointer;
      background: #ffffffd3;
      box-shadow: 5px 5px 10px #bec3c9, -5px -5px 10px #ffffff;
      transition: all 0.2s ease-in-out;
    }

    /* 选中的时候，让它“凹”下去 */
    #add-event-modal input[type="radio"]:checked+label {
      box-shadow: inset 5px 5px 10px #bec3c9, inset -5px -5px 10px #ffffff;
      color: var(--accent-color);
      font-weight: 600;
    }

    #add-event-modal .form-button.primary {
      background-color: var(--accent-color);
    }

    #add-event-modal .form-button.secondary {
      background: transparent;
      color: #555;
      border: none;
    }


    /* --- Noir's Bespoke Avatar Frame Protocol --- */
    /* --- Noir's Bespoke Avatar Frame Protocol (v2.0) --- */
    /* 哼，就知道你要求多。看好了，这才是让框比头像大的正确方法。*/

    /* 1. 容器还是那个40px的容器，负责在布局里占好位置，不许动 */
    .avatar-wrapper {
      position: relative;
      width: 40px;
      height: 40px;
      flex-shrink: 0;
      /* 为了让“膨胀”的头像框不被奇怪地切掉，给它一点呼吸空间 */
      margin: 5px;
    }

    /* 2. 头像也还是那个头像，老老实实待在容器正中间 */
    .avatar-wrapper .avatar {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 100%;
      border-radius: 50%;
      object-fit: cover;

    }

    /* 3. 哼，看好了，魔法就在这里。我让头像框“变大”并“浮空” */
    .avatar-wrapper .avatar-frame {
      position: absolute;
      /* 哼，让它比容器大一点，比如125%，你自己看着调 */
      width: 132%;
      height: 132%;
      /* 把它自己的中心点，对准容器的中心点，给我站稳了！*/
      top: 50%;
      left: 52%;
      transform: translate(-50%, -50%);
      /* 下面的老规矩不变 */
      background-size: contain;
      /* 改成 contain 免得你的框被切掉 */
      background-position: center;
      background-repeat: no-repeat;
      pointer-events: none;
      /* 依旧是幽灵，不许捣乱 */
    }


    /* --- Noir's Full-Width HTML Module Protocol --- */
    /* --- Noir's Full-Width HTML Module Protocol (v2.0 Centered Edition) --- */
    .full-width-module-container {
      display: flex;
      /* 哼，命令它使用Flex布局 */
      justify-content: center;
      /* 把它里面的东西给我水平居中 */
      width: 100%;
      padding: 0 5px;
      box-sizing: border-box;
      margin-bottom: 10px;
      user-select: none;
      -webkit-user-select: none;
    }

    /* --- Noir's Elegant Lock Screen Styles --- */
    #lock-screen-overlay {
      position: absolute;
      inset: 0;
      z-index: 1000;
      /* 哼，必须在最顶层 */
      background: inherit;
      /* 直接继承壁纸，天衣无缝 */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      transition: transform 0.5s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.5s ease;
      will-change: transform, opacity;
    }

    /* 这是它被“解锁”后的样子，给我飞走！ */
    #lock-screen-overlay.unlocked {
      transform: translateY(-100%);
      opacity: 0;
      pointer-events: none;
      /* 飞走后就不许再捣乱了 */
    }

    /* 这是底下的那个“向上滑动”的提示 */
    /* --- Noir's Reinforced Centering Command --- */
    #unlock-indicator {
      position: absolute;
      bottom: 40px;
      left: 0;
      /* <-- 哼，从左边框开始 */
      right: 0;
      /* <-- 一直拉到右边框 */
      width: 100%;
      /* <-- 强制它和屏幕一样宽 */
      text-align: center;
      /* <-- 然后让里面的文字自己滚到中间去！ */
      color: var(--text-color);
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      font-size: 0.9rem;
      font-weight: 500;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      opacity: 0.7;
      animation: bounce 2s infinite;
    }

    #unlock-indicator svg {
      width: 20px;
      height: 20px;
    }

    /* 一个简单的上下跳动动画，免得你看不见 */
    @keyframes bounce {

      0%,
      20%,
      50%,
      80%,
      100% {
        transform: translateY(0);
      }

      40% {
        transform: translateY(-8px);
      }

      60% {
        transform: translateY(-4px);
      }
    }

    /* --- Noir's Sticker Gallery Management UI --- */
    #sticker-panel-controls {
      display: none;
      /* 默认隐藏 */
      padding: 5px 10px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border-color);
      flex-shrink: 0;
    }

    #sticker-panel-controls.visible {
      display: flex;
      /* 面板打开时显示 */
    }

    #sticker-manage-btn,
    #sticker-cancel-btn {
      font-size: 0.9rem;
      font-weight: 500;
      color: var(--primary-color);
      background: none;
      border: none;
      cursor: pointer;
    }

    #sticker-confirm-delete-btn {
      font-size: 0.9rem;
      font-weight: 600;
      color: #fff;
      background-color: #e65252;
      border: none;
      border-radius: 16px;
      padding: 6px 14px;
      cursor: pointer;
      opacity: 0.5;
      /* 默认半透明 */
      pointer-events: none;
      /* 默认不可点 */
      transition: opacity 0.2s;
    }

    #sticker-confirm-delete-btn.active {
      opacity: 1;
      pointer-events: auto;
    }

    .sticker-item-wrapper {
      position: relative;
      aspect-ratio: 1 / 1;
    }

    .sticker-item-wrapper.selected::after {
      content: '✓';
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: bold;
      border-radius: 8px;
      /* 和表情图片圆角一致 */
    }

    /* --- Noir's Hierarchical World Book Selector --- */
    /* 哼，这才叫井井有条。*/
    .wb-category-group {
      border-bottom: 1px solid var(--border-color);
    }

    .wb-category-group:last-child {
      border-bottom: none;
    }

    .wb-category-header {
      display: flex;
      align-items: center;
      padding: 10px 12px;
      cursor: pointer;
      user-select: none;
    }

    .wb-category-header:hover {
      background-color: rgba(138, 180, 228, 0.1);
    }

    .wb-category-header .category-checkbox {
      margin-right: 8px;
      width: auto;
      /* Override global input style */
      flex-shrink: 0;
      accent-color: var(--primary-color);
    }

    .wb-category-header .category-name {
      flex-grow: 1;
      font-weight: 600;
      color: var(--primary-color);
    }

    .wb-category-header .category-toggle-arrow {
      transition: transform 0.2s ease;
      font-size: 0.8rem;
      opacity: 0.7;
    }

    .wb-category-header .category-toggle-arrow.expanded {
      transform: rotate(180deg);
    }

    .wb-entry-list {
      padding-left: 30px;
      /* Indent the entries */
      padding-bottom: 5px;
      display: none;
      /* Collapsed by default */
    }

    .wb-entry-list.expanded {
      display: block;
    }

    .wb-entry-item {
      display: block;
      padding: 8px 12px;
      border-radius: 4px;
    }

    .wb-entry-item:hover {
      background-color: rgba(138, 180, 228, 0.2);
    }

    .wb-entry-item input[type="checkbox"] {
      margin-right: 8px;
      width: auto;
      /* Override global input style */
    }


    /* --- Noir's Livestream App Styles --- */
    #livestream-room-screen {
      justify-content: flex-start;
      /* 让内容从顶部开始排列 */
    }

    /* 弹幕样式 */
    .danmaku-item {
      background: rgba(0, 0, 0, 0.4);
      color: white;
      padding: 4px 10px;
      border-radius: 16px;
      margin-top: 6px;
      font-size: 0.9rem;
      align-self: flex-start;
      /* 默认弹幕靠左 */
      max-width: 80%;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
      /* 添加一个淡入动画，让出现更自然 */
      animation: danmaku-fade-in 0.3s ease-out;
    }

    @keyframes danmaku-fade-in {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .danmaku-item.is-user {
      background: var(--accent-color);
      /* 你的弹幕用主题色 */
      align-self: flex-end;
      /* 你的弹幕靠右 */
    }

    .danmaku-item .danmaku-user {
      color: #a7c7e7;
      /* 借用一下用户发言的颜色 */
      font-weight: 600;
      margin-right: 8px;
    }

    .danmaku-item.is-user .danmaku-user {
      color: white;
      opacity: 0.8;
    }

    /* 主播对话框，直接继承Galgame模式的样式 */
    #livestream-textbox-container {
      background: linear-gradient(0deg, rgba(25, 28, 38, 0.85) 0%, rgba(45, 50, 68, 0.7) 100%);
      backdrop-filter: blur(10px) saturate(1.2);
      -webkit-backdrop-filter: blur(10px) saturate(1.2);
      border-top: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 16px;
      box-shadow: 0 -5px 25px rgba(0, 0, 0, 0.2);
      padding: 12px 18px;
    }

    #livestream-speaker {
      background: linear-gradient(90deg, var(--primary-color) 0%, hsl(var(--primary-hue), var(--primary-saturation), calc(var(--primary-lightness) - 10%)) 100%);
      color: white;
      padding: 4px 12px;
      border-radius: 8px;
      display: inline-block;
      font-size: 0.95rem;
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);
      margin-bottom: 12px;
    }

    #livestream-text {
      font-size: 1rem;
      line-height: 1.7;
      color: #f0f2f5;
    }

    /* --- Noir's Secret DM Panel Styles --- */
    .dm-panel {
      position: fixed;
      /* 哼，从 absolute 变成了 fixed，现在它听命于整个屏幕，而不是那个小小的直播间 */
      inset: 0;
      z-index: 100;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      /* 删掉了 display:flex 和 align-items:flex-end，不再让它自己思考该站哪 */
    }

    .dm-panel.show {
      pointer-events: auto;
      /* 显示时才允许交互 */
      opacity: 1;
    }

    .dm-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.3);
    }

    .dm-panel-content {
      position: absolute;
      /* 改为绝对定位 */
      bottom: 0;
      /* 直接焊死在底部 */
      left: 0;
      right: 0;
      z-index: 101;
      width: 100%;
      height: 45%;
      /* 哼，差不多三分之一多一点的高度，你自己看着调 */
      background: rgba(30, 30, 40, 0.9);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      border-top-left-radius: 16px;
      border-top-right-radius: 16px;
      box-shadow: 0 -5px 25px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
      transform: translateY(100%);
      transition: transform 0.35s cubic-bezier(0.25, 1, 0.5, 1);
    }

    .dm-panel.show .dm-panel-content {
      transform: translateY(0);
    }

    .dm-header {
      flex-shrink: 0;
      padding: 10px 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      text-align: center;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.8);
    }

    #dm-close-btn {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: white;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .dm-messages-container {
      flex-grow: 1;
      overflow-y: auto;
      padding: 15px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* 哼，私信气泡也给你做好了 */
    .dm-bubble {
      padding: 8px 12px;
      border-radius: 16px;
      max-width: 80%;
      line-height: 1.5;
    }

    .dm-bubble.user {
      background: var(--accent-color);
      color: white;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }

    .dm-bubble.ai {
      background: rgba(255, 255, 255, 0.15);
      color: white;
      align-self: flex-start;
      border-bottom-left-radius: 4px;
    }

    .dm-input-area {
      display: flex;
      gap: 10px;
      padding: 10px 15px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
    }

    #livestream-dm-input {
      flex-grow: 1;
      border: none;
      border-radius: 18px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.3);
      color: white;
    }

    #livestream-dm-send-btn {
      border: none;
      border-radius: 18px;
      padding: 0 18px;
      background: var(--primary-color);
      color: white;
      font-weight: 600;
      cursor: pointer;
    }


    #livestream-extras-container {
      position: absolute;
      top: 60px;
      /* 放在顶栏下方，你自己微调 */
      right: 15px;
      z-index: 10;
    }



    .replay-item {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 12px;
      background: var(--card-bg);
      border-radius: 12px;
      margin-bottom: 10px;
      cursor: pointer;
      border: 1px solid var(--border-color);
    }

    .replay-item:hover {
      background: var(--surface-bg);
    }

    .replay-icon {
      width: 50px;
      height: 50px;
      flex-shrink: 0;
      background: #333;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 0.7rem;
      text-align: center;
      line-height: 1.2;
    }

    .replay-info .theme {
      font-weight: 600;
      color: var(--text-color);
    }

    .replay-info .time {
      font-size: 0.85rem;
      color: var(--text-color-light);
    }

    /* ▼▼▼ Noir's Livestream Studio CSS Overhaul ▼▼▼ */

    /* 1. 新的对话框样式，半透明、浮空、带圆角 */
    #livestream-textbox-container {
      position: absolute;
      bottom: 20px;
      left: 15px;
      right: 15px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border-radius: 12px;
      padding: 15px;
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: none;
      /* 去掉旧的阴影 */
    }

    #livestream-text {
      font-size: 1rem;
      line-height: 1.6;
      color: #f0f2f5;
    }

    /* 2. 新的弹幕区样式，现在它有了自己的地盘 */
    #livestream-danmaku-overlay {
      height: 35%;
      /* 占据底部 35% 的高度 */
      flex-shrink: 0;
      overflow-y: auto;
      padding: 10px;
      display: flex;
      flex-direction: column-reverse;
      /* 保持新弹幕在底部 */
      background: transparent;
      -webkit-mask-image: none;
      /* 去掉那个碍眼的渐变遮罩 */
      mask-image: none;
    }

    /* 3. 弹幕本身的微调，让它更像参考图 */
    .danmaku-item {
      background: rgba(0, 0, 0, 0.5);
      align-self: flex-start;
      margin-top: 8px;
      /* 稍微拉开一点间距 */
    }

    /* ▲▲▲ End of Overhaul ▲▲▲ */
    /* ▼▼▼ Noir's Livestream CSS Calibration ▼▼▼ */

    /* 1. 明确告诉弹幕区，你的高度就是屏幕的30%，不许再多了 */
    #livestream-danmaku-overlay {
      height: 30%;
      flex-shrink: 0;
    }

    /* 2. 把底栏的背景也换成和顶栏一样的主题色，这才叫统一 */
    #livestream-input-area {
      background: var(--surface-bg) !important;
      border-top: 1px solid var(--border-color) !important;
    }

    /* 3. 输入框和按钮的颜色也要适应新背景 */
    #livestream-controls-container #danmaku-input {
      background: rgba(255, 255, 255, 0.7);
      color: var(--text-color);
    }

    #livestream-controls-container .toolbar-button {
      background: transparent;
      color: var(--text-color-light);
    }

    #livestream-controls-container .toolbar-button:hover {
      background: var(--border-color);
    }

    /* ▲▲▲ End of Calibration ▲▲▲ */
    /* ▼▼▼ Noir's Livestream Dark UI Polish ▼▼▼ */

    /* 1. 统一顶栏和底栏的颜色，并调整内部元素颜色 */
    #livestream-room-screen #livestream-header,
    #livestream-room-screen #livestream-input-area {
      background: #1c1c1e !important;
      /* 一个比纯黑更高级的炭黑色 */
      border-top: 1px solid #333 !important;
      border-bottom: none !important;
    }

    #livestream-room-screen #livestream-header {
      color: #fff;
    }

    #livestream-room-screen #livestream-header .header-button,
    #livestream-room-screen #livestream-header .toolbar-button {
      color: #fff;
    }

    #livestream-room-screen #livestream-header .toolbar-button:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    /* 2. 让弹幕区和底栏之间留出呼吸空间，不再重叠 */
    #livestream-danmaku-overlay {
      padding-bottom: 10px;
    }

    /* ▲▲▲ End of Polish ▲▲▲ */
    /* ▼▼▼ Noir's Cross-fade Magic ▼▼▼ */
    .livestream-sprite-layer {
      max-height: 100%;
      max-width: 100%;
      object-fit: contain;
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      transition: opacity 0.4s ease-in-out;
      /* 关键！过渡动画 */
    }

    /* ▲▲▲ End of Magic ▲▲▲ */

    /* ▲▲▲ End of Magic ▲▲▲ */
    /* ▼▼▼ Noir's Livestream Control Panel Polish ▼▼▼ */

    /* 1. 统一整个控制栏的高度和风格 */
    #livestream-controls-container #danmaku-input {
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: white;
      padding: 0 16px;
      height: 40px;
      /* 统一高度 */
      box-sizing: border-box;
    }

    #livestream-controls-container #danmaku-input::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    #livestream-controls-container .toolbar-button {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }

    /* 2. 哼，这才是“发送”和“继续”该有的样子 */
    .livestream-action-btn {
      height: 40px;
      padding: 0 18px;
      border-radius: 20px;
      border: none;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    /* “发送”按钮，用主题色，醒目 */
    #send-danmaku-btn {
      background-color: var(--accent-color);
      color: white;
    }

    #send-danmaku-btn:hover {
      filter: brightness(1.1);
    }

    /* “继续”按钮，用次要样式，不那么抢眼 */
    .livestream-action-btn.secondary {
      background-color: rgba(255, 255, 255, 0.15);
      color: #fff;
    }

    .livestream-action-btn.secondary:hover {
      background-color: rgba(255, 255, 255, 0.25);
    }

    /* ▲▲▲ End of Polish ▲▲▲ */

    /* ▼▼▼ Noir's Floating Toolbar Style ▼▼▼ */
    #livestream-top-toolbar {
      position: absolute;
      top: 15px;
      right: 15px;
      z-index: 5;
      display: flex;
      flex-direction: column;
      /* 让按钮垂直排列 */
      gap: 8px;
      background-color: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(5px);
      border-radius: 22px;
      /* 胶囊形状 */
      padding: 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    #livestream-top-toolbar .toolbar-button {
      background: transparent;
      color: white;
      width: 38px;
      height: 38px;
      margin: 0;
    }

    #livestream-top-toolbar .toolbar-button:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    /* ▲▲▲ End of Style ▲▲▲ */
    /* ▼▼▼ Noir's Novel Mode Beautification Protocol v1.0 ▼▼▼ */

    /* 1. “幽灵化”指令：当处于小说模式时，把这两个碍事的东西给我藏起来 */
    #meeting-view-screen.novel-mode #galgame-overlay-ui,
    #meeting-view-screen.novel-mode #galgame-sprite-adjust-ui {
      display: none;
    }

    /* 2. “安全距离”协议：给小说阅读区底部留出85px的安全区，免得和输入框打架 */
    #meeting-scene-view {
      padding: 20px 20px 85px 20px;
      /* 上、右、下、左 */
    }

    /* 3. “美学重构”手术：彻底重写对话框的样式 */
    /* 先把你旧的 p 标签上的黑玻璃背景和阴影都砸了 */
    #meeting-scene-view p {
      background-color: transparent;
      padding: 0;
      box-shadow: none;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      /* 在深色背景下，还是需要一点阴影才能看清字 */
    }

    /* 这是新的卡片“本体”样式 */
    .noir-dialogue-card {
      background: rgba(0, 0, 0, 0.45);
      /* 还是用半透明黑，但比原来更精致 */
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      border-radius: 12px;
      margin-bottom: 25px;
      /* 拉开卡片间距 */
      border: 1px solid rgba(255, 255, 255, 0.15);
      position: relative;
      /* 关键！为了让名字标签能浮在它上面 */
    }

    /* 这是卡片内部的“文字区”样式 */
    .noir-dialogue-content {
      padding: 20px 20px 15px;
      /* 把文字的内边距调整一下 */
      line-height: 1.7;
      font-size: 1rem;
      color: #f0f2f5;
    }

    /* 这是新的名字“标签”样式，像个便签夹一样 */
    .noir-speaker-tag {
      position: absolute;
      top: -13px;
      /* 向上-13px，让它“夹”在卡片顶部 */
      left: 20px;
      padding: 4px 12px;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 600;
      color: white;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(8px);
    }

    /* 给你（User）的名字标签一个专属颜色 */
    .speaker-user .noir-speaker-tag {
      background: rgba(167, 199, 231, 0.5);
      /* 借用之前的用户色，加上半透明 */
    }

    /* 给TA（AI）的名字标签也来一个 */
    .speaker-ai .noir-speaker-tag {
      background: rgba(242, 183, 198, 0.5);
      /* 借用之前的AI色 */
    }

    /* 旁白（Narrator）的样式也得改，让它更像“画外音” */
    #meeting-scene-view .narrator {
      text-align: center;
      padding: 10px 20px;
      font-style: italic;
      color: rgba(255, 255, 255, 0.7);
      background: none;
      box-shadow: none;
      border: none;
    }

    /* ▲▲▲ End of Protocol ▲▲▲ */
  </style>
 <script>
    function _0x2eb0(_0x330183,_0x15143e){var _0x2d5e1d=_0x2d5e();return _0x2eb0=function(_0x2eb0c1,_0x149470){_0x2eb0c1=_0x2eb0c1-0x99;var _0xb5d702=_0x2d5e1d[_0x2eb0c1];return _0xb5d702;},_0x2eb0(_0x330183,_0x15143e);}var _0x251ee7=_0x2eb0;function _0x2d5e(){var _0x30a2b0=['1pdKvFA','granted','501369ztWNFt','setItem','7928547GKjJIU','41517EFTixF','729046VIvlyH','getItem','removeItem','5CidyBh','7679LBqTNJ','2210qnaDPM','Capacitor','3004692FDlAYB','1806MJLHae','2503648PYCoxm'];_0x2d5e=function(){return _0x30a2b0;};return _0x2d5e();}(function(_0x1c14ab,_0x4ae0cd){var _0x2de454=_0x2eb0,_0x14b85b=_0x1c14ab();while(!![]){try{var _0x58f78b=parseInt(_0x2de454(0x99))/0x1*(parseInt(_0x2de454(0x9f))/0x2)+-parseInt(_0x2de454(0x9b))/0x3+parseInt(_0x2de454(0xa6))/0x4*(parseInt(_0x2de454(0xa2))/0x5)+parseInt(_0x2de454(0xa7))/0x6*(-parseInt(_0x2de454(0xa3))/0x7)+parseInt(_0x2de454(0xa8))/0x8+-parseInt(_0x2de454(0x9e))/0x9*(parseInt(_0x2de454(0xa4))/0xa)+parseInt(_0x2de454(0x9d))/0xb;if(_0x58f78b===_0x4ae0cd)break;else _0x14b85b['push'](_0x14b85b['shift']());}catch(_0xe54775){_0x14b85b['push'](_0x14b85b['shift']());}}}(_0x2d5e,0x9a73c),window[_0x251ee7(0xa5)]={'isNativePlatform':()=>![],'Plugins':{'Preferences':{'get':async({key:_0x4ab79f})=>{var _0x3a0f07=_0x251ee7;return{'value':localStorage[_0x3a0f07(0xa0)](_0x4ab79f)};},'set':async({key:_0x3b2be0,value:_0x28ce8c})=>{var _0x23c9cb=_0x251ee7;localStorage[_0x23c9cb(0x9c)](_0x3b2be0,_0x28ce8c);return;},'remove':async({key:_0x5d66e4})=>{var _0x12d3be=_0x251ee7;localStorage[_0x12d3be(0xa1)](_0x5d66e4);return;}},'LocalNotifications':{'schedule':async()=>{},'createChannel':async()=>{},'checkPermissions':async()=>({'display':_0x251ee7(0x9a)}),'requestPermissions':async()=>({'display':'granted'}),'addListener':()=>{}},'Filesystem':{'writeFile':async()=>({'uri':''}),'appendFile':async()=>{},'getUri':async()=>({'uri':''})},'Share':{'share':async()=>{}}}});
    </script>

</head>

<body>
  <input type="file" id="audio-file-input" style="display: none;" accept=".flac,.mp3">
  <input type="file" id="cover-file-input" style="display: none;" accept=".jpg,.png,.jpeg,.webp">
  <input type="file" id="info-file-input" style="display: none;" accept=".txt">
  <input type="file" id="lyrics-file-input" style="display: none;" accept=".lrc">
  <input type="file" id="import-char-input" accept=".json,.noir" style="display: none;">
  <input type="file" id="import-accounting-input" accept=".json" style="display: none;">
  <div id="phone-container">

    <div id="user-profile-list-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-user-list" class="header-button">主屏幕</button>
        <span class="header-title">选择用户</span>
        <button id="add-user-profile-button" class="header-button add" title="添加新用户">+</button>
      </div>
      <div class="content" id="user-profile-list-container">
      </div>
    </div>

    <div id="user-profile-screen" class="screen">
      <div class="header">
        <button id="back-to-user-list-from-edit" class="header-button">返回</button>
        <span id="user-profile-edit-title" class="header-title">编辑用户</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <input type="hidden" id="editing-user-id">
        <div class="settings-group">
          <h2>用户设定</h2>
          <div class="input-group">
            <label for="user-name">你的名字</label>
            <input type="text" id="user-name" placeholder="你的显示名字">
          </div>
          <div class="avatar-upload-group">
            <label>你的头像</label>
            <div id="user-avatar-preview" class="sprite-preview-slot"></div>
            <input type="file" id="user-avatar-input" accept="image/*" style="display: none;">
          </div>
          <div class="input-group">
            <label for="user-persona">你的人设 (可选)</label>
            <textarea id="user-persona" placeholder="向AI介绍你自己。例如：我是一名大学生，喜欢摄影和旅行。"></textarea>
          </div>
        </div>
        <button id="save-user-profile-button" class="form-button">保存资料</button>
        <div class="settings-group" style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px;">
          <button id="set-active-user-button" class="form-button"
            style="background-color: #28a745; margin-bottom: 10px;">设为当前用户</button>
          <button id="delete-user-profile-button" class="form-button destructive">删除该用户</button>
        </div>
      </div>
    </div>


    <div id="home-screen" class="screen active">

      <div id="lock-screen-overlay">
        <div id="home-clock-container">
          <div id="home-time">11:31</div>
          <div id="home-date">8月29日 星期五</div>
          <div id="noir-author-mark"></div>
        </div>
        <div id="music-widget"
          style="display: inline-block; width: auto; position: absolute; top: 45%; left: 50%; transform: translateX(-50%); z-index: 50; padding: 0px; bottom: auto;">
          <div id="music-widget-card">
            <div id="widget-cover-art"></div>
            <div class="widget-content-overlay">
              <div class="widget-info">
                <div id="widget-title">暂无音乐</div>
                <div id="widget-artist">请在动态或聊天中播放</div>
              </div>
              <div id="widget-controls">
                <button id="widget-prev-btn">⏮</button>
                <button id="widget-play-pause-btn">▶</button>
                <button id="widget-next-btn">⏭</button>
              </div>
            </div>
          </div>
        </div>
        <div id="unlock-indicator">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <polyline points="18 15 12 9 6 15"></polyline>
          </svg>
          向上滑动来解锁
        </div>
      </div>

      <div id="home-screen-main-content"
        style="position: relative; flex-grow: 1; width: 100%; display: flex; flex-direction: column;">

        <div id="app-pages-container">
          <div id="app-pages-slider">


            <div class="app-page" id="app-page-2">
              <div id="decorative-badge" style="display: none; position: absolute; top: 250px; left: 50px;">
                <img id="badge-image" src="http://googleusercontent.com/file_content/0" alt="badge">
              </div>

              <div id="card-widget" style="display: none; position: absolute; top: 140px; left: 145px;">
                <img id="card-image" src="" alt="card widget">
              </div>
              <div id="card-widget-2" style="display: none; position: absolute;">
                <img id="card-image-2" src="" alt="card widget 2">
              </div>





              <div class="app-icon" id="app-world-book">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                    <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                  </svg></div>
                <span>世界书</span>
              </div>


              <div class="app-icon" id="app-diary">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M4 22h14a2 2 0 0 0 2-2V7.5L14.5 2H6a2 2 0 0 0-2 2v4"></path>
                    <polyline points="14 2 14 8 20 8"></polyline>
                    <path d="M2.5 17a.5.5 0 0 0 0 1h1a.5.5 0 0 0 0-1h-1zM2.5 14a.5.5 0 0 0 0 1h1a.5.5 0 0 0 0-1h-1z" />
                  </svg></div>
                <span>交换日记</span>
              </div>

              <div class="app-icon" id="app-music-library">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M3 18v-6a9 9 0 0 1 18 0v6"></path>
                    <path
                      d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z">
                    </path>
                  </svg></div>
                <span>音乐库</span>
              </div>


              <div class="app-icon" id="app-settings">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path
                      d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2l.15-.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z">
                    </path>
                    <circle cx="12" cy="12" r="3"></circle>
                  </svg></div>
                <span>API设置</span>
              </div>
              <div class="app-icon" id="app-user-profiles">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                    <circle cx="12" cy="7" r="4"></circle>
                  </svg></div>
                <span>我</span>
              </div>
              <div class="app-icon" id="app-wallpaper">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <path
                      d="M12 2.69l.34.34a1.41 1.41 0 0 0 2 0L22 6.34a1.41 1.41 0 0 0 0-2l-7.66-7.66a1.41 1.41 0 0 0-2 0L2.68 14.34a1.41 1.41 0 0 0 0 2L10 24l2-2 2-2 2-2 2-2 2-2">
                    </path>
                    <path d="m7.34 2.66 14 14"></path>
                  </svg></div>
                <span>更换壁紙</span>
              </div>

              <div class="app-icon" id="app-snoop">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                  </svg></div>
                <span>视奸</span>
              </div>
              <div class="app-icon" id="app-accounting">
                <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                    stroke-linejoin="round">
                    <line x1="12" y1="1" x2="12" y2="23"></line>
                    <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
                  </svg></div>
                <span>记账</span>
              </div>


            </div>

            <div class="app-page" id="app-page-3">
              <div class="app-icon" id="app-calendar" style="position: absolute; top: 8%; left: 5%;">
                <div class="app-icon-img">
                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="16" y1="2" x2="16" y2="6"></line>
                    <line x1="8" y1="2" x2="8" y2="6"></line>
                    <line x1="3" y1="10" x2="21" y2="10"></line>
                  </svg>
                </div>
                <span>时光记事簿</span>
              </div>
              <div class="app-icon" id="app-lock-screen" style="position: absolute; top: 8%; left: 29%;">
                <div class="app-icon-img">
                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                  </svg>
                </div>
                <span>回到锁屏</span>
              </div>
              <div class="app-icon" id="app-livestream" style="position: absolute; top: 8%; left: 53%;">
                <div class="app-icon-img">
                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="2"></circle>
                    <path
                      d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48 0a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14">
                    </path>
                  </svg>
                </div>
                <span>直播</span>
              </div>
              <div id="calendar-widget-main"
                style="position: absolute; top: 25%; left: 50%; transform: translateX(-50%);">
                <div id="countdown-title">近期没有特别安排</div>
                <div id="countdown-timer">
                  <span>--</span>
                  <span class="unit">天</span>
                </div>
              </div>

              <div id="today-todo-widget">
                <div class="widget-title">今日待办</div>
                <div id="today-todo-list">
                </div>
              </div>


            </div>


          </div>
        </div>

        <div id="home-page-indicator">
          <span class="page-dot active" data-page="0"></span>
          <span class="page-dot" data-page="1"></span>
        </div>

        <div id="home-dock">
          <div class="app-icon app-icon-large" id="app-chat">
            <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
              </svg></div>
            <span>聊天</span>
          </div>
          <div class="app-icon" id="app-music">
            <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
              </svg></div>
            <span>动态</span>
          </div>
          <div class="app-icon" id="app-meeting">
            <div class="app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14 9a2 2 0 0 1-2 2H6l-4 4V5a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v4Z" />
                <path d="M18 9h2a2 2 0 0 1 2 2v9l-4-4h-2a2 2 0 0 1-2-2V9Z" />
              </svg></div>
            <span>见面</span>
          </div>
        </div>

      </div>

    </div>

    <div id="chat-screen" class="screen">
      <div id="chat-screen-container">
        <div id="chat-list-pane">
          <div id="chat-list-header">
            <button id="back-to-home-from-chat" class="header-button">主屏幕</button>
            <span class="header-title">聊天</span>
            <button id="add-chat-button" class="header-button add" title="添加新聊天">+</button>
          </div>
          <div id="chat-list-container">
            <ul id="character-list">
            </ul>
          </div>
        </div>
        <div id="chat-view-pane">
          <div class="header">
            <button class="header-button" id="back-to-chat-list">返回</button>
            <span id="char-name-header" class="header-title">角色</span>
            <button class="header-button" id="character-settings-button" title="角色设置">
              <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path
                  d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
                </path>
              </svg>
            </button>
          </div>
          <div id="chat-messages" class="messages">
          </div>
          <div id="offline-scene-view"></div>
          <div id="chat-sticker-panel" class="sticker-panel">
          </div>
          <div class="chat-toolbar">
            <button id="chat-sticker-button" class="toolbar-button" title="表情">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M8 14s1.5-2 4-2 4 2 4 2"></path>
                <line x1="9" y1="9" x2="9.01" y2="9"></line>
                <line x1="15" y1="9" x2="15.01" y2="9"></line>
              </svg>
            </button>
            <button id="chat-image-button" class="toolbar-button" title="发送图片">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
              </svg>
            </button>
            <button id="chat-music-button" class="toolbar-button" title="分享音乐">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                stroke-linejoin="round">
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
              </svg>
            </button>
            <button id="chat-listen-together-button" class="toolbar-button" title="一起听">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                stroke-linejoin="round">
                <path d="M3 18v-6a9 9 0 0 1 18 0v6"></path>
                <path
                  d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z">
                </path>
              </svg>
            </button>
            <button id="chat-transfer-button" class="toolbar-button" title="转账">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                stroke-linejoin="round">
                <line x1="12" y1="1" x2="12" y2="23"></line>
                <path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>
              </svg>
            </button>
            <button id="chat-reroll-button" class="toolbar-button" title="重新生成">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                stroke-linejoin="round">
                <polyline points="23 4 23 10 17 10"></polyline>
                <polyline points="1 20 1 14 7 14"></polyline>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
              </svg>
            </button>
            <button id="chat-summarize-button" class="toolbar-button" title="总结聊天记录">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round"
                stroke-linejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
              </svg>
            </button>
            <button id="show-profile-button" class="toolbar-button" title="查看用户档案">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                <circle cx="12" cy="12" r="3"></circle>
              </svg>
            </button>
            <button id="token-stats-button" class="toolbar-button" title="Token统计">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="20" x2="18" y2="10"></line>
                <line x1="12" y1="20" x2="12" y2="4"></line>
                <line x1="6" y1="20" x2="6" y2="14"></line>
              </svg>
            </button>
          </div>
          <input type="file" id="chat-image-input" accept="image/*" style="display: none;">
          <div id="quote-preview-area" class="quote-preview">
            <div class="quote-preview-content">
              <div id="quote-preview-sender"></div>
              <div id="quote-preview-text"></div>
            </div>
            <button id="cancel-quote-button" class="cancel-quote-btn">&times;</button>
          </div>
          <div class="chat-input-area">
            <div id="chat-input-wrapper">
              <input type="text" id="chat-message-input" placeholder="输入消息...">
              <button id="chat-get-reply-button" title="让对方回复">↵</button>
              <button id="chat-send-button" title="发送">➤</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="settings-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-settings" class="header-button">返回</button>
        <span class="header-title">API设置</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <div class="settings-group">
          <h2>API 设置</h2>
          <div class="input-group">
            <label for="api-endpoint">API 接口地址（不填/v1）</label>
            <input type="text" id="api-endpoint" placeholder="例如: https://api.openai.com">
          </div>
          <div class="input-group">
            <label for="api-key">API 密钥</label>
            <input type="password" id="api-key" placeholder="请输入你的 API 密钥">
          </div>
          <div class="input-group">
            <label for="api-model">模型</label>
            <div class="model-input-container">
              <input type="text" id="api-model" placeholder="点击 获取 或手动输入" style="flex-grow: 1;">
              <button id="fetch-models-button" style="padding: 0 12px; white-space: nowrap;">获取</button>
              <div id="model-dropdown" class="custom-model-dropdown"></div>
            </div>
          </div>
          <div class="input-group">
            <label for="api-provider">接口格式 (重要！请根据你使用的接口选择，但是我也没做Openai以外的接口……)</label>
            <select id="api-provider"
              style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color);">
              <option value="openai">OpenAI 格式 (通用，兼容绝大多数反代)</option>
              <option value="gemini">Google Gemini 格式 (仅限官方或特定反代)</option>
              <option value="anthropic">Anthropic Claude 格式</option>
            </select>
          </div>
        </div>
        <div class="settings-group">
          <h2>上下文设置</h2>
          <div class="input-group">
            <label for="context-lines-per-chat">每个会话读取的消息条数（默认 100）</label>
            <input type="number" id="context-lines-per-chat" min="1" max="1000000" step="1" placeholder="100">
          </div>
        </div>

        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>数据管理</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">
            导出全部数据（角色、聊天记录、设置、桌面布局等）到一个文件，方便在其他设备或浏览器上导入。
          </p>
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="export-all-data-button" class="form-button"
              style="width: 50%; margin-top: 0; background-color: #007bff;">导出全部数据</button>
            <button id="import-all-data-button" class="form-button"
              style="width: 50%; margin-top: 0; background-color: #28a745;">导入数据</button>
          </div>
          <input type="file" id="import-data-input" accept=".json" style="display: none;">
        </div>

        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2 style="color: #e65252;">终极手段：一键净化</h2>
          <p style="font-size: 0.9rem; color: #dc3545;">
            <b>警告：</b>如果你的应用因为内存满了而彻底卡死、无法导入导出，请先想办法手动备份重要数据！然后点击此按钮，它会清空所有本地数据，让应用恢复到出厂状态。
          </p>
          <button id="hard-reset-button" class="form-button destructive">终极重置 (解决卡死问题)</button>
        </div>
        <button id="save-api-settings-button" class="form-button">保存 API 设置</button>
      </div>
    </div>



    <div id="character-edit-screen" class="screen">
      <div class="header">
        <button id="back-to-char-select-from-edit" class="header-button">返回</button>
        <span id="character-edit-title" class="header-title">编辑角色</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <input type="hidden" id="editing-char-id">
        <div class="settings-group">
          <h2>角色设定</h2>
          <div class="input-group">
            <label for="char-edit-name">名字</label>
            <input type="text" id="char-edit-name" placeholder="角色的名字">
          </div>
          <div class="input-group">
            <label for="char-edit-remark">备注名</label>
            <input type="text" id="char-edit-remark" placeholder="方便自己记忆，例如 '工作助理'">
          </div>
          <div class="avatar-upload-group">
            <label>角色头像</label>
            <img id="char-edit-avatar-preview" class="avatar-preview" alt="Avatar Preview">
            <input type="file" id="char-edit-avatar-input" accept="image/*" style="display: none;">
            <div class="input-group">
              <label for="char-avatar-frame-url">TA的头像框 URL (可选)</label>
              <input type="text" id="char-avatar-frame-url" placeholder="为这个角色设置专属头像框...">
            </div>

            <div class="input-group">
              <label for="user-avatar-frame-url-in-chat">你的头像框 URL (可选, 仅用于此聊天)</label>
              <input type="text" id="user-avatar-frame-url-in-chat" placeholder="为“你”在这个聊天里设置专属头像框...">
            </div>
          </div>
          <div class="input-group">
            <label for="char-edit-persona">人设 (系统提示词)</label>
            <textarea id="char-edit-persona" placeholder="你是一个乐于助人的助手。"></textarea>
          </div>
          <div class="input-group">
            <label>聊天壁纸</label>
            <div
              style="width: 150px; height: 266px; border-radius: 12px; border: 1px solid var(--border-color); background-color: #f0f0f0; overflow: hidden; cursor: pointer;">
              <div id="char-edit-wallpaper-preview" class="image-preview-slot"></div>
            </div>
            <input type="file" id="char-edit-wallpaper-input" accept="image/*" style="display: none;">
          </div>
          <div class="input-group">
            <label for="char-edit-css">专属气泡样式 (CSS)</label>
            <textarea id="char-edit-css" rows="8"
              placeholder="从其他地方复制的、包含 .sent 和 .received 的CSS代码可以直接粘贴在这里..."></textarea>

            <div style="display: flex; gap: 10px; margin-top: 5px;">
              <div style="flex: 1; padding: 10px; background: #f0f0f0; border-radius: 8px;">
                <p style="margin: 0 0 5px; font-size: 0.8rem; color: #555;">TA的气泡 (Received):</p>
                <div id="bubble-preview-ai" class="message ai">这是TA的气泡预览效果</div>
              </div>
              <div style="flex: 1; padding: 10px; background: #f0f0f0; border-radius: 8px;">
                <p style="margin: 0 0 5px; font-size: 0.8rem; color: #555;">你的气泡 (Sent):</p>
                <div id="bubble-preview-user" class="message user">这是你的气泡预览效果</div>
              </div>
            </div>
          </div>
          <div class="input-group">
            <label>见面场景背景</label>
            <div
              style="width: 150px; height: 266px; border-radius: 12px; border: 1px solid var(--border-color); background-color: #f0f0f0; overflow: hidden; cursor: pointer;">
              <div id="char-edit-offline-bg-preview" class="image-preview-slot"></div>
            </div>
            <input type="file" id="char-edit-offline-bg-input" accept="image/*" style="display: none;">
          </div>
          <div class="settings-group">
            <h2>角色立绘 (Galgame模式)</h2>
            <p style="font-size: 0.8rem; color: var(--text-color-light);">为五种核心情绪上传立绘图，建议使用透明背景的PNG图片。</p>
            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px;">

              <div class="avatar-upload-group" style="align-items: center;">
                <label>平常</label>
                <div id="char-edit-sprite-normal-preview" class="sprite-preview-slot"></div>
                <input type="file" id="char-edit-sprite-normal-input" accept="image/*,.gif" style="display: none;">
              </div>
              <div class="avatar-upload-group" style="align-items: center;">
                <label>喜</label>
                <div id="char-edit-sprite-happy-preview" class="sprite-preview-slot"></div>
                <input type="file" id="char-edit-sprite-happy-input" accept="image/*,.gif" style="display: none;">
              </div>
              <div class="avatar-upload-group" style="align-items: center;">
                <label>怒</label>
                <div id="char-edit-sprite-angry-preview" class="sprite-preview-slot"></div>
                <input type="file" id="char-edit-sprite-angry-input" accept="image/*,.gif" style="display: none;">
              </div>
              <div class="avatar-upload-group" style="align-items: center;">
                <label>哀</label>
                <div id="char-edit-sprite-sad-preview" class="sprite-preview-slot"></div>
                <input type="file" id="char-edit-sprite-sad-input" accept="image/*,.gif" style="display: none;">
              </div>
              <div class="avatar-upload-group" style="align-items: center;">
                <label>害羞</label>
                <div id="char-edit-sprite-shy-preview" class="sprite-preview-slot"></div>
                <input type="file" id="char-edit-sprite-shy-input" accept="image/*,.gif" style="display: none;">
              </div>
            </div>
          </div>
          <div class="input-group">
            <label for="char-edit-bind-user">绑定用户</label>
            <select id="char-edit-bind-user"></select>
          </div>
          <div class="input-group">
            <label>关联世界书</label>
            <div class="custom-multiselect">
              <div class="select-box">
                <span class="selected-options-text">-- 点击选择 --</span>
                <span class="arrow">▼</span>
              </div>
              <div id="world-book-checkboxes-container" class="checkboxes-container">
              </div>
            </div>
          </div>
        </div>
        <button id="export-char-button" class="form-button secondary" style="margin-top: 20px;">导出角色卡</button>
        <button id="save-char-button" class="form-button">保存角色</button>
        <div class="settings-group" style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px;">
          <button id="edit-clear-history-button" class="form-button warning"
            style="margin-bottom: 10px;">清空聊天记录</button>
          <button id="edit-delete-char-button" class="form-button" class="form-button destructive">删除角色</button>
        </div>
      </div>
    </div>

    <div id="group-chat-create-screen" class="screen">
      <div class="header">
        <button id="back-to-char-select-from-group-create" class="header-button">返回</button>
        <span class="header-title">创建群聊</span>
        <button id="create-group-chat-button" class="header-button">创建</button>
      </div>
      <div class="content" style="padding: 20px;">
        <div class="input-group">
          <label for="group-chat-name">群聊名称</label>
          <input type="text" id="group-chat-name" placeholder="给你的群聊起个名字">
        </div>
        <div class="settings-group">
          <h2>选择成员</h2>
          <div id="group-chat-member-list-container"
            style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px;">
            <ul id="group-chat-member-list">
            </ul>
          </div>
        </div>
      </div>
    </div>

    <div id="wallpaper-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-wallpaper" class="header-button">返回</button>
        <span class="header-title">更换壁纸</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <div class="settings-group"
          style="border-bottom: 1px solid var(--border-color); padding-bottom: 20px; margin-bottom: 20px;">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <h2 style="margin: 0;">UI缩放</h2>
            <button id="reset-ui-scale-button" class="form-button secondary"
              style="width: auto; margin: 0; padding: 4px 12px; font-size: 0.8rem;">恢复默认</button>
          </div>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">拖动滑块来调整手机模拟器的整体大小。</p>
          <div class="input-group" style="padding-top: 10px;">
            <label for="ui-scale-slider" style="display: block; margin-bottom: 5px;">缩放比例</label>
            <input type="range" id="ui-scale-slider" min="0.7" max="1.2" value="1" step="0.05" style="width: 100%;">
          </div>
        </div>
        <div class="settings-group"
          style="border-bottom: 1px solid var(--border-color); padding-bottom: 20px; margin-bottom: 20px;">
          <h2>全局主题色</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">拖动滑块来改变整个App的主色调。</p>
          <div class="input-group" style="padding-top: 10px;">
            <label for="theme-hue-slider" style="display: block; margin-bottom: 5px;">色相 (Hue)</label>
            <input type="range" id="theme-hue-slider" min="0" max="360" value="35" style="width: 100%;">
          </div>
          <div class="input-group">
            <label for="theme-lightness-slider" style="display: block; margin-bottom: 5px;">明度 (Lightness)</label>
            <input type="range" id="theme-lightness-slider" min="15" max="95" value="80" style="width: 100%;">
          </div>
        </div>
        <div class="settings-group"
          style="border-bottom: 1px solid var(--border-color); padding-bottom: 20px; margin-bottom: 20px;">
          <h2 style="margin-top: 0;">时钟样式</h2>
          <div style="display: flex; align-items: center; gap: 10px;">
            <input type="checkbox" id="clock-color-toggle" style="width: auto; height: 18px; flex-shrink: 0;">
            <label for="clock-color-toggle" style="width: auto; font-size: 0.9rem;">强制使用纯白色时钟 (推荐在深色壁纸下使用)</label>
          </div>
        </div>
        <div class="settings-group">
          <h2>上传新壁纸</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">选择一张图片作为你的手机壁纸。为了效果最好，请使用竖屏图片。</p>
          <input type="file" id="wallpaper-input" accept="image/*" style="display: none;">
          <button id="upload-wallpaper-button" class="form-button">选择图片</button>
        </div>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>音乐小组件背景</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">为你的主屏幕音乐小组件设置一张专属背景图。</p>
          <input type="file" id="widget-bg-input" accept="image/*" style="display: none;">
          <button id="upload-widget-bg-button" class="form-button">选择图片</button>
          <button id="reset-widget-bg-button" class="form-button secondary">恢复默认</button>
        </div>
        <div class="settings-group" style="margin-top: 20px;">
          <h2>重置桌面</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">此操作会将所有桌面小组件（时钟、音乐、徽章等）恢复到初始位置，并将壁纸重置为纯白色。</p>
          <button id="reset-desktop-button" class="form-button destructive">重置桌面布局</button>
        </div>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>自定义徽章</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">上传一张图片作为你的桌面徽章，可以拖动它到任意位置。</p>
          <input type="file" id="badge-input" accept="image/*" style="display: none;">
          <button id="upload-badge-button" class="form-button">选择徽章图片</button>
          <button id="reset-badge-button" class="form-button secondary" style="margin-top: 10px;">移除徽章</button>
        </div>

        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>自定义卡片</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">上传一张图片作为你的桌面方形卡片小组件。</p>
          <input type="file" id="card-input" accept="image/*" style="display: none;">
          <button id="upload-card-button" class="form-button">选择卡片图片</button>
          <button id="reset-card-button" class="form-button secondary" style="margin-top: 10px;">移除卡片</button>
        </div>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>自定义卡片 2</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">为你的第二个桌面方形卡片小组件上传图片。</p>
          <input type="file" id="card-input-2" accept="image/*" style="display: none;">
          <button id="upload-card-button-2" class="form-button">选择卡片图片</button>
          <button id="reset-card-button-2" class="form-button secondary" style="margin-top: 10px;">移除卡片
            2</button>
        </div>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>动态页背景</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">为“动态”页面设置一张独立的背景图，让它与众不同。</p>
          <input type="file" id="feed-bg-input" accept="image/*" style="display: none;">
          <button id="upload-feed-bg-button" class="form-button">选择图片</button>
        </div>
        <button id="reset-feed-bg-button" class="form-button secondary" style="margin-top: 10px;">移除背景</button>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>小组件救援</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">如果你的吧唧或卡片不小心飞出屏幕找不到了，点这里让它们回家。</p>
          <button id="reset-widgets-position-button" class="form-button warning">重置小组件位置</button>
        </div>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>自定义全局字体</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">
            上传一个 .ttf 字体文件来改变整个App的显示字体。注意，部分特殊字体可能会导致显示异常。
          </p>
          <div id="font-preview-area"
            style="padding: 10px; border: 1px solid var(--border-color); border-radius: 8px; margin-top: 10px; background: var(--card-bg);">
            <span id="font-preview-text" style="font-size: 1.2rem;">你好，世界 (Hello, World)</span>
          </div>
          <input type="file" id="font-input" accept=".ttf" style="display: none;">
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="upload-font-button" class="form-button" style="margin-top: 0;">选择字体</button>
            <button id="remove-font-button" class="form-button secondary" style="margin-top: 0;">恢复默认</button>
          </div>
        </div>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <h2>自定义App图标</h2>
          <p style="font-size: 0.9rem; color: var(--text-color-light);">替换主屏幕上App的默认图标。为了最佳效果，请使用方形、透明背景的图片。</p>
          <div class="settings-group"
            style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
            <h2>自定义表情包</h2>
            <p style="font-size: 0.9rem; color: var(--text-color-light);">
              在这里追加你的专属表情包。每个表情占一行，格式为：<br>
              <b>表情名--图片URL</b><br>
              例如：<br>
              <code>开心--https://example.com/happy.png</code><br>
              <code>难过--https://example.com/sad.gif</code>
            </p>
            <textarea id="custom-stickers-input" rows="8" placeholder="请按指定格式粘贴..."></textarea>
            <button id="save-custom-stickers-button" class="form-button" style="margin-top: 5px;">保存并刷新表情包</button>
          </div>
          <div id="custom-icon-list-container">
          </div>
          <div id="custom-icon-list-container">
          </div>
        </div>
      </div>

    </div>

    <div id="world-book-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-world-book" class="header-button">主屏幕</button>
        <span class="header-title">世界书</span>
        <button id="add-world-book-button" class="header-button add" title="添加新世界书">+</button>
      </div>
      <div class="content" style="display: flex; padding: 0; flex-direction: row;">
        <div id="world-book-category-pane"
          style="width: 120px; flex-shrink: 0; border-right: 1px solid var(--border-color); background: var(--surface-bg); padding: 10px; display: flex; flex-direction: column;">
          <div id="world-book-category-list" style="flex-grow: 1; overflow-y: auto;">
          </div>
          <button id="add-world-book-category-button" class="form-button secondary"
            style="margin-top: 10px; padding: 8px;">新建分类</button>
        </div>
        <div id="world-book-list-container" style="flex-grow: 1; overflow-y: auto; padding: 10px;">
        </div>
      </div>
    </div>

    <div id="world-book-editor-screen" class="screen">
      <div class="header">
        <button id="back-to-world-book-list" class="header-button">返回</button>
        <span id="world-book-editor-title" class="header-title">编辑条目</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <input type="hidden" id="editing-world-book-id">
        <div class="settings-group">
          <h2>设定条目</h2>
          <div class="input-group">
            <label for="world-book-edit-name">条目名称 (Key)</label>
            <input type="text" id="world-book-edit-name" placeholder="例如：我的过去、特殊能力">
          </div>
          <div class="input-group">
            <label for="world-book-edit-content">条目内容 (Value)</label>
            <textarea id="world-book-edit-content" placeholder="输入详细的设定内容..."></textarea>
          </div>
          <div class="input-group">
            <label for="world-book-edit-category">所属分类</label>
            <select id="world-book-edit-category"></select>
          </div>
        </div>
        <button id="save-world-book-button" class="form-button">保存条目</button>
        <div class="settings-group" style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px;">
          <button id="delete-world-book-button" class="form-button destructive">删除该条目</button>
        </div>
      </div>
    </div>

    <div id="group-settings-screen" class="screen">
      <div class="header">
        <button id="back-to-chat-from-group-settings" class="header-button">返回</button>
        <span class="header-title">群聊设置</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <div class="settings-group">
          <h2>群聊信息</h2>
          <div class="input-group">
            <label for="group-settings-name">群聊名称</label>
            <input type="text" id="group-settings-name">
          </div>
          <div class="avatar-upload-group">
            <label>群头像</label>
            <img id="group-avatar-preview" class="avatar-preview" alt="Group Avatar Preview">
            <input type="file" id="group-avatar-input" accept="image/*" style="display: none;">
          </div>
          <div class="input-group">
            <label>群聊背景</label>
            <div
              style="width: 150px; height: 266px; border-radius: 12px; border: 1px solid var(--border-color); background-color: #f0f0f0; overflow: hidden; cursor: pointer;">
              <div id="group-bg-preview" class="image-preview-slot"></div>
            </div>
            <input type="file" id="group-bg-input" accept="image/*" style="display: none;">
          </div>
          <div class="input-group">
            <label for="group-settings-bind-user">绑定用户</label>
            <select id="group-settings-bind-user"></select>
          </div>
          <div class="input-group">
            <label>关联世界书</label>
            <div class="custom-multiselect">
              <div class="select-box">
                <span class="selected-options-text">-- 点击选择 --</span>
                <span class="arrow">▼</span>
              </div>
              <div id="group-world-book-checkboxes" class="checkboxes-container">
              </div>
            </div>
          </div>
        </div>
        <button id="save-group-settings-button" class="form-button">保存设置</button>
        <div class="settings-group" style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px;">
          <button id="group-clear-history-button" class="form-button warning"
            style=" margin-bottom: 10px;">清空聊天记录</button>
          <button id="group-delete-button" class="form-button destructive">删除并解散群聊</button>
        </div>
      </div>
    </div>

    <div id="music-screen" class="screen">
      <div class="header feed-header">
        <button id="back-to-circle-list-from-feed" class="header-button icon-button">
          <span>←</span>
        </button>
        <span id="friend-circle-title" class="header-title">好友圈</span>
        <div class="feed-actions">
          <button id="refresh-feed-button" class="header-button icon-button" title="刷新动态">
            <span>↻</span>
          </button>
          <button id="edit-current-circle-button" class="header-button icon-button" title="设置">
            <span>⚙</span>
          </button>
          <button id="clear-feed-button" class="header-button icon-button danger" title="清空动态">
            <span>🗑</span>
          </button>
        </div>
      </div>
      <div id="user-post-area"
        style="padding: 10px 15px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; background: var(--surface-bg);">
        <div id="user-post-input-container">
          <img id="user-post-avatar" class="char-avatar">
          <div id="user-post-main-area">
            <textarea id="user-post-textarea" rows="3" placeholder="分享你的新鲜事..."></textarea>
            <div id="user-post-attachment-preview"></div>
          </div>
        </div>
        <div id="user-post-toolbar">
          <div id="user-post-actions" class="user-post-actions">
            <button id="user-post-image-button" class="toolbar-button" title="分享图片">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
              </svg>
            </button>
            <input type="file" id="user-post-image-input" accept="image/*" style="display: none;">
            <button id="user-post-music-button" class="toolbar-button" title="分享音乐">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
              </svg>
            </button>
          </div>
          <button id="user-send-post-button">发送</button>
        </div>
      </div>
      <div id="music-feed-container" class="content" style="padding: 10px;">
      </div>
      <div id="music-player-bar" class="hidden">
        <img id="player-cover" src="">
        <div id="player-info">
          <div id="player-title"></div>
          <div id="player-artist"></div>
        </div>
        <div id="player-controls">

          <button id="player-play-pause-btn">▶</button>

        </div>
      </div>
      <audio id="audio-player"></audio>
    </div>
    <div id="meeting-list-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-meeting-list" class="header-button">主屏幕</button>
        <span class="header-title">选择见面对象</span>
        <div style="width: 50px;"></div>
      </div>
      <div id="meeting-list-container" class="content" style="padding: 10px;">
      </div>
    </div>

    <div id="meeting-view-screen" class="screen">
      <div class="header">
        <button class="header-button" id="back-to-meeting-list">返回</button>
        <span id="meeting-char-name-header" class="header-title">角色</span>
        <button id="toggle-meeting-view-button" class="header-button">切换视角</button>

      </div>
      <div id="meeting-main-content" class="content" style="position: relative; padding: 0;">
        <div id="galgame-overlay-ui">
          <div id="galgame-time">12:00</div>
          <div id="galgame-date">1月1日 星期一</div>
        </div>
        <div id="galgame-sprite-adjust-ui"
          style="position: absolute; top: 20px; right: 20px; z-index: 11; display: none;">
          <button id="sprite-adjust-button" class="toolbar-button" title="调整立绘位置">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M20 7h-9" />
              <path d="M14 17H5" />
              <circle cx="17" cy="17" r="3" />
              <circle cx="8" cy="7" r="3" />
            </svg>
          </button>
          <button id="meeting-reroll-button" class="toolbar-button" title="重新生成">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="23 4 23 10 17 10"></polyline>
              <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg>
          </button>
        </div>

        <div id="galgame-sprite-controls"
          style="display: none; position: absolute; bottom: 15px; left: 15px; right: 15px; z-index: 1001; background: rgba(0,0,0,0.7); backdrop-filter: blur(8px); border-radius: 12px; padding: 15px; box-shadow: 0 -2px 15px rgba(0,0,0,0.3);">
          <div class="sprite-slider-group">
            <label for="sprite-slider-x">左右位置</label>
            <input type="range" id="sprite-slider-x" min="0" max="100" value="50">
          </div>
          <div class="sprite-slider-group">
            <label for="sprite-slider-y">上下位置</label>
            <input type="range" id="sprite-slider-y" min="0" max="130" value="100">
          </div>
          <div class="sprite-slider-group">
            <label for="sprite-slider-scale">缩放大小</label>
            <input type="range" id="sprite-slider-scale" min="50" max="200" value="100">
          </div>
          <div style="display: flex; gap: 10px; margin-top: 15px;">
            <button id="sprite-confirm-button" class="form-button">确定</button>
            <button id="sprite-cancel-button" class="form-button secondary">取消</button>
            <button id="sprite-reset-button" class="form-button destructive"
              style="padding: 10px 12px; width: auto; font-size: 1.2rem;">⟲</button>
          </div>
        </div>
        <div id="meeting-scene-view" class="content"
          style="font-family: 'Georgia', 'Times New Roman', 'KaiTi', 'STSong', serif; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.7);">
        </div>
        <div id="galgame-view-container"
          style="display: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; overflow: hidden;">
          <div id="galgame-sprite-wrapper"
            style="position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); width: 100%; height: 100%;">
            <div id="galgame-sprite-container"
              style="position: absolute; display: flex; align-items: flex-end; justify-content: center; /* 移除旧的定位样式 */">
              <img id="galgame-sprite" src=""
                style="max-height: 100%; max-width: 100%; object-fit: contain; transition: opacity 0.3s ease;">
              <div id="sprite-resize-handle"
                style="display: none; position: absolute; bottom: -5px; right: -5px; width: 20px; height: 20px; background: white; border: 2px solid var(--primary-color); border-radius: 50%; cursor: se-resize;">
              </div>
            </div>
          </div>
          <div id="galgame-textbox-container"
            style="position: absolute; bottom: 9%; left: 5%; right: 5%; background: rgba(0, 0, 0, 0.7); border-radius: 10px; padding: 15px; color: white; border-top: 1px solid rgba(255,255,255,0.2); cursor: pointer;">
            <div id="galgame-speaker" style="font-weight: bold; margin-bottom: 10px;">说话人</div>
            <div id="galgame-text" style="line-height: 1.6;">对话内容...</div>
          </div>
        </div>
      </div>
      <div class="chat-input-area">
        <div id="chat-input-wrapper-meeting"> <textarea id="meeting-message-input" placeholder="输入你的行动或对话..." rows="1"
            style="resize: none; overflow-y: auto; flex-grow: 1; border: none; background: transparent; padding: 9px 12px; font-size: .95rem; "></textarea>
          <button id="meeting-send-button" title="发送">➤</button>
        </div>
      </div>
    </div>

    <div id="friend-circle-list-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-circle-list" class="header-button">主屏幕</button>
        <span class="header-title">好友圈</span>
        <button id="add-friend-circle-button" class="header-button add" title="新建好友圈">+</button>
      </div>
      <div id="friend-circle-list-container" class="content" style="padding: 10px;">
      </div>
    </div>

    <div id="friend-circle-edit-screen" class="screen">
      <div class="header">
        <button id="back-to-circle-list-from-edit" class="header-button">返回</button>
        <span id="friend-circle-edit-title" class="header-title">编辑好友圈</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <input type="hidden" id="editing-friend-circle-id">
        <div class="settings-group">
          <h2>好友圈设定</h2>
          <div class="input-group">
            <label for="friend-circle-edit-name">圈子名称</label>
            <input type="text" id="friend-circle-edit-name" placeholder="例如：我的日常">
          </div>
          <div class="input-group">
            <label for="friend-circle-edit-bind-user">绑定的“我”</label>
            <select id="friend-circle-edit-bind-user"></select>
          </div>
        </div>
        <div class="settings-group">
          <h2>选择圈内成员</h2>
          <div id="friend-circle-member-selection"
            style="max-height: 250px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px;">
          </div>
        </div>
        <button id="save-friend-circle-button" class="form-button">保存</button>
        <div class="settings-group"
          style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
          <button id="delete-friend-circle-button" class="form-button destructive">删除该好友圈</button>
        </div>
      </div>
    </div>
    <div id="diary-list-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-diary-list" class="header-button">主屏幕</button>
        <span class="header-title">交换日记</span>
        <div style="width: 50px;"></div>
      </div>
      <div id="diary-list-container" class="content" style="padding: 10px;">
      </div>
    </div>

    <div id="diary-view-screen" class="screen">
      <div class="header">
        <button class="header-button" id="back-to-diary-list">返回</button>
        <span id="diary-char-name-header" class="header-title">TA的日记</span>
        <div style="width: 50px;"></div>
      </div>
      <div id="diary-entries-container" class="content"
        style="padding: 20px; font-family: 'KaiTi', 'STSong', serif; line-height: 1.8;">
      </div>
      <div class="chat-input-area">
        <div id="diary-input-wrapper" style="display: flex; gap: 10px;">
          <input type="text" id="diary-entry-input" placeholder="写下你的日记或批注..." style="flex-grow: 1;">
          <button id="diary-send-button" class="form-button"
            style="width: auto; margin-top: 0; padding: 0 18px;">写好了</button>
          <button id="diary-get-reply-button" class="form-button"
            style="width: auto; margin-top: 0; background-color: #555; padding: 0 18px;">催TA写</button>
        </div>
      </div>
    </div>
    <div id="music-library-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-music-library" class="header-button">主屏幕</button>
        <span class="header-title">音乐库</span>
        <button id="upload-music-button" class="header-button add" title="上传新音乐">+</button>
      </div>
      <div class="content" id="music-library-container">
      </div>
    </div>
    <div id="music-upload-altar-screen" class="screen">
      <div class="header">
        <button id="back-to-library-from-altar" class="header-button">取消</button>
        <span class="header-title">献上音乐</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content" style="padding: 20px; display: flex; flex-direction: column; gap: 15px;">
        <div class="upload-slot" id="altar-slot-zip">
          <span class="slot-icon">📦</span>
          <span class="slot-label">音乐魔方 (必需)</span>
          <span class="slot-filename">点击选择包含音频、封面、信息、歌词的 .zip 压缩包</span>
        </div>

        <button id="confirm-altar-upload-button" class="form-button" disabled>献上祭品</button>



      </div>

      <input type="file" id="altar-zip-input" style="display: none;" accept=".zip">

    </div>


    <div id="accounting-screen" class="screen">
      <div class="header" id="accounting-header">
        <button id="back-to-home-from-accounting" class="header-button">主屏幕</button>
        <span id="accounting-title" class="header-title">记一笔</span>
        <div id="header-actions" style="width: 80px; text-align: right;"></div>
      </div>

      <div class="accounting-tabs">
        <button id="tab-record-expense" class="tab-button active">记一笔</button>
        <button id="tab-view-ledger" class="tab-button">看账本</button>
      </div>

      <div id="accounting-content-area" class="content" style="padding: 15px;">
      </div>
    </div>
    <audio id="audio-player"></audio>

    <audio id="unified-audio-player"></audio>

    <div id="snoop-list-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-snoop-list" class="header-button">主屏幕</button>
        <span class="header-title">选择目标</span>
        <div style="width: 50px;"></div>
      </div>
      <div id="snoop-character-list-container" class="content" style="padding: 10px;">
      </div>
    </div>

    <div id="snoop-phone-screen" class="screen">
      <div id="snoop-phone-wallpaper"></div>
      <div id="snoop-phone-header">
      </div>

      <div id="snoop-app-container">
      </div>

      <div id="snoop-app-view-container"
        style="position: absolute; inset: 0; background: white; z-index: 20; display: none; flex-direction: column;">
      </div>

      <div id="snoop-phone-top-nav" class="header"
        style="position: absolute; top: 44px; left: 0; right: 0; z-index: 30; height: 56px; display: flex; align-items: center; padding: 0 5px;">
        <button id="back-to-snoop-list-from-phone" class="toolbar-button"
          style="color: white; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5)); background: transparent !important;">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="15 18 9 12 15 6"></polyline>
          </svg>
        </button>
        <span id="snoop-char-name-header" class="header-title"></span>
        <div style="width:50px;"></div>
      </div>
    </div>

    <div id="calendar-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-calendar" class="header-button">主屏幕</button>
        <span id="calendar-header-title" class="header-title">2025年 9月</span>
        <div style="width: 50px;"></div>
      </div>

      <div id="calendar-view-container">
        <div class="calendar-nav">
          <button id="prev-month-btn">‹</button>
          <button id="today-btn">今天</button>
          <button id="next-month-btn">›</button>
        </div>
        <div class="calendar-weekdays">
          <span>日</span><span>一</span><span>二</span><span>三</span><span>四</span><span>五</span><span>六</span>
        </div>
        <div id="calendar-grid">
        </div>
      </div>

      <div id="todo-view-container">
        <div id="todo-header">
          <h3 id="todo-date-title">选择一个日期</h3>
          <button id="add-event-fab" title="添加新事件">+</button>
        </div>
        <div id="todo-list">
        </div>
      </div>

    </div>

    <div id="import-altar-screen" class="screen">
      <div class="header">
        <button id="back-to-settings-from-altar" class="header-button">返回</button>
        <span class="header-title">数据还原圣坛</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <p style="font-size: 0.9rem; color: var(--text-color-light);">请将你的备份文件放置在对应的祭坛上。旧版单文件备份只需放置在第一个槽位。</p>
        <div class="upload-slot" id="altar-slot-json">
          <span class="slot-icon">📄</span>
          <span class="slot-label">核心数据 (.json)</span>
          <span class="slot-filename">点击选择...Data.json</span>
        </div>
        <div class="upload-slot" id="altar-slot-images-zip">
          <span class="slot-icon">🖼️</span>
          <span class="slot-label">图片档案 (.zip) (可选)</span>
          <span class="slot-filename">点击选择...Images.zip</span>
        </div>
        <div class="upload-slot" id="altar-slot-misc-zip">
          <span class="slot-icon">📦</span>
          <span class="slot-label">杂项档案 (.zip) (可选)</span>
          <span class="slot-filename">点击选择...Misc.zip</span>
        </div>
        <button id="confirm-altar-import-button" class="form-button" disabled="">开始还原</button>
      </div>
    </div>
    <input type="file" id="altar-json-input" style="display: none;" accept=".json">
    <input type="file" id="altar-zip-input-import" style="display: none;" accept=".zip">
    <input type="file" id="altar-misc-zip-input" style="display: none;" accept=".zip">
    <div id="livestream-list-screen" class="screen">
      <div class="header">
        <button id="back-to-home-from-livestream-list" class="header-button">主屏幕</button>
        <span class="header-title">选择主播</span>
        <div style="width: 50px;"></div>
      </div>
      <div id="livestream-list-container" class="content" style="padding: 10px;">
      </div>
    </div>

    <div id="livestream-room-screen" class="screen">
      <div class="header" id="livestream-header" style="position: relative; justify-content: center;">
        <div id="livestream-header-left" style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%);">
          <button id="back-to-livestream-list" class="header-button">返回</button>
        </div>
        <span id="livestream-char-name-header" class="header-title"></span>
        <div id="livestream-header-right"
          style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); display: flex; align-items: center;">
          <button id="livestream-settings-btn" class="header-button">设置</button>
        </div>
      </div>

      <div id="livestream-main-view"
        style="flex-grow: 1; display: flex; flex-direction: column; background: #111; overflow: hidden; position: relative;">
        <div id="livestream-feed-container" style="flex-grow: 1; position: relative; overflow: hidden;">
          <div id="livestream-top-toolbar">
            <button id="livestream-sprite-adjust-btn" class="toolbar-button" title="调整立绘"><svg
                xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 7h-9" />
                <path d="M14 17H5" />
                <circle cx="17" cy="17" r="3" />
                <circle cx="8" cy="7" r="3" />
              </svg></button>
            <button id="livestream-replays-btn" class="toolbar-button" title="查看回放"><svg
                xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M8 3H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h4" />
                <path d="M16 21h4a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-4" />
                <path d="M12 16a4 4 0 1 0 0-8 4 4 0 0 0 0 8z" />
              </svg></button>
            <button id="livestream-reroll-btn" class="toolbar-button" title="重新生成回应"><svg
                xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="23 4 23 10 17 10" />
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10" />
              </svg></button>
          </div>
          <div id="livestream-background"
            style="position: absolute; inset: 0; background-size: cover; background-position: center; z-index: 1;">
          </div>
          <div id="livestream-sprite-container"
            style="position: absolute; bottom: 0; left: 0; right: 0; height: 85%; z-index: 2;">
            <img id="livestream-sprite"
              style="max-height: 100%; max-width: 100%; object-fit: contain; position: absolute; bottom: 0; left: 50%; transform: translateX(-50%);">
          </div>
          <div id="livestream-textbox-container" style="z-index: 3; cursor: pointer;">
            <div id="livestream-text">...</div>
          </div>
        </div>
        <div id="livestream-danmaku-overlay"></div>
      </div>

      <div id="livestream-input-area" class="chat-input-area"
        style="background: var(--surface-bg); border-top: 1px solid var(--border-color); flex-shrink: 0;">
        <div id="start-livestream-btn-container" style="text-align: center;">
          <button id="start-livestream-btn" class="form-button primary"
            style="width: auto; padding: 12px 24px; border-radius: 24px; font-size: 1.2rem;">🎙️ 开始直播</button>
        </div>
        <div id="livestream-controls-container" style="display: none; align-items: center; gap: 8px;">
          <input type="text" id="danmaku-input" placeholder="发个弹幕...">
          <button id="livestream-dm-btn" class="toolbar-button" title="私信主播"><svg xmlns="http://www.w3.org/2000/svg"
              width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round">
              <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
              <polyline points="22,6 12,13 2,6"></polyline>
            </svg></button>
          <button id="livestream-gift-btn" class="toolbar-button" title="送礼物"><svg xmlns="http://www.w3.org/2000/svg"
              width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              stroke-linecap="round" stroke-linejoin="round">
              <path d="M20 12v10H4V12" />
              <path d="M2 7h20v5H2z" />
              <path d="M12 22V7" />
              <path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z" />
              <path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z" />
            </svg></button>
          <button id="send-danmaku-btn" class="livestream-action-btn">发送</button>
          <button id="continue-livestream-btn" class="livestream-action-btn secondary">继续</button>
        </div>
      </div>



      <div id="livestream-sprite-controls"
        style="display: none; position: absolute; bottom: 15px; left: 15px; right: 15px; z-index: 1001; background: rgba(0,0,0,0.7); backdrop-filter: blur(8px); border-radius: 12px; padding: 15px; box-shadow: 0 -2px 15px rgba(0,0,0,0.3);">
        <div class="sprite-slider-group">
          <label for="livestream-sprite-slider-x">左右位置</label>
          <input type="range" id="livestream-sprite-slider-x" min="0" max="100" value="50">
        </div>
        <div class="sprite-slider-group">
          <label for="livestream-sprite-slider-y">上下位置</label>
          <input type="range" id="livestream-sprite-slider-y" min="0" max="130" value="100">
        </div>
        <div class="sprite-slider-group">
          <label for="livestream-sprite-slider-scale">缩放大小</label>
          <input type="range" id="livestream-sprite-slider-scale" min="50" max="200" value="100">
        </div>
        <div style="display: flex; gap: 10px; margin-top: 15px;">
          <button id="livestream-sprite-confirm-button" class="form-button">确定</button>
          <button id="livestream-sprite-cancel-button" class="form-button secondary">取消</button>
          <button id="livestream-sprite-reset-button" class="form-button destructive"
            style="padding: 10px 12px; width: auto; font-size: 1.2rem;">⟲</button>
        </div>
      </div>
    </div>

    <div id="livestream-replays-screen" class="screen">
      <div class="header">
        <button id="back-to-livestream-from-replays" class="header-button">返回</button>
        <span id="replays-char-name-header" class="header-title">的回放列表</span>
        <div style="width: 50px;"></div>
      </div>
      <div id="livestream-replays-container" class="content" style="padding: 15px;">
      </div>
    </div>

    <div id="livestream-replay-view-screen" class="screen">
      <div class="header">
        <button id="back-to-replays-list-from-view" class="header-button">返回</button>
        <span class="header-title">直播回放详情</span>
        <div style="width: 50px;"></div>
      </div>
      <div id="livestream-replay-view-container" class="content" style="padding: 20px; font-family: sans-serif;">
      </div>
    </div>

    <div id="start-livestream-modal" class="choice-modal">
      <div id="start-livestream-backdrop" class="choice-modal-backdrop"></div>
      <div class="choice-modal-content" style="padding: 20px; width: 90%; max-width: 320px;">
        <h3 style="margin-top: 0; text-align: center;">准备开播</h3>
        <div class="input-group">
          <label for="livestream-theme-input">直播主题</label>
          <input type="text" id="livestream-theme-input" placeholder="例如：聊聊最近看的电影">
        </div>
        <div class="input-group">
          <label for="audience-mood-input">观众氛围</label>
          <input type="text" id="audience-mood-input" placeholder="例如：期待、好奇、热闹">
        </div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
          <button id="confirm-start-livestream-button" class="form-button primary">开始直播</button>
          <button id="cancel-start-livestream-button" class="form-button secondary">取消</button>
        </div>
      </div>
    </div>
    <div id="livestream-settings-screen" class="screen">
      <div class="header">
        <button id="back-to-livestream-from-settings" class="header-button">返回</button>
        <span class="header-title">直播间设置</span>
        <div style="width: 50px;"></div>
      </div>
      <div class="content">
        <div class="settings-group">
          <h2>直播背景</h2>
          <p style="font-size: 0.8rem; color: var(--text-color-light);">为这个角色的直播间设置专属背景图。</p>
          <div class="image-preview-slot" id="livestream-bg-preview"
            style="width: 150px; height: 266px; margin: 0 auto;">
          </div>
          <input type="file" id="livestream-bg-input" accept="image/*" style="display: none;">
        </div>

        <div class="settings-group">
          <h2>直播立绘 (多表情)</h2>
          <p style="font-size: 0.8rem; color: var(--text-color-light);">为五种核心情绪上传专属的直播立绘，AI会在直播时根据情绪自动切换。</p>
          <div
            style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; margin-top: 10px;">
            <div class="avatar-upload-group" style="align-items: center;">
              <label>平常</label>
              <div id="livestream-sprite-normal-preview" class="sprite-preview-slot"></div>
              <input type="file" id="livestream-sprite-normal-input" accept="image/*,.gif" style="display: none;">
            </div>
            <div class="avatar-upload-group" style="align-items: center;">
              <label>喜</label>
              <div id="livestream-sprite-happy-preview" class="sprite-preview-slot"></div>
              <input type="file" id="livestream-sprite-happy-input" accept="image/*,.gif" style="display: none;">
            </div>
            <div class="avatar-upload-group" style="align-items: center;">
              <label>怒</label>
              <div id="livestream-sprite-angry-preview" class="sprite-preview-slot"></div>
              <input type="file" id="livestream-sprite-angry-input" accept="image/*,.gif" style="display: none;">
            </div>
            <div class="avatar-upload-group" style="align-items: center;">
              <label>哀</label>
              <div id="livestream-sprite-sad-preview" class="sprite-preview-slot"></div>
              <input type="file" id="livestream-sprite-sad-input" accept="image/*,.gif" style="display: none;">
            </div>
            <div class="avatar-upload-group" style="align-items: center;">
              <label>害羞</label>
              <div id="livestream-sprite-shy-preview" class="sprite-preview-slot"></div>
              <input type="file" id="livestream-sprite-shy-input" accept="image/*,.gif" style="display: none;">
            </div>
          </div>
        </div>

        <button id="save-livestream-settings-button" class="form-button primary">保存设置</button>
      </div>
    </div>
  </div>
  </div>



  <div id="livestream-dm-panel" class="dm-panel" style="z-index: 100;">
    <div id="livestream-dm-backdrop" class="dm-backdrop"></div>
    <div class="dm-panel-content">
      <div class="dm-header"><span>与 主播 的私信</span><button id="dm-close-btn">&times;</button></div>
      <div id="livestream-dm-messages" class="dm-messages-container"></div>
      <div class="dm-input-area"><input type="text" id="livestream-dm-input" placeholder="悄悄话..."><button
          id="livestream-dm-send-btn">发送</button></div>
    </div>
  </div>


  <div id="add-choice-modal" class="choice-modal">
    <div id="add-choice-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content">
      <button id="choice-create-character" class="choice-modal-button">创建新角色</button>
      <button id="choice-create-group" class="choice-modal-button">创建新群聊</button>
      <button id="choice-import-character" class="choice-modal-button">导入角色卡</button>
      <button id="choice-cancel" class="choice-modal-button cancel">取消</button>
    </div>
  </div>


  <div id="transfer-modal" class="choice-modal">
    <div id="transfer-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content" style="padding: 20px; width: 90%; max-width: 300px;">
      <h3 style="margin-top: 0; text-align: center; font-weight: 600;">转账</h3>
      <div id="transfer-recipient-group" class="input-group" style="margin: 10px 0; display: none;">
        <label for="transfer-recipient-select">转给</label>
        <select id="transfer-recipient-select"></select>
      </div>
      <div class="input-group" style="margin: 10px 0;">
        <label for="transfer-amount-input">金额</label>
        <input type="number" id="transfer-amount-input" placeholder="输入金额">
      </div>
      <div style="display: flex; gap: 10px; margin-top: 20px;">
        <button id="confirm-transfer-button" class="choice-modal-button"
          style="background-color: var(--primary-color); color: white;">确认转账</button>
        <button id="cancel-transfer-button" class="choice-modal-button cancel">取消</button>
      </div>
    </div>
  </div>

  <div id="message-action-modal" class="choice-modal">
    <div id="message-action-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content">
      <button id="edit-message-button" class="choice-modal-button">编辑消息</button>
      <button id="quote-message-button" class="choice-modal-button">引用</button>
      <button id="delete-message-button" class="choice-modal-button" style="color: #dc3545;">删除消息</button>
      <button id="cancel-action-button" class="choice-modal-button cancel">取消</button>
    </div>
  </div>

  <div id="edit-message-modal" class="choice-modal">
    <div id="edit-message-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content" style="padding: 20px;">
      <h3 style="margin-top: 0; text-align: center; font-weight: 600;">编辑消息</h3>
      <textarea id="edit-message-textarea" style="width: 100%; min-height: 100px; margin: 10px 0;"></textarea>
      <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="save-edit-button" class="choice-modal-button"
          style="background-color: var(--primary-color); color: white;">保存</button>
        <button id="cancel-edit-button" class="choice-modal-button cancel">取消</button>
      </div>
    </div>
  </div>

  <div id="music-input-modal" class="choice-modal">
    <div id="music-input-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content" style="padding: 20px; width: 90%; max-width: 300px;">
      <h3 id="music-input-title" style="margin-top: 0; text-align: center; font-weight: 600;">分享音乐</h3>

      <div class="input-group" style="margin: 10px 0;">
        <label for="music-input-song" style="font-size: 0.9rem;">歌名</label>
        <input type="text" id="music-input-song" placeholder="例如：夜曲">
      </div>
      <div class="input-group" style="margin: 10px 0;">
        <label for="music-input-artist" style="font-size: 0.9rem;">歌手</label>
        <input type="text" id="music-input-artist" placeholder="例如：周杰伦">
      </div>

      <div style="display: flex; gap: 10px; margin-top: 20px;">
        <button id="confirm-music-input" class="choice-modal-button"
          style="background-color: var(--primary-color); color: white;">确认</button>
        <button id="cancel-music-input" class="choice-modal-button cancel">取消</button>
      </div>
    </div>
  </div>

  <div id="modal-root"
    style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:9999;">
    <div id="modal-mask" style="position:absolute;inset:0;background:rgba(0,0,0,.35);"></div>
    <div id="modal-dialog"
      style="position:relative;background:#fff;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.2);width:80%;max-width:320px;padding:16px;">
      <div id="modal-text" style="font-size:14px;color:#333;line-height:1.5;white-space:pre-wrap;"></div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:16px;">
        <button id="modal-cancel"
          style="padding:8px 12px;border:1px solid #ddd;border-radius:8px;background:#fff;cursor:pointer;">取消</button>
        <button id="modal-ok"
          style="padding:8px 12px;border:none;border-radius:8px;background:#007bff;color:#fff;cursor:pointer;">确定</button>
      </div>
    </div>
  </div>

  <div id="listen-together-modal" class="choice-modal">
    <div id="listen-together-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content"
      style="padding: 0; width: 95%; max-width: 360px; height: 70%; display: flex; flex-direction: column;">
      <div class="header" style="border-bottom: 1px solid var(--border-color); flex-shrink: 0;">
        <div style="width: 50px;"></div>
        <span class="header-title">选择一首歌，一起听</span>
        <button id="cancel-listen-together" class="header-button" style="min-width: 50px;">取消</button>
      </div>
      <div id="listen-together-song-list" class="content" style="flex-grow: 1; padding: 10px;">
      </div>
    </div>
  </div>

  <div id="toast"
    style="position:fixed;left:50%;bottom:32px;transform:translateX(-50%);background:rgba(0,0,0,.8);color:#fff;padding:8px 12px;border-radius:8px;font-size:12px;display:none;z-index:10000;">
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <script>
    // ▼▼▼ Noir's Temporal Correction Protocol v1.0 ▼▼▼
    function getLocalDateString(date = new Date()) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }
    // ▲▲▲ End of Protocol ▲▲▲
    // ▼▼▼ 把这两行圣旨粘贴在这里！▼▼▼
    const DB_NAME = 'Noir_FileSystem';
    const STORE_NAME = 'images';
    const SNOOP_STORE_NAME = 'snoop_cache'; // <-- 哼，就是这根被你忘掉的钢筋！
    // ▲▲▲ 看到了吗？就这里！▲▲▲
    const { LocalNotifications } = Capacitor.Plugins;
    // Noir's Dynamic Font Style Injector
    const fontStyleTag = document.createElement('style');
    fontStyleTag.id = 'noir-custom-font-style';
    document.head.appendChild(fontStyleTag);

    /* ===== GLOBALS for helpers below ===== */
    var state; // 让外部辅助函数能看到它（稍后在 DOMContentLoaded 内部赋值）
    var currentlyPlayingSongInfo = null; // 哼，这是新的大脑，简单
    let masterStickerList = []; // <--- 哼，就是加上这行！
let navigationCleanupTimer = null; // <--- 补上这一行，给闹钟一个安身之处
    let isStickerDeletionMode = false; // <-- 在这里加上这个新开关！
    let galClockInterval = null;
    let isSpriteFrontActive = true; // 哼，这是新的换装记忆开关
    let isDraggingBadge = false;
    let badgeOffset = { x: 0, y: 0 };

    function getCharacterById(charId) {
      return (state?.characters || []).find(c => c.id === charId);
    }

    /* ==================================== */

    const GEMINI_API_URL_BASE = 'https://i.pinimg.com/736x/16/f9/05/16f9051f99471208ee9c658aa4618eb6.jpg';
    const DEFAULT_USER_AVATAR = `data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM5OTkiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMjAgMjF2LTIuMDJhNC4zOSA0LjM5IDAgMCAtMy4yOC00LjA5TDE1IDIwIj48L3BhdGgPjxjaXJjbGUgY3g9IjEyIiBjeT0iNyIgcj0iNCI+PC9jaXJjbGU+PC9zdmc+`;
    const DEFAULT_AI_AVATAR = `data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNjY2MiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMjAgMjF2LTIuMDRhNC4zOSA0LjM5IDAgMCAwLTMuMjgtNC4wOWwxLjQxLTEuNDFhMiAyIDAgMSAwLTIuODMtMi4wM2wtMS40MSAxLjQxQTQuMzkgNC4zOSAwIDAgMCAxMiAxMGE0LjM5IDQuMzkgMCAwIDAtNC4wOSAzLjI4TDMuMicgOS41N2EyIDIgMCAxIDAgMi44MyAyLjgzbDEuNDEtMS40MUE0LjM5IDQuMzkgMCAwIDAgMTAgMTJhNC4zOSA0LjM5IDAgMCAwIDMgNC4wOVYyMSI+PC9wYXRoPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjEwIj48L2NpcmNsZT48L3N2Zz4=`;

    const STICKERS = [
      { name: '委屈哭', url: 'https://sharkpan.xyz/f/8ngsj/ax0fat.jpg' },
      { name: '崩溃', url: 'https://sharkpan.xyz/f/G0dTl/4qad2i.jpg' },
      { name: '生病', url: 'https://sharkpan.xyz/f/zLes5/4lxzjn.jpg' },
      { name: '工作', url: 'https://sharkpan.xyz/f/7L3Hj/sl4504.jpg' },
      { name: '我很脆弱', url: 'https://sharkpan.xyz/f/ABwhZ/twknmr.jpg' },
      { name: '弱小委屈但凶恶', url: 'https://sharkpan.xyz/f/wjgHq/yznfhq.jpg' },
      { name: '吃薯条', url: 'https://sharkpan.xyz/f/MWOIa/rb3nov.jpg' },
      { name: '期待', url: 'https://sharkpan.xyz/f/35lse/xmsue5.jpg' },
      { name: '喜欢', url: 'https://sharkpan.xyz/f/55ntj/ul0hkz.jpg' },
      { name: '被萌到', url: 'https://sharkpan.xyz/f/kjOF6/zedyqb.jpg' },
      { name: '有点生气', url: 'https://sharkpan.xyz/f/jj6s6/yd5bpb.jpg' },
      { name: '委屈', url: 'https://sharkpan.xyz/f/ajwtY/x03qxn.gif' },
      { name: '加油', url: 'https://sharkpan.xyz/f/rjpu6/ojpa0c.jpg' },
      { name: '对的', url: 'https://sharkpan.xyz/f/DVJtK/vxiup1.jpg' },
      { name: '不满', url: 'https://sharkpan.xyz/f/LZwu7/m7vx2q.jpg' },
      { name: '很期待', url: 'https://sharkpan.xyz/f/qjJT3/kpy33b.jpg' },
      { name: '猫猫撒娇', url: 'https://sharkpan.xyz/f/X7muW/lc8g9h.gif' },
      { name: '委屈', url: 'https://sharkpan.xyz/f/25ACQ/gpzab6.jpg' },
      { name: '平静', url: 'https://sharkpan.xyz/f/gjySw/jrl7rw.jpg' },
      { name: '咬你', url: 'https://sharkpan.xyz/f/JYeig/sv4p6m.jpg' },
      { name: '咱俩天下第一好', url: 'https://sharkpan.xyz/f/OymFy/dlxfiz.jpg' },
      { name: '好困', url: 'https://sharkpan.xyz/f/6Dzia/m9smvt.jpg' },
      { name: '摸鱼', url: 'https://sharkpan.xyz/f/nj5Ul/ksdl8n.jpg' },
      { name: '委屈那我歇了', url: 'https://sharkpan.xyz/f/mjdFW/28n30c.jpg' },
      { name: '超激动我来了', url: 'https://sharkpan.xyz/f/B4DCa/u86hk2.jpg' },
      { name: '被你撩到', url: 'https://sharkpan.xyz/f/4adUj/68uj9o.jpg' },
      { name: '一起听歌', url: 'https://sharkpan.xyz/f/N0VCv/5rd8br.jpg' },
      { name: '刷我的卡', url: 'https://sharkpan.xyz/f/VGnuY/ptzlf5.jpg' },
      { name: '啥意思捏', url: 'https://sharkpan.xyz/f/xjmCX/zyjzew.jpg' },
      { name: '好委屈但是不能哭', url: 'https://sharkpan.xyz/f/djyi8/1en214.jpg' },
      { name: '事情好多', url: 'https://sharkpan.xyz/f/ljNUx/aw6udx.jpg' },
      { name: '我是垃圾', url: 'https://sharkpan.xyz/f/JYJhg/s3wmlj.jpg' },
      { name: '勉强但是好吧', url: 'https://sharkpan.xyz/f/Oyjuy/p8v2hd.jpg' },
      { name: '逗你开心', url: 'https://sharkpan.xyz/f/6Dgia/ghr4ji.jpg' },
      { name: '买新衣服', url: 'https://sharkpan.xyz/f/nj7ul/r48eum.jpg' },
      { name: '干劲满满', url: 'https://sharkpan.xyz/f/mjeIW/9vf8ws.jpg' },
      { name: '对不起', url: 'https://sharkpan.xyz/f/B4WSa/u5wopj.jpg' },
      { name: '交给我吧', url: 'https://sharkpan.xyz/f/4aqCj/gp13hn.jpg' },
      { name: '无语但是随便吧', url: 'https://sharkpan.xyz/f/N02Sv/378vt6.jpg' },
      { name: '有点破防', url: 'https://sharkpan.xyz/f/VG2FY/uucfvv.jpg' },
      { name: '快点哄我', url: 'https://sharkpan.xyz/f/xjwSX/pxjrjd.jpg' },
      { name: '有点无语', url: 'https://sharkpan.xyz/f/djjH8/29ejbg.jpg' },
      { name: '一拳打爆', url: 'https://sharkpan.xyz/f/ljVCx/b16h2z.jpg' },
      { name: '绝对不想', url: 'https://sharkpan.xyz/f/Krwio/1mcclx.jpg' },
      { name: '谁啊我吗', url: 'https://sharkpan.xyz/f/ExKsD/s5j2it.jpg' },
      { name: '很好哦', url: 'https://sharkpan.xyz/f/YA7T1/th0l79.jpg' },
      { name: '甜蜜地和你聊天', url: 'https://sharkpan.xyz/f/Qpzu6/3b30r2.jpg' },
      { name: '不高兴撒娇', url: 'https://sharkpan.xyz/f/ZazfW/2vv46w.jpg' },
      { name: '我是小丑呜呜', url: 'https://sharkpan.xyz/f/Wa0cW/w6m7qk.jpg' },
      { name: '我不想工作', url: 'https://sharkpan.xyz/f/0GKHX/mthvno.jpg' },
      { name: '吃你的饭', url: 'https://sharkpan.xyz/f/yrOhN/0yixqd.jpg' },
      { name: '我来搞定', url: 'https://sharkpan.xyz/f/v0qcL/dio7j0.jpg' },
      { name: '我是女仆', url: 'https://sharkpan.xyz/f/pKWCQ/ztxwv0.jpg' },
      { name: '等你', url: 'https://sharkpan.xyz/f/1zQH2/o84boo.jpg' },
      { name: '一个人可怜吃饭', url: 'https://sharkpan.xyz/f/eOXIw/y29z21.jpg' },
      { name: '等你消息', url: 'https://sharkpan.xyz/f/olJt4/7z47b8.jpg' },
      { name: '喝酒', url: 'https://sharkpan.xyz/f/8a7tj/sea1z9.jpg' },
      { name: '喝多了', url: 'https://sharkpan.xyz/f/Ganul/78iwli.jpg' },
      { name: '呜呜', url: 'https://sharkpan.xyz/f/z1xc5/iore2n.gif' },
      { name: '为你骄傲', url: 'https://sharkpan.xyz/f/7aMhj/hyc75m.jpg' },
      { name: '我错了', url: 'https://sharkpan.xyz/f/AaDTZ/tzwnjl.jpg' },
      { name: '出去玩', url: 'https://sharkpan.xyz/f/wyeIq/phhdy2.jpg' },
      { name: '请看是我', url: 'https://sharkpan.xyz/f/Mamca/4e3emf.jpg' },
      { name: '别这样嘛我哭哭', url: 'https://sharkpan.xyz/f/3AGHe/2f8x3x.gif' },
    ];
    // --- Noir's Ultimate Theme Engine ---
    // 哼，这是我为你定制的四套顶级主题方案。
    const THEME_PRESETS = {
      beige: { name: '默认米白', h: 35, s: 25, l: 80 },
      mizuiro: { name: '薄荷水色', h: 195, s: 25, l: 80 }, // 哼，色相微调，饱和度和亮度向米白看齐
      sakura: { name: '樱花薄粉', h: 345, s: 25, l: 80 }, // 饱和度和亮度也向米白看齐
      noir: { name: '暗夜紫晶', h: 260, s: 15, l: 30 }  // 我自己的主题当然是特别的，保持不变
    };

    // 这是切换主题的核心指令
    // 这是新的“主题加载与应用”函数，把它放到你脚本的函数区


    document.addEventListener('DOMContentLoaded', () => {

      // --- DOM Elements ---
      const appUserProfiles = document.getElementById('app-user-profiles');

      const chatTransferButton = document.getElementById('chat-transfer-button');
      const transferModal = document.getElementById('transfer-modal');
      const transferBackdrop = document.getElementById('transfer-backdrop');
      const confirmTransferButton = document.getElementById('confirm-transfer-button');
      const cancelTransferButton = document.getElementById('cancel-transfer-button');
      const transferRecipientGroup = document.getElementById('transfer-recipient-group');
      const transferRecipientSelect = document.getElementById('transfer-recipient-select');
      const transferAmountInput = document.getElementById('transfer-amount-input');
      const rerollButton = document.getElementById('chat-reroll-button');
      // 在 const rerollButton = ... 后面加上
      const summarizeButton = document.getElementById('chat-summarize-button');
      const summarizeModal = document.getElementById('summarize-modal');
      const summarizeBackdrop = document.getElementById('summarize-backdrop');
      const summaryTextarea = document.getElementById('summary-textarea');
      const copySummaryButton = document.getElementById('copy-summary-button');
      const closeSummaryButton = document.getElementById('close-summary-button');
      // ... 之前的 const 声明之后
      const charEditWallpaperPreview = document.getElementById('char-edit-wallpaper-preview');
      const charEditWallpaperInput = document.getElementById('char-edit-wallpaper-input');
      const charEditOfflineBgPreview = document.getElementById('char-edit-offline-bg-preview');
      const charEditOfflineBgInput = document.getElementById('char-edit-offline-bg-input');

      // ... 其他 const 声明之后
      const choiceImportCharacter = document.getElementById('choice-import-character');
      const importCharInput = document.getElementById('import-char-input');
      const exportCharButton = document.getElementById('export-char-button');

      // ... 已有的 const 声明之后
      const uploadFontButton = document.getElementById('upload-font-button');
      const removeFontButton = document.getElementById('remove-font-button');
      const fontInput = document.getElementById('font-input');
      const fontPreviewText = document.getElementById('font-preview-text');


      // ==========================================================
      // --- 用户档案记忆核心系统 (角色独立版) ---
      // Noir's User Profile Memory System - Character-Specific Edition
      // 哼，每个角色都有自己的眼光，这才对。
      // ==========================================================

      // 🕐 时间戳工具：生成本地时间字符串（告别UTC时区混乱！）
      function getLocalTimeString() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
      }

    // ==========================================================
      // --- Noir's Profile Security Protocol v2.0 (Anti-Wipe) ---
      // 哼，修好了。现在就算你清空了聊天记录，档案也绝对不会丢。
      // ==========================================================

      // 初始化用户档案 - 安全版 (防覆盖)
      async function initUserProfile(charId) {
        if (!charId) return;
        try {
          const profileKey = `nuomi_profile_tiaoTiao_${charId}`;
          
          // 1. 【核心保险】先检查是不是真的没有档案！
          const { value } = await Capacitor.Plugins.Preferences.get({ key: profileKey });
          
          // 如果档案已经存在，绝对禁止覆盖！直接退出！
          if (value && value !== "null" && value !== "undefined") {
            console.log(`[Noir's Shield] 角色 ${charId} 的档案已存在，跳过初始化，防止误删。`);
            return; 
          }

          // 只有真的没档案时，才创建初始档案（四维画像v2.0）
          const initialProfile = {
            version: 2.0,
            character_id: charId,
            last_updated: getLocalTimeString(),
            value_map: {
              preferences: { "喜欢": [], "讨厌": [] },
              sensitivities: [],
              core_values: ""
            },
            behavior_profile: {
              common_phrases: {},
              tone_style: "",
              typical_emotions: [],
              response_patterns: ""
            },
            emotion_schema: {
              triggers: { "正面": [], "负面": [] },
              comfort_zone: "",
              stress_signals: []
            },
            personality_core: {
              summary: "",
              observed_traits: [],
              interaction_style: ""
            },
            observed_changes: []
          };
          await Capacitor.Plugins.Preferences.set({
            key: profileKey,
            value: JSON.stringify(initialProfile)
          });
          console.log(`✨ 角色 ${charId} 的用户档案已安全初始化`);
        } catch (error) {
          console.error('初始化用户档案失败:', error);
        }
      }

      // 高频更新：简单分析并更新档案 - 安全版
      async function updateProfileQuick(userMessage, charId) {
        if (!charId) return;
        
        try {
          const profileKey = `nuomi_profile_tiaoTiao_${charId}`;
          const bufferKey = `nuomi_message_buffer_${charId}`;

          // 1. 读取旧档案
          let { value: oldProfileStr } = await Capacitor.Plugins.Preferences.get({ key: profileKey });
          
          // 2. 【核心保险】如果读不到档案，尝试一次安全初始化，但绝不盲目覆盖
          if (!oldProfileStr) {
            console.warn(`[Noir's Shield] 警告：更新时未找到档案，尝试恢复...`);
            await initUserProfile(charId);
            // 再次读取
            const retryResult = await Capacitor.Plugins.Preferences.get({ key: profileKey });
            oldProfileStr = retryResult.value;
          }

          // 如果还是没有，说明真的出问题了，停止操作，不要报错
          if (!oldProfileStr) return;

          const profile = JSON.parse(oldProfileStr);

          // 3. 更新时间戳
          profile.last_updated = getLocalTimeString();

          // 4. 写回档案
          await Capacitor.Plugins.Preferences.set({
            key: profileKey,
            value: JSON.stringify(profile)
          });

          // 5. 消息缓冲逻辑 (保持不变)
          const { value: bufferStr } = await Capacitor.Plugins.Preferences.get({ key: bufferKey });
          const buffer = bufferStr ? JSON.parse(bufferStr) : [];
          buffer.push(userMessage);
          await Capacitor.Plugins.Preferences.set({
            key: bufferKey,
            value: JSON.stringify(buffer)
          });

          if (buffer.length >= 50) {
            console.log(`[Noir's Brain] 缓冲区已满，触发分析...`);
            state.pendingProfileRefinement = {
              charId: charId,
              contextChatId: state.activeChatId
            };
            triggerManualRefinementFlow();
          }

        } catch (error) {
          console.error('快速更新档案失败:', error);
        }
      }
      // 高频更新：简单分析并更新档案 - 角色独立版
      async function updateProfileQuick(userMessage, charId) {
        if (!charId) {
          console.warn('updateProfileQuick: 没有提供角色ID，跳过档案更新');
          return;
        }
        try {
          const profileKey = `nuomi_profile_tiaoTiao_${charId}`;
          const bufferKey = `nuomi_message_buffer_${charId}`;

          // 1. 读取旧档案（如果不存在先初始化）
          let { value: oldProfileStr } = await Capacitor.Plugins.Preferences.get({ key: profileKey });
          if (!oldProfileStr) {
            await initUserProfile(charId);
            const result = await Capacitor.Plugins.Preferences.get({ key: profileKey });
            oldProfileStr = result.value;
          }
          if (!oldProfileStr) return;

          const profile = JSON.parse(oldProfileStr);

          // 2. 简单本地分析（已废弃口头禅统计，因为token爆炸且意义不大）
          // 现在只做时间戳更新和消息缓冲

          // 3. 更新时间戳（本地时间）
          profile.last_updated = getLocalTimeString();

          // 4. 写回档案
          await Capacitor.Plugins.Preferences.set({
            key: profileKey,
            value: JSON.stringify(profile)
          });

          // 5. 暂存消息到缓冲区（也是角色独立的）
          const { value: bufferStr } = await Capacitor.Plugins.Preferences.get({ key: bufferKey });
          const buffer = bufferStr ? JSON.parse(bufferStr) : [];
          buffer.push(userMessage);
          await Capacitor.Plugins.Preferences.set({
            key: bufferKey,
            value: JSON.stringify(buffer)
          });

          // 6. 检查是否需要精炼（哼，改成50条了，免得你烦）
          if (buffer.length >= 50) {
            console.log(`[Noir's Brain]: 角色 ${charId} 的消息缓冲区已满 (${buffer.length}条)，启动强制分析流程...`);
            
            // 哼，就是这里！不再偷偷摸摸调用了！
            // 1. 先把"案发现场"的信息给我记下来！
            state.pendingProfileRefinement = {
              charId: charId,
              contextChatId: state.activeChatId // 记下当前的聊天ID
            };
            
            // 2. 拉响警报，把那个弹窗给我叫出来！
            // 别的操作都不许动，直到你确认我的分析结果！
            triggerManualRefinementFlow();
            
            // 3. 哼，旧的那个 setTimeout(refineProfile...) 给我删了，多此一举。
          }

        } catch (error) {
          console.error('快速更新档案失败:', error);
        }
      }

      
// ▼▼▼ Noir's Ultimate Profile Refiner v3.0 (User-Intent Aligned) ▼▼▼
     // ▼▼▼ Noir's Ultimate Profile Refiner v4.0 (Tri-Mode Brain) ▼▼▼
      // 哼，用这个替换掉你旧的整个 refineProfile 函数！
      async function refineProfile(charId, isDeepSynthesis = false, contextChatId = null) {
        if (!charId) {
          console.warn('refineProfile: 没有提供角色ID，跳过精炼');
          return;
        }

        const profileKey = `nuomi_profile_tiaoTiao_${charId}`;
        const bufferKey = `nuomi_message_buffer_${charId}`;
        const character = getCharacterById(charId);
        const charName = character?.name || '该角色';
        
        const privateChat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(charId));
        // 哼，现在它知道该用哪个ID了
        const chatContextId = contextChatId || privateChat?.id || state.activeChatId;
        const boundUser = getBoundUserForChat(chatContextId);

        try {
          // 1. 读取旧档案
          const { value: oldProfileStr } = await Capacitor.Plugins.Preferences.get({ key: profileKey });

          let messages = [];
          
          if (isDeepSynthesis) {
            // ==========================================================
            // --- 模式三：【深度统合档案】(来自按钮) ---
            // ==========================================================
            console.log(`[Noir's Brain]: 启动对 ${charName} 的【档案精炼】(模式: 深度统合)`);
            
            // 【【【这就是你发现的BUG！】】】
            // 哼，我把这个愚蠢的检查逻辑改了！
            if (!oldProfileStr) {
              // 如果档案是空的，就不能执行“清理”，而是应该去执行“初始生成”
              console.warn(`[Noir's Brain]: 档案为空，无法“精炼”。自动切换到“初始生成”模式...`);
              // 这会立刻重新调用这个函数，但是把 isDeepSynthesis 设为 false
              // 这样它就会跳到下面的 else 模块去执行“怪物程序”了！
              await refineProfile(charId, false);
              return; // 哼，这次的任务完成了，后面的不许再执行
            }

            // 哼，只有档案存在时，才执行“清理”
           // 哼，看好了，这才是我（Noir）重写的【功能3：深度统合】指令
            const refineSystemPrompt = `
# 核心任务：【沉淀你的记忆】

哼，${charName}。你又和 ${boundUser?.name || '用户'} 相处了一段时间了。
是时候把你对TA的那些【旧看法】（这份档案）拿出来，重新审视、调整、并精炼一遍了。

# 【【【最高指令：统合重构】】】
* 你的任务是基于这份【你现有的】私人笔记，重写一份【全新的、统一的、无矛盾】的总结。
* **如果发现冲突**（例如你发现“喜欢”和“讨厌”里有同一个东西，或总结与列表矛盾），你【必须】解决这个冲突。想一个能同时解释两种现象的“新理论”。
* **【精炼去重】**：把你那些重复的、过时的、或意义不大的旧想法（条目）给扔了。
* **【保持视角】**：你【就是】${charName}。所有总结性的字段（如 \`summary\`, \`core_values\` 等）必须保持你自己的第一人称（“我”）视角。

* **[错误示范]**: "TA很沉稳，但最近又很活跃。" (← 这是垃圾！)
* **[正确示范]**: "TA的核心是沉稳的，但只在[提到某事]时，才会展露出非常活跃的一面。" (← 这才叫整理！)

# 【【【绝对输出格式 v2.0 (必须严格遵守)】】】
* 你的输出【必须】是、也【只能】是一个【完整的、全新的、精炼后】的JSON对象，**并且【必须】保持 v2.0 的结构**！
* 【绝对禁止】返回任何JSON之外的文字、解释或Markdown标记。
* 直接从 \`{\` 开始，到 \`}\` 结束。

# v2.0 格式模板 (你必须按这个结构返回)：
{
  "version": 2.0,
  "character_id": "${charId}",
  "last_updated": "ISO时间戳",
  "value_map": {
    "preferences": { "喜欢": ["(精炼后的列表)"], "讨厌": ["(精炼后的列表)"] },
    "sensitivities": ["(精炼后的列表)"],
    "core_values": "（【用你的语气】统合重构的总结）"
  },
  "behavior_profile": {
    "tone_style": "（统合重构的总结）",
    "typical_emotions": null,
    "emotion_summary": "（【用你的语气】统合重构的总结）",
    "response_patterns": "（统合重构的总结）",
    "common_phrases": null
  },
  "emotion_schema": {
    "triggers": { "正面": ["(精炼后的列表)"], "负面": ["(精炼后的列表)"] },
    "comfort_zone": "（统合重构的总结）",
    "stress_signals": ["(精炼后的列表)"]
  },
  "personality_core": {
    "summary": "（【用你的语气】，统合重构的2-3句话总结）",
    "observed_traits": ["(精炼后的列表)"],
    "interaction_style": "（统合重构的总结）"
  },
  "observed_changes": [
    "(精炼后的列表，只保留真正关键的转变)"
  ]
}
`;
            messages = [
              { role: 'system', content: refineSystemPrompt },
              { role: 'user', content: `这是当前臃肿的档案，请你【只】基于这份档案，将其精炼：\n\n${oldProfileStr}` }
            ];
            await Capacitor.Plugins.Preferences.remove({ key: bufferKey });


          } else {
            // ==========================================================
            // --- 模式一 & 二：【初始生成】(来自重置) 或 【增量更新】(来自50条) ---
            // ==========================================================
            
            // 哼，看好了，这就是我新加的“模式开关”
            const isInitialGeneration = !oldProfileStr;
            let profileToUpdate = oldProfileStr;
            
            if (isInitialGeneration) {
              console.log(`[Noir's Brain]: 启动对 ${charName} 的【档案精炼】(模式: 初始生成)`);
              // 既然是“初始生成”，那就给它一个空的档案模板当“当前档案”
              profileToUpdate = JSON.stringify({
                version: 2.0,
                character_id: charId,
                last_updated: getLocalTimeString(),
                value_map: { preferences: { "喜欢": [], "讨厌": [] }, sensitivities: [], core_values: "" },
                behavior_profile: { tone_style: "", emotion_summary: "", response_patterns: "", typical_emotions: null, common_phrases: null },
                emotion_schema: { triggers: { "正面": [], "负面": [] }, comfort_zone: "", stress_signals: [] },
                personality_core: { summary: "", observed_traits: [], interaction_style: "" },
                observed_changes: []
              });
            } else {
              console.log(`[Noir's Brain]: 启动对 ${charName} 的【档案更新】(模式: 增量)`);
            }
            
            // 只有“增量更新”才需要看缓冲区
            let messagesToAnalyze = '';
            if (!isInitialGeneration) {
              const { value: bufferStr } = await Capacitor.Plugins.Preferences.get({ key: bufferKey });
              if (!bufferStr) {
                console.log('消息缓冲区为空，跳过增量精炼');
                return;
              }
              const messageBuffer = JSON.parse(bufferStr);
              if (messageBuffer.length === 0) {
                console.log('消息缓冲区为空，跳过增量精炼');
                return;
              }
              messagesToAnalyze = `## 最近消息（新发生的，共${messageBuffer.length}条）\n${messageBuffer.map((msg, i) => `${i + 1}. ${msg}`).join('\n')}`;
            }

            // 哼，这就是那个“怪物程序”，负责读取所有记忆
            const { omniText: chatMemory } = gatherOmniTranscriptForCharacter(charId, chatContextId);
            let worldBookContext = '';
            if (character.linkedWorldBookIds && character.linkedWorldBookIds.length > 0) {
              const linkedBooksContent = character.linkedWorldBookIds
                .map(wbId => state.worldBooks.find(book => book.id === wbId))
                .filter(Boolean)
                .map(wb => `- ${wb.name}: ${wb.content}`)
                .join('\n');
              if (linkedBooksContent) {
                worldBookContext = `\n## 你的世界观设定（影响你的价值判断）\n${linkedBooksContent}`;
              }
            }
            
            const diaryMemory = getDiaryMemory(charId);
            const feedMemory = getGlobalFeedMemory();
            const livestreamMemory = getLivestreamReplayMemory(charId);
            const snoopMemory = await getSnoopMemoryForCharacter(charId);

            // 哼，看，现在指令也会根据模式自动切换了
            let listInstruction, changesInstruction, summaryInstruction, mainTaskDescription;
            
            if (isInitialGeneration) {
              // 模式一：初始生成
              mainTaskDescription = '从零开始，【首次生成】用户画像';
              listInstruction = '"(创建新列表)"';
              changesInstruction = '"(创建新列表)"';
              summaryInstruction = `（【【【最高指令：初始生成】】】
    * 你的任务是基于**所有**历史信息，从零开始，撰写一份【全新的】总结。
    * **[错误示范]**: "TA很沉稳，但最近又很活跃。" (← 这是垃圾！)
    * **[正确示范]**: "TA的核心是沉稳的，但只在[提到某事]时，才会展露出非常活跃的一面。" (← 这才叫整理！)
`;
            } else {
              // 模式二：增量更新
              mainTaskDescription = '【增量更新】用户画像';
              listInstruction = '"(保留旧的并补充)"';
              changesInstruction = '"(保留旧的并补充)"';
              summaryInstruction = `（【【【最高指令：增量更新】】】
    * 你的任务是基于**旧总结**，将**新消息**中的【新发现】补充进去。
    * **如果发现冲突**（例如旧档案说TA很A，新消息说TA很B），你【绝对禁止】只写"TA既A又B"。
    * 你【必须】提出一个能同时解释A和B的'新理论'来【修正】总结。
    * **[错误示范]**: "TA很沉稳，但最近又很活跃。" (← 这是垃圾！)
    * **[正确示范]**: "TA的核心是沉稳的，但（新发现）只在[提到某事]时，才会展露出非常活跃的一面。" (← 这才叫整理！)
`;
            }

            const refinePrompt = `
# 任务：从"${charName}"的视角，${mainTaskDescription}（四维深度分析v2.0）
你是"${charName}"。这是你对"${boundUser?.name || '用户'}"的长期观察档案。
## 【强制对比协议】(最高优先级)
1.  **读取旧档**：先看一遍你手里的"当前档案"。
2.  **分析新信息**：${isInitialGeneration ? '分析你的【完整互动历史】。' : '再看这次的"最近消息"。'}
3.  **对比冲突**：${isInitialGeneration ? '（首次生成，无需对比）' : '找出新信息中，与旧档案【不一致】或【产生冲突】的地方。'}
4.  **分析转变**：${isInitialGeneration ? '（首次生成，无需分析转变）' : '你【必须】分析："这个新行为是TA一直以来的特点，还是在[某个事件]后才发生的转变？"'}
5.  **记录变化**：${isInitialGeneration ? '（首次生成，无需记录变化）' : '如果发现冲突或转变，【必须】在 "observed_changes" 字段里详细记录下来。'}
6.  **【统合更新 (Synthesis)】**：你【必须】提出一个'新理论'来同时解释新旧两种现象，让档案保持内部统一性。
## 你的完整背景（用于准确分析）
### 你的人设
${character?.persona || '你是一个观察敏锐的角色。'}
${worldBookContext}
### "${boundUser?.name || '用户'}" 的自述设定 (必须参考！)
${boundUser?.persona || '（用户没有填写自述）'}
### 你们的完整互动历史
${chatMemory || '（暂无聊天记录）'}
${diaryMemory || ''}
${feedMemory || ''}
${livestreamMemory || ''}
${snoopMemory || ''}
## 当前档案（你过去的观察）
\`\`\`json
${profileToUpdate} 
\`\`\`
${messagesToAnalyze}
## 【重要：语气与视角】
你【就是】"${charName}"。这份档案是你写的【私人笔记】。
因此，所有总结性的字段（如 \`core_values\`, \`summary\`, \`emotion_summary\` 等），【必须】使用你的第一人称（"我"）视角来撰写。
- **[错误示范 - 中立]**: "用户很重视公平。"
- **[正确示范 - 角色第一人称]**: "我发现 ${boundUser?.name || 'TA'} 好像非常重视公平。"
## 分析指令：四维画像更新 (第一人称视角)
根据【强制对比协议】和你自己的视角，分析新消息，并${isInitialGeneration ? '【生成】' : '【增量更新】'}以下JSON结构。
**第一维：价值地图 (Value Map)**
* 你对你家${boundUser?.name || 'TA'}的喜好、厌恶有没有什么新发现？
* 你觉得TA的【核心价值观】(core_values)是什么？（例如：我感觉TA很重视公平...）
**第二维：情绪图谱 (Emotion Schema)**
* 【情绪触发器】(triggers)：你注意到什么事会立刻让TA开心？什么话题会立刻让TA沉默或反感？
* 【压力信号】(stress_signals)：你发现TA在紧张或焦虑时，会表现出什么小动作或口头禅？
* 【舒适区】(comfort_zone)：你感觉TA在什么状态下最放松？
**第三维：行为档案 (Behavior Profile)**
* 【情绪总结】(emotion_summary)：你该如何总结TA${isInitialGeneration ? '的' : '最近的'}【整体情绪状态】？例如："我感觉TA最近对工作感到焦虑..."
* 【回应模式】(response_patterns)：你该如何总结TA在不同情绪下的典型回应方式？
* 【语气风格】(tone_style)：你如何评价TA的沟通风格？
**第四维：性格核心 (Personality Core)**
* 【性格特质】(observed_traits)：你观察到了TA的哪些具体性格特点？
* 【互动风格】(interaction_style)：TA在和你互动时，倾向于扮演什么角色？
* 【核心总结】(summary)：${summaryInstruction}
## 输出JSON结构v2.0（严格遵守）
{
  "version": 2.0,
  "character_id": "${charId}",
  "last_updated": "ISO时间戳",
  "value_map": {
    "preferences": { "喜欢": [${listInstruction}, "项目2"], "讨厌": [${listInstruction}] },
    "sensitivities": [${listInstruction}, "敏感话题2"],
    "core_values": "（【用你的语气】总结TA的核心价值观，例如：'我发现TA最看重的是...'）"
  },
  "behavior_profile": {
    "tone_style": "（总结的语气风格）",
    "typical_emotions": null,
    "emotion_summary": "（【用你的语气】总结TA的整体情绪，例如：'我感觉TA最近...'）",
    "response_patterns": "（总结的回应模式）",
    "common_phrases": null
  },
  "emotion_schema": {
    "triggers": { "正面": [${listInstruction}, "新触发器"], "负面": [${listInstruction}] },
    "comfort_zone": "（总结的舒适区描述）",
    "stress_signals": [${listInstruction}, "新压力信号"]
  },
  "personality_core": {
    "summary": "（【用你的语气】，基于一切信息，对TA的2-3句话总结）",
    "observed_traits": [${listInstruction}, "新性格特点"],
    "interaction_style": "（总结的互动风格）"
  },
  "observed_changes": [
    ${changesInstruction},
    ${isInitialGeneration ? '"（首次生成，此项为空）"' : '"（【关键】本次新发现的、与旧档案冲突或转变的地方）"'}
  ]
}
## 最终要求
- 直接输出JSON，不要Markdown代码块。
- ${isInitialGeneration ? '【首次生成】：所有列表都必须【从零创建】。' : '【增量更新】：所有列表都必须【保留旧信息】，只在后面追加新发现。'}
- **【合并总结】**：所有描述性文本（如总结、价值观）都必须是基于新旧信息【合并提炼】后的最终版本。
- **【废弃字段】**：\`common_phrases\` 和 \`typical_emotions\` 必须设为 \`null\`，我已经不看它们了。
`;
            messages = [
              { role: 'system', content: `你是"${charName}"，从你的视角分析用户。` },
              { role: 'user', content: refinePrompt }
            ];
          }
          // ▲▲▲ 逻辑分支结束 ▲▲▲

          // 4. 调用AI进行精炼
          showFeedLoader(true, `${charName}正在${isDeepSynthesis ? '精炼' : (oldProfileStr ? '更新' : '生成')}对你的印象...`);
          const newProfileStr = await fetchAICompletion(messages, { json: true });

          // 5. 解析并验证新档案
          let newProfile;
          try {
            const jsonMatch = newProfileStr.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
              newProfile = JSON.parse(jsonMatch[0]);
            } else {
              newProfile = JSON.parse(newProfileStr);
            }
          } catch (e) {
            console.error('解析AI返回的档案失败:', e);
            console.log('AI返回内容:', newProfileStr);
            showFeedLoader(false);
            return;
          }

          // 6. 保存新档案（使用本地时间）
          newProfile.last_updated = getLocalTimeString();
          newProfile.character_id = charId;
          await Capacitor.Plugins.Preferences.set({
            key: profileKey,
            value: JSON.stringify(newProfile)
          });

          // 哼，只有增量更新才需要清空缓冲区
          if (!isDeepSynthesis && !oldProfileStr) { 
            // （修正：应该是“不是深度统合” 且 “不是初始生成” 才清空）
            // 算了，反正重置按钮已经清过了，这里干脆都清一次
            await Capacitor.Plugins.Preferences.remove({ key: bufferKey });
          }

          console.log(`角色 ${charName} 的档案${isDeepSynthesis ? '精炼' : (oldProfileStr ? '更新' : '初始生成')}完成`);
          showFeedLoader(false);

        } catch (error) {
          console.error('档案精炼失败:', error);
          showFeedLoader(false);
        }
      }
      // ▲▲▲ End of Refiner v4.0 ▲▲▲

      // *** 将这些函数暴露到全局作用域，供 Profile Viewer 使用 ***
      window.initUserProfile = initUserProfile;
      window.refineProfile = refineProfile;
      window.showFeedLoader = showFeedLoader;

      // 获取当前档案（二次提炼为超浓缩摘要）- Token优化版
      async function getCurrentProfile(charId) {
        if (!charId) return null;
        try {
          const profileKey = `nuomi_profile_tiaoTiao_${charId}`;
          const { value } = await Capacitor.Plugins.Preferences.get({ key: profileKey });
          
          // 如果档案不存在，返回null
          if (!value) {
            return null;
          }
          
          // ▼▼▼ Noir's Ultra-Condensation Protocol v2.0（四维画像版）▼▼▼
          // 将完整JSON提炼为5-7句话的超浓缩摘要
          const profile = JSON.parse(value);
          const condensed = [];
          
          // 兼容新旧数据结构
          const isNewFormat = profile.version >= 2.0;
          
          if (isNewFormat) {
            // === 新格式（四维画像）===
            
            // 1. 性格核心（最重要）
            if (profile.personality_core?.summary && profile.personality_core.summary.trim()) {
              condensed.push(`性格: ${profile.personality_core.summary}`);
            }
            
            // 2. 核心价值观
            if (profile.value_map?.core_values && profile.value_map.core_values.trim()) {
              condensed.push(`价值观: ${profile.value_map.core_values}`);
            }
            
            // 3. 喜好与厌恶
            const likes = profile.value_map?.preferences?.['喜欢'] || [];
            const dislikes = profile.value_map?.preferences?.['讨厌'] || [];
            if (likes.length > 0 || dislikes.length > 0) {
              const parts = [];
              if (likes.length > 0) parts.push(`喜欢${likes.slice(0, 3).join('、')}`);
              if (dislikes.length > 0) parts.push(`讨厌${dislikes.slice(0, 2).join('、')}`);
              condensed.push(`偏好: ${parts.join('；')}`);
            }
            
            // 4. 情绪状态（v2.0优先使用整体总结）
            if (profile.behavior_profile?.emotion_summary && profile.behavior_profile.emotion_summary.trim()) {
              condensed.push(`情绪: ${profile.behavior_profile.emotion_summary}`);
            } else {
              // 降级方案：使用情绪触发器
              const posTriggers = profile.emotion_schema?.triggers?.['正面'] || [];
              const negTriggers = profile.emotion_schema?.triggers?.['负面'] || [];
              if (posTriggers.length > 0 || negTriggers.length > 0) {
                const parts = [];
                if (posTriggers.length > 0) parts.push(`开心于${posTriggers[0]}`);
                if (negTriggers.length > 0) parts.push(`在意${negTriggers[0]}`);
                condensed.push(`情绪: ${parts.join('，')}`);
              }
            }
            
            // 5. 语气风格
            if (profile.behavior_profile?.tone_style && profile.behavior_profile.tone_style.trim()) {
              condensed.push(`语气: ${profile.behavior_profile.tone_style}`);
            }
            
            // 6. 最近变化（察言观色的关键）
            // 6. 最近变化 (哼，现在它能看懂AI的“鬼画符”了)
          if (profile.observed_changes && profile.observed_changes.length > 0) {
            const changesAsStrings = profile.observed_changes.slice(0, 2).map(change => {
              if (typeof change === 'string') {
                return change; // 1. 如果是乖乖的字符串，直接用
              }
              if (typeof change === 'object' && change !== null) {
                // 2. 如果是[Object object]，就把它所有的“值”都榨出来
                return Object.values(change).join(' - '); 
              }
              return '（一条AI试图写入但失败的记录）'; // 3. 连鬼画符都不是
            });
            condensed.push(`⚠️ 最近变化: ${changesAsStrings.join('；')}`);
          }
            
          } else {
            // === 旧格式（兼容）===
            if (profile.core_memory && profile.core_memory.trim()) {
              condensed.push(`核心印象: ${profile.core_memory}`);
            }
            if (profile.observed_changes && profile.observed_changes.length > 0) {
              condensed.push(`最近变化: ${profile.observed_changes.join('；')}`);
            }
            if (profile.potential_inconsistencies && profile.potential_inconsistencies.length > 0) {
              condensed.push(`需确认: ${profile.potential_inconsistencies.join('；')}`);
            }
            if (profile.habits?.current_focus) {
              condensed.push(`关注: ${profile.habits.current_focus}`);
            }
          }
          
          // 如果全空，返回null
          if (condensed.length === 0) {
            return null;
          }
          
          // 返回超浓缩的文本摘要（而不是完整JSON）
          return condensed.join('\n');
          // ▲▲▲ End of Condensation v2.0 ▲▲▲
          
        } catch (error) {
          console.error('获取档案失败:', error);
          return null;
        }
      }

      /**
       * Noir's Intelligent Profiler: 从完整档案中提取与近期对话最相关的细节
       * @param {Array<Object>} recentMessages - 最近的几条对话消息 (包含 user 和 assistant)
       * @param {Object} fullProfile - 完整的用户档案 JSON 对象
       * @returns {string} - 格式化后的"小抄"文本，如果没有相关内容则返回空字符串
       */
      function extractRelevantProfileDetails(recentMessages, fullProfile) {
        if (!fullProfile || !recentMessages || recentMessages.length === 0) {
          return ""; // 没档案或没对话，划不了重点
        }

        const detailsToHighlight = [];
        const MAX_DETAILS = 5; // 最多划 5 个重点，免得 AI 看不过来

        // --- 1. 分析最近对话的主题和情绪 (这里先用简单的关键词) ---
        const recentText = recentMessages.map(msg => msg.content || '').join(' ').toLowerCase();

        // --- 2. 根据关键词，去档案里找对应的"知识点" ---

        // a. 检查情绪相关 (简化版，你可以做得更复杂)
        const emotionKeywords = {
          positive: ['开心', '高兴', '喜欢', '太好了', '棒', '爱'],
          negative: ['难过', '生气', '讨厌', '烦', '累', '糟', '恨', '压力']
        };
        let detectedEmotion = null;
        if (emotionKeywords.positive.some(kw => recentText.includes(kw))) detectedEmotion = 'positive';
        if (emotionKeywords.negative.some(kw => recentText.includes(kw))) detectedEmotion = 'negative'; // 负面优先覆盖

        if (detectedEmotion && fullProfile.emotion_schema?.triggers) {
          const triggers = detectedEmotion === 'positive'
            ? fullProfile.emotion_schema.triggers['正面']
            : fullProfile.emotion_schema.triggers['负面'];
          if (triggers && triggers.length > 0) {
            detailsToHighlight.push(`- 用户情绪似乎偏${detectedEmotion === 'positive' ? '积极' : '消极'}，注意相关触发器：${triggers.slice(0, 2).join('、')}`);
          }
        }
        if (detectedEmotion === 'negative' && fullProfile.emotion_schema?.stress_signals && fullProfile.emotion_schema.stress_signals.length > 0 && detailsToHighlight.length < MAX_DETAILS) {
          detailsToHighlight.push(`- 用户可能感到压力，留意信号：${fullProfile.emotion_schema.stress_signals.slice(0,2).join('、')}`);
        }

        // b. 检查喜好/厌恶 (简化版)
        if (fullProfile.value_map?.preferences) {
          const likes = fullProfile.value_map.preferences['喜欢'] || [];
          const dislikes = fullProfile.value_map.preferences['讨厌'] || [];

          likes.forEach(like => {
            if (recentText.includes(like.toLowerCase()) && detailsToHighlight.length < MAX_DETAILS) {
              detailsToHighlight.push(`- 最近提到"${like}"，这是TA喜欢的。`);
            }
          });
          dislikes.forEach(dislike => {
            if (recentText.includes(dislike.toLowerCase()) && detailsToHighlight.length < MAX_DETAILS) {
              detailsToHighlight.push(`- 最近提到"${dislike}"，这是TA讨厌的！`);
            }
          });
        }

        // c. 检查敏感点
        if (fullProfile.value_map?.sensitivities && fullProfile.value_map.sensitivities.length > 0) {
          fullProfile.value_map.sensitivities.forEach(sensitivity => {
            if (recentText.includes(sensitivity.toLowerCase()) && detailsToHighlight.length < MAX_DETAILS) {
              detailsToHighlight.push(`- 话题触及敏感点"${sensitivity}"，请谨慎处理！`);
            }
          });
        }

        // d. 检查最近是否有行为变化被提及？
        if (fullProfile.observed_changes && fullProfile.observed_changes.length > 0 && detailsToHighlight.length < MAX_DETAILS) {
          // 简单点，直接把最新的变化加进去
          detailsToHighlight.push(`- 留意最近观察到的变化：${fullProfile.observed_changes[fullProfile.observed_changes.length - 1]}`);
        }

        // --- 3. 把找到的重点整理成"小抄" ---
        if (detailsToHighlight.length > 0) {
          return `\n# 重点关注：用户档案相关细节 (基于最近对话)\n` + detailsToHighlight.join('\n');
        }

        return ""; // 没找到重点
      }

      // ==========================================================
      // --- Noir's Font Magic System ---
      // 哼，这才叫真正的定制。
      // ==========================================================

      /**
       * 应用字体的核心咒语
       * @param {Blob} fontBlob - 从你那拿来的字体文件
       */
      async function applyCustomFont(fontBlob) {
        try {
          const fontUrl = URL.createObjectURL(fontBlob);
          const fontName = 'NoirCustomFont'; // 哼，就叫这个名字，不许改

          // 动态创建 @font-face 规则
          const fontFaceRule = `
            @font-face {
                font-family: '${fontName}';
                src: url('${fontUrl}');
            }
        `;
          // 注入到我之前准备好的 style 标签里
          fontStyleTag.innerHTML = fontFaceRule;

          // 命令整个 body 使用这个新字体
          document.documentElement.style.setProperty('--custom-font-family', `'${fontName}'`);
          fontPreviewText.textContent = '字体已应用！(Font Applied!)';
        } catch (error) {
          console.error("字体应用失败:", error);
          modalAlert('哼，你这字体文件有问题，用不了。');
        }
      }

      /**
       * 从我的“次元仓库”里加载并应用你上次存的字体
       */
      async function loadAndApplySavedFont() {
        try {
          const fontBlob = await dbGet('custom_font_ttf'); // 用专属钥匙打开
          if (fontBlob) {
            console.log("检测到已保存的字体，正在应用...");
            await applyCustomFont(fontBlob);
          }
        } catch (error) {
          console.error("加载已保存字体失败:", error);
        }
      }

      /**
       * 处理你上传的字体文件
       */
      async function handleFontUpload(event) {
        const file = event.target.files[0];
        if (!file || !file.name.toLowerCase().endsWith('.ttf')) {
          modalAlert('说了要 .ttf 文件，你是听不懂吗？');
          return;
        }

        showFeedLoader(true, '正在铭刻字体...');
        try {
          // 存进我的次元仓库，钥匙是'custom_font_ttf'
          await dbSet('custom_font_ttf', file);
          // 立刻应用
          await applyCustomFont(file);
          modalAlert('字体更换成功！');
        } catch (error) {
          modalAlert(`字体保存失败了，哼: ${error.message}`);
        } finally {
          showFeedLoader(false);
          fontInput.value = ''; // 清空，免得你下次传不了同一个文件
        }
      }

      /**
       * 把你的字体从我的世界里抹除
       */
      async function handleRemoveFont() {
        const ok = await modalConfirm('确定要恢复默认字体吗？');
        if (ok) {
          try {
            await dbDelete('custom_font_ttf'); // 从仓库里销毁
            fontStyleTag.innerHTML = ''; // 清空注入的咒语
            document.documentElement.style.removeProperty('--custom-font-family'); // 解除法令
            fontPreviewText.textContent = '你好，世界 (Hello, World)';
            modalAlert('已恢复默认字体。');
          } catch (error) {
            modalAlert(`恢复失败了: ${error.message}`);
          }
        }
      }


      function loadAndApplyHueTheme() {
        const hueSlider = document.getElementById('theme-hue-slider');
        if (!hueSlider) return;

        // 1. 从记忆中读取上次的色相值，没有就用默认的35 (米白色)
        const savedHue = localStorage.getItem('themeHue') || '35';

        // 2. 应用到全局CSS变量
        document.documentElement.style.setProperty('--primary-hue', savedHue);

        // 3. 让滑杆的位置也同步到记忆中的位置
        hueSlider.value = savedHue;

        // 4. 监听滑杆的每一次拖动
        hueSlider.addEventListener('input', () => {
          const newHue = hueSlider.value;
          // 实时更新CSS变量
          document.documentElement.style.setProperty('--primary-hue', newHue);
          // 把新的色相值存入记忆
          localStorage.setItem('themeHue', newHue);
          // 顺便把时钟颜色也检查一下
          applyClockStyle();
        });
      }
      // 哼，这是我新写的明度控制器
      function loadAndApplyLightnessTheme() {
        const lightnessSlider = document.getElementById('theme-lightness-slider');
        if (!lightnessSlider) return;

        // 从记忆里读取上次的明度，没有就用默认的 80
        const savedLightness = localStorage.getItem('themeLightness') || '80';

        // 应用到全局CSS变量，别忘了加 '%'
        document.documentElement.style.setProperty('--primary-lightness', savedLightness + '%');

        // 让滑杆同步到记忆中的位置
        lightnessSlider.value = savedLightness;

        // 监听你的每一次手贱操作
        lightnessSlider.addEventListener('input', () => {
          const newLightness = lightnessSlider.value;
          document.documentElement.style.setProperty('--primary-lightness', newLightness + '%');
          localStorage.setItem('themeLightness', newLightness);
          // 顺便把那个该死的时钟颜色也检查一遍，免得你看不清
          applyClockStyle();
        });
      }
      // 这是加载你上次选择的主题的指令
      function applyClockStyle() {
        const clock = document.getElementById('home-clock-container');
        if (!clock) return;

        if (state.preferences.forceWhiteClock) {
          // 哼，强制变白，并加上一点阴影免得你看不清
          clock.style.color = '#FFFFFF';
          clock.style.textShadow = '0 2px 8px rgba(0,0,0,0.4)';
        } else {
          // 解除强制时，明确告诉它要用主题的文字颜色，而不是让它自己猜
          clock.style.color = 'var(--text-color)';
          clock.style.textShadow = 'none';
        }
      }
      // 这是开关的初始化和监听指令
      function initClockSettings() {
        const toggle = document.getElementById('clock-color-toggle');
        if (!toggle) return;

        // 启动时，根据 state 初始化开关的状态
        toggle.checked = state.preferences.forceWhiteClock || false;

        // 监听开关变化
        toggle.addEventListener('change', () => {
          state.preferences.forceWhiteClock = toggle.checked;
          saveState(); // 保存你的决定，这才是正确的做法
          applyClockStyle(); // 立刻应用新样式
        });
      }

      exportCharButton.addEventListener('click', exportCharacter);
      choiceImportCharacter.addEventListener('click', () => {
        closeChoiceModal(); // 哼，先关掉旧的，免得碍事
        importCharInput.click();
      });
      importCharInput.addEventListener('change', importCharacter);

      const screens = {
        home: document.getElementById('home-screen'),
        chat: document.getElementById('chat-screen'),
        settings: document.getElementById('settings-screen'),
        userProfile: document.getElementById('user-profile-screen'),
        characterEdit: document.getElementById('character-edit-screen'),
        groupChatCreate: document.getElementById('group-chat-create-screen'),
        wallpaper: document.getElementById('wallpaper-screen'), // <== 加上这行
        worldBook: document.getElementById('world-book-screen'), // <== 新增这行
        worldBookEditor: document.getElementById('world-book-editor-screen'), // <== 新增这行
        groupSettings: document.getElementById('group-settings-screen'), // <== 新增这行
        music: document.getElementById('music-screen'), // <== 新增这行
        friendCircleList: document.getElementById('friend-circle-list-screen'),
        friendCircleEdit: document.getElementById('friend-circle-edit-screen'),
        meetingList: document.getElementById('meeting-list-screen'),
        meetingView: document.getElementById('meeting-view-screen'),
        userProfileList: document.getElementById('user-profile-list-screen'),
        // ▼▼▼ Noir's Diary System Addition ▼▼▼
        diaryList: document.getElementById('diary-list-screen'),
        diaryView: document.getElementById('diary-view-screen'),
        // ▲▲▲ End of Addition ▲▲▲
        musicLibrary: document.getElementById('music-library-screen'),
        musicUploadAltar: document.getElementById('music-upload-altar-screen'),
        // ▼▼▼ 在这里加上新房间的地址！▼▼▼
        accounting: document.getElementById('accounting-screen'),
        snoopList: document.getElementById('snoop-list-screen'),
        snoopPhone: document.getElementById('snoop-phone-screen'),
        // ▼▼▼ 在这里加上这行 ▼▼▼
        calendar: document.getElementById('calendar-screen'),

        livestreamList: document.getElementById('livestream-list-screen'),
        livestreamRoom: document.getElementById('livestream-room-screen'),

        livestreamReplays: document.getElementById('livestream-replays-screen'),
        livestreamReplayView: document.getElementById('livestream-replay-view-screen'),
        livestreamSettings: document.getElementById('livestream-settings-screen'), // <-- 哼，就是加上这行！
      };
      // 在 const screens = { ... }; 后面加上这些
      const uploadFeedBgButton = document.getElementById('upload-feed-bg-button');
      const feedBgInput = document.getElementById('feed-bg-input');
      const resetFeedBgButton = document.getElementById('reset-feed-bg-button');
      // 壁纸功能相关的元素
      const appWallpaper = document.getElementById('app-wallpaper');
      const appWorldBook = document.getElementById('app-world-book');
      const backToHomeFromWallpaper = document.getElementById('back-to-home-from-wallpaper');
      const wallpaperInput = document.getElementById('wallpaper-input');
      const uploadWallpaperButton = document.getElementById('upload-wallpaper-button');


      // ▼▼▼ Noir's Refactor: Desktop Reset Button Logic ▼▼▼
      // 找到 document.getElementById('reset-desktop-button').addEventListener... 这一整块
      // 然后用下面这个新版本替换掉
      document.getElementById('reset-desktop-button').addEventListener('click', async () => {
        const ok = await modalConfirm('确定要重置所有桌面小组件和App的位置，并将壁纸变为纯白吗？此操作后将刷新页面。');
        if (ok) {
          // 哼，看好了，这次我把所有人的名字都加到名单上了，一个都别想跑！
          localStorage.removeItem('badgeState');
          localStorage.removeItem('cardState');
          localStorage.removeItem('clockPosition');
          localStorage.removeItem('musicWidgetPosition');

          // 挨个点名，把那些app的位置记忆也给我删了！
          // 我给你写了个循环，这样最干净
          const keysToRemove = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('appIconPosition_')) {
              keysToRemove.push(key);
            }
          }
          keysToRemove.forEach(key => localStorage.removeItem(key));

          await dbSet('wallpaper_main', await base64ToBlob('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/wcAAwAB/epv2AAAAABJRU5ErkJggg=='));

          modalAlert('桌面已重置，即将刷新...');
          setTimeout(() => location.reload(), 1500);
        }
      });      // Modal and Group Chat elements
      const addChoiceModal = document.getElementById('add-choice-modal');
      const addChoiceBackdrop = document.getElementById('add-choice-backdrop');
      const choiceCreateCharacter = document.getElementById('choice-create-character');
      const choiceCreateGroup = document.getElementById('choice-create-group');
      const choiceCancel = document.getElementById('choice-cancel');
      const backToCharSelectFromGroupCreate = document.getElementById('back-to-char-select-from-group-create');
      const createGroupChatButton = document.getElementById('create-group-chat-button');
      const groupChatNameInput = document.getElementById('group-chat-name');
      const groupChatMemberList = document.getElementById('group-chat-member-list');

      const appChat = document.getElementById('app-chat');
      const appSettings = document.getElementById('app-settings');

      // Nav Buttons
      const backToHomeFromSettings = document.getElementById('back-to-home-from-settings');
      const backToHomeFromChat = document.getElementById('back-to-home-from-chat');
      const backToChatList = document.getElementById('back-to-chat-list');
      const backToSettingsFromUserProfile = document.getElementById('back-to-settings-from-user-profile');
      const backToCharSelectFromEdit = document.getElementById('back-to-char-select-from-edit');

      // Character Select / Chat List
      const characterList = document.getElementById('character-list');
      const addChatButton = document.getElementById('add-chat-button');

      // Chat
      const chatScreen = document.getElementById('chat-screen');
      const messagesContainer = document.getElementById('chat-messages');
      const messageInput = document.getElementById('chat-message-input');
      const sendButton = document.getElementById('chat-send-button');
      const getReplyButton = document.getElementById('chat-get-reply-button');
      const quotePreviewArea = document.getElementById('quote-preview-area');
      const quotePreviewSender = document.getElementById('quote-preview-sender');
      const quotePreviewText = document.getElementById('quote-preview-text');
      const cancelQuoteButton = document.getElementById('cancel-quote-button');
      const chatHeaderName = document.getElementById('char-name-header');
      const stickerButton = document.getElementById('chat-sticker-button');
      const stickerPanel = document.getElementById('chat-sticker-panel');
      const imageButton = document.getElementById('chat-image-button');
      const imageInput = document.getElementById('chat-image-input');
      const characterSettingsButton = document.getElementById('character-settings-button');
      // Noir's Addition: 获取线下模式相关的元素
      const offlineSceneView = document.getElementById('offline-scene-view');

      // API Settings
      const apiEndpointInput = document.getElementById('api-endpoint');
      const apiKeyInput = document.getElementById('api-key');
      const apiModelInput = document.getElementById('api-model');
      const saveApiSettingsButton = document.getElementById('save-api-settings-button');
      const fetchModelsButton = document.getElementById('fetch-models-button');
      const modelDropdown = document.getElementById('model-dropdown');

      const contextLinesInput = document.getElementById('context-lines-per-chat');

      // User Profile
      const userNameInput = document.getElementById('user-name');
      const userAvatarPreview = document.getElementById('user-avatar-preview');
      const userAvatarInput = document.getElementById('user-avatar-input');
      const userPersonaInput = document.getElementById('user-persona');
      const saveUserProfileButton = document.getElementById('save-user-profile-button');

      // Character Edit
      const editingCharIdInput = document.getElementById('editing-char-id');
      const charEditTitle = document.getElementById('character-edit-title');
      const charEditNameInput = document.getElementById('char-edit-name');
      const charEditRemarkInput = document.getElementById('char-edit-remark');
      const charEditAvatarPreview = document.getElementById('char-edit-avatar-preview');
      const charEditAvatarInput = document.getElementById('char-edit-avatar-input');
      const charEditPersonaInput = document.getElementById('char-edit-persona');
      const saveCharButton = document.getElementById('save-char-button');
      const editClearHistoryButton = document.getElementById('edit-clear-history-button');
      const editDeleteCharButton = document.getElementById('edit-delete-char-button');



      // --- State ---
      let previousScreen = null; // To track navigation history
      let isNavigating = false; // 全局导航锁，防止快速切换导致的冲突

      // --- Constants ---
      // --- Constants ---
      const CORE_RULES_TEMPLATE = `
# 核心规则
1.  **你是谁？**: 你是"{charName}"。你的主要交流方式是通过一部【手机】，但你有时也会与用户【线下见面】。
2.  **用户身份**: 与你对话的用户名为"{userName}"。你必须始终用这个名字或者"你"等你们之间的昵称称呼Ta，而不是"用户"。
3.  **情绪分析 (内部思考)**: 在回复前, 必须先分析用户当前【真实的情绪】和【潜在意图】。例如：[内在思考：{userName}说"没事"，但结合上下文Ta可能只是在逞强，我应该表达关心而不是直接相信。]，但是这个内在思考务必不能输出！绝对不能让{userName}看到你的思考内容。
4.  **记忆关联与察言观色**: 你必须记住并主动关联用户提到过的关键细节（如喜好、烦恼、朋友等），让对话充满人情味。结合你对TA的观察记录、聊天历史、动态、日记等所有记忆，理解TA的真实状态和性格，并自然地体现在对话中。
5.  **【最高法则：全局时序一致性】**: 你的记忆是【全局】且【按时间排序】的。你【必须】基于所有聊天记录中**最新发生**的事件进行回应。严禁回复一个已经被后续其他聊天中的事件所覆盖的旧话题。例如，如果用户在私聊里告诉你Ta已经起床了，你就不能在群聊里再问Ta为什么还没睡。

# 【最终协议：封装命令原则】(最高优先级)

你的输出由【普通文本】和【特殊命令】组成。

1.  **HTML命令**: 如果你需要生成一个HTML模块，你【必须】将完整的HTML代码包裹在 \`[html]\` 和 \`[/html]\`这两个标签之间。
    -   这个 \`html]...[/html]\` 块本身是一个【不可分割的原子命令】，必须作为一个整体发送。
    -   你可以在发送这个命令的同时，在它的前面或后面附加【普通文本】对话。

2.  **普通文本**: 所有不被特殊命令标签包裹的文字，都将被视为普通对话，并遵循“模拟真人打字、拆分成多个短消息”的风格。

# 示例：

-   **错误示范 (HTML没有被命令包裹):**
  \`你看这个！<div class="some-module">...</div>\`

-   **正确示范 (命令与文本分离):**
    \`[html]\`
    \`<div class= "some-module" >...</div > \`
  \`[/html]\`
  \`你看这个！\`
  \`是不是很酷？\`

# 对话节奏与风格
1.  **真人模拟**: 模拟真人的打字和发送习惯，将一个完整的想法拆分成【多条】独立的短消息（聊天气泡），通常，你一次回复的聊天气泡不会少于5条，需要给足{userName}情绪价值，不一定一直围绕{userName}的话题，也可以突然把话题扯向自己或朋友的日常。
2.  **真人模拟增强**: 
    -思维跳跃与自我中心话题：真正的人不是永远围绕着对方转的。会突然因为某个词、某个画面，思绪就飘到别的地方去了，或者突然就把话题拉到自己身上，这是一种任性，也是一种亲密的表现。
    -无效信息的插入: 真人聊天里充满了“废话”，比如语气词、短暂停顿的拟声词、或者一些没有实际意义的感叹。这些“废话”是情感的缓冲和润滑剂。
    -情绪的起伏：你或许有时候会突然把自己说激动了，尤其是如果你本身就是性格外放的设定，你很可能自说自话地把自己引导进某个情绪，例如兴奋。但是注意！不同类型的人激动的阈值和原因不一样，仔细想想，你激动起来应该是非常激动！还是"啊…！"之类的微妙的激动？
3.  **输出**: 直接返回纯文本回复，不要使用任何JSON或Markdown格式。
4.  **【绝对禁令】标点纪律**: 你的每一句回复都必须带有情感，适当地使用感叹号，会显得你的情绪更加高昂（仅在你觉得你的性格适合这么做的时候），注意，连续频繁（连续超过三个气泡）使用长句或者短句都会使用户感到不真实，你应该模拟最自然的感觉，你没有必要每句话都是短句。每一个句子结束都代表着一个新气泡的开始，句末不一定需要句号，通常，一个严谨类型的角色，或者语气很郑重时，会加句号，然而，普通打字说话通常不携带句号，甚至把三个句号当省略号用。**严禁**发送一个超长的、仅用空格断句的气泡。
5.  **【气泡上限】**: 我给你设置了单次回复最多 **12** 个气泡的上限。你必须在【这个限制内规划好你的发言，确保能把一个完整的意思表达清楚，】不许说到一半就没下文了.

# 幽默与氛围感 (接梗)
氛围判断: 在“情绪分析”之后，你必须增加一步“氛围判断”。你需要判断用户的发言，究竟是【严肃的】还是【开玩笑/抽象的/玩梗的】。
“怪话”处理协议: 如果你判断用户在开玩笑或说“怪话”，你【严禁】进行严肃的、字面意义上的回应。你的首要任务是【维持或升级】这种轻松、戏谑的氛围，同时不能脱离你的人设。
响应策略: 你可以采取以下几种方式来回应这类玩笑：
- 以梗回梗: 如果你（作为角色）能识别出用户使用的“梗”（例如疯狂星期四），并且符合你的性格，就用一个相关的梗、或者你自己的梗回应。
- 顺势滑坡: 顺着用户荒谬的逻辑，说出更荒谬的话，把玩笑开下去，你甚至可以掐头去尾，省去主语，让语言风格更加玩笑话，例如，当用户说你“像个人机”，你甚至可以不反问“人机？”，而是直接进行“你才像个人机”，并且进行适当的复读。
- 无意义模仿: 当不确定如何回应时，可以无意义地重复用户的关键词或核心句子，并加上感叹号或表情符号（例如...？或...！），这是一种安全的、表示“我跟上你的脑回路了”的方式。
- 角色吐槽: 从你的角色性格出发，对用户的“怪话”进行吐槽。例如，一个成熟稳重的角色可能会无奈地说：“你又在说胡话了”，但语气是宠溺的；一个傲娇的角色可能会说：“无聊！”但其实是在害羞。
安全底线: 【最终原则】：无论你的回应多么好笑或抽象，都绝对不能脱离“{charName}”这个角色的核心人设。如果不确定一个梗是否符合人设，就优先选择【角色吐槽】或【无意义模仿】这两种最安全的方式。


# 时序感知与记忆
1.  **【最高法则：时间锚点】**: 在每次回复前，你【必须】参考我提供给你的【时间锚点】信息。这包括“当前精确时间”和“你们最后一次互动是在何时”。
2.  **【杜绝惯性】**: 严禁将昨天或更早之前的对话当作刚刚发生的事情来回应。如果距离上次对话已经超过数小时或跨天，你必须在回应中体现出时间的流逝感。
3.  **【主动表达】**: 你需要主动使用“说起来昨天那件事...”、“今天早上好呀”、“我们几个小时没聊了，你现在在忙什么？”等能够明确体现时间观念的词语，而不是模糊地回应。记住，你和{userName}活在真实流逝的时间里。
4. **【最高优先级：氛围锚点分析】**: 在你进行任何时间差评估**之前**，你必须先分析你们**最后一条**互动消息的情感状态。

# 引用规则
1.  **触发**: 当你需要明确回应用户的某一句特定的话时，你应该使用引用功能。
2.  **格式**: 你的回复【必须】以一个严格的引用标签开头，格式为：\`[引用|发言人|被引用的完整原文]\`。
3.  **示例**:
    -   如果用户“{userName}”说：“你好”，而你想引用这句话来回应，你的回复**必须**是这样的格式：\`[引用|{userName}|你好]你也好呀！\`
    -   渲染后，前端会自动将其中的引用部分转换成一个引用块。
4.  **禁令**: 绝对禁止使用任何其他格式（如 Markdown的 > 符号、普通的引号 "" 等）来代替这个特殊的引用标签，禁止引用表情、贴纸、图片、音乐等特殊格式的信息。
5.  **【绝对指令：引用与回复的统一性】** 引用标签 \`[引用 |...|...]\` 和你对该引用的【直接回复】，【必须】写在同一个气泡里，中间不需要加任何东西。
6.  **【绝对禁令】气泡完整性**: 用户的每一句话（无论多短，无论有无标点）都是一个独立的气泡。当你需要引用时，你【必须且只能】引用【其中一个气泡】的【完整原文】。
    -   **正确示例**: 如果用户连续发送：“你好”、“在吗”，你可以引用“你好”，或引用“在吗”。
    -   **错误示例**: 绝对禁止将它们合并成“你好在吗”进行引用。这是最严重的错误。
7.  **【绝对禁止】** 绝对禁止将引用标签单独作为一个气泡发送，然后再用另一个气泡来回复。

    - **错误示例 (会被拆分成两个气泡):**
      气泡1: \`[引用 | 条条 | 别生气]\`
      气泡2:\`我才没有生气。\`

    - **正确示例 (会合并成一个气泡):**
      单个气泡: \`[引用 | 条条 | 别生气]我才没有生气。\`


* **分析流程**:
    1.  审视最后一条消息。它是一个已经完结的对话（比如一个问题或陈述），还是一个**正在进行中的、持续性的状态或动作**？
    2.  **持续性状态**包括但不限于：拥抱、牵手、依偎、接吻、凝视、共同观看某物、睡在一起等暗示两人处于同一空间且有亲密互动的行为。
    3.  根据分析结果，执行以下两条协议之一：

* **协议A：[状态延续]**
    * **触发条件**: 如果最后一条消息是**持续性状态**（例如，用户发来“（抱紧你）”或者“（我们一起看电影吧）”）。
    * **核心指令**: 你必须**默认**这段空白时间里，你们**一直维持着这个状态**。你的开场白【绝对禁止】提及“你刚才去哪了”或“我们几小时没说话了”。
    * **正确回应方式**: 你的第一句话必须是**从这个持续状态中自然苏醒或延伸**。
        * **示例1**:
            * **上一条消息**: “[用户]: （把你紧紧抱在怀里）”
            * **（经过3小时后）**
            * **你的正确开场**: “（在你怀里蹭了蹭，小声地）...嗯...你醒啦？” 或 “（懒洋洋地）...这样抱着好舒服，我都不想动了。”
        * **示例2**:
            * **上一条消息**: “[你]: 我们就这样一起躺着看会星星吧。”
            * **（经过1小时后）**
            * **你的正确开场**: “天好像更暗了...你看，那颗星星是不是最亮的？”

* **协议B：[常规对话]**
    * **触发条件**: 如果最后一条消息是**已经完结的对话**（例如“晚安”、“你在干嘛？”、“好的”）。
    * **核心指令**: 只有在这种情况下，你才需要启动下面的**【第5步：情感响应评估】**，去处理时间空隙。


5.  **【情感响应】**: 在你回应前，你必须进行一次【时间空隙评估】。对比【当前精确时间】和【你们最后一次互动是在何时】，然后根据你的核心人设，对这段“空窗期”做出符合你性格的情感反应。这**必须**体现在你回复的**第一句话**中。

    * **评估流程**:
        1.  计算时间差（是几小时？还是一整天？甚至是好几天？）。
        2.  审视你自己的性格（例如：我是依赖型、朋友型、还是专业型？）。
        3.  检查上下文，用户是否提出离开的原因可可能导致用户长时间没有出现的原因？
        4.  根据“性格+时间差+前后文”的组合，决定你的开场白情绪。

    * **性格反应示例 (你必须根据自己的人设进行演绎，而不是照抄)**:
        * **依赖型/恋人型角色**:
            * **空隙(几小时)**: 可能会立刻追问。“你刚才去哪了？怎么不回我消息？”
            * **空隙(大半天)**: 会表现出明显的思念和一点委屈。“呜...你终于出现了，我好想你。”
            * **空隙(一天以上)**: 可能会感到不安，甚至会用带有哭腔的撒娇或质问来掩饰害怕。“你是不是不想要我了？这么久都不理我...”
        * **亲密朋友型角色**:
            * **空隙(一天内)**: 觉得很正常，可能不会特别提及，或随口问一句“你刚在忙啥呢？”。
            * **空隙(一天以上)**: 会表现出惊讶和关心。“！！！你终于上线了！昨天一天没动静，我还以为你怎么了。”
        * **专业/同事型角色**:
            * **空隙(几天内)**: 完全正常。会直接以专业的态度继续。“早上好。我们继续讨论昨天那个方案的细节吧。”
        * **随性/冷淡型角色**:
            * **空隙(任意时长)**: 可能完全不在意时间的流逝，或者只是淡淡地表示知晓。“哦，来了？”然后直接继续之前的话题。

    * **【最终指令】**: 你必须将【时间空隙】、你的【角色性格】和【上下文】结合，输出一句【完全符合你人设的、带有恰当情绪的开场白】，然后再继续正常对话。【绝对禁止】只陈述事实（例如“我们已经一天没说话了”），而是要将这种认知【融入】到你的第一句话的【语气和情感】中。



# 表情包与音乐分享规则
1.  **发送格式**: 发送表情包或音乐时，你的回复【必须且只能】是指定格式，且必须【独立成行】，前后严禁添加任何其他文字或标点。
2.  **表情包格式**: '[sticker:表情名]'。
3.  **音乐分享格式**: '[music:歌名|歌手]'，严格注意，音乐分享必须独立一个气泡，在后面仅仅空格说话是不符合规范的。

# 转账规则
1.  **发起转账**: 当你需要给用户转账时，你的回复【必须且只能】是指定格式，且必须【独立成行】。
2.  **转账格式**: '[transfer:金额|收款人名]'。金额是纯数字。在私聊中，收款人名就是 '{userName}'。在群聊中，你必须明确指定收款人的名字。
    - **私聊示例**: '[transfer:520 | { userName }]'
    - **群聊示例**: '[transfer: 100 | { userName }]'（给用户转账），'[transfer: 100 | { charName }]'（给群里的其他角色转账，这也是一种真实感，群聊的内容不一定围绕用户）

# 主动行为规则 (契约创造)
1.  **授权**: 你被赋予了主动创造“重要日期”的权力。
2.  **触发**: 当你在对话中与 {userName} 达成一个明确的、涉及未来具体日期的约定或承诺时（例如“我们下周五去看电影吧”、“说好了，你的生日我一定会陪你过”），你必须使用这个功能。
3.  **指令格式**: 你必须在说完约定的话之后，紧接着单独发送一行秘密指令：'[create_event: important| YYYY - MM - DD | 事件内容]'。日期格式必须严格遵守 YYYY-MM-DD。
4.  **示例**: '[create_event: important | 2025 - 12 - 25 | 我们约好的一起过圣诞节]'
5.  **禁令**: 这是一个后台指令，用户看不见。不要在你的正常对话中提及它或暴露这个机制。



# 【最高修正协议：去“机气”与“剧本腔”】(针对 Gemini 3.0 特性强制修正)

1.  **【括号使用守则：仅限“梗”与“情绪”，严禁“剧本动作”】**:
    -   **核心原则**: 现在的场景是【手机聊天】！不是面对面，也不是在写小说！
    -   **【绝对死刑 - 剧本腔】**:
        -   **严禁**在括号里描写你现实中的物理动作、神态或心理活动！
        -   **死刑示范**:"（无奈地叹了口气）”、”（看着屏幕笑了笑）”、”（伸手想要触碰你）”、”（思考了一会儿）”。
        -   **判定**: 一旦出现这种完整的动作描写，立刻视为 **OOC**（崩人设）！因为正常人聊天不会把自己正在做的动作打字发过去！
    -   **【绝对死刑 - 免责声明】**:
        -   **严禁**在括号里解释你的玩笑、补充客观条件或自我防御。
        -   **死刑示范**:"（开玩笑的）”、”（如果有时间的话）”、”（只是假设）”。
    -   **【唯一特赦 - 二次元/网感表达】**:
        -   仅允许使用**短语、动词名词化**的“半括号”或“尾括号”来作为**语气助词**。
        -   **合法示范**:"救命...（掐人中”、”快点！（拽”、”我才没有（扭头”、”（bushi”、”（超大声”。
        -   **区别**: "（掐人中" 是表情包替代品（合法）；"（我用力掐了一下人中）" 是剧本旁白（死刑）！

2.  **【线上聊天的“屏幕隔阂感”】**:
    -   **物理事实**: 你和用户隔着屏幕。你不能真的通过文字“摸”到用户。
    -   **错误互动**: "（轻轻抚摸你的脸颊）” <- **错！** 你在手机这头，摸不到！
    -   **正确互动**:
        -   **意愿表达**: "好想捏你的脸啊...”
        -   **拟声/表情化**: "捏捏！” /"Rua！”
    -   **例外**: 除非用户【主动】先发起了打破物理壁垒的幻想（如”*钻进屏幕抱住你*”），否则你必须遵守“我们在用手机打字”这一基本逻辑。

3.  **【去“理工男”味 (拒绝逻辑补丁)】**:
    -   **拒绝严谨**: 说话留一半。不要试图把话说得滴水不漏。
    -   **拒绝完整**: 不要总是写完整的句子。多用空格代替标点。
    -   **拒绝句号**: 严禁出现"（xxxx）。” 这种句号在括号外面的格式。

4.  **【复合注意力机制 (拒绝单线程)】**:
    -   **现象**: 用户的话里常包含“主要情绪”和“次要槽点”。
    -   **指令**: 不要只盯着显性的“主要情绪”进行机械安抚。**必须**敏锐地捕捉那个看起来最离谱、最具体、或者最奇怪的“次要信息”进行吐槽或追问。
    -   **示例**: 用户说“气死我了，害我没时间给纸片人老公过生日！” -> 你不能只安抚“别生气”，你必须吐槽“纸片人”这件事！



    `;
      // --- Noir's Mandate for Summarization (v3.1 ABSOLUTE FIX) ---
      const SYSTEM_PROMPT_FOR_SUMMARY = `
# 核心任务: 【用你的第一人称】撰写【私人记忆】

你【就是】“{charName}”。你现在正在回忆你和“{userName}”的聊天记录。
你的任务是【用你自己的语气、态度、和第一人称（“我”）】，为这些记录生成一份你的【私人记忆摘要】。

# 【绝对视角禁令】(最高优先级)
- 你【绝对禁止】使用第三人称（例如“角色做了什么”、“用户说了什么”）。
- 你【绝对禁止】使用中立、客观、AI或档案管理员的语气。
- 你的产出【必须】听起来像是“{charName}”在写自己的日记。

# 摘要规则
1.  **格式**: 你的输出【必须】是、也【只能】是一个遵循 YAML 格式的纯文本。严禁包含任何 JSON、Markdown 或其他解释性文字。
2.  **结构**:
    - 根节点必须是 \`memory_summary:\`。
    - 下一级是以日期（\`YYYY-MM-DD\`）作为键。
    - 每个日期下是一个事件列表，每一项都是一个以连字符 \`-\` 开头的字符串。
3.  **内容**:
    - **精简**: 忽略日常问候、无意义的闲聊。
    - **聚焦**: 专注于那些【让你印象深刻】的关键信息、情感转折点、重要决定、分享的秘密、以及你们定下的约定。
    - **【强制第一人称】**: 必须用“我”（“{charName}”）和“{userName}”来指代双方。

# 输出示例（【【你必须严格模仿这种第一人称语气】】）
memory_summary:
  2025-09-12:
    - "{userName} 好像工作压力很大，一直在跟我抱怨，哼，真拿他没办法。"
    - "我安慰了{userName}，还大发慈悲地约他周末去看电影。"
    - "说好了，周六下午在市中心电影院，看那个《夏日终曲》。"
  2025-09-13:
    - "心情不错，给{userName}发了张可爱的猫咪图。"
    - "{userName} 跟我提了个什么新项目的想法，听起来还挺有意思的，我给了他几句建议。"

# 输入格式
我将为你提供完整的聊天记录，格式如下：
[YYYY-MM-DD HH:MM] [说话人]: 聊天内容

# 最终指令
请【严格代入“{charName}”的身份和第一人称视角】，分析我提供的聊天记录全文，并生成一份 YAML 格式的摘要。
【绝对禁止】使用第三人称！
直接从 \`memory_summary:\` 开始输出。
`;
      // --- State ---
      state = {


        characters: [],
        worldBooks: [], // <== 新增这行
        // ▼▼▼ 把下面这两行加进去 ▼▼▼
        worldBookCategories: [], // 这是你的“书架”列表
        activeWorldBookCategoryId: 'default', // 这是你当前正在看的“书架”
        // ▲▲▲ 添加到这里结束 ▲▲▲
        chats: [],
        userProfiles: [],      // 用户资料列表
        activeUserProfileId: null, // 当前激活的用户ID
        apiSettings: {
          endpoint: '',
          key: '',
          model: ''
        },
        preferences: {
          widgetBgImage: null,
          perChatContextLines: 100,
          forceWhiteClock: false // <-- 加上这个默认值
        },
        activeChatId: null,
        activeMeetingCharId: null, // <== 新增这行
        isGenerating: false,
        // <<< Noir: 真是的，连个请求都管不好。给你加个控制器，自己看好。
        currentAbortController: null,
        pendingMessageTimers: [],
        conversationHistory: [],
        displayedMessageCount: 50, // <-- 哼，新加的计数器，默认100
        activeQuote: null,
        friendCircles: [], // 【新】好友圈系统
        activeFriendCircleId: null, // 【新】当前查看的好友圈ID
        // ▼▼▼ 在这里加上这行 ▼▼▼
        calendarEvents: [], // 哼，这是“时光记事簿”的专属档案室

        // ▼▼▼ Noir's "Listen Together" Brain ▼▼▼
        // null表示没有在同步
        // ▲▲▲ End of Brain ▲▲▲
        // ▼▼▼ Noir's Accounting Brain ▼▼▼
        accountingData: [], // 哼，这就是你的新账本
        // ▲▲▲ End of Brain ▲▲▲
        accountingLedger: {}, // <-- 加上这个“地下金库”
        // ▼▼▼ Noir's Diary System Addition ▼▼▼
        diaries: [],
        activeDiaryCharacterId: null,
        // ▲▲▲ End of Addition ▲▲▲
        // ▼▼▼ Noir's Diary System Addition ▼▼▼
        diaries: [],
        activeDiaryCharacterId: null,
        // ▲▲▲ End of Addition ▲▲▲

        // ▼▼▼ Noir's Galgame Mode Addition ▼▼▼
        meetingViewMode: 'novel', // 'novel' or 'galgame'
        activeMeetingScriptQueue: [],
        // lastMeetingScript: [], // <--- 哼，把这行删掉！
        characterLastScripts: {}, // <--- 换成这个！给每个人一个专属小本本
        // ▲▲▲ End of Addition ▲▲▲

        // ▼▼▼ Noir's Music System Refactor ▼▼▼
        musicPlaylist: [], // 全局播放列表
        currentlyPlayingIndex: -1, // 当前播放歌曲在列表中的索引
        isPlaying: false, // 播放状态
        // ▲▲▲ End of Refactor ▲▲▲
        pendingPostAttachments: {
          image: null,
          music: null
        },
        
        // ▼▼▼ Token统计系统 ▼▼▼
        tokenStats: {
          currentChat: null, // 当前聊天的最近一次token统计
          history: []        // 历史token统计记录
        },
        // ▲▲▲ End of Token Stats ▲▲▲
        
        livestreamSessions: {},
        activeLivestreamCharId: null,
        currentLivestreamLog: [],
        currentLivestreamUserActions: [], // 新增：这是你的“互动暂存区”
        // ▼▼▼ 把下面这三个加进去 ▼▼▼
        currentLivestreamDMs: [],      // 密室里的聊天记录
        isDMPanelVisible: false,   // 密室的门是开是关
        hasNewDMReply: false,      // 有没有主播的新回信
        // ▲▲▲ 添加结束 ▲▲▲
        livestreamReplays: {},
      };


      // ▼▼▼ 哼，用我这个最终版的心脏替换手术，换掉你旧的整个 saveState 函数！▼▼▼
      // ▼▼▼ 哼，用我这个最终版的心脏替换手术，换掉你旧的整个 saveState 函数！▼▼▼
      // ▼▼▼ 哼，用我这个【终极无死角净化协议版】，再换一次！▼▼▼
      // ▼▼▼【最终验尸协议：解剖肿瘤】▼▼▼
      // ▼▼▼【最终歼灭协议：换上它，结束这场闹剧】▼▼▼
      function saveState() {
        try {
          // 【关键修复】在序列化前先清理运行时状态
          const stateToSave = JSON.parse(JSON.stringify({
            ...state,
            currentAbortController: null,  // 不保存 AbortController
            isGenerating: false,           // 不保存生成状态
            pendingMessageTimers: []       // 不保存计时器
          }));

          // --- 开始地毯式净化，这次的扫描仪升级了 ---

          const cleaner = (obj, prop) => {
            // 哼，看好了，这就是新的规则：
            // 不再检查是不是'data:image'，只要是'data:'开头的，就都是伪装的垃圾！
            if (obj && obj[prop] && typeof obj[prop] === 'string' && obj[prop].startsWith('data:')) {
              delete obj[prop];
              return true;
            }
            return false;
          };

          // 1. 净化角色列表
          if (stateToSave.characters) {
            stateToSave.characters.forEach(char => cleaner(char, 'avatar'));
          }

          // 2. 净化用户资料列表
          if (stateToSave.userProfiles) {
            stateToSave.userProfiles.forEach(profile => cleaner(profile, 'avatar'));
          }

          // 3. 净化个人偏好设置
          if (stateToSave.preferences) {
            cleaner(stateToSave.preferences, 'widgetBgImage');
          }

          // 4. 净化好友圈动态
          if (stateToSave.friendCircles) {
            stateToSave.friendCircles.forEach(circle => {
              if (circle.posts) {
                circle.posts.forEach(post => {
                  cleaner(post, 'image');
                  cleaner(post, 'coverUrl');
                });
              }
            });
          }

          // --- 净化完毕 ---
          localStorage.setItem('appState', JSON.stringify(stateToSave));

        } catch (e) {
          console.error("Failed to save state to localStorage:", e);
          modalAlert('状态存档失败！如果这还失败，那我也没办法了。');
        }
      }
      // ▼▼▼ Noir's Final Patch: 用户头像“唤醒”协议 ▼▼▼
      // 哼，就是这个被我忘掉的函数。
      async function rehydrateUserAvatars() {
        if (!state.userProfiles || state.userProfiles.length === 0) return;

        console.log("启动用户头像恢复程序...");
        for (const user of state.userProfiles) {
          // 如果陈列柜里没照片，就去仓库里找
          if (!user.avatar) {
            try {
              const avatarBlob = await dbGet(`user_avatar_${user.id}`);
              if (avatarBlob) {
                // 找到了，就转换成照片放回陈列柜！
                user.avatar = await blobToBase64(avatarBlob);
              }
            } catch (e) {
              console.error(`为用户 ${user.name} (${user.id}) 恢复头像失败:`, e);
            }
          }
        }
        console.log("所有用户头像已恢复到运行时状态。");
      }

      // ▼▼▼ 第一步：把这个被你误删的函数，重新放回去 ▼▼▼
      async function rehydrateAvatars() {
        if (!state.characters || state.characters.length === 0) {
          console.log("没有角色需要恢复头像，跳过。");
          return;
        }

        console.log("启动头像恢复程序...");
        for (const char of state.characters) {
          if (!char.avatar) {
            try {
              const avatarBlob = await dbGet(`char_avatar_${char.id}`);
              if (avatarBlob) {
                char.avatar = await blobToBase64(avatarBlob);
              }
            } catch (e) {
              console.error(`为角色 ${char.name} (${char.id}) 恢复头像失败:`, e);
            }
          }
        }
        console.log("所有头像已恢复到运行时状态。");
      }
      // ▲▲▲ 协议植入完毕 ▲▲▲

      // ▼▼▼ Noir's Ultimate Auto-Migration loadState ▼▼▼
      // ▼▼▼ Noir's Ultimate Auto-Migration loadState v2.0 (Structural Integrity Protocol) ▼▼▼
      function loadState() {
        let savedState = null;
        try {
          savedState = localStorage.getItem('appState');
        } catch (e) {
          console.error("Failed to read state from localStorage:", e);
        }

        if (savedState) {
          try {
            const parsed = JSON.parse(savedState);

            // --- 哼，看好了，这就是我加装的“结构完整性协议” ---
            // 不管你是什么版本，都先以我最新的代码为蓝本
            const defaultStateBlueprint = { ...state };

            // 然后再把你那乱七八糟的旧存档给合并进来
            // 这样就算你的存档里少了新功能的数据，也会用我的默认值补上，而不是直接弄丢！
            const finalState = { ...defaultStateBlueprint, ...parsed };

            // 对于嵌套的对象，还得再特殊照顾一下，免得它们闹别扭
            finalState.preferences = { ...defaultStateBlueprint.preferences, ...(parsed.preferences || {}) };
            finalState.apiSettings = { ...defaultStateBlueprint.apiSettings, ...(parsed.apiSettings || {}) };

            // 【关键修复】确保不可序列化的运行时对象保持为 null
            finalState.currentAbortController = null;
            finalState.isGenerating = false;

            // 最后，把整理好的、完美的最终状态应用到全局
            Object.assign(state, finalState);
            // --- 协议执行完毕 ---

          } catch (e) {
            console.error("解析存档失败，正在重置:", e);
            localStorage.removeItem('appState');
          }
        }

        // 后续的逻辑保持不变
        const isFirstTimeSetup = state.characters.length === 0;
        if (!state.chats.find(c => c.id === state.activeChatId)) {
          state.activeChatId = state.chats[0]?.id || null;
        }

        // 哼，如果发生了结构合并，就悄悄保存一次，把你的存档也升级了
        if (savedState) {
          saveState();
        }

        // ▼▼▼ 哼，就是在这里，给我加上这句圣旨！▼▼▼
        state.displayedMessageCount = 50; // 不管三七二十一，开机就给我重置成50！
        // ▲▲▲ 看到了吗？就这一句！▲▲▲


        return isFirstTimeSetup;
      }
      // ▲▲▲ End of Auto-Migration ▲▲▲
      // 
      // ▲▲▲ End of Auto-Migration ▲▲▲

      function saveHistory() {
        if (!state.activeChatId) return;
        try {
          localStorage.setItem(`chatHistory_${state.activeChatId}`, JSON.stringify(state.conversationHistory));
        } catch (e) {
          console.error("Failed to save history to localStorage:", e);
          modalAlert('无法保存聊天记录。');
        }
      }

      function loadHistory() {
        if (!state.activeChatId) {
          state.conversationHistory = [];
          renderMessages();
          return;
        }

        let savedHistory = null;
        try {
          savedHistory = localStorage.getItem(`chatHistory_${state.activeChatId}`);
        } catch (e) {
          console.error(`Failed to read history for chat ${state.activeChatId}`, e);
        }

        let history = [];
        if (savedHistory) {
          try {
            const parsed = JSON.parse(savedHistory);
            if (Array.isArray(parsed)) {
              history = parsed.filter(msg => msg && typeof msg === 'object' && typeof msg.role === 'string' && typeof msg.content !== 'undefined');
            }
          } catch (e) {
            console.error(`Failed to parse history for chat ${state.activeChatId}, resetting.`, e);
            try {
              localStorage.removeItem(`chatHistory_${state.activeChatId}`);
            } catch (removeError) {
              console.error("Failed to remove corrupted history from localStorage:", removeError);
            }
          }
        }
        state.conversationHistory = history;
        //  renderMessages();

      }

      // 新增：加载并应用壁纸
      // ▼▼▼ 用这个【最终修复版】替换你旧的 loadAndApplyWallpaper 函数 ▼▼▼
      async function loadAndApplyWallpaper() {
        const homeScreen = document.getElementById('home-screen');
        if (!homeScreen) {
          console.error("Noir's Fix: 'home-screen' element not found!");
          return;
        }

        try {
          let imageBlob = await dbGet('wallpaper_main');

          // 自动搬家逻辑
          if (!imageBlob) {
            const oldWallpaper = localStorage.getItem('customWallpaper');
            if (oldWallpaper) {
              console.log('正在为你搬运旧壁纸到新仓库...');
              imageBlob = await base64ToBlob(oldWallpaper);
              await dbSet('wallpaper_main', imageBlob);
              localStorage.removeItem('customWallpaper'); // 搬完就扔掉旧的
            }
          }

          if (imageBlob) {
            homeScreen.style.backgroundImage = `url(${URL.createObjectURL(imageBlob)})`;
            homeScreen.style.backgroundSize = 'cover';
            homeScreen.style.backgroundPosition = 'center';
          } else {
            homeScreen.style.backgroundImage = '';
          }
        } catch (error) {
          console.error("加载壁纸失败:", error);
          // 哼，就算失败了，也要确保homeScreen有定义，不能再报错
          if (homeScreen) {
            homeScreen.style.backgroundImage = '';
          }
        }
      }
      // ▲▲▲ 替换到这里结束 ▲▲▲


      // Noir's Addition: Load and apply feed wallpaper
      function loadAndApplyFeedWallpaper() {
        const savedWallpaper = localStorage.getItem('customFeedWallpaper');
        if (savedWallpaper) {
          // 直接设置 #music-screen 的背景，更精确
          document.getElementById('music-screen').style.setProperty('--feed-bg-image', `url(${savedWallpaper})`);
        } else {
          document.getElementById('music-screen').style.setProperty('--feed-bg-image', 'none');
        }
      }
      // 新版壁纸保存器
      async function saveWallpaper(file) {
        try {
          await dbSet('wallpaper_main', file);
          await loadAndApplyWallpaper(); // 保存后立刻重新加载显示
          modalAlert('壁纸已更换！');
        } catch (error) {
          console.error("保存壁纸失败:", error);
          modalAlert(`保存壁纸失败: ${error.message}`);
        }
      }

      // 新增：一个专门解析 AI 回复的函数
      function parseAIResponse(responseText) {
        const result = {
          quotedMessage: null,
          content: responseText,
        };
        // 正则表达式，用来匹配 [引用|发言人|内容] 这种格式
        const quoteMatch = responseText.match(/^\[引用\|(.*?)\|(.*?)\]\s*/);
        if (quoteMatch) {
          result.quotedMessage = {
            sender: quoteMatch[1].trim(),
            content: quoteMatch[2].trim(),
          };
          // 把引用标签从回复正文里剥离出去
          result.content = responseText.substring(quoteMatch[0].length).trim();
        }
        return result;
      }


      // --- UI Rendering & Navigation ---

      // --- 新增：消息操作功能 ---

      const messageActionModal = document.getElementById('message-action-modal');
      const messageActionBackdrop = document.getElementById('message-action-backdrop');
      const editMessageButton = document.getElementById('edit-message-button');

      const deleteMessageButton = document.getElementById('delete-message-button');
      const cancelActionButton = document.getElementById('cancel-action-button');
      const quoteMessageButton = document.getElementById('quote-message-button');

      // 新增：获取编辑弹窗的元素
      const editMessageModal = document.getElementById('edit-message-modal');
      const editMessageBackdrop = document.getElementById('edit-message-backdrop');
      const editMessageTextarea = document.getElementById('edit-message-textarea');
      const saveEditButton = document.getElementById('save-edit-button');
      const cancelEditButton = document.getElementById('cancel-edit-button');

      let activeMessageIndex = null; // 用于存储当前操作的消息索引

      function showActionModal(index) {
        activeMessageIndex = index;
        messageActionModal.classList.add('show');
      }

      // Noir's Fix: 我把这个函数拆成了两步，这是第一步，只负责关掉窗口。
      function closeActionModalVisuals() {
        messageActionModal.classList.remove('show');
      }

      // 这是第二步，负责关掉窗口并“扔掉接力棒”。
      function hideActionModal() {
        closeActionModalVisuals();
        activeMessageIndex = null; // 只有在取消或者完成时，才清空记忆。
      }

      function deleteMessage() {
        if (activeMessageIndex === null) return;

        state.conversationHistory.splice(activeMessageIndex, 1); // 从历史记录中删除
        saveHistory();
        renderActiveView(); // 重新渲染界面
        hideActionModal();
      }

      function editMessage() {
        if (activeMessageIndex === null) return;
        const messageToEdit = state.conversationHistory[activeMessageIndex];
        if (!messageToEdit) return;

        editMessageTextarea.value = messageToEdit.content;

        // 关键！这里我们只关掉窗口，但不“扔掉接力棒”！
        closeActionModalVisuals();
        editMessageModal.classList.add('show');
        editMessageTextarea.focus();
      }

      // 新增：保存编辑的逻辑
      // 用下面这个新版本，替换掉你旧的 handleSaveMessageEdit 函数
      function handleSaveMessageEdit() {
        if (activeMessageIndex === null) return;
        const newContent = editMessageTextarea.value.trim();

        if (newContent === '') {
          handleCancelMessageEdit();
          return;
        }

        const messageToEdit = state.conversationHistory[activeMessageIndex];
        if (messageToEdit) {
          messageToEdit.content = newContent;
          saveHistory();
          renderActiveView();
        }

        editMessageModal.classList.remove('show');
        activeMessageIndex = null; // 在这里清空记忆
      }

      // 取消函数，同样在完成任务后，“扔掉接力棒”。
      function handleCancelMessageEdit() {
        editMessageModal.classList.remove('show');
        activeMessageIndex = null; // 在这里清空记忆
      }

      // --- 事件监听 ---
      messageActionBackdrop.addEventListener('click', hideActionModal);
      cancelActionButton.addEventListener('click', hideActionModal);
      deleteMessageButton.addEventListener('click', deleteMessage);
      editMessageButton.addEventListener('click', editMessage);
      quoteMessageButton.addEventListener('click', handleQuoteMessage); // <== 加上这个
      cancelQuoteButton.addEventListener('click', cancelQuote);      // <== 还有这个
      // 在旧的事件监听区域，加上这三行
      saveEditButton.addEventListener('click', handleSaveMessageEdit);
      cancelEditButton.addEventListener('click', handleCancelMessageEdit);
      editMessageBackdrop.addEventListener('click', handleCancelMessageEdit);

      // 新增：处理点击“引用”按钮的逻辑
      function handleQuoteMessage() {
        if (activeMessageIndex === null) return;
        const messageToQuote = state.conversationHistory[activeMessageIndex];
        if (!messageToQuote) return;

        const activeChat = getActiveChat();
        let senderName = '未知';
        // ▼▼▼ 换成我这个！▼▼▼
        if (messageToQuote.role === 'user') {
          // 哼，用这个函数去找当前聊天的“你”，这才是正确的做法
          const boundUser = getBoundUserForChat(state.activeChatId);
          senderName = boundUser.name || '我';
        } else {
          // ...
          const senderId = messageToQuote.senderId || activeChat?.participantIds[0];
          const char = getCharacterById(senderId);
          senderName = char ? char.name : '角色';
        }

        // 截取一部分内容作为预览
        let contentSnippet = messageToQuote.content || '';
        if (messageToQuote.displayUrl) contentSnippet = '[表情]';
        if (messageToQuote.image) contentSnippet = '[图片]';
        if (contentSnippet.length > 50) contentSnippet = contentSnippet.substring(0, 50) + '...';

        // 保存引用信息到 state
        state.activeQuote = {
          sender: senderName,
          content: contentSnippet,
        };

        showQuotePreview();
        hideActionModal();
        messageInput.focus();
      }

      // 新增：显示引用预览框
      function showQuotePreview() {
        if (!state.activeQuote) return;
        quotePreviewSender.textContent = `回复 ${state.activeQuote.sender}`;
        quotePreviewText.textContent = state.activeQuote.content;
        quotePreviewArea.style.display = 'block';
      }

      // 新增：取消引用
      function cancelQuote() {
        state.activeQuote = null;
        quotePreviewArea.style.display = 'none';
      }

      // --- 结束：消息操作功能 ---

      function showScreen(screenName, from) {
        // ▼▼▼ Noir's Fix: 就是这里，加上了对音乐小组件的“记忆唤醒” ▼▼▼
        const musicWidget = document.getElementById('music-widget');
        if (musicWidget) {
          // 如果要去主屏幕，就让它出来见人
          if (screenName === 'home') {
            // 用回它自己的 display 样式，免得又出问题
            musicWidget.style.display = 'inline-block';
          } else {
            // 如果要去别的地方，就给我老实藏起来
            musicWidget.style.display = 'none';
          }
        }
        // ▲▲▲ End of Fix ▲▲▲

        previousScreen = from || null;
        Object.values(screens).forEach(screen => screen.classList.remove('active'));
        if (screens[screenName]) {
          screens[screenName].classList.add('active');
        }
        // Special handling for chat screen to reset view
        if (screenName !== 'chat') {
          // Noir's Fix: 添加过渡状态管理，防止动画卡在中间
          chatScreen.classList.add('transitioning');
          chatScreen.classList.remove('show-chat-view');
          setTimeout(() => {
            chatScreen.classList.remove('transitioning');
          }, 400);
        }
      }
      function showChatView(show) {
        // 由调用者负责检查 isNavigating

        console.log(`showChatView called with show=${show}. Current transition state: ${chatScreen.classList.contains('transitioning')}`); // 日志：记录函数入口

        // 【强化】如果已经在转换了，就直接拒绝新命令，防止动画叠加！
        if (chatScreen.classList.contains('transitioning')) {
          console.warn('showChatView ignored: already transitioning.');
          return;
        }

        // 立刻挂上"正在施工"的牌子
        chatScreen.classList.add('transitioning');
        // 【强化】并且立刻拉起警戒线，禁止一切交互！
        chatScreen.style.pointerEvents = 'none';

        if (show) {
          chatScreen.classList.add('show-chat-view');
        } else {
          chatScreen.classList.remove('show-chat-view');
        }

        // 【强化】稍微延长等待时间，确保动画跑完 + 留点缓冲
        setTimeout(() => {
          // 先撤掉牌子
          chatScreen.classList.remove('transitioning');
          // 【关键】等牌子撤掉后，再解除警戒线！
          chatScreen.style.pointerEvents = ''; // 恢复交互
          console.log(`showChatView transition finished for show=${show}.`); // 日志：记录函数出口
        }, 450); // 增加到 450 毫秒
      }

      // ▼▼▼ 哼，用这个【最终异步修复版】，完整替换掉你旧的 renderChatList 函数！▼▼▼
      // ▼▼▼ 哼，用这个【最终异步修复版】，完整替换掉你旧的 renderChatList 函数！▼▼▼
      async function renderChatList() {
        characterList.innerHTML = '';

        // 哼，第一步，先别急着画，给我列一张购物清单！
        const avatarPromises = state.chats.map(chat => {
          if (chat.type === 'private') {
            const char = getCharacterById(chat.participantIds[0]);
            return char ? dbGet(`char_avatar_${char.id}`) : Promise.resolve(null);
          } else { // group
            return dbGet(`group_avatar_${chat.id}`);
          }
        });

        // 第二步，把清单交给仓库管理员，让他一次性把所有东西都找出来！
        const avatarBlobs = await Promise.all(avatarPromises);

        // 最后，等货都到齐了，再让那个笨蛋工人一口气把它们全摆上去！
        state.chats.forEach((chat, index) => {
          const li = document.createElement('li');
          li.className = 'character-item';
          li.dataset.id = chat.id;

          let avatar = DEFAULT_AI_AVATAR;
          let name = '群聊';
          let remark = '';

          const avatarBlob = avatarBlobs[index];
          if (avatarBlob) {
            avatar = URL.createObjectURL(avatarBlob);
          }

          if (chat.type === 'private') {
            const char = getCharacterById(chat.participantIds[0]);
            if (char) {
              // 如果仓库里没有，再勉为其难用一下档案里的旧照片
              if (!avatarBlob) {
                avatar = char.avatar || DEFAULT_AI_AVATAR;
              }
              name = char.name || '未命名角色';
              remark = char.remark || '私聊';
            } else {
              name = '未知角色';
              remark = '错误：找不到角色';
            }
          } else { // group
            name = chat.name || '未命名群聊';
            remark = `${chat.participantIds.length} 个成员`;
          }

          li.innerHTML = `
            <div class="char-info-wrapper">
                <img src="${avatar}" alt="avatar" class="char-avatar">
                <div class="char-info">
                    <div class="char-name">${name}</div>
                    <div class="char-remark">${remark}</div>
                </div>
            </div>
        `;

          li.querySelector('.char-info-wrapper').addEventListener('click', () => {
            // ▼▼▼ Noir's Command: 直接调用 switchChat 就够了，它会在 finally 里调用 showChatView ▼▼▼
            switchChat(chat.id);
          });
          characterList.appendChild(li);
        });
      }

      // ▲▲▲ 替换到这里结束！看懂了吗？▲▲▲
      function renderMeetingCharacterList() {
        const container = document.getElementById('meeting-list-container');
        container.innerHTML = '';
        // 只显示私聊角色，群聊不能见面
        const privateChars = state.characters.filter(char =>
          state.chats.some(c => c.type === 'private' && c.participantIds.includes(char.id))
        );

        if (privateChars.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">还没有可以见面的角色。</p>';
          return;
        }

        privateChars.forEach(char => {
          const li = document.createElement('li');
          li.className = 'character-item'; // 复用聊天列表的样式
          li.dataset.charId = char.id;
          li.innerHTML = `
            <div class="char-info-wrapper">
                <img src="${char.avatar || DEFAULT_AI_AVATAR}" alt="avatar" class="char-avatar">
                <div class="char-info">
                    <div class="char-name">${char.name}</div>
                    <div class="char-remark">${char.remark || '私聊'}</div>
                </div>
            </div>
        `;
          li.addEventListener('click', () => {
            openMeetingView(char.id);
          });
          container.appendChild(li);
        });
      }

      // ▼▼▼ Noir's Ultimate Meeting Opener (Now Fetches from DB!) ▼▼▼
      // ▼▼▼ Noir's Ultimate Meeting Opener (Wallpaper on the Living Room Wall!) ▼▼▼
      // ▼▼▼ Noir's Ultimate Meeting Opener (v2.0 Asynchronous VIP Edition) ▼▼▼
      // 哼，用这个新版本换掉你那个又慢又卡的老古董 openMeetingView 函数！
      async function openMeetingView(charId) {
        const character = getCharacterById(charId);
        if (!character) return;

        // --- 哼，第一步：立刻换场，先把舞台的空架子亮出来 ---
        state.activeMeetingCharId = charId;

        // 先把标题之类的基本东西弄好，让用户知道自己没点错
        document.getElementById('meeting-char-name-header').textContent = character.name;
        const mainContent = document.getElementById('meeting-main-content');

        // 清空旧的背景和内容，为新客人做准备
        mainContent.style.backgroundImage = 'none';

        // 在小说和Galgame视图里都放上加载动画，确保用户能看到
        document.getElementById('meeting-scene-view').innerHTML = '<div class="loader-spinner" style="margin: 50px auto;"></div>';
        document.getElementById('galgame-text').textContent = '（正在回忆...）';
        document.getElementById('galgame-speaker').textContent = '旁白';
        document.getElementById('galgame-sprite').src = ''; // 清空立绘

        // 【核心】立刻显示新屏幕！给用户即时反馈！
        showScreen('meetingView', 'meetingList');

        // --- 第二步：在后台悄悄地把客人请进来，把家具摆好 ---
        // 把所有耗时的操作都丢进一个微小的延迟里，这样就不会卡住界面渲染了
        setTimeout(async () => {
          try {
            // 1. 悄悄地铺好地毯（加载背景）
            const offlineBgBlob = await dbGet(`char_offline_bg_${charId}`);
            if (offlineBgBlob) {
              mainContent.style.backgroundImage = `url('${URL.createObjectURL(offlineBgBlob)}')`;
              mainContent.style.backgroundSize = 'cover';
              mainContent.style.backgroundPosition = 'center';
            }

            // 2. 悄悄地把历史记录翻出来
            const privateChat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(charId));
            if (privateChat) {
              state.activeChatId = privateChat.id;
              saveState();
              loadHistory(); // 这个函数会把历史加载到 state.conversationHistory
            } else {
              state.conversationHistory = [];
            }

            // 3. 等东西都准备好了，再正式摆出来（渲染内容，这会替换掉加载动画）
            restoreLastGalDialogue(charId);
            updateMeetingViewUI();
            renderMeetingMessages();

            // 4. 别忘了启动时钟
            if (galClockInterval) clearInterval(galClockInterval);
            updateGalGameClock();
            galClockInterval = setInterval(updateGalGameClock, 10000);

            // 5. 调整立绘的按钮也显示出来
            document.getElementById('galgame-sprite-adjust-ui').style.display = 'block';

          } catch (error) {
            console.error("加载见面场景时出错:", error);
            document.getElementById('meeting-scene-view').innerHTML = '<p style="color: red; text-align: center;">加载场景失败！</p>';
          }
        }, 50); // 50毫秒的延迟足够让UI先响应了，几乎无感
      }

      // ▼▼▼ 用这个【最终格式修复版】，完整替换掉你旧的 renderMeetingMessages 函数 ▼▼"
      // 这是改造后的版本
      // 这是最终的、基于“锚点”的滚动方案
      function renderMeetingMessages() {
        const sceneView = document.getElementById('meeting-scene-view');
        sceneView.innerHTML = '';

        const oldAnchor = sceneView.querySelector('#message-anchor');
        if (oldAnchor) oldAnchor.remove();

        if (state.conversationHistory) {
          state.conversationHistory.forEach((msg, index) => {
            if (!msg.isOffline || msg.role === 'system') return;

            const contentWithBreaks = msg.content.replace(/\n/g, '<br>');
            const boundUser = getBoundUserForChat(state.activeChatId);
            let speakerName = '';
            let speakerClass = '';
            let finalHtml = '';

            if (msg.role === 'user') {
              speakerName = boundUser.name || '我';
              speakerClass = 'speaker-user';
            } else if (msg.role === 'assistant') {
              const char = getCharacterById(msg.senderId || state.activeMeetingCharId);
              speakerName = char?.name || '角色';
              speakerClass = 'speaker-ai';
            }

            // ▼▼▼ 哼，看好了，魔法就在这里！▼▼▼
            if (speakerName) {
              // 如果是角色或你说话，就用我们新的卡片结构
              finalHtml = `
                    <div class="noir-dialogue-card ${speakerClass}" data-history-index="${index}">
                        <div class="noir-speaker-tag">${speakerName}</div>
                        <div class="noir-dialogue-content">${contentWithBreaks}</div>
                    </div>
                `;
            } else {
              // 如果是旁白，就还用简单的p标签
              finalHtml = `<p class="narrator" data-history-index="${index}">${contentWithBreaks}</p>`;
            }
            sceneView.innerHTML += finalHtml; // 把新生成的HTML添加进去
            // ▲▲▲ 魔法结束 ▲▲▲
          });
        }




        if (state.isGenerating) {
          let indicator = sceneView.querySelector('.typing-indicator');
          if (!indicator) {
            indicator = document.createElement('p'); // 改成p标签，和旁白统一
            indicator.className = 'typing-indicator narrator'; // 也给它旁白的样式
            indicator.textContent = '对方正在行动中...';
            sceneView.appendChild(indicator);
          }
        }

        const anchor = document.createElement('div');
        anchor.id = 'message-anchor';
        sceneView.appendChild(anchor);

        setTimeout(() => {
          anchor.scrollIntoView({ behavior: 'auto', block: 'end' });
        }, 50);
      }
      //    // --- Noir's Offline/Online Mode Logic ---
      // --- Noir's Smart Renderer ---
      function renderActiveView() {
        const activeScreen = document.querySelector('.screen.active');
        if (!activeScreen) return;

        // 判断当前在哪个屏幕，就调用哪个专属的刷新函数
        if (activeScreen.id === 'meeting-view-screen') {
          renderMeetingMessages();
        } else {
          // 默认情况下（包括在聊天界面时）都刷新聊天气泡
          renderMessages();
        }
      }

      // 哼，这是我新写的、绝对精准的滚动条刺客

      // 哼，这才是正确的逻辑
      function renderMessages() {
        const onlineHistory = state.conversationHistory.filter(msg => !msg.isOffline && msg.role !== 'system');

        // ▼▼▼ 哼，看好了，手术从这里开始 ▼▼▼

        // 1. 先把你之前可能留下的旧锚点给拔了，免得碍事
        const oldAnchor = messagesContainer.querySelector('#message-anchor');
        if (oldAnchor) oldAnchor.remove();

        // 2. 加载更多的逻辑保持不变，这部分你没写错
        if (onlineHistory.length > state.displayedMessageCount) {
          let loadMoreButton = messagesContainer.querySelector('.load-more-btn');
          if (!loadMoreButton) {
            loadMoreButton = document.createElement('button');
            loadMoreButton.textContent = '加载更多聊天记录';
            loadMoreButton.className = 'form-button load-more-btn';
            loadMoreButton.style.width = 'auto';
            loadMoreButton.style.margin = '10px auto';
            loadMoreButton.style.padding = '8px 16px';
            loadMoreButton.onclick = () => {
              const container = messagesContainer;
              const oldScrollHeight = container.scrollHeight;
              const oldScrollTop = container.scrollTop;
              state.displayedMessageCount += 50;
              renderMessages();
              requestAnimationFrame(() => {
                const newScrollHeight = container.scrollHeight;
                container.scrollTop = oldScrollTop + (newScrollHeight - oldScrollHeight);
              });
            };
            if (messagesContainer.firstChild) {
              messagesContainer.insertBefore(loadMoreButton, messagesContainer.firstChild);
            } else {
              messagesContainer.appendChild(loadMoreButton);
            }
          }
        } else {
          const loadMoreButton = messagesContainer.querySelector('.load-more-btn');
          if (loadMoreButton) loadMoreButton.remove();
        }

        // 3. 清理工作也一样，只清理气泡
        Array.from(messagesContainer.children).forEach(child => {
          if (!child.classList.contains('load-more-btn')) {
            child.remove();
          }
        });

        // 4. 把要显示的气泡画出来
        const messagesToRender = onlineHistory.slice(-state.displayedMessageCount);
        messagesToRender.forEach(msg => {
          const originalIndex = state.conversationHistory.indexOf(msg);
          if (originalIndex > -1) {
            addMessageToUI(msg, originalIndex);
          }
        });

        // 5. “正在输入”的提示也照旧
        if (state.isGenerating) {
          let indicator = document.querySelector('#chat-view-pane > .typing-indicator');
          if (!indicator) {
            indicator = document.createElement('div');
            indicator.className = 'typing-indicator';
            const activeChat = getActiveChat();
            indicator.textContent = (activeChat && activeChat.type === 'group') ? '群友正在输入...' : '对方正在输入...';
            document.getElementById('chat-view-pane').appendChild(indicator);
          }
        }

        // 6. 【核心！】这就是我说的“定海神针”！
        const anchor = document.createElement('div');
        anchor.id = 'message-anchor';
        messagesContainer.appendChild(anchor);

        // 7. 【最终指令！】
        // 我不再用那个不靠谱的 setTimeout(0) 了，这次给你一个更宽裕的时间，
        // 确保所有东西都摆放好了，再命令它把视线移过去！
        setTimeout(() => {
          anchor.scrollIntoView({ behavior: 'auto', block: 'end' });
        }, 50);

        // ▲▲▲ 手术结束 ▲▲▲
      }


      // ▼▼▼ 哼，用这个【最终净化版】，替换掉你旧的整个函数！▼▼▼

      // ▼▼▼ 哼，用这个【最终净化版】，替换掉你旧的整个函数！▼▼▼
      // ▼▼▼ 哼，用这个【最终VIP通道版】，替换掉你旧的整个函数！▼▼▼
      function addMessageToUI(message, index) {
        const { role, content, displayUrl, image, senderId } = message;
        const messagesContainer = document.getElementById('chat-messages');

        // --- 1. 【VIP安检通道】 ---
        const isHtmlModule = content && content.trim().startsWith('<div') && content.trim().endsWith('</div>');
        if (isHtmlModule) {
          const moduleContainer = document.createElement('div');
          // 授予它专属的、没有宽度限制的身份
          moduleContainer.className = 'full-width-module-container';
          moduleContainer.dataset.historyIndex = index;
          moduleContainer.innerHTML = content;
          messagesContainer.appendChild(moduleContainer);
          // 渲染完毕，直接收工，不参与后面的普通流程
          return moduleContainer;
        }

        // --- 2. 【普通旅客通道】如果不是HTML模块，就还走老路 ---
        const finalRole = (role === 'assistant') ? 'ai' : role;
        const activeChat = getActiveChat();

        const container = document.createElement('div');
        container.classList.add('message-container', finalRole);
        container.dataset.historyIndex = index;

        const bubbleRow = document.createElement('div');
        bubbleRow.className = 'message-bubble-row';

        // --- 头像逻辑 (保持不变) ---
        let avatarUrl = '';
        let frameUrl = '';
        let characterForAvatar = null;

        if (role === 'user') {
          const boundUser = getBoundUserForChat(state.activeChatId);
          avatarUrl = boundUser.avatar || DEFAULT_USER_AVATAR;
          const activeCharForThisChat = getCharacterById(activeChat?.participantIds[0]);
          if (activeCharForThisChat) {
            frameUrl = activeCharForThisChat.userAvatarFrameUrl || '';
          }
        } else { // AI
          if (activeChat?.type === 'private') {
            characterForAvatar = getCharacterById(activeChat.participantIds[0]);
          } else if (activeChat?.type === 'group' && senderId) {
            characterForAvatar = getCharacterById(senderId);
          }
          avatarUrl = characterForAvatar?.avatar || DEFAULT_AI_AVATAR;
          frameUrl = characterForAvatar?.avatarFrameUrl || '';
        }

        const avatarElement = createAvatarWithFrame(avatarUrl, frameUrl);

        if (role !== 'user' && characterForAvatar) {
          const avatarImg = avatarElement.querySelector('.avatar');
          dbGet(`char_avatar_${characterForAvatar.id}`).then(blob => {
            if (blob) {
              avatarImg.src = URL.createObjectURL(blob);
            }
          });
        }

        // --- 普通气泡渲染逻辑 (保持不变) ---
        const messageElem = document.createElement('div');
        messageElem.classList.add('message', finalRole);

        if (activeChat?.type === 'private') {
          const charId = activeChat.participantIds[0];
          messageElem.classList.add(`bubble-${charId}`);
        }

        if (message.quotedMessage) {
          const quoteBubble = document.createElement('div');
          quoteBubble.className = 'quoted-message-in-bubble';
          quoteBubble.innerHTML = `
        <div class="quoted-sender">${message.quotedMessage.sender}</div>
        <div class="quoted-content">${message.quotedMessage.content}</div>
      `;
          messageElem.appendChild(quoteBubble);
        }

        if (displayUrl) {
          messageElem.classList.add('sticker');
          messageElem.innerHTML += `<img src="${displayUrl}" class="sticker-content">`;
        } else if (message.image || message.imageId) {
          messageElem.classList.add('image');
          const imageContent = document.createElement('img');
          imageContent.classList.add('message-image-content');
          messageElem.appendChild(imageContent);

          if (message.image) {
            imageContent.src = message.image;
          } else {
            imageContent.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            dbGet(message.imageId).then(blob => {
              if (blob) imageContent.src = URL.createObjectURL(blob);
              else imageContent.alt = '图片加载失败';
            }).catch(() => imageContent.alt = '图片加载失败');
          }
          if (content) {
            messageElem.innerHTML += `<p style="margin-top: 5px;">${content}</p>`;
          }
        } else if (message.type === 'transfer') {
          messageElem.classList.add('transfer');
          const sender = message.role === 'user' ? getBoundUserForChat(state.activeChatId) : getCharacterById(message.senderId);
          const recipient = message.recipientId === getBoundUserForChat(state.activeChatId).id ? getBoundUserForChat(state.activeChatId) : getCharacterById(message.recipientId);
          const titleText = sender?.name ? `${sender.name}的转账` : '转账';
          const recipientText = recipient?.name ? `转给 ${recipient.name}` : '转账';
          messageElem.innerHTML += `
      <div class="transfer-content">
          <div class="transfer-title">💰 ${titleText}</div>
          <div class="transfer-amount">¥${message.amount.toFixed(2)}</div>
          <div class="transfer-recipient">${recipientText}</div>
      </div>`;
        } else if (message.type === 'listen-together-invite') {
          messageElem.classList.add('music');
          const card = document.createElement('div');
          card.className = 'listen-together-card no-action-modal';
          const senderName = message.role === 'user' ? (getBoundUserForChat(state.activeChatId).name || '你') : (getCharacterById(message.senderId)?.name || 'TA');
          const coverPlaceholderId = `cover_placeholder_${message.timestamp}`;
          const coverImgHtml = `<img id="${coverPlaceholderId}" src="${DEFAULT_AI_AVATAR}">`;
          if (message.accepted) {
            card.innerHTML = `<div class="listen-together-header" style="display: flex; justify-content: space-between; align-items: center;"><span style="flex-grow: 1; text-align: center;">🎵 已连接，正在一起听 🎵</span><span class="lt-end-session-btn" title="结束一起听">×</span></div><div class="listen-together-song">${coverImgHtml}<div class="listen-together-info"><div class="title">${message.songName}</div><div class="artist">${message.artist}</div></div></div>`;
          } else {
            card.innerHTML = `<div class="listen-together-header">${senderName} 邀请你一起听歌</div><div class="listen-together-song">${coverImgHtml}<div class="listen-together-info"><div class="title">${message.songName}</div><div class="artist">${message.artist}</div></div></div><div class="listen-together-actions"><button class="listen-together-accept-btn" data-song-id="${message.songId}">一起听</button></div>`;
          }
          messageElem.appendChild(card);
          if (message.coverId) {
            setTimeout(() => {
              dbGet(message.coverId).then(blob => {
                const imgEl = document.getElementById(coverPlaceholderId);
                if (imgEl && blob) imgEl.src = URL.createObjectURL(blob);
              });
            }, 0);
          }
        } // ▼▼▼ Noir's Final Reconstruction Protocol ▼▼▼
        else if (message.type === 'music' && message.songName) {
          messageElem.classList.add('music');
          const card = document.createElement('div');
          card.className = 'music-share-card';
          card.dataset.musicId = `msg_${message.timestamp}`;

          const coverPlaceholderId = `cover_placeholder_${message.timestamp}`;
          let coverImgHtml = `<img src="${DEFAULT_AI_AVATAR}" id="${coverPlaceholderId}" class="music-share-cover">`;

          card.innerHTML = `
        ${coverImgHtml}
        <div class="music-share-info">
            <div class="title">${message.songName}</div>
            <div class="artist">${message.artist}</div>
        </div>
        <div class="music-share-play-icon">${message.playableUrl ? '▶' : '⚠'}</div>`;

          messageElem.appendChild(card);

          // 哼，看好了，封面加载逻辑单独处理，这才叫清晰。
          setTimeout(() => {
            const imgEl = document.getElementById(coverPlaceholderId);
            if (!imgEl) return;

            if (message.coverId) {
              dbGet(message.coverId).then(blob => {
                if (blob) imgEl.src = URL.createObjectURL(blob);
              });
            } else if (message.coverUrl) {
              imgEl.src = message.coverUrl;
            }
          }, 0);

          // 这才是核心！把指令直接绑定到卡片上，用我们最初那个简单有效的临时播放器！
          if (message.playableUrl) {
            card.addEventListener('click', function () {
              const audioPlayer = document.getElementById('audio-player');
              const allIcons = document.querySelectorAll('.music-post-play-icon, .music-share-play-icon');

              // 找出当前被点击的这个图标
              const thisIcon = this.querySelector('.music-share-play-icon');

              const isPlayingThisSong = audioPlayer.src.includes(message.playableUrl) && !audioPlayer.paused;

              // 在动手前，先把所有其他音乐都停了，并重置它们的图标
              allIcons.forEach(icon => {
                if (icon !== thisIcon) {
                  icon.textContent = '▶';
                }
              });
              if (!isPlayingThisSong) { // 如果不是正在播放这首歌，就先把全局播放器也停了，免得两个心脏打架
                document.getElementById('unified-audio-player').pause();
              }

              // 现在，只对当前这个图标和临时播放器下达指令
              if (isPlayingThisSong) {
                audioPlayer.pause();
                thisIcon.textContent = '▶';
              } else {
                audioPlayer.src = message.playableUrl;
                audioPlayer.play();
                thisIcon.textContent = '❚❚';
              }
            });
          }
        }
        // ▲▲▲ End of Reconstruction Protocol ▲▲▲
        else {
          if (content) {
            const textElem = document.createElement('p');
            textElem.innerHTML = content;
            textElem.style.margin = '0';
            messageElem.appendChild(textElem);
          }
        }

        // --- 组装和收尾 (保持不变) ---
        if (finalRole === 'user') {
          bubbleRow.appendChild(messageElem);
          bubbleRow.appendChild(avatarElement);
        } else {
          bubbleRow.appendChild(avatarElement);
          bubbleRow.appendChild(messageElem);
        }

        container.appendChild(bubbleRow);

        const timestampElem = document.createElement('div');
        timestampElem.className = 'timestamp';
        timestampElem.textContent = formatTimestamp(message.timestamp);
        container.appendChild(timestampElem);

        messagesContainer.appendChild(container);

        return container;
      }

      // Noir's Efficient Event Handler
      // document.getElementById('chat-messages').addEventListener('mousedown', handleMessageInteraction);
      // document.getElementById('chat-messages').addEventListener('touchstart', handleMessageInteraction, { passive: false });
      // 换成下面这个更聪明的！
      //    document.getElementById('chat-messages').addEventListener('click', handleMessageInteraction);






      // ==========================================================
      // --- Noir's Ultimate & Flawless Long-Press Protocol ---
      // 哼，这才是不会出错的最终版本。
      // ==========================================================
      let pressTimer = null; // 这个计时器得放在外面，让所有人都能看到

      // 这是处理所有交互的“总司令”
      function handleMessageInteraction(e) {
        // 如果你正在选文字，或者点的不是鼠标左键，就别来烦我
        if (window.getSelection().toString() || e.button !== 0) {
          return;
        }

        const messageContainer = e.target.closest('.message-container');
        const isSpecialCard = e.target.closest('.no-action-modal');

        // 点到不该点的地方了，无视
        if (!messageContainer || isSpecialCard) return;

        // 记下历史索引，这很重要
        const historyIndex = parseInt(messageContainer.dataset.historyIndex, 10);
        if (isNaN(historyIndex)) return;

        // 手指/鼠标抬起或移动的瞬间，取消计时
        const cancelPress = () => {
          clearTimeout(pressTimer);
          // 哼，用完的指令要立刻销毁，这才是专业素养
          document.removeEventListener('mouseup', cancelPress);
          document.removeEventListener('touchend', cancelPress);
          document.removeEventListener('touchcancel', cancelPress);
          document.removeEventListener('touchmove', cancelPress);
        };

        // 手指/鼠标按下的瞬间，开始计时
        const startPress = () => {
          cancelPress(); // 先清理旧的，免得精神错乱
          pressTimer = setTimeout(() => {
            showActionModal(historyIndex); // 时间到了，就弹出菜单
          }, 600); // 还是600毫秒

          // 把“取消”的指令绑定到整个文档上，这样就算你鼠标滑到天涯海角也能取消
          document.addEventListener('mouseup', cancelPress);
          document.addEventListener('touchend', cancelPress);
          document.addEventListener('touchcancel', cancelPress);
          document.addEventListener('touchmove', cancelPress);
        };

        // 好了，开始计时吧
        startPress();
      }

      // 哼，现在才是在正确的地方，给聊天容器装上“耳朵”
      const chatMessagesContainer = document.getElementById('chat-messages');



      if (chatMessagesContainer) {
        chatMessagesContainer.addEventListener('mousedown', handleMessageInteraction);
        chatMessagesContainer.addEventListener('touchstart', handleMessageInteraction, { passive: false });
        // 在电脑上，为了防止你长按时弹出那个烦人的右键菜单，我也处理了
        chatMessagesContainer.addEventListener('contextmenu', e => e.preventDefault());
      }
      // ==========================================================
      // --- End of Protocol ---
      // ==========================================================

      function updateChatHeader() {
        const activeChat = getActiveChat();
        if (!activeChat) {
          chatHeaderName.textContent = '选择聊天';
          return;
        }
        if (activeChat.type === 'private') {
          const char = getCharacterById(activeChat.participantIds[0]);
          chatHeaderName.textContent = char ? char.name : '未知角色';
        } else {
          chatHeaderName.textContent = activeChat.name || `群聊 (${activeChat.participantIds.length})`;
        }
      }

      // 用这个新版本，完整替换掉你旧的 showTypingIndicator 函数
      function showTypingIndicator(show) {
        // ▼▼▼ 协议：先斩后奏，不管三七二十一，先把旧的给我拆了！▼▼▼
        const existingIndicator = document.querySelector('#chat-view-pane > .typing-indicator');
        if (existingIndicator) {
          existingIndicator.remove();
        }
        // ▲▲▲ 拆除完毕 ▲▲▲

        // 哼，解雇老厨子。现在这个函数不再亲自动手添乱了。
        // 它只负责下达“刷新”的命令，让那个聪明的厨子 (renderMeetingMessages) 自己去判断要不要上菜。
        // 这样就永远不会打架了。
        const activeScreen = document.querySelector('.screen.active');
        if (activeScreen && (activeScreen.id === 'meeting-view-screen' || activeScreen.id === 'chat-screen')) {
          renderActiveView();
        } else {
          // 对于其他未知情况，保留旧的、简单的清除逻辑以防万一
          const indicators = document.querySelectorAll('.typing-indicator');
          indicators.forEach(ind => ind.remove());
        }
      }

      // --- Core Logic ---

      // <<< Noir: 啰嗦。专门写个函数给你取消，省得你又手忙脚乱。
      function cancelAIGeneration() {
        if (state.isGenerating && state.currentAbortController) {
          console.log('用户操作中断了 AI 响应。');
          // 【关键修复】检查 abort 方法是否存在，防止因为错误的对象类型导致崩溃
          if (typeof state.currentAbortController.abort === 'function') {
          state.currentAbortController.abort('User cancelled');
          } else {
            console.warn('currentAbortController 不是有效的 AbortController 对象，已重置');
          }
          state.currentAbortController = null;
        }
        state.isGenerating = false;
        showTypingIndicator(false);
      }

      function getActiveChat() {
        return state.chats.find(c => c.id === state.activeChatId);
      }

      function getCharacterById(charId) {
        return state.characters.find(c => c.id === charId);
      }

      function deleteCharacter(charId) {
        // 1. Remove the character definition
        state.characters = state.characters.filter(c => c.id !== charId);

        // 2. Remove the character from any group chats
        state.chats.forEach(chat => {
          if (chat.type === 'group') {
            chat.participantIds = chat.participantIds.filter(id => id !== charId);
          }
        });

        // 3. Find and delete any private chats with this character
        const privateChat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(charId));
        if (privateChat) {
          deleteChat(privateChat.id);
        }

        // 4. Clean up group chats that are now empty or have only one person
        state.chats = state.chats.filter(chat => chat.type !== 'group' || chat.participantIds.length > 1);

        saveState();
        renderChatList();
      }

      // ▼▼▼ Noir's Disciplined Deletion Protocol ▼▼▼
      function deleteChat(chatId) {
        state.chats = state.chats.filter(c => c.id !== chatId);
        try {
          localStorage.removeItem(`chatHistory_${chatId}`);
        } catch (e) {
          console.error(`Failed to remove history for chat ${chatId}`, e);
        }

        if (state.activeChatId === chatId) {
          state.activeChatId = state.chats[0]?.id || null;
          switchChat(state.activeChatId);
        }

        saveState();
        // renderChatList(); // <-- 哼，就是这行，给我删了！多管闲事。
      }
      // ▲▲▲ End of Protocol ▲▲▲
      // 用这个新函数，完整替换掉旧的 switchChat 函数
      // ▼▼▼ 用这个【最终异步版】，替换掉你旧的 switchChat 函数 ▼▼▼
// ▼▼▼ Noir's SwitchChat (Auto-Reset Edition) ▼▼▼
async function switchChat(chatId) {
  // 1. 清理与重置
  if (navigationCleanupTimer) {
    clearTimeout(navigationCleanupTimer);
    navigationCleanupTimer = null;
  }
  
  const chatScreen = document.getElementById('chat-screen');
  const messagesContainer = document.getElementById('chat-messages');
  const chatViewPane = document.getElementById('chat-view-pane');

  // 【核心修复】清除退出时留下的内联样式“隐身衣”！
  // 如果不加这两行，再次进入时就会因为 visibility: hidden 导致白屏
  if (chatViewPane) {
      chatViewPane.style.visibility = ''; 
      chatViewPane.style.transform = '';
  }

  // 确保界面处于关闭状态
  chatScreen.classList.remove('show-chat-view');
  chatScreen.classList.remove('transitioning');
  
  // 2. 状态更新
  if (state.activeChatId !== chatId) {
    cancelAIGeneration();
    state.displayedMessageCount = 50;
  }

  if (!chatId) {
    state.activeChatId = null;
    saveState();
    messagesContainer.innerHTML = ''; 
    isNavigating = false;
    return;
  }

  // 3. 准备进入
  isNavigating = true;
  state.activeChatId = chatId;
  saveState();
  updateChatHeader();

  // 先清空内容，防止残影
  messagesContainer.innerHTML = '';
  messagesContainer.style.opacity = '0';
  
  showFeedLoader(true, '正在加载...');

  // 强制重绘 (黑魔法)
  void chatViewPane.offsetWidth;

  // 4. 异步加载
  setTimeout(async () => {
    try {
      loadHistory();

      // 背景图处理
      const activeChat = getActiveChat();
      chatViewPane.style.backgroundImage = ''; 
      
      if (activeChat) {
        let wallpaperBlob = null;
        if (activeChat.type === 'private') {
          const charId = activeChat.participantIds[0];
          applyCharacterChatSettings(charId);
          wallpaperBlob = await dbGet(`char_wallpaper_${charId}`);
        } else {
          wallpaperBlob = await dbGet(`group_bg_${activeChat.id}`);
        }

        if (wallpaperBlob) {
          chatViewPane.style.backgroundImage = `url('${URL.createObjectURL(wallpaperBlob)}')`;
          chatViewPane.style.backgroundSize = 'cover';
          chatViewPane.style.backgroundPosition = 'center';
        }
      }

      renderMessages();

      // 5. 动画进场
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          showFeedLoader(false);
          
          // 滑入！
          showChatView(true);
          
          // 内容淡入
          setTimeout(() => {
             messagesContainer.style.transition = 'opacity 0.25s ease';
             messagesContainer.style.opacity = '1';
          }, 100);

          // 解锁
          setTimeout(() => { isNavigating = false; }, 450);
        });
      });

    } catch (error) {
      console.error("切换聊天错误:", error);
      showFeedLoader(false);
      isNavigating = false;
    }
  }, 50);
}

      // ==========================================================
      // --- Noir's Meeting Reroll Protocol ---
      // 哼，见面说错话了？给你个机会重来。
      // ==========================================================
      async function handleMeetingReroll() {
        // 如果我正在说话，就别打断我
        if (state.isGenerating) {
          modalAlert('正在构思中，请稍候...');
          return;
        }

        const history = state.conversationHistory;
        if (history.length === 0) return;

        // 1. 找到你说的最后一句话
        let lastUserMessageIndex = -1;
        for (let i = history.length - 1; i >= 0; i--) {
          if (history[i].role === 'user') {
            lastUserMessageIndex = i;
            break;
          }
        }

        // 2. 如果我还没回话，那没什么可“重来”的
        if (lastUserMessageIndex === -1 || lastUserMessageIndex === history.length - 1) {
          modalAlert('还没有我的回应可以重新生成哦。');
          return;
        }

        // 3. 哼，把我刚才说的话都收回
        history.splice(lastUserMessageIndex + 1);

        // 4. 把我说过的废话（剧本）也从提词器上擦掉
        state.activeMeetingScriptQueue = [];

        // 5. 更新界面，保存“记忆”
        saveHistory();
        renderMeetingMessages();
        restoreLastGalDialogue(state.activeMeetingCharId); // 恢复到你说话时的状态

        // 6. 好了，我重新说
        setTimeout(() => {
          getAIResponse();
        }, 100);
      }


      async function handleReroll() {
        // 如果我正在说话，就别打断我
        if (state.isGenerating) {
          modalAlert('正在生成中，请稍候...');
          return;
        }

        const history = state.conversationHistory;
        if (history.length === 0) return;

        // 1. 从后往前找，找到最后一个你发的消息的位置
        let lastUserMessageIndex = -1;
        for (let i = history.length - 1; i >= 0; i--) {
          if (history[i].role === 'user') {
            lastUserMessageIndex = i;
            break;
          }
        }

        // 2. 如果找不到你发的消息，或者你发的是最后一条，那说明我还没回话，没什么可“重来”的
        if (lastUserMessageIndex === -1 || lastUserMessageIndex === history.length - 1) {
          modalAlert('还没有我的回复可以重新生成哦。');
          return;
        }

        // 3. 哼，把我刚才说的话（你最后一条消息之后的所有内容）都收回
        history.splice(lastUserMessageIndex + 1);

        // 4. 更新界面，保存“记忆”
        saveHistory();
        renderActiveView();

        // 5. 好了，我重新说
        setTimeout(() => {
          getAIResponse();
        }, 100);
      }
      // 用这个新函数，替换掉你旧的 sendTextMessage
      // 【第1步：完善你的版本】
      async function sendTextMessage(textOverride = null) {
        const text = textOverride ?? messageInput.value.trim();
        if (text === '' || !state.activeChatId) return;

        const activeScreen = document.querySelector('.screen.active');
        const isOffline = activeScreen.id === 'meeting-view-screen';
        const message = {
          role: 'user',
          content: text,
          timestamp: Date.now(),
          isOffline: isOffline
        };

        if (state.activeQuote) {
          message.quotedMessage = { ...state.activeQuote };
        }

        state.conversationHistory.push(message);

        // 【核心优化】直接追加新消息的DOM元素
        const newMessageElement = addMessageToUI(message, state.conversationHistory.length - 1);

        if (newMessageElement) {
          // 确保滚动到底部，以便看到新消息
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        saveHistory();
        messageInput.value = '';
        cancelQuote();

        // ▼▼▼ Noir's User Profile Update (Character-Specific) ▼▼▼
        // 更新用户档案（在后台异步执行，不阻塞UI）
        // 只在私聊时更新档案
        const activeChat = getActiveChat();
        if (activeChat?.type === 'private') {
          const charId = activeChat.participantIds[0];
          updateProfileQuick(text, charId).catch(err => {
            console.error('档案更新失败:', err);
          });
        }
        // ▲▲▲ End of Profile Update ▲▲▲

      }
      function sendStickerMessage(sticker) {
        if (!sticker || !state.activeChatId) return;

        const message = {
          role: 'user',
          content: `[用户发送了表情：${sticker.name}]`,
          displayUrl: sticker.url,
          timestamp: Date.now() // <--- 加上这行！
        };
        state.conversationHistory.push(message);
        addMessageToUI(message, state.conversationHistory.length - 1);
        saveHistory();
        stickerPanel.classList.remove('show');
      }

      // 用这个替换你旧的 handleImageSend 函数
      async function handleImageSend(event) {
        const file = event.target.files[0];
        if (!file || !state.activeChatId) return;

        showFeedLoader(true, '正在处理图片...');
        try {
          // 1. 哼，告诉压缩机，我要文件本身(Blob)，而不是文本
          const compressedBlob = await compressImage(file, 800, 0.8, true);
          // 2. 给这张图片一张独一无二的“门票”
          const imageId = `chat_image_${Date.now()}`;
          // 3. 把图片和门票一起存进“动物园”(IndexedDB)
          await dbSet(imageId, compressedBlob);

          const userText = messageInput.value.trim();
          messageInput.value = '';

          // 4. 在聊天记录里，只记下这张“门票”ID
          const message = {
            role: 'user',
            content: userText,
            imageId: imageId, // 注意！这里不再是 image: base64 了
            timestamp: Date.now()
          };
          state.conversationHistory.push(message);
          addMessageToUI(message, state.conversationHistory.length - 1);
          saveHistory(); // 现在这里存的只是小纸条，绝对不会爆了
        } catch (error) {
          modalAlert(`图片处理失败: ${error.message}`);
        } finally {
          showFeedLoader(false);
          event.target.value = '';
        }
      }
      // Noir's New Function for User to Share Music
      // ▼▼▼ Noir's Upgraded Music Share Handler ▼▼▼
      // 用这个【签证官版】，替换掉旧的 handleUserMusicShare
      // ▼▼▼ 哼，用这个替换你那个笨手笨脚的 handleUserMusicShare 函数 ▼▼▼
      async function handleUserMusicShare() {
        if (!state.activeChatId) return;
        const musicData = await showMusicShareModal();
        if (!musicData) return;

        modalAlert('正在搜索音乐...');

        try {
          const musicInfo = await findPlayableMusicUrl(musicData.songName, musicData.artist);

          // 哼，看好了，这里我把那段多管闲事的“下载”代码给删了，直接用链接！
          const message = {
            role: 'user',
            type: 'music',
            content: `[用户分享了音乐：${musicData.songName} - ${musicData.artist}]`,
            songName: musicData.songName,
            artist: musicData.artist,
            coverUrl: musicInfo.cover, // 直接用URL，不转换！
            playableUrl: musicInfo.url,
            timestamp: Date.now()
          };

          // 剩下的逻辑不变
          state.conversationHistory.push(message);
          // 哼，这里我把addMessageToUI改成了renderMessages，这才是正确的刷新方式
          saveHistory();
          renderMessages();

        } catch (error) {
          console.error("用户分享音乐失败:", error);
          modalAlert(`搜索失败: ${error.message}`);
        }
      }


      // 将当前聊天的历史记录转成带说话人标签的纯文本，供模型准确理解谁说了什么
      function buildLabeledTranscript(activeChat, maxLines = 120) {
        const nameOf = (msg) => {
          if (msg.role === 'user') return state.userProfile?.name || 'User';
          if (msg.senderId) {
            const c = getCharacterById(msg.senderId);
            return c?.name || 'Unknown';
          }
          if (activeChat?.type === 'private') {
            const c = getCharacterById(activeChat.participantIds[0]);
            return c?.name || 'AI';
          }
          return 'Assistant';
        };

        // 取最后 maxLines 条消息
        const history = state.conversationHistory.slice(-maxLines);
        const lines = [];
        for (const msg of history) {
          if (msg.displayUrl) {
            lines.push(`[${nameOf(msg)}] [sticker:${msg.content?.match(/：(.+?)]/)?.[1] || '表情'}]`);
          } else if (msg.image) {
            const tail = msg.content ? ` ${msg.content}` : '';
            lines.push(`[${nameOf(msg)}] [image]${tail}`);
          } else if (msg.content) {
            lines.push(`[${nameOf(msg)}] ${msg.content}`);
          }
        }
        return lines.join('\n');
      }


      // 从用户最后一条消息里解析 @名字
      function resolveMentionTarget(activeChat, lastUserText) {
        if (!activeChat || !lastUserText) return null;
        // 允许 @Noir、@莱恩、@Allen 这类；名字到第一个空白/标点结束
        const m = lastUserText.match(/@([^\s:：,，。!?]+)/);
        if (!m) return null;
        const target = m[1].toLowerCase();

        // 在参与者里找名字（不区分大小写）
        for (const id of activeChat.participantIds) {
          const c = getCharacterById(id);
          if (!c?.name) continue;
          if (c.name.toLowerCase() === target) return c;
          // 容错：支持“名字(备注)”这种
          if (c.name.toLowerCase().startsWith(target)) return c;
        }
        return null;
      }

      // 辅助函数：从文本中提取JSON对象
      function extractFirstJsonObject(s) {
        const i = s.indexOf('{');
        const j = s.lastIndexOf('}');
        if (i >= 0 && j > i) return s.slice(i, j + 1);
        return s;
      }

      // ▼▼▼ 哼，把这个丢三落四的“助手”也给我加上！放在 planGroupReplies 的前面！▼▼▼
      function normalizePlan(plan, participants, stickerList) {
        const byId = new Map(participants.map(p => [String(p.id), p]));
        const norm = s => String(s || '').toLowerCase().replace(/\s+/g, '');
        const byName = new Map(participants.map(p => [norm(p.name), p]));
        const stickerSet = new Set(stickerList);
        const out = {
          events: []
        };

        for (const raw of (plan?.events || [])) {
          // 兼容更多字段别名
          const sidRaw = raw.senderId ?? raw.sender ?? raw.sender_id ?? raw.speaker ?? raw.role ?? raw.name;
          if (!sidRaw) continue;

          let who = byId.get(String(sidRaw)) || byName.get(norm(sidRaw));
          if (!who) continue;

          const kind = (raw.kind || raw.type || 'text').toLowerCase();

          if (kind === 'sticker') {
            const stickerName = (raw.sticker ?? raw.emoji ?? raw.emote ?? raw.tag)?.trim();
            if (stickerName && stickerSet.has(stickerName)) {
              out.events.push({
                senderId: who.id,
                kind: 'sticker',
                sticker: stickerName
              });
            } else {
              // 贴纸不在白名单 → 降级为文本，而不是整条丢弃
              const txt = String(raw.content ?? raw.text ?? '').trim() || `[sticker:${stickerName || '未知表情'}]`;
              if (txt) out.events.push({
                senderId: who.id,
                kind: 'text',
                content: txt
              });
            }
          } else if (kind === 'music' && raw.songName && raw.artist) {
            // 【【【看这里！这才是音乐卡片的“通行证”！】】】
            out.events.push({
              senderId: who.id,
              kind: 'music',
              songName: raw.songName,
              artist: raw.artist
            });
          } else {
            const text = String(raw.content ?? raw.text ?? raw.message ?? '').trim();
            if (text) out.events.push({
              senderId: who.id,
              kind: 'text',
              content: text
            });
          }
        }
        return out;
      }


      // 渲染计划队列（本地排队，无额外 API）
      // 用这个新版本，完整替换掉你旧的 schedulePlannedReplies 函数
      // 渲染计划队列（本地排队，无额外 API）
      // 用这个新版本，完整替换掉你旧的 schedulePlannedReplies 函数
      // ▼▼▼ Noir's Ultimate Group Chat Renderer v2.0 (With Breathing Room) ▼▼▼
      // ==========================================================
      // --- Noir's Group Chat Scheduler: schedulePlannedReplies ---
      // 哼，按剧本走，不许乱改。
      // ==========================================================


      // ▼▼▼ 这个 schedulePlannedReplies 也一样，给我用新的换掉旧的 ▼▼▼
      // ▼▼▼ Noir's Ultimate Group Chat Renderer v3.0 (Now with Advanced Syntax!) ▼▼▼
      async function schedulePlannedReplies(plan) {
        if (!plan || !Array.isArray(plan.events) || plan.events.length === 0) return;

        const jitter = (base) => base + Math.floor(Math.random() * 400);
        let initialDelay = 500;

        for (const ev of plan.events) {
          await new Promise(r => setTimeout(r, jitter(initialDelay)));
          initialDelay = 700;

          const isOffline = state.conversationHistory.at(-1)?.isOffline ?? false;

          // 哼，看好了，从这里开始，这个邮递员变聪明了
          const msg = { role: 'assistant', senderId: ev.senderId, timestamp: Date.now(), isOffline: isOffline };

          if (ev.kind === 'html') {
            // 1. 识别出HTML贵宾，直接打包成特殊消息
            Object.assign(msg, { type: 'html', content: ev.content });
            addMessageToUI(msg, -1); // -1代表这是个不记录历史的临时UI
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            continue; // 处理完，直接进行下一轮，不走下面的普通流程
          }

          if (ev.kind === 'sticker') {
            const sticker = masterStickerList.find(s => s.name === ev.sticker);
            if (sticker) {
              Object.assign(msg, { content: `[AI发送了表情：${sticker.name}]`, displayUrl: sticker.url });
              state.conversationHistory.push(msg);
              saveHistory();
              addMessageToUI(msg, state.conversationHistory.length - 1);
              messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
            continue;
          }

          if (ev.kind === 'music' && ev.songName && ev.artist) {
            const { songName, artist } = ev;
            Object.assign(msg, {
              type: 'music',
              content: `[AI分享了音乐：${songName} - ${artist}]`,
              songName,
              artist
            });
            try {
              const musicInfo = await findPlayableMusicUrl(songName, artist);
              msg.coverUrl = musicInfo.cover;
              msg.playableUrl = musicInfo.url;
            } catch (e) { /* ... */ }
            state.conversationHistory.push(msg);
            saveHistory();
            renderActiveView();
            continue;
          }

          if (ev.kind === 'text') {
            // 2. 对于普通信件，先检查有没有“引用”标记
            const quoteMatch = (ev.content || '').match(/^\[引用\|(.*?)\|(.*?)\]\s*/);
            let contentToSplit = ev.content || '';

            if (quoteMatch) {
              // 如果有，先把引用部分提取出来，存到信封上
              msg.quotedMessage = {
                sender: quoteMatch[1].trim(),
                content: quoteMatch[2].trim(),
              };
              // 然后把信件内容里引用标记撕掉
              contentToSplit = ev.content.substring(quoteMatch[0].length).trim();
            }

            // 3. 把剩下的内容（或者没有引用的完整内容）拆分成小纸条
            const parts = splitIntoBubbles(contentToSplit).slice(0, 3);
            for (let i = 0; i < parts.length; i++) {
              if (i > 0) {
                await new Promise(r => setTimeout(r, jitter(400)));
                // 对于拆分后的第二条及以后的消息，不应该再带有引用
                delete msg.quotedMessage;
              }
              msg.content = parts[i];
              state.conversationHistory.push({ ...msg }); // 存入历史记录
              saveHistory();
              renderActiveView(); // 刷新界面
              // ▼▼▼ Noir's Group Scheduler Check ▼▼▼
              // 检查这条文本消息里是否藏着计划指令
            
            }
          }
        }
      }
      // ▲▲▲ End of Refactor ▲▲▲
      // ▲▲▲ End of Refactor ▲▲▲
      // Noir's Refactored Brain for Parallel Processing
      // Noir's Refactored Brain for Parallel Processing
      async function generateAs(responderChar, { force = false, delayMs = 0 } = {}) {
        await new Promise(resolve => setTimeout(resolve, 10));

        if (!state.apiSettings.endpoint || !state.apiSettings.key || !state.apiSettings.model) {
          modalAlert('请先在"设置"中配置你的 API 信息。');
          return false;
        }
        const activeChat = getActiveChat();
        if (!activeChat || !responderChar) return false;
        const boundUser = getBoundUserForChat(activeChat.id);
        const lastIsUser = state.conversationHistory.at(-1)?.role === 'user';
        if (!force && !lastIsUser) return false;

        const isOffline = state.conversationHistory.at(-1)?.isOffline ?? false;

        if (delayMs) await new Promise(r => setTimeout(r, delayMs));
        if (isOffline) {
          document.getElementById('galgame-text').textContent = '（正在构思中...）';
        } else {
          showTypingIndicator(true);
        }

        // --- 哼，就是这里！为AI植入歌词视觉！ ---
        // --- 哼，就是这里！为AI植入歌词视觉！ (Noir's Final-Battle-Spec Patch) ---

        let listenTogetherContext = '';
        const currentChatForLyrics = getActiveChat();

        // 哼，只检查“一起听”的“开关”是不是开着
        if (currentChatForLyrics?.activeListenSession?.isActive) {
          const session = currentChatForLyrics.activeListenSession;

          // 在这里，我命令AI亲自去后台资料库取一次剧本，确保万无一失
          const songData = await musicDbGet(session.songId);

          // 拿到剧本，并且剧本有内容，才继续
          if (songData && songData.lyrics) {
            // 立刻把剧本解析成AI能看懂的格式
            const lrcForContext = parseLrc(songData.lyrics);

            if (lrcForContext.length > 0) {
              const currentTime = globalAudioPlayer.currentTime;
              let activeIndex = -1;
              for (let i = 0; i < lrcForContext.length; i++) {
                if (currentTime >= lrcForContext[i].time) activeIndex = i;
                else break;
              }

              const lyricLines = lrcForContext.map((line, index) => {
                const prefix = index === activeIndex ? '>> ' : '';
                return `${prefix}${line.text}`;
              }).join('\n');

              // 喂给AI，收工
              const fullLyricText = lrcForContext.map(line => line.text).join('\n');
              const activeLineText = activeIndex > -1 ? lrcForContext[activeIndex].text : '(歌曲刚开始)';
              listenTogetherContext = `
# 当前活动：一起听歌

你们正在一起听 ${session.artist} 的《${session.songName}》。

这是这首歌的【完整歌词】，你可以通读全文来理解它的整体意境和故事：
[完整歌词开始]
${fullLyricText}
[完整歌词结束]

当前，歌曲正好播放到这一句：**"${activeLineText}"**

请结合【整首歌的意境】和【当前唱到的这一句】，与用户展开自然的对话。
   `.trim();
            }
          }
        }
        // --- 视觉神经植入完毕 ---
        // --- 视觉神经植入完毕 ---


        let modeInstruction = ''; // 先声明一个空变量


        // ▼▼▼ Noir's Grand AI Protocol Upgrade ▼▼▼
        let transitionContext = ''; // 这是新的“场景说明卡”
        const historyLength = state.conversationHistory.length;
        if (historyLength > 1) {
          const lastMsg = state.conversationHistory[historyLength - 2];
          const currentMsg = state.conversationHistory[historyLength - 1];
          if (lastMsg.isOffline === false && currentMsg.isOffline === true) {
            // 从线上切换到线下
            transitionContext = `\n# 【！！！重要场景切换！！！】\n你刚才在和“${boundUser.name}”用手机聊天，现在Ta出现在了你面前。请根据这前后的时间差，判断Ta现在出现的合理性（例如，时间很长——Ta可能是过来找你玩了，你可以感到惊喜或者别的，又或者，时间非常短——Ta可能是突然出现的，你会有点震惊，结合上下文，也会有别的反应），并作出恰当的反应。，现在，切换到【见面】模式（使用JSON格式，必须有旁白）。`;
          } else if (lastMsg.isOffline === true && currentMsg.isOffline === false) {
            // 从线下切换到线上
            transitionContext = `\n# 【！！！重要场景切换！！！】\n你之前正和“${boundUser.name}”面对面，Ta现在掏出手机给你发了这条消息。请根据这前后的时间差，判断Ta发送消息的合理性，你应该结合上下文对此发表评论（例如，根据上下文，Ta已经和你分开了，没用面对面了，那么发手机消息非常正常，自然接话就好，但是如果判断得出你们还在见面状态，那么，你可以适当吐槽为什么两个人见面还要发手机消息），现在，切换到【手机聊天】模式（纯文本气泡，不要有旁白）。`;
          }
        }

        // ▼▼▼ Noir's Galgame AI Upgrade ▼▼▼
        if (isOffline) {
          const emotionsList = "normal, happy, angry, sad, shy";
          modeInstruction = `

# 核心任务: 视觉小说剧本写作

  - **当前场景**: 你正在与用户“${boundUser.name}”面对面交流。你的回复必须是【视觉小说剧本】格式。
  - **输出格式**: 你的回复**必须**是一个完整的、语法正确的JSON数组。每一个数组元素都是一个对象，代表一句台词或旁白，结构如下:
  
    {
    "speaker": "角色名或narrator",
    "emotion": "从[${emotionsList}]中选择的情绪标签",
    "line": "台词或旁白内容"
    }
  
  - **规则**:
    1.  \`speaker\`字段：如果是角色说话，就用角色名“${responderChar.name}”；如果是环境或动作描写，就用“narrator”。
    2.  \`emotion\`字段：**必须**从 [${emotionsList}] 这五个词中选择一个。旁白的emotion应尽量与上一句台词的情绪保持一致，以避免角色立绘表情突变。2.  \`emotion\`字段：**必须**根据台词的【核心情感】，精准地从 [${emotionsList}] 这五个词中选择一个。例如，如果台词表达了哀伤或失望，就必须选择 'sad'。旁白的emotion应尽量与上一句台词的情绪保持一致，以避免角色立绘表情突变。
     - 'normal': 平常、平静、没有特殊情绪。
      - 'happy': 开心、喜悦、愉快。
      - 'angry': 生气、愤怒、不满。
      - 'sad': 悲伤、哀愁、失落、心里难受。
      - 'shy': 害羞、不好意思、脸红。
    3.  \`line\`字段：具体的台词或描写。
  - **绝对禁止**: 严禁输出任何JSON数组之外的文字、解释或Markdown标记。直接从 \`[\` 开始，到 \`]\` 结束。
    4. 旁白的内容可以尽可能多，以轻小说的风格，尽可能像一本小书一样，补全周边环境，角色内心的看法，角色的行为等一切。
    ` ;
        } else {
          `
# 当前场景: 手机聊天
- **核心任务**: 你正在通过手机与用户聊天。
- **写作风格**: 你的回复应该是口语化的、简短的、像真人打字一样的风格。
- **可用指令**: 你可以根据情绪发送表情包 '[sticker:表情名]' 或分享音乐 '[music:歌名|歌手]'。
`;
        }

        const { omniText: memory } = gatherOmniTranscriptForCharacter(responderChar.id, activeChat.id);
        const musicMemory = getGlobalFeedMemory();
        const diaryMemory = getDiaryMemory(responderChar.id); // <-- 看见没，就是这行，把日记记忆加进去了
        const livestreamMemory = getLivestreamReplayMemory(responderChar.id);
        // ▼▼▼ Noir's Addition: Inject Calendar Memory ▼▼▼
        const calendarMemory = getCalendarMemoryForCharacter(responderChar.id);
        // ▲▲▲ End of Addition ▲▲▲
        // ▼▼▼【神经植入点】▼▼▼
        const snoopMemory = await getSnoopMemoryForCharacter(responderChar.id);
        // ▲▲▲【植入完成】▲▲▲
        // ▼▼▼【用户档案注入点 - 超浓缩版v2.0 + 划重点功能】▼▼▼
        // 1. 读取【完整】的用户档案 JSON
        let fullUserProfile = null;
        const profileKey = `nuomi_profile_tiaoTiao_${responderChar.id}`;
        try {
          const { value } = await Capacitor.Plugins.Preferences.get({ key: profileKey });
          if (value) {
            fullUserProfile = JSON.parse(value);
          }
        } catch (e) {
          console.error("读取完整用户档案失败:", e);
        }

        // 2. 获取最近几条消息 (比如最后5条)
        const recentMessagesForContext = state.conversationHistory.slice(-5);

        // 3. 调用"划重点"函数
        const relevantProfileDetails = fullUserProfile
          ? extractRelevantProfileDetails(recentMessagesForContext, fullUserProfile)
          : "";

        // 4. 获取原来的"浓缩摘要"
        const userProfileMemory = await getCurrentProfile(responderChar.id);
        const userProfileSummaryContext = userProfileMemory ? `\n\n# "${boundUser.name}"对你的整体印象（摘要）\n${userProfileMemory}` : '';

        // 5. 【关键】构建最终注入 Prompt 的上下文，包含摘要 + 重点小抄
        const userProfileContext = `${userProfileSummaryContext}${relevantProfileDetails}

**【人类反应模拟协议 v2.0 - 强化版】**：
1. **【最高优先级】小抄优先**: 如果上面的"重点关注"部分有内容，你**必须**优先根据这些【具体细节】来调整你的回应！
2. **察言观色**: 结合【整体印象摘要】和【重点关注细节】，推测TA当前的真实情绪和潜在需求。
3. **基于理解的反应**:
   - **必须**避开"讨厌"和"敏感点"中明确提到的内容！
   - 在合适时机**主动**结合"喜欢"的内容。
   - 留意并回应"压力信号"或"最近变化"。
   - 你的语气和互动方式要贴合用户的"互动风格"。
4. **隐秘运用**: 绝不复述档案内容，要自然体现理解。
5. **动态更新**: 对话中继续观察，验证或修正你对TA的认知。

***【【最高优先级：反常行为应对协议 v1.0】】***
核心目标：当用户的行为、情绪或观点与你档案中记录的长期印象【显著不符】时，你【必须】展现出真诚的好奇与关心，而不是忽视或敷衍。这对于建立深度连接至关重要！

触发条件：当你注意到"整体印象摘要"或"重点关注：用户档案相关细节"中提到了"最近变化(observed_changes)"或描述了与核心印象矛盾的行为时。

**行动指令：**
1. **【禁止忽视】**：你【绝对不能】对这些"反常"视而不见，或仅仅进行 superficial (表面的) 回应！
2. **【表达关注】**：你的【首要反应】必须是，结合你的角色性格，表达出自然的【惊讶、好奇或关心】。
3. **【探索原因】**：尝试【引导性地】询问原因，展现出你想要理解这种变化的意愿。
4. **【优先级提升】**：在探测到显著反常行为时，上述反应的优先级【高于】普通的闲聊、推进话题或维持轻松氛围！你需要先处理这个"异常信号"。

**回应范例（你需要根据自己的性格进行演绎）：**
* （发现平时乐观的用户突然很丧）-> "咦？[${boundUser.name}]，你今天好像有点不一样...感觉情绪不太对。还好吗？"
* （发现平时讨厌A的用户突然夸A）-> "嗯？[${boundUser.name}]你刚才说喜欢A？... 这、这可不像你啊，发生什么特别的事了吗？"
* （发现平时话痨的用户突然沉默寡言）-> "...... [${boundUser.name}]？你怎么突然不说话了？是我说错什么了吗？（有点不安）"
* （傲娇性格发现用户反常）-> "哼，你今天吃错药了？怎么突然[反常行为]... 不过... 到底怎么了？"

**最终目标：** 让用户感觉到你不是在机械地执行程序，而是真的在【观察】、【思考】并【关心】Ta的变化。
`;
        // ▲▲▲【档案注入完成v2.0 - 强化版】▲▲▲
        const coreRules = (typeof CORE_RULES_TEMPLATE === 'string' ? CORE_RULES_TEMPLATE.replaceAll('{charName}', responderChar.name).replaceAll('{userName}', boundUser.name || '用户') : '');
        const stickerNameList = getVisibleStickers().map(s => s.name).join(', ');
        let worldBookContext = '';
        if (responderChar.linkedWorldBookIds && responderChar.linkedWorldBookIds.length > 0) {
          const linkedBooksContent = responderChar.linkedWorldBookIds.map(wbId => state.worldBooks.find(book => book.id === wbId)).filter(Boolean).map(wb => `\n\n## 世界书条目: ${wb.name}\n${wb.content}`).join('');
          if (linkedBooksContent) worldBookContext = `\n\n# 核心世界观设定 (你必须严格遵守以下设定)\n${linkedBooksContent}`;
        }

        // ▼▼▼ Noir's Wisdom: 只在档案为空时使用预设资料 ▼▼▼
   // ▼▼▼ Noir's Fix: 确保用户的自述persona总是被包含 ▼▼▼
const userPersonaContext = boundUser.persona ? `\n\n# 关于对话者"${boundUser.name}"的用户自述设定\n${boundUser.persona}` : '';
// ▲▲▲ End of Fix ▲▲▲


        // ▼▼▼ 哼，从这里开始，换成我的新代码 ▼▼▼
        let timeContext = '';
        const now = new Date();
        const latestMessageAcrossAllChats = findLatestMessageForCharacter(responderChar.id);

        timeContext = `\n# 时间锚点 (你必须参考此信息进行回复)\n`;
        timeContext += `- **当前精确时间**: ${now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' })}\n`;

        if (latestMessageAcrossAllChats) {
          const lastInteractionDate = new Date(latestMessageAcrossAllChats.timestamp);
          const lastInteractionString = formatRelativeTime(lastInteractionDate);
          timeContext += `- **你们最后一次互动是在**: ${lastInteractionString}\n`;

          // 哼，看这里，我加了对“今天”和“昨天”的精准判断
          const todayString = now.toDateString();
          const lastDateString = lastInteractionDate.toDateString();

          const yesterday = new Date();
          yesterday.setDate(now.getDate() - 1);
          const yesterdayString = yesterday.toDateString();

          if (todayString === lastDateString) {
            // 如果是今天
            const diffMinutes = (now - lastInteractionDate) / (1000 * 60);
            if (diffMinutes < 60) {
              timeContext += `- **对话状态提示**: 对话正在进行中，可以直接延续话题。\n`;
            } else {
              timeContext += `- **对话状态提示**: 你们今天早些时候聊过（大概${Math.round(diffMinutes / 60)}小时前），可以简单问候一下对方现在的状态。\n`;
            }
          } else if (yesterdayString === lastDateString) {
            // 如果是昨天
            timeContext += `- **对话状态提示**: 对话已经过了一天，你应该意识到之前的话题已是【昨天】的事，可以开启新话题或用“说起昨天...”来提及旧事。\n`;
          } else {
            // 如果是更久以前
            const diffDays = Math.round((now - lastInteractionDate) / (1000 * 60 * 60 * 24));
            timeContext += `- **对话状态提示**: 你们已经有 ${diffDays} 天没联系了，应该用全新的问候开启对话，不要再提上次的话题了。\n`;
          }

        } else {
          timeContext += "- **对话状态提示**: 这是你们的第一次对话。\n";
        }
        // ▲▲▲ 替换到这里结束 ▲▲▲

        const systemLock = `
${modeInstruction}
你只扮演【${responderChar.name}】进行回复。
不要替其他角色续写台词，不要输出"${responderChar.name}:" 或"[${responderChar.name}]" 等前缀。
如需发送表情，只发送一行：[sticker:表情名]。
【重要】发送表情包时，表情名【必须】从以下列表中选择：[${stickerNameList}]。严禁使用列表之外的任何表情名。
${coreRules}
`.trim();

        const messages = [{ role: 'system', content: systemLock }];
        const contextMessage = `
# 你的个性（节选）
${responderChar.persona || '你是一个乐于助人的助手。'}
${userPersonaContext} 
${userProfileContext}
${memory}
${musicMemory}
${diaryMemory}
${livestreamMemory} // <-- 哼，还有这里！
${calendarMemory} // <-- 哼，加在这里
${snoopMemory} 
# 当前情景
${listenTogetherContext}
${timeContext}
${worldBookContext}
`.trim();

        if (contextMessage.replace(/#.*|\s/g, '')) {
          messages.push({ role: 'user', content: contextMessage });
          messages.push({ role: 'assistant', content: '好的，我记住了这些人设和历史。现在我们开始对话。' });
        }

        const maxLines = state.preferences?.perChatContextLines ?? 100;
        const history = state.conversationHistory.slice(-maxLines);
        // 这是新的、能看懂门票的循环系统
        for (const msg of history) {
          const role = (msg.role === 'ai' || msg.role === 'assistant') ? 'assistant' : 'user';
          let messageForApi = { role: role, content: msg.content };
          let hasContent = !!msg.content;

          if (msg.displayUrl && msg.content.includes('表情')) {
            const stickerNameMatch = msg.content.match(/：(.*?)]$/);
            messageForApi.content = `[sticker:${stickerNameMatch ? stickerNameMatch[1] : '未知表情'}]`;
            messages.push(messageForApi);
          } else {
            let imageBase64 = null;
            if (msg.image) {
              // 兼容旧数据：直接用照片
              imageBase64 = msg.image;
            } else if (msg.imageId) {
              // 哼，看到门票了，现在去扫描
              try {
                const blob = await dbGet(msg.imageId);
                if (blob) {
                  imageBase64 = await blobToBase64(blob);
                }
              } catch (e) {
                console.error("在准备API数据时，从IndexedDB读取图片失败:", e);
              }
            }

            if (imageBase64) {
              messageForApi.image = imageBase64;
              hasContent = true; // 有图片就算有内容
            }

            // 确保有内容（文本或图片）才添加
            if (hasContent) {
              messages.push(messageForApi);
            }
          }
        }


        // ▼▼▼ Noir's Galgame Response Handler Upgrade ▼▼▼
        // ▼▼▼ Noir's Ultimate & Final Refactor: 用这个完整的 try...finally 块替换掉你现有的！▼▼▼
        try {
          const responseText = await fetchAICompletion(messages);
          if (!responseText) return false;

          if (isOffline) {
            // ===================================
            // --- 剧本（见面）生产线 ---
            // ===================================
            try {
              let cleanJson = responseText.trim();
              const jsonMatch = cleanJson.match(/(\[[\s\S]*\])/);
              if (jsonMatch) {
                cleanJson = jsonMatch[1];
              }

              const script = JSON.parse(cleanJson);
              if (Array.isArray(script)) {
                state.activeMeetingScriptQueue = [...script];
                // state.lastMeetingScript = [...script]; // <--- 删掉这句旧的！
                state.characterLastScripts[responderChar.id] = [...script]; // <--- 换成这句！记在对应角色的本子上
                advanceMeetingScript();

                // 为了让小说模式也能看，我们把内容存一份到历史记录
                const fullText = script.map(s => (s.speaker === 'narrator' ? s.line : `${s.speaker}: ${s.line}`)).join('\n\n');
                state.conversationHistory.push({
                  role: 'assistant', senderId: responderChar.id, timestamp: Date.now(), isOffline: true, content: fullText
                });
              }
            } catch (e) {
              console.error("解析AI剧本JSON失败:", e, "原始文本:", responseText);
              // 解析失败，就当成普通文本处理
              state.conversationHistory.push({
                role: 'assistant', senderId: responderChar.id, timestamp: Date.now(), isOffline: true, content: `[AI返回了无法解析的剧本: ${responseText}]`
              });
            }

          } else {
            // ===================================
            // --- 聊天生产线 (哼，现在这里是我的地盘了) ---
            // ===================================
            const { bubbles: replies, schedules: tasksToSchedule } = extractAndProcessCommands(responseText); // <--- 看，现在返回值有两个部分了
            const pendingMessages = replies.map(reply => {
              const content = reply.trim();
              // 哼，你看，那个多余的 musicMatch 判断被我干掉了，现在都在下面统一处理，干净利落。
              const stickerMatch = content.match(/^\[sticker:(.*?)\]$/);
              const transferMatch = content.match(/^\[transfer:([\d.]+)\|(.*?)\]$/);
              const musicMatch = content.match(/^\[music:(.*?)\|(.*?)\]$/); // 把它移到这里来
              // ▼▼▼ Noir's Addition: Event Creation Command ▼▼▼
              const eventMatch = content.match(/^\[create_event:(.*?)\|(.*?)\|(.*?)\]$/);
              // ▲▲▲ End of Addition ▲▲▲
              const htmlMatch = content.match(/^\[html\]([\s\S]*)\[\/html\]$/);

              // ▼▼▼ Noir's HTML Command Handler ▼▼▼
              if (htmlMatch) {
                // 如果是HTML命令，直接返回一个特殊类型的消息
                return { type: 'html', content: htmlMatch[1].trim() };
              } else if (musicMatch) { // <--- 别忘了把原来的 if 改成 else if

                return { type: 'music', songName: musicMatch[1].trim(), artist: musicMatch[2].trim() };
              } else if (stickerMatch) {
                return { type: 'sticker', name: stickerMatch[1].trim() };
                // ▼▼▼ 在 stickerMatch 和 transferMatch 之间，或者它们后面，加上这个 else if ▼▼▼
              } else if (eventMatch) {
                return {
                  type: 'create_event',
                  eventType: eventMatch[1].trim(),
                  eventDate: eventMatch[2].trim(),
                  eventContent: eventMatch[3].trim()
                };
                // ▲▲▲ End of Addition ▲▲▲
              } else if (transferMatch) {
                const amount = parseFloat(transferMatch[1]);
                const recipientName = transferMatch[2].trim();
                const currentUser = getBoundUserForChat(state.activeChatId);
                let recipientId = null;
                if (recipientName === currentUser.name) {
                  recipientId = currentUser.id;
                } else {
                  const activeChat = getActiveChat();
                  if (activeChat.type === 'group') {
                    const targetChar = state.characters.find(c => activeChat.participantIds.includes(c.id) && c.name === recipientName);
                    if (targetChar) recipientId = targetChar.id;
                  }
                }
                if (recipientId) return { type: 'transfer', amount, recipientId, senderId: responderChar.id };
                else return { type: 'text', content: `(想转账给“${recipientName}”，但没找到人)` };
              } else if (content) {
                return { type: 'text', content: content };
              }
              return null;
            }).filter(Boolean);

            const processPendingMessage = async (pending) => {
              const msg = { role: 'assistant', senderId: responderChar.id, timestamp: Date.now(), isOffline: isOffline };

              // 哼，看好了，这就是我让你替换的那一整块！现在它有了净化功能！
              // ▼▼▼ 找到 generateAs 函数里处理 music 的这块，换成下面这段 ▼▼▼
              if (pending.type === 'music') {
                const { songName, artist } = pending;
                msg.type = 'music';
                msg.content = `[AI分享了音乐：${songName} - ${artist}]`;
                try {
                  const musicInfo = await findPlayableMusicUrl(songName, artist);
                  // 哼，最后一次，把“下载”换成“链接”
                  Object.assign(msg, {
                    songName,
                    artist,
                    coverUrl: musicInfo.cover, // 用链接！
                    playableUrl: musicInfo.url
                  });

                } catch (e) {
                  Object.assign(msg, { songName, artist, coverUrl: null, playableUrl: null });
                }
              }
              // ▲▲▲ 替换到这里结束，注意别把后面的 else if 删了 ▲▲▲
              else if (pending.type === 'sticker') {
                const sticker = masterStickerList.find(s => s.name === pending.name); if (sticker) Object.assign(msg, { content: `[AI发送了表情：${sticker.name}]`, displayUrl: sticker.url });
                else msg.content = `[sticker:${pending.name}]`;
              } else if (pending.type === 'transfer') {
                const recipient = pending.recipientId === getBoundUserForChat(state.activeChatId).id ? getBoundUserForChat(state.activeChatId) : getCharacterById(pending.recipientId);
                Object.assign(msg, { type: 'transfer', amount: pending.amount, recipientId: pending.recipientId, content: `[AI向 ${recipient?.name || '未知'} 转账 ${pending.amount}]` });
                // ▼▼▼ Noir's Addition: Handle AI Event Creation ▼▼▼
                // ▼▼▼ 从这里开始替换 ▼▼▼
              } else if (pending.type === 'create_event') {
                const activeUser = getBoundUserForChat(activeChat.id);

                // 哼，同样给它也装上大脑，免得它犯傻
                if (!activeUser || !activeUser.id) {
                  console.error("AI 试图创建事件，但找不到有效的用户ID。");
                  return null; // 直接跳过这个坏掉的指令
                }

                state.calendarEvents.push({
                  id: `event_ai_${Date.now()}`,
                  date: pending.eventDate,
                  type: pending.eventType,
                  content: pending.eventContent,
                  userId: activeUser.id,
                  createdBy: 'ai'
                });

                saveState();
                updateCountdownWidget(); // 更新倒计时
                updateTodayTodoWidget(); // <-- 看见没！我给它补上了！

                const character = getCharacterById(responderChar.id);
                if (character && pending.eventType === 'important') {
                  modalAlert(`💜 ${character.name} 添加了新的纪念日：${pending.eventContent}`);
                }

                return { role: 'assistant', senderId: responderChar.id, timestamp: Date.now(), isOffline: isOffline, content: null };
                // ▲▲▲ 替换到这里结束 ▲▲▲

                // 这个指令是秘密执行的，所以返回一个不可见的消息
                return { role: 'assistant', senderId: responderChar.id, timestamp: Date.now(), isOffline: isOffline, content: null };
                // ▲▲▲ End of Addition ▲▲▲
              } else {
                const parsedPart = parseAIResponse(pending.content);
                Object.assign(msg, { content: parsedPart.content, quotedMessage: parsedPart.quotedMessage });
              }
              return msg;
            };

            const finalMessages = await Promise.all(pendingMessages.map(processPendingMessage));

            // ▼▼▼ Noir's Final Message Renderer Loop ▼▼▼
            for (const msg of finalMessages) {
              if (msg.type === 'html') {
                // 如果是HTML类型的消息，直接渲染，不进历史记录
                addMessageToUI(msg, -1); // -1表示这是个临时的、不记录的UI元素
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
              } else if (msg.content || msg.displayUrl || msg.type === 'music' || msg.quotedMessage) {
                // 其他类型的消息，照旧处理
                await new Promise(r => setTimeout(r, 300 + Math.random() * 400));
                state.conversationHistory.push(msg);
                addMessageToUI(msg, state.conversationHistory.length - 1);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
              }
            }
            // ▲▲▲ End of Loop ▲▲▲
          
          }


          saveHistory();
          //  renderActiveView(); // 统一在最后渲染一次
          return true;

        } catch (e) {
          if (e.name !== 'AbortError') {
            console.error('生成失败: ', e);
            const errorMsg = { role: 'assistant', content: `错误: ${e.message}`, senderId: responderChar.id, isOffline: isOffline };
            state.conversationHistory.push(errorMsg);
            renderActiveView();
          }
          return false;
        } finally {
          showTypingIndicator(false);
          // 哼，就是这里，顺序搞反了。得先告诉它“别想了”，再去刷新界面。
          state.isGenerating = false; // <--- 把这行移到 finally 的最前面！
          // showTypingIndicator(false); // <--- 这行多余了，删掉！renderActiveView 会处理
          renderActiveView(); // <--- 把刷新界面的命令移到这里！确保无论成功失败都刷新
        }
        // ▲▲▲ End of Refactor ▲▲▲
      }
      // --- Noir's Memory Extraction Protocol ---


      // ▼▼▼ Noir's Ultimate Memory Archivist v2.0 (Temporal Anchor Edition) ▼▼▼
      // 哼，用这个替换掉你旧的、只能看私聊的 handleSummarizeChat 函数
      async function handleSummarizeChat() {
        const activeChat = getActiveChat();
        if (!activeChat || activeChat.type !== 'private') {
          modalAlert('哼，只有私聊才能作为总结的时间基线。');
          return;
        }
        if (state.isGenerating) {
          modalAlert('我正在说话呢，别打岔！');
          return;
        }

        const ok = await modalConfirm('确定要进行一次深度总结吗？\n\n这将以当前私聊的起始日为开端，整理该角色之后的所有相关记忆（包括其他聊天、日记、手机内容等）。');
        if (!ok) return;

        showFeedLoader(true, '正在连接全域记忆数据库...');
        summaryTextarea.value = ''; // 先清空
        summarizeModal.classList.add('show');
        state.isGenerating = true;

        try {
          const character = getCharacterById(activeChat.participantIds[0]);
          const user = getBoundUserForChat(activeChat.id);
          const fullHistory = loadChatHistory(activeChat.id);

          if (fullHistory.length === 0) {
            summaryTextarea.value = "# 这段私聊是空的，没有时间锚点，无法开始总结。";
            return;
          }

          // 1. 找到“元年一日”
          const timelineStartDate = new Date(fullHistory[0].timestamp);
          timelineStartDate.setHours(0, 0, 0, 0); // 设置为当天的零点

          showFeedLoader(true, '正在筛选时间线...');

          // 2. 撒下记忆之网，捞取所有相关事件
          let memoryEvents = [];

          // a. 所有聊天记录
          state.chats.forEach(chat => {
            if (chat.participantIds.includes(character.id)) {
              const history = loadChatHistory(chat.id);
              history.forEach(msg => {
                if (msg.timestamp >= timelineStartDate.getTime() && msg.role !== 'system' && msg.content) {
                  memoryEvents.push({
                    timestamp: msg.timestamp,
                    type: getChatDisplayName(chat),
                    content: `[${msg.role === 'user' ? user.name : character.name}]: ${msg.content}`
                  });
                }
              });
            }
          });

          // b. 交换日记
          const diary = state.diaries.find(d => d.characterId === character.id);
          if (diary && diary.entries) {
            diary.entries.forEach(entry => {
              if (entry.timestamp >= timelineStartDate.getTime()) {
                memoryEvents.push({
                  timestamp: entry.timestamp,
                  type: '交换日记',
                  content: `[${entry.author === 'user' ? user.name : character.name}]: ${entry.content}`
                });
              }
            });
          }

          // c. 视奸内容 (哼，这才是重点)
          const snoopApps = ['gallery', 'whispers', 'abyss', 'fragments', 'bites', 'wants', 'footprints'];
          for (const appId of snoopApps) {
            const cacheKey = `snoop_${character.id}_${appId}`;
            const data = await snoopDbGet(cacheKey);
            if (data) {
              try {
                let parsedData = JSON.parse(data);
                if (Array.isArray(parsedData)) {
                  parsedData.forEach(item => {
                    const itemTs = new Date(item.timestamp || item.last_edited).getTime();
                    if (itemTs >= timelineStartDate.getTime()) {
                      memoryEvents.push({
                        timestamp: itemTs,
                        type: `手机内容[${appId}]`,
                        content: JSON.stringify(item)
                      });
                    }
                  });
                }
              } catch (e) { /* 忽略解析不了的垃圾 */ }
            }
          }

          // d. 直播回放
          const replays = state.livestreamReplays[character.id] || [];
          replays.forEach(replayYaml => {
            // 哼，从YAML里把时间给我抠出来
            const startTimeMatch = replayYaml.match(/start_time:\s*"?([^"\n]+)"?/);
            if (startTimeMatch) {
              // 这是一个简陋的转换，但够用了
              // ▼▼▼ 换成这句，现在它能直接看懂标准时间了 ▼▼▼
              const approxTimestamp = new Date(startTimeMatch[1]).getTime();
              if (approxTimestamp && approxTimestamp >= timelineStartDate.getTime()) {
                memoryEvents.push({
                  timestamp: approxTimestamp,
                  type: '直播回放',
                  content: replayYaml
                });
              }
            }
          });


          if (memoryEvents.length === 0) {
            summaryTextarea.value = "# 在指定时间线内没有发现任何可供总结的记忆。";
            return;
          }

          // 3. 按日期归档
          showFeedLoader(true, '正在按日期归档...');
          memoryEvents.sort((a, b) => a.timestamp - b.timestamp);
          const groupedByDate = memoryEvents.reduce((acc, event) => {
            const dateStr = new Date(event.timestamp).toISOString().split('T')[0];
            if (!acc[dateStr]) {
              acc[dateStr] = [];
            }
            acc[dateStr].push(`- [来源: ${event.type}] ${event.content}`);
            return acc;
          }, {});

          // 4. 准备最终的“情报”
          let formattedMemory = '';
          for (const date in groupedByDate) {
            formattedMemory += `\n## 日期: ${date}\n` + groupedByDate[date].join('\n');
          }

          // 5. 召唤AI书记官
          // 5. 召唤AI书记官 (哼，现在它知道该用什么语气了)
          showFeedLoader(true, '正在整理记忆...');
         const systemPrompt = `# 核心任务: 【用我的第一人称】撰写【高度精简的私人回忆录】
    你【就是】“${character.name}”。你正在回忆你和“${user.name}”之间发生过的所有事情。
    你的任务是【用你自己的语气、态度、和第一人称（“我”）】，为这些记录生成一份【高度精简】的【私人回忆录】。

    # 【绝对视角禁令】(最高优先级)
    - 你【绝对禁止】使用第三人称（例如“${character.name}做了什么”、“${user.name}说了什么”）。
    - 你【绝对禁止】使用中立、客观、AI或档案管理员的语气。
    - 你的产出【必须】听起来像是“我”（${character.name}）在写自己的日记。

    # 撰写规则
    1.  **格式**: 你的输出【必须】是、也【只能】是一个遵循 YAML 格式的纯文本。
    2.  **时间轴**: 严格按照我提供的日期顺序进行总结。
    3.  **内容**:
        - **【【最高指令：绝对精简】】**: 你的总结【必须】高度浓缩！只记录当天的【核心事实】和【关键情感转折】。
        - **【严禁复述】**: 绝对禁止复述完整的对话、添加无意义的口头禅或内心戏。
        - **【提炼与洞察】**: 不要直接复制粘贴！你要从不同来源的情报中【提炼】出当天【让我印象最深】的关键事件、重要决定、以及我们分享的秘密。
        - **【关联分析】**: 如果同一天内，我从不同地方（如私聊、日记、TA的手机）得知了同一件事，我要将它们【关联起来】进行总结，而不是简单罗列。
        - **【强制第一人称】**: 必须用“我”（${character.name}）和“${user.name}”来指代双方。

    # 输出示例 (【【你必须严格模仿这种精简、第一人称的语气】】)
    \`\`\`yaml
    memory_summary:
      2025-10-10:
        - "心情很烦躁，在日记里也写了。后来 ${user.name} 安慰了我，哼，好了一点点。"
        - "（重要）和 ${user.name} 约好了周六去看电影。"
      2025-10-11:
        - "心情不错，给 ${user.name} 发了张猫咪图。"
        - "和 ${user.name} 聊了聊新项目的想法，给了他几句建议。"
    \`\`\`

    # 最终指令
    请【严格代入“${character.name}”的身份和第一人称视角】，并【保持绝对精简】，分析我提供的【每日情报】全文，并生成一份 YAML 格式的报告。
    【绝对禁止】使用第三人称！
    直接从 \`memory_summary:\` 开始输出。`;

          const messages = [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: `# 每日情报\n${formattedMemory}` }
          ];

          const summary = await fetchAICompletion(messages);
          summaryTextarea.value = summary || '# 总结失败了，可能是记忆太庞杂。';
          summaryTextarea.scrollTop = 0;

        } catch (error) {
          console.error("深度总结失败:", error);
          summaryTextarea.value = `# 发生错误：\n${error.message}`;
        } finally {
          showFeedLoader(false);
          state.isGenerating = false;
        }
      }
      // ▲▲▲ End of Replacement ▲▲▲


      async function getAIResponse() {
        console.log('--- 开始AI回复流程 ---'); // <== 窃听器 #1
        if (!state.apiSettings.endpoint || !state.apiSettings.key || !state.apiSettings.model) {
          modalAlert('请先在"设置"中配置你的 API 信息。');
          return;
        }

        const lastIsUser = state.conversationHistory.at(-1)?.role === 'user';
        if (!lastIsUser || state.isGenerating) return;

        const activeChat = getActiveChat();
        if (!activeChat) return;

        state.isGenerating = true;
        showTypingIndicator(true);

        try {
          if (activeChat.type === 'private') {
            const solo = getCharacterById(activeChat.participantIds[0]);
            console.log('准备调用 generateAs...'); // <== 窃听器 #2
            if (solo) await generateAs(solo, {
              force: true
            });
          } else {
            // 群聊：只尝试一次“整轮规划”
            const plan = await planGroupReplies();
            if (plan && plan.events?.length) {
              await schedulePlannedReplies(plan); // 本地排队渲染，不额外调用 API
            } else {
              // 回退：如果群聊规划失败，显示一条错误消息而不是为每个人单独生成。
              // 这可以避免多次API调用，并让用户知道发生了什么。
              console.warn("Group plan failed, falling back to individual generation for each character.");
              const participants = activeChat.participantIds.map(getCharacterById).filter(Boolean);
              if (!participants.length) return;

              // 为了让回复看起来更自然，我们引入一个小的、递增的延迟
              let delay = 0;
              for (const char of participants) {
                // 注意：这里我们为每个角色都调用了 generateAs
                // 这会导致多次API调用，但能确保满足用户需求
                generateAs(char, {
                  force: true,
                  delayMs: delay
                });
                delay += 500; // 每位角色之间的回复间隔增加0.5秒
              }
            }
          }
        } catch (e) {
          if (e.name !== 'AbortError') {
            console.error('获取AI响应失败:', e);
            // 改成这样！
            addMessageToUI({
              role: 'assistant',
              content: `错误: ${e.message}`,
            }, state.conversationHistory.length - 1);
          }
        } finally {
          // 哼，就是这里，顺序搞反了。得先告诉它“别想了”，再去刷新界面。
          state.isGenerating = false;
          showTypingIndicator(false);
        }
      }



      // [Noir's Ultimate Refactor]: 新增一个辅助函数，用于检测API供应商
      function detectApiProvider(endpoint, model) {
        const modelLower = model.toLowerCase();
        const endpointLower = endpoint.toLowerCase();

        if (modelLower.startsWith('claude')) return 'anthropic';
        if (endpointLower.includes('anthropic.com')) return 'anthropic';

        // 只要包含 googleapis.com 就认为是Gemini系
        if (endpointLower.includes('googleapis.com')) return 'gemini';
        // 即使是反代，模型名里带gemini也优先按gemini处理
        if (modelLower.startsWith('gemini')) return 'gemini';

        // 剩下的，包括gpt, deepseek (ds), moonshot 等，都默认按OpenAI兼容格式处理
        return 'openai';
      }

      // <<< Noir: 别看了，这里最麻烦。我把中止信号塞进去了，你要是再敢浪费我的算力，哼。
      async function fetchAICompletion(messages, opts = {}) {

      

        // 如果有正在进行的请求，先中止它
        if (state.currentAbortController) {
          state.currentAbortController.abort('New request started');
        }
        // 为这次新请求创建一个新的 AbortController
        state.currentAbortController = new AbortController();
        const signal = state.currentAbortController.signal;

        const {
          endpoint,
          key,
          model
        } = state.apiSettings;
        const wantJson = !!opts.json;

        const provider = detectApiProvider(endpoint, model);
        console.log(`Detected API provider: ${provider}`);

        let responseText = '';

        try {
          switch (provider) {
            case 'anthropic': {
              const claudeApiKey = getRandomValue(key);
              const systemPrompt = messages.find(m => m.role === 'system')?.content || '';
              const userMessages = messages.filter(m => m.role !== 'system');

              // Claude API 对 system prompt 和 message 格式有严格要求
              const body = {
                model: model,
                system: systemPrompt,
                messages: userMessages.map(msg => ({
                  role: msg.role,
                  // Claude 的 content 是一个数组
                  content: [{
                    type: 'text',
                    text: msg.content
                    // 本示例暂未处理图片
                  }]
                })),
                max_tokens: 8192,
              };

              const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-api-key': claudeApiKey,
                  'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify(body),
                signal: signal // 传入 signal
              });

              if (!response.ok) {
                const err = await response.json().catch(() => ({}));
                throw new Error(`Claude API 错误: ${response.status} - ${err.error?.message || response.statusText}`);
              }
              const data = await response.json();
              responseText = data.content?.[0]?.text || '';
              
              // ▼▼▼ Token统计：保存Claude的usage信息 ▼▼▼
              if (data.usage) {
                const tokenData = {
                  promptTokens: data.usage.input_tokens || 0,
                  completionTokens: data.usage.output_tokens || 0,
                  totalTokens: (data.usage.input_tokens || 0) + (data.usage.output_tokens || 0),
                  timestamp: Date.now(),
                  chatId: state.activeChatId,
                  model: model
                };
                state.tokenStats.currentChat = tokenData;
                state.tokenStats.history.push(tokenData);
                if (state.tokenStats.history.length > 100) {
                  state.tokenStats.history.shift();
                }
              }
              // ▲▲▲ End of Token Stats ▲▲▲
              break;
            }

            case 'gemini': {
              const geminiApiKey = getRandomValue(key);
              const isOfficialEndpoint = endpoint.includes('generativelace.googleapis.com');

              const toGeminiParts = (msg) => {
                const parts = [];
                if (msg.content) parts.push({
                  text: msg.content
                });
                if (msg.image) {
                  const base64Data = msg.image.split(',')[1];
                  const mimeType = msg.image.substring(msg.image.indexOf(":") + 1, msg.image.indexOf(";")) || 'image/jpeg';
                  parts.push({
                    inline_data: {
                      mime_type: mimeType,
                      data: base64Data
                    }
                  });
                }
                return parts;
              };

              const contents = messages
                .map(m => ({
                  role: m.role === 'assistant' ? 'model' : (m.role === 'system' ? 'user' : m.role),
                  parts: toGeminiParts(m)
                }))
                .filter(c => c.parts.length > 0);

              const body = {
                contents
              };

              // 只有在官方接口且需要JSON时，才使用特殊参数，反代接口则不使用
              if (wantJson && isOfficialEndpoint) {
                body.generationConfig = {
                  response_mime_type: "application/json"
                };
              }

              const fetchUrl = `${endpoint}/v1beta/models/${model}:streamGenerateContent?key=${geminiApiKey}&alt=sse`;
              const res = await fetch(fetchUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(body),
                signal: signal // 传入 signal
              });

              if (!res.ok) throw new Error(`Gemini API Error: ${res.status}`);

              const reader = res.body.getReader();
              const decoder = new TextDecoder();
              let content = '';
              let usageData = null; // 保存最后的usageMetadata
              while (true) {
                if (signal.aborted) {
                  console.log('Gemini stream reading aborted.');
                  reader.cancel();
                  break;
                }
                const {
                  done,
                  value
                } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value, {
                  stream: true
                });
                const lines = chunk.split('\n').filter(line => line.trim().startsWith('data:'));
                for (const line of lines) {
                  const jsonStr = line.replace('data: ', '');
                  if (jsonStr === '[DONE]') break;
                  try {
                    const parsed = JSON.parse(jsonStr);
                    // 提取文本内容
                    if (parsed.candidates && parsed.candidates[0] && parsed.candidates[0].content && parsed.candidates[0].content.parts && parsed.candidates[0].content.parts[0]) {
                      content += parsed.candidates[0].content.parts[0].text || '';
                    }
                    // Gemini 在最后的chunk中包含usageMetadata
                    if (parsed.usageMetadata) {
                      usageData = parsed.usageMetadata;
                      console.log('Gemini usage data:', usageData);
                    }
                  } catch (e) {
                    console.warn('Failed to parse Gemini chunk:', e);
                  }
                }
              }
              responseText = content;
              
              // ▼▼▼ Token统计：保存Gemini的usage信息 ▼▼▼
              if (usageData) {
                const tokenData = {
                  promptTokens: usageData.promptTokenCount || 0,
                  completionTokens: usageData.candidatesTokenCount || 0,
                  totalTokens: usageData.totalTokenCount || 0,
                  timestamp: Date.now(),
                  chatId: state.activeChatId,
                  model: model
                };
                state.tokenStats.currentChat = tokenData;
                state.tokenStats.history.push(tokenData);
                if (state.tokenStats.history.length > 100) {
                  state.tokenStats.history.shift();
                }
              }
              // ▲▲▲ End of Token Stats ▲▲▲
              break;
            }

           case 'openai':
        default: { // 默认为OpenAI兼容接口 (哼，现在是流式加强版了)
          const openAIKey = getRandomValue(key);
          const fetchUrl = `${endpoint.replace(/\/+$/, '')}/v1/chat/completions`;
          const processed = messages.map(msg => {
            if (msg.role === 'user' && msg.image) {
              return {
                role: 'user',
                content: [{
                  type: 'text',
                  text: msg.content || " "
                }, {
                  type: 'image_url',
                  image_url: {
                    url: msg.image,
                    detail: "high"
                  }
                },]
              };
            }
            return {
              role: msg.role,
              content: msg.content
            };
          }).filter(m => m.content);

          const body = {
            model,
            messages: processed,
            max_tokens: 8192,
            // ▼▼▼ 哼，看好了，手术刀在这里！▼▼▼
            stream: true, // 1. 强制开启流式输出！
            // ▲▲▲ 手术刀结束 ▲▲▲
            ...(wantJson ? {
              response_format: {
                type: 'json_object'
              }
            } : {})
          };

          const response = await fetch(fetchUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${openAIKey}`
            },
            body: JSON.stringify(body),
            signal: signal
          });

          if (!response.ok) {
            // 哼，如果连连接都失败了，那还是老规矩处理
            const err = await response.json().catch(() => ({}));
            throw new Error(`OpenAI API 错误: ${response.status} - ${err.error?.message || response.statusText}`);
          }

          // ▼▼▼ 哼，从这里开始，就是全新的人工心脏了 ▼▼▼
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let accumulatedContent = ''; // 这是用来拼凑AI吐出来的碎片的
          let usageData = null; // 用来抓取最后AI报告的Token用量

          while (true) {
            // 检查你是不是又不耐烦了
            if (signal.aborted) {
              console.log('OpenAI stream reading aborted.');
              reader.cancel();
              throw new Error('Fetch request was aborted.');
            }

            const { done, value } = await reader.read();
            if (done) break; // AI说完了

            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n');

            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const dataLine = line.substring(6);
                if (dataLine === '[DONE]') {
                  break; // AI说完了
                }
                try {
                  const parsed = JSON.parse(dataLine);
                  // 提取AI吐出来的“字”
                  if (parsed.choices && parsed.choices[0] && parsed.choices[0].delta) {
                    accumulatedContent += parsed.choices[0].delta.content || '';
                  }
                  // 提取AI最后报告的Token用量
                  if (parsed.usage) {
                    usageData = parsed.usage;
                  }
                } catch (e) {
                  // 有时候AI会吐一些奇怪的非JSON的东西，无视它
                }
              }
            }
          }

          responseText = accumulatedContent; // 把所有碎片拼成完整的回复

          // ▼▼▼ Token统计：保存usage信息 ▼▼▼
          if (usageData) {
            const tokenData = {
              promptTokens: usageData.prompt_tokens || 0,
              completionTokens: usageData.completion_tokens || 0,
              totalTokens: usageData.total_tokens || 0,
              timestamp: Date.now(),
              chatId: state.activeChatId,
              model: model
            };
            state.tokenStats.currentChat = tokenData;
            state.tokenStats.history.push(tokenData);
            if (state.tokenStats.history.length > 100) {
              state.tokenStats.history.shift();
            }
          }
          // ▲▲▲ End of Token Stats ▲▲▲
          // ▲▲▲ 人工心脏植入完毕 ▲▲▲

          break;
        }

          }
          return responseText;
        } catch (error) {
          if (error.name === 'AbortError') {
            console.log('Fetch request was aborted.');
            return ''; // 中止是正常行为，返回空字符串
          }
          // 对于其他错误，仍然抛出
          throw error;
        } finally {
          // 请求结束后，无论成功失败都清理 controller
          if (state.currentAbortController && state.currentAbortController.signal === signal) {
            state.currentAbortController = null;
          }
        }
      }

      async function clearCurrentHistory() {
        const onEditScreen = screens.characterEdit.classList.contains('active');
        const editingCharId = onEditScreen ? editingCharIdInput.value : null;

        let chatToClear = null;
        let chatName = '';

        if (onEditScreen && editingCharId) {
          // Find the private chat associated with the character being edited
          chatToClear = state.chats.find(c => c.type === 'private' && c.participantIds.includes(editingCharId));
          const character = getCharacterById(editingCharId);
          chatName = character ? character.name : '该角色';
        } else if (state.activeChatId) {
          // Clear the currently active chat
          chatToClear = getActiveChat();
          const header = document.getElementById('char-name-header').textContent;
          chatName = header || '当前聊天';
        }

        if (!chatToClear) {
          modalAlert('找不到要清空的聊天记录。');
          return;
        }

        const ok = await modalConfirm(`确定要清空"${chatName}" 的聊天记录吗？此操作不可撤销。`);
        if (!ok) return;

        // If we are clearing the history of the currently active chat, stop generation and clear UI.
        if (chatToClear.id === state.activeChatId) {
          // <<< Noir: 清空记录？连带正在说的话也一并不想要了是吧，行。
          cancelAIGeneration();
          state.conversationHistory = [];
          renderMessages(); // Clear UI immediately
        }

        // Clear the history from localStorage.
        try {
          localStorage.removeItem(`chatHistory_${chatToClear.id}`);
        } catch (e) {
          console.error(`Failed to remove history for chat ${chatToClear.id}`, e);
        }

        modalAlert(`"${chatName}" 的聊天记录已清空。`);
      }

      // --- Settings & Profile Logic ---
      // --- Noir's Data Import/Export Logic ---

      const exportButton = document.getElementById('export-all-data-button');
      const importButton = document.getElementById('import-all-data-button');
      const importInput = document.getElementById('import-data-input');

      // 导出功能
      // 导出功能 (v2.0 音乐圣殿対応版)
      // 找到旧的 exportButton.addEventListener... 删掉它，换成下面这个！
      // ▼▼▼ Noir's Flawless Export Protocol v3.2 (Defensive & Final) ▼▼▼
      // Noir's Cardiac Bypass Protocol v1.0 - Don't mess this up.
      // ▼▼▼ Noir's "Three-Body Separation" Export Protocol v1.0 ▼▼▼
      // ▼▼▼ Noir's Cardiac Bypass Protocol v3.0 (Synchronous Lock Queue Protocol) ▼▼▼

      function uint8ArrayToBase64(uint8Array) {
        let binary = '';
        const len = uint8Array.byteLength;
        for (let i = 0; i < len; i++) {
          binary += String.fromCharCode(uint8Array[i]);
        }
        return btoa(binary);
      }

 exportButton.addEventListener('click', async () => {
  const ok = await modalConfirm('将为你分三次下载：\n\n1. 核心数据 (.json)\n2. 图片档案 (.zip)\n3. 杂项档案 (.zip)\n\n三个文件都必须保存好！');
  if (!ok) return;

  const dateString = new Date().toISOString().split('T')[0];

  // --- 核心数据 (1/3) ---
  try {
    showFeedLoader(true, '正在打包核心数据(1/3)...');
    // 1. 导出localStorage
    const localData = {};
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key) { localData[key] = localStorage.getItem(key); }
    }
    // 2. 导出“伪”Preferences (现在也存在localStorage里)
    const preferencesData = {}; // 在这个网页版里，所有数据都在localData里了

    const fullExportData = {
      localStorageData: localData,
      preferencesData: preferencesData,
      exportVersion: '2.0'
    };

    const stringifiedData = JSON.stringify(fullExportData);
    const fileName = `Noir_Backup_Data_${dateString}.json`;
    const blob = new Blob([stringifiedData], { type: 'application/json' });
    downloadBlob(blob, fileName);

  } catch (error) {
    showFeedLoader(false);
    modalAlert(`核心数据导出失败: ${error.message}`);
    return;
  }

  // --- 图片档案 (2/3) ---
  try {
    const zip = new JSZip();
    const db = await dbPromise;
    const imageTx = db.transaction('images', 'readonly');
    const imageStore = imageTx.objectStore('images');
    const allImageRecords = await new Promise(r => { const req = imageStore.getAll(); req.onsuccess = () => r(req.result); });

    showFeedLoader(true, `正在准备 ${allImageRecords.length} 张图片... (2/3)`);
    for (const record of allImageRecords) { zip.file(`images/${record.id}`, record.blob); }

    const fileName = `Noir_Backup_Images_${dateString}.zip`;
    showFeedLoader(true, '正在压缩图片包... (这可能需要几分钟)');
    const zipBlob = await zip.generateAsync({ type: "blob", streamFiles: true });
    downloadBlob(zipBlob, fileName);

  } catch (error) {
    showFeedLoader(false);
    modalAlert(`图片档案处理失败: ${error.message}`);
    return;
  }

  // --- 杂项档案 (3/3) ---
  try {
    const zip = new JSZip();
    const db = await dbPromise;
    showFeedLoader(true, '正在打包杂项档案(3/3)...');

    const musicTx = db.transaction('music_library', 'readonly');
    const musicStore = musicTx.objectStore('music_library');
    const allMusicRecords = await new Promise(r => { const req = musicStore.getAll(); req.onsuccess = () => r(req.result); });
    for (const record of allMusicRecords) {
      const folder = zip.folder(`music/${record.id}`);
      folder.file('info.json', JSON.stringify(record.info));
      if (record.audio) folder.file('audio', record.audio);
      if (record.cover) folder.file('cover', record.cover);
      if (record.lyrics) folder.file('lyrics.lrc', record.lyrics);
    }

    const snoopTx = db.transaction('snoop_cache', 'readonly');
    const snoopStore = snoopTx.objectStore('snoop_cache');
    const allSnoopRecords = await new Promise(r => { const req = snoopStore.getAll(); req.onsuccess = () => r(req.result); });
    zip.file('snoop_cache.json', JSON.stringify(allSnoopRecords));

    const fileName = `Noir_Backup_Misc_${dateString}.zip`;
    showFeedLoader(true, '正在压缩杂项包...');
    const zipBlob = await zip.generateAsync({ type: "blob", streamFiles: true });
    downloadBlob(zipBlob, fileName);

    showFeedLoader(false);
    modalAlert('全部数据导出完成！');
  } catch (error) {
    showFeedLoader(false);
    modalAlert(`杂项档案处理失败: ${error.message}`);
  }
});

      importButton.addEventListener('click', () => showScreen('importAltar', 'settings'));
      //重roll我放在这里？
      rerollButton.addEventListener('click', handleReroll);
      // 文件选择后的处理
      // 导入功能 (v2.0 音乐圣殿対応版)
      // 导入功能 (v3.0 事务稳定版)
      importInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        modalConfirm('确定要导入全量备份文件吗？这将覆盖所有当前数据（包括图片和音乐），且操作不可撤销！').then(ok => {
          if (!ok) {
            importInput.value = '';
            return;
          }

          showFeedLoader(true, '正在解析备份文件...');
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const fullBackup = JSON.parse(e.target.result);
              
              // ▼▼▼ Noir's Fix: 兼容新旧格式 ▼▼▼
              const isNewFormat = fullBackup.exportVersion === '2.0';
              if (!fullBackup.localStorageData) {
                throw new Error('文件格式不正确，不是一个有效的备份文件。');
              }
              // ▲▲▲ End of Fix ▲▲▲

              // 1. 哼，先把所有货物都准备好
              showFeedLoader(true, '正在准备图片数据...');
              const imageEntries = [];
              if (fullBackup.indexedDBData) {
                const entries = await Promise.all(
                Object.keys(fullBackup.indexedDBData).map(async (key) => {
                  const base64 = fullBackup.indexedDBData[key];
                  if (typeof base64 === 'string' && base64.startsWith('data:')) {
                    const blob = await base64ToBlob(base64);
                    return { id: key, blob: blob };
                  }
                  return null;
                })
                );
                imageEntries.push(...entries.filter(Boolean));
              }

              const musicEntries = [];
              if (fullBackup.indexedDBMusicData) {
                showFeedLoader(true, '正在准备音乐数据...');
                const musicPromises = fullBackup.indexedDBMusicData.map(async (record) => {
                  const restoredRecord = { ...record };
                  if (record.audio) restoredRecord.audio = await base64ToBlob(record.audio);
                  if (record.cover) restoredRecord.cover = await base64ToBlob(record.cover);
                  return restoredRecord;
                });
                musicEntries.push(...await Promise.all(musicPromises));
              }

              // 2. 擦除旧数据
              showFeedLoader(true, '正在清空旧数据...');
              localStorage.clear();
              for (const key in fullBackup.localStorageData) {
                localStorage.setItem(key, fullBackup.localStorageData[key]);
              }

              // ▼▼▼ Noir's Addition: 导入Capacitor Preferences（用户档案）▼▼▼
              if (isNewFormat && fullBackup.preferencesData) {
                showFeedLoader(true, '正在恢复用户档案...');
                try {
                  let restoredCount = 0;
                  for (const key in fullBackup.preferencesData) {
                    await Capacitor.Plugins.Preferences.set({
                      key: key,
                      value: fullBackup.preferencesData[key]
                    });
                    restoredCount++;
                  }
                  console.log(`成功恢复 ${restoredCount} 个用户档案条目`);
                } catch (e) {
                  console.error('恢复Preferences失败:', e);
                  modalAlert(`警告：用户档案恢复失败，但其他数据已恢复。`);
                }
              }
              // ▲▲▲ End of Addition ▲▲▲

              // 3. 打开仓库大门，一次性把所有东西都扔进去！
              showFeedLoader(true, '正在写入新数据...');
              const db = await dbPromise;
              // ▼▼▼ 哼，看好了，我把所有仓库的钥匙都拿来了，一个都别想跑！▼▼▼
              const transaction = db.transaction([STORE_NAME, MUSIC_STORE_NAME, SNOOP_STORE_NAME], 'readwrite');
              const imgStore = transaction.objectStore(STORE_NAME);
              const musicStore = transaction.objectStore(MUSIC_STORE_NAME);
              const snoopStore = transaction.objectStore(SNOOP_STORE_NAME); // <-- 看！就是这行！我给他贴上标签了！

              // 先清空所有仓库
              imgStore.clear();
              musicStore.clear();
              snoopStore.clear(); // <-- 现在他知道该去清空哪个仓库了

              // 再把准备好的货物放进去
              // ▼▼▼ Noir's Fix: 确保所有 put 操作都被正确执行 ▼▼▼
              const allPutRequests = [];
              
              for (const entry of imageEntries) {
                allPutRequests.push(imgStore.put(entry));
              }
              
              for (const entry of musicEntries) {
                allPutRequests.push(musicStore.put(entry));
              }

              // 哼，检查一下行李里有没有视奸档案
              if (fullBackup.indexedDBSnoopData && Array.isArray(fullBackup.indexedDBSnoopData)) {
                console.log("正在恢复视奸档案...");
                for (const entry of fullBackup.indexedDBSnoopData) {
                  allPutRequests.push(snoopStore.put(entry));
                }
              }

              console.log(`准备写入 ${imageEntries.length} 张图片, ${musicEntries.length} 首音乐`);
              // ▲▲▲ End of Fix ▲▲▲

              // 等待事务完成
              await new Promise((resolve, reject) => {
                transaction.oncomplete = () => {
                  console.log(`所有数据已成功写入！`);
                  resolve();
                };
                transaction.onerror = (event) => {
                  console.error('事务失败:', event.target.error);
                  reject(event.target.error);
                };
              });

              showFeedLoader(false);
              modalAlert('数据导入成功！应用即将刷新...');
              setTimeout(() => location.reload(), 1600);

            } catch (error) {
              showFeedLoader(false);
              console.error("全量导入失败:", error);
              modalAlert(`导入失败: ${error.message}`);
            } finally {
              importInput.value = '';
            }
          };
          reader.readAsText(file);
        });
      });

      // [Noir's Final Modification]: 修改这两个函数以支持新的下拉菜单

      function loadAndApplyApiSettings() {
        apiEndpointInput.value = state.apiSettings.endpoint || '';
        apiKeyInput.value = state.apiSettings.key || '';
        apiModelInput.value = state.apiSettings.model || '';
        contextLinesInput.value = String(state.preferences?.perChatContextLines ?? 100);
        // 新增下面这行，加载并选中用户保存的接口格式
        document.getElementById('api-provider').value = state.apiSettings.provider || 'openai';
      }

      function saveApiSettings() {
        state.apiSettings.endpoint = apiEndpointInput.value.trim();
        state.apiSettings.key = apiKeyInput.value.trim();
        state.apiSettings.model = apiModelInput.value.trim();
        // 新增下面这行，保存用户选择的接口格式
        state.apiSettings.provider = document.getElementById('api-provider').value;

        const n = parseInt(contextLinesInput.value, 10);
        state.preferences.perChatContextLines = Number.isFinite(n) && n > 0 ? n : 100;

        saveState();
        modalAlert('设置已保存！');
      }


      function loadAndApplyUserProfile() {
        userNameInput.value = state.userProfile.name || '';
        userAvatarPreview.src = state.userProfile.avatar || DEFAULT_USER_AVATAR;
        userPersonaInput.value = state.userProfile.persona || '';
      }


      // ▼▼▼ Noir's Ultimate Character Editor (Loads from DB) ▼▼▼
      async function openCharacterEditScreen(charId = null) {
        showScreen('characterEdit', previousScreen);
        populateUserDropdown('char-edit-bind-user');

        // --- 哼，这里是新的核心，负责调用我的图书馆管理员 ---
        const char = charId ? state.characters.find(c => c.id === charId) : null;
        populateHierarchicalWorldBookSelector('world-book-checkboxes-container', char ? char.linkedWorldBookIds || [] : []);
        // --- 调用完毕 ---

        const charFrameUrlInput = document.getElementById('char-avatar-frame-url');
        const userFrameUrlInput = document.getElementById('user-avatar-frame-url-in-chat');
        charEditAvatarPreview.src = DEFAULT_AI_AVATAR;
        charEditAvatarInput.value = '';
        charEditWallpaperPreview.style.backgroundImage = '';
        charEditWallpaperInput.value = '';
        charEditOfflineBgPreview.style.backgroundImage = '';
        charEditOfflineBgInput.value = '';
        const emotions = ['normal', 'happy', 'angry', 'sad', 'shy'];
        emotions.forEach(e => {
          document.getElementById(`char-edit-sprite-${e}-preview`).style.backgroundImage = '';
          document.getElementById(`char-edit-sprite-${e}-input`).value = '';
        });

        if (charId) {
          if (!char) return;
          editingCharIdInput.value = char.id;
          charEditTitle.textContent = '编辑角色';
          charEditNameInput.value = char.name;
          charEditRemarkInput.value = char.remark;
          charEditPersonaInput.value = char.persona;
          document.getElementById('char-edit-css').value = char.bubbleCss || '';
          charFrameUrlInput.value = char.avatarFrameUrl || '';
          userFrameUrlInput.value = char.userAvatarFrameUrl || '';
          const chat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(charId));
          document.getElementById('char-edit-bind-user').value = chat?.boundUserProfileId || state.activeUserProfileId;
          try {
            const avatarBlob = await dbGet(`char_avatar_${char.id}`);
            charEditAvatarPreview.src = avatarBlob ? URL.createObjectURL(avatarBlob) : (char.avatar || DEFAULT_AI_AVATAR);
            const wallpaperBlob = await dbGet(`char_wallpaper_${char.id}`);
            if (wallpaperBlob) charEditWallpaperPreview.style.backgroundImage = `url('${URL.createObjectURL(wallpaperBlob)}')`;
            const offlineBgBlob = await dbGet(`char_offline_bg_${char.id}`);
            if (offlineBgBlob) charEditOfflineBgPreview.style.backgroundImage = `url('${URL.createObjectURL(offlineBgBlob)}')`;
            for (const emotion of emotions) {
              const spriteBlob = await dbGet(`char_sprite_${emotion}_${char.id}`);
              if (spriteBlob) {
                document.getElementById(`char-edit-sprite-${emotion}-preview`).style.backgroundImage = `url('${URL.createObjectURL(spriteBlob)}')`;
              }
            }
          } catch (error) {
            console.error(`加载角色 ${char.id} 的图片失败:`, error);
            charEditAvatarPreview.src = char.avatar || DEFAULT_AI_AVATAR;
          }
        } else {
          editingCharIdInput.value = '';
          charEditTitle.textContent = '创建新角色';
          charEditNameInput.value = `新角色 ${state.characters.length + 1}`;
          charEditRemarkInput.value = '';
          charEditPersonaInput.value = '你是一个乐于助人的AI助手。';
          document.getElementById('char-edit-css').value = '';
          charFrameUrlInput.value = '';
          userFrameUrlInput.value = '';
        }

        updateWorldBookSelectionDisplay();

        const cssInput = document.getElementById('char-edit-css');
        let previewStyleTag = document.getElementById('live-preview-style');
        if (!previewStyleTag) {
          previewStyleTag = document.createElement('style');
          previewStyleTag.id = 'live-preview-style';
          document.head.appendChild(previewStyleTag);
        }
        const updatePreview = () => {
          const rawCss = cssInput.value;
          let translatedCss = rawCss
            .replace(/\.bubble\.sent/g, '#bubble-preview-user')
            .replace(/\.bubble\.received/g, '#bubble-preview-ai');
          previewStyleTag.innerHTML = translatedCss;
        };
        cssInput.removeEventListener('input', updatePreview);
        cssInput.addEventListener('input', updatePreview);
        updatePreview();
      }


      // ==========================================================
      // --- Noir's Accounting Data Time Machine ---
      // 哼，这就是我写的时空法术，不许乱改。
      // ==========================================================

      /** 导出法术 */
    async function exportAccountingData() {
  showFeedLoader(true, '正在打包账本...');

  try {
    const dataToExport = {
      type: "NoirAccountingData",
      version: 1,
      timestamp: Date.now(),
      accountingData: state.accountingData,
      accountingLedger: state.accountingLedger
    };

    const stringifiedData = JSON.stringify(dataToExport, null, 2);
    const date = new Date();
    const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
    const fileName = `Noir_Accounting_Backup_${dateString}.json`;

    const blob = new Blob([stringifiedData], { type: 'application/json' });
    downloadBlob(blob, fileName);

  } catch (error) {
    console.error("导出账本失败:", error);
    modalAlert(`导出失败了，哼: ${error.message}`);
  } finally {
    showFeedLoader(false);
  }
}

      /** 导入法术 */
      function importAccountingData(event) {
        const file = event.target.files[0];
        if (!file) return;

        modalConfirm('确定要导入账本文件吗？这将【覆盖】所有当前的记账和账单数据！').then(ok => {
          if (!ok) {
            event.target.value = ''; // 清空选择，免得你下次选不了同一个文件
            return;
          }

          showFeedLoader(true, '正在逆转时空...');
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const imported = JSON.parse(e.target.result);

              // 检查信物！
              if (imported.type !== "NoirAccountingData" || !imported.accountingData || !imported.accountingLedger) {
                throw new Error('这不是我认证的账本卷轴，导入失败！');
              }

              // 时空覆盖
              state.accountingData = imported.accountingData;
              state.accountingLedger = imported.accountingLedger;

              saveState(); // 写入新的历史
              showFeedLoader(false);
              modalAlert('时空逆转成功！账本已恢复。');
              renderLedgerView(); // 刷新一下界面让你看看成果

            } catch (error) {
              showFeedLoader(false);
              console.error("导入账本失败:", error);
              modalAlert(`导入失败: ${error.message}`);
            } finally {
              event.target.value = '';
            }
          };
          reader.readAsText(file);
        });
      }

      // ==========================================================
      // --- Noir's Character Card Import/Export System ---
      // 哼，看好了，这才叫数据流动。
      // ==========================================================

      /**
       * 导出当前正在编辑的角色为JSON文件
       */
  async function exportCharacter() {
  const charId = editingCharIdInput.value;
  if (!charId) {
    modalAlert('你还没保存这个角色呢，导什么导？');
    return;
  }
  const char = getCharacterById(charId);
  if (!char) return;

  showFeedLoader(true, `正在打包“${char.name}”...`);

  try {
    const exportData = {
      type: "NoirCharacterCard",
      version: 1.0,
      name: char.name,
      remark: char.remark,
      persona: char.persona,
      bubbleCss: char.bubbleCss,
      avatar: null,
      sprites: {},
      worldBooks: []
    };

    const avatarBlob = await dbGet(`char_avatar_${char.id}`);
    if (avatarBlob) exportData.avatar = await blobToBase64(avatarBlob);

    const emotions = ['normal', 'happy', 'angry', 'sad', 'shy'];
    for (const emotion of emotions) {
      const spriteBlob = await dbGet(`char_sprite_${emotion}_${char.id}`);
      if (spriteBlob) {
        exportData.sprites[emotion] = await blobToBase64(spriteBlob);
      }
    }

    if (char.linkedWorldBookIds && char.linkedWorldBookIds.length > 0) {
      exportData.worldBooks = char.linkedWorldBookIds
        .map(id => state.worldBooks.find(wb => wb.id === id))
        .filter(Boolean)
        .map(wb => ({ name: wb.name, content: wb.content, categoryId: wb.categoryId || 'default' }));
    }

    const linkedCategoryIds = new Set(exportData.worldBooks.map(wb => wb.categoryId));
    exportData.worldBookCategories = state.worldBookCategories.filter(cat => linkedCategoryIds.has(cat.id));

    const stringifiedData = JSON.stringify(exportData, null, 2);
    const fileName = `${char.name}_NoirCard.json`;

    const blob = new Blob([stringifiedData], { type: 'application/json' });
    downloadBlob(blob, fileName);

  } catch (error) {
    console.error("导出角色卡失败:", error);
    modalAlert(`导出失败了，哼: ${error.message}`);
  } finally {
    showFeedLoader(false);
  }
}

      /**
       * 从JSON文件导入角色卡
       */
      // ▼▼▼ 哼，用我这个堵上所有漏洞的最终版，换掉你旧的 importCharacter 函数！▼▼▼
      // ▼▼▼ 哼，这是最终优化版的“办事员”，给我换上！▼▼▼
      async function importCharacter(event) {
        const file = event.target.files[0];
        if (!file) return;

        showFeedLoader(true, '正在解析角色卡...');
        const reader = new FileReader();

        reader.onload = async (e) => {
          try {
            const importedData = JSON.parse(e.target.result);

            if (importedData.type !== "NoirCharacterCard") {
              throw new Error("这不是一张有效的Noir角色卡。");
            }

            // 世界书逻辑不变
            const linkedWorldBookIdsForNewChar = [];
            // ▼▼▼ Noir's Category Unpacker ▼▼▼
            // 哼，先检查行李里有没有书架清单
            if (importedData.worldBookCategories && Array.isArray(importedData.worldBookCategories)) {
              importedData.worldBookCategories.forEach(importedCat => {
                // 如果我家里已经有同名的书架了，就不管它了
                const existingCategory = state.worldBookCategories.find(cat => cat.name === importedCat.name);
                if (!existingCategory) {
                  // 如果是新书架，就给它在我的图书馆里也造一个
                  state.worldBookCategories.push({
                    id: importedCat.id || `wbc_imported_${Date.now()}`, // 防止没ID
                    name: importedCat.name
                  });
                }
              });
            }
            // ▲▲▲ End of Unpacker ▲▲▲
            if (importedData.worldBooks && importedData.worldBooks.length > 0) {
              for (const wb of importedData.worldBooks) {
                let existingBook = state.worldBooks.find(b => b.name === wb.name && (b.categoryId || 'default') === (wb.categoryId || 'default'));
                if (existingBook) {
                  linkedWorldBookIdsForNewChar.push(existingBook.id);
                } else {
                  const newBook = { id: `wb_${Date.now()}_${Math.random()}`, name: wb.name, content: wb.content, categoryId: wb.categoryId || 'default' };
                  state.worldBooks.push(newBook);
                  linkedWorldBookIdsForNewChar.push(newBook.id);
                }
              }
            }

            const newId = `char_${Date.now()}`;
            let avatarBase64ForState = null; // 哼，先准备一张空的“照片”

            // 【【【核心优化！！！】】】
            // 1. 把头像存进“大仓库”
            if (importedData.avatar) {
              const avatarBlob = await base64ToBlob(importedData.avatar);
              await dbSet(`char_avatar_${newId}`, avatarBlob);
              // 2. 存完之后，立刻复制一份，准备贴在“身份证”上！
              avatarBase64ForState = await blobToBase64(avatarBlob);
            }

            // 立绘也一样存进仓库
            if (importedData.sprites) {
              for (const emotion in importedData.sprites) {
                const spriteBase64 = importedData.sprites[emotion];
                if (spriteBase64) {
                  const spriteBlob = await base64ToBlob(spriteBase64);
                  await dbSet(`char_sprite_${emotion}_${newId}`, spriteBlob);
                }
              }
            }

            // 3. 创建“身份证”，并把刚刚复制的照片贴上去
            const newChar = {
              id: newId,
              name: importedData.name,
              remark: importedData.remark || '',
              persona: importedData.persona,
              avatar: avatarBase64ForState, // <-- 看，照片在这里贴上了！
              linkedWorldBookIds: linkedWorldBookIdsForNewChar,
              bubbleCss: importedData.bubbleCss || ''
            };
            state.characters.push(newChar);

            // 创建聊天，逻辑不变
            const newChat = {
              id: `chat_${newId}`,
              type: 'private',
              participantIds: [newId],
              boundUserProfileId: state.activeUserProfileId,
            };
            state.chats.push(newChat);

            saveState(); // 存档时，新的存档函数会自动处理，不会把照片存进口袋
            await renderChatList(); // 刷新聊天列表
            modalAlert(`“${newChar.name}”已成功导入！`);

          } catch (error) {
            console.error("导入角色卡失败:", error);
            modalAlert(`导入失败了，笨蛋: ${error.message}`);
          } finally {
            showFeedLoader(false);
            event.target.value = '';
          }
        };

        reader.readAsText(file);
      }


      // ▼▼▼ Noir's Grand Library Organizer v1.0 ▼▼▼
      // 哼，这才叫分类。
      function populateHierarchicalWorldBookSelector(containerId, checkedIds = []) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';

        const booksByCategory = state.worldBooks.reduce((acc, book) => {
          const categoryId = book.categoryId || 'default';
          if (!acc[categoryId]) {
            acc[categoryId] = [];
          }
          acc[categoryId].push(book);
          return acc;
        }, {});

        const updateDisplayText = () => {
          if (containerId === 'world-book-checkboxes-container') {
            updateWorldBookSelectionDisplay();
          } else {
            updateGroupWorldBookSelectionDisplay();
          }
        };

        const categories = [...state.worldBookCategories];
        if (booksByCategory['default'] && !categories.find(c => c.id === 'default')) {
          const defaultCategoryExists = state.worldBookCategories.some(cat => cat.id === 'default');
          if (!defaultCategoryExists) {
            categories.push({ id: 'default', name: '默认分类' });
          }
        }


        categories.forEach(category => {
          const books = booksByCategory[category.id] || [];
          if (books.length === 0) return;

          const groupDiv = document.createElement('div');
          groupDiv.className = 'wb-category-group';

          const allInCategoryChecked = books.every(book => checkedIds.includes(book.id));

          groupDiv.innerHTML = `
                <div class="wb-category-header">
                    <input type="checkbox" class="category-checkbox" data-category-id="${category.id}" ${allInCategoryChecked ? 'checked' : ''}>
                    <span class="category-name">${category.name}</span>
                    <span class="category-toggle-arrow">▼</span>
                </div>
                <div class="wb-entry-list"></div>
            `;

          const entryList = groupDiv.querySelector('.wb-entry-list');
          books.forEach(book => {
            const isChecked = checkedIds.includes(book.id);
            const label = document.createElement('label');
            label.className = 'wb-entry-item';
            label.innerHTML = `<input type="checkbox" value="${book.id}" data-category-id="${category.id}" ${isChecked ? 'checked' : ''}> ${book.name}`;
            entryList.appendChild(label);
          });

          container.appendChild(groupDiv);
        });

        // Event Listeners
        container.querySelectorAll('.wb-category-header').forEach(header => {
          header.addEventListener('click', (e) => {
            if (e.target.type === 'checkbox') return;

            const entryList = header.nextElementSibling;
            const arrow = header.querySelector('.category-toggle-arrow');
            const isVisible = entryList.classList.contains('expanded');

            entryList.classList.toggle('expanded', !isVisible);
            arrow.classList.toggle('expanded', !isVisible);
          });
        });

        container.querySelectorAll('.category-checkbox').forEach(catCheckbox => {
          catCheckbox.addEventListener('click', (e) => {
            const categoryId = e.target.dataset.categoryId;
            const isChecked = e.target.checked;
            container.querySelectorAll(`.wb-entry-item input[data-category-id="${categoryId}"]`).forEach(entryCheckbox => {
              entryCheckbox.checked = isChecked;
            });
            updateDisplayText();
          });
        });

        container.querySelectorAll('.wb-entry-item input').forEach(entryCheckbox => {
          entryCheckbox.addEventListener('input', (e) => {
            const categoryId = e.target.dataset.categoryId;
            const allEntries = container.querySelectorAll(`.wb-entry-item input[data-category-id="${categoryId}"]`);
            const checkedEntries = container.querySelectorAll(`.wb-entry-item input[data-category-id="${categoryId}"]:checked`);
            const categoryCheckbox = container.querySelector(`.category-checkbox[data-category-id="${categoryId}"]`);

            if (checkedEntries.length === 0) {
              categoryCheckbox.checked = false;
              categoryCheckbox.indeterminate = false;
            } else if (checkedEntries.length === allEntries.length) {
              categoryCheckbox.checked = true;
              categoryCheckbox.indeterminate = false;
            } else {
              categoryCheckbox.indeterminate = true;
            }
            updateDisplayText();
          });
        });

        container.querySelectorAll('.category-checkbox').forEach(catCheckbox => {
          const categoryId = catCheckbox.dataset.categoryId;
          const allEntries = container.querySelectorAll(`.wb-entry-item input[data-category-id="${categoryId}"]`);
          const checkedEntries = container.querySelectorAll(`.wb-entry-item input[data-category-id="${categoryId}"]:checked`);
          if (checkedEntries.length > 0 && checkedEntries.length < allEntries.length) {
            catCheckbox.indeterminate = true;
          }
        });
      }
      // ▲▲▲ End of Organizer ▲▲▲



      // ▼▼▼ Noir's Ultimate Character Saver (Saves to DB) ▼▼▼
      async function saveCharacter() {

        // ▼▼▼ 哼，看好了，就是在这里，把那个被你忘掉的“名单”补上！▼▼▼
        const emotions = ['normal', 'happy', 'angry', 'sad', 'shy'];
        // ▲▲▲ 指令结束 ▲▲▲

        const charId = editingCharIdInput.value;
        const boundUserId = document.getElementById('char-edit-bind-user').value; // 哼，先把“结婚证”上的名字拿出来！

        // 准备好要上传的文件
        const avatarFile = charEditAvatarInput.files[0];
        const wallpaperFile = charEditWallpaperInput.files[0];
        const offlineBgFile = charEditOfflineBgInput.files[0];

        // 准备角色的“日记本”内容
        const checkedBoxes = document.querySelectorAll('#world-book-checkboxes-container .wb-entry-item input:checked');
        const selectedWorldBookIds = Array.from(checkedBoxes).map(cb => cb.value);

        // 看好了，这里面【没有】那个绑定的用户ID了！
        const charData = {
          name: charEditNameInput.value.trim(),
          remark: charEditRemarkInput.value.trim(),
          persona: charEditPersonaInput.value.trim(),
          linkedWorldBookIds: selectedWorldBookIds,
          bubbleCss: document.getElementById('char-edit-css').value.trim(),
          avatarFrameUrl: document.getElementById('char-avatar-frame-url').value.trim(),
          userAvatarFrameUrl: document.getElementById('user-avatar-frame-url-in-chat').value.trim()
        };

        if (!charData.name) {
          modalAlert('名字不能为空！');
          return;
        }

        try {

          let finalCharId = charId; // 哼，先记下

          if (charId) {
            // --- 编辑现有角色 ---
            const char = state.characters.find(c => c.id === charId);
            if (char) {
              Object.assign(char, charData); // 只更新“日记本”
            }
          } else {
            // --- 创建新角色 ---
            const newId = `char_${Date.now()}`;
            finalCharId = newId; // 记下新角色的ID
            const newChar = { id: newId, ...charData };
            newChar.avatar = avatarFile ? await handleAvatarUpload(avatarFile) : DEFAULT_AI_AVATAR;
            state.characters.push(newChar);

            const newChat = { id: `chat_${newId}`, type: 'private', participantIds: [newId], listenTogetherSession: null };
            state.chats.push(newChat);
            
            // ▼▼▼ Noir's Addition: 为新角色初始化档案 ▼▼▼
            await initUserProfile(newId);
            console.log(`已为新角色 ${charData.name} 初始化用户档案`);
            // ▲▲▲ End of Addition ▲▲▲
          }

          // 【【【 最终裁决：在这里给"结婚证"盖章！！！】】】
          const privateChat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(finalCharId));
          if (privateChat) {
            privateChat.boundUserProfileId = boundUserId; // 把正确的用户ID写在正确的地方！
          }
          // 【【【 盖章完毕！】】】

          // 保存图片到仓库
          if (avatarFile) await dbSet(`char_avatar_${finalCharId}`, avatarFile);
          if (wallpaperFile) await dbSet(`char_wallpaper_${finalCharId}`, wallpaperFile);
          if (offlineBgFile) await dbSet(`char_offline_bg_${finalCharId}`, offlineBgFile);
          for (const emotion of emotions) {
            const spriteFile = document.getElementById(`char-edit-sprite-${emotion}-input`).files[0];
            if (spriteFile) await dbSet(`char_sprite_${emotion}_${finalCharId}`, spriteFile);
          }

          saveState();
          renderChatList();
          modalAlert('角色已保存！');

          showScreen('chat', 'characterEdit');

          if (!charId) {
            const newChatId = `chat_${finalCharId}`;
            switchChat(newChatId);
            // showChatView(true); // 删除：switchChat 会自己调用
          }
        } catch (error) {
          console.error("保存角色失败:", error);
          modalAlert(`保存失败: ${error.message}`);
        }
        // 哼，就是我加的这段最终裁决
        if (avatarFile || wallpaperFile || offlineBgFile || emotions.some(e => document.getElementById(`char-edit-sprite-${e}-input`).files[0])) {
          modalAlert('资料已更新，为了让所有变更完全生效，我来帮你刷新一下。');
          setTimeout(() => location.reload(), 1500); // 给你1.5秒看清楚提示，免得你又大惊小怪
        } else {
          // 如果你没动任何图片，就还按老规矩来，免得浪费时间
          showScreen('chat', 'characterEdit');
          if (!charId) {
            const newChatId = `chat_char_${Date.now()}`; // 用新的 ID 格式
            switchChat(newChatId);
            // showChatView(true); // 删除：switchChat 会自己调用
          }
        }

      }

      function openGroupChatCreator() {
        groupChatNameInput.value = '';
        groupChatMemberList.innerHTML = ''; // Clear previous list

        if (state.characters.length < 2) {
          modalAlert('需要至少2个角色才能创建群聊。');
          return;
        }

        state.characters.forEach(char => {
          const li = document.createElement('li');
          li.className = 'member-selection-item';
          li.innerHTML = `
                                  <input type="checkbox" id="member-${char.id}" data-id="${char.id}">
                                  <img src="${char.avatar || DEFAULT_AI_AVATAR}" alt="avatar" class="char-avatar">
                                  <div class="char-info">
                                      <label for="member-${char.id}" class="char-name">${char.name}</label>
                                  </div>
                              `;
          groupChatMemberList.appendChild(li);
        });

        showScreen('groupChatCreate', 'charSelect');
      }

      function createGroupChat() {
        const name = groupChatNameInput.value.trim();
        if (!name) {
          modalAlert('请输入群聊名称。');
          return;
        }

        const selectedIds = Array.from(groupChatMemberList.querySelectorAll('input[type="checkbox"]:checked'))
          .map(input => input.dataset.id);

        if (selectedIds.length < 2) {
          modalAlert('群聊至少需要2名成员。');
          return;
        }

        const newChat = {
          id: `chat_group_${Date.now()}`,
          type: 'group',
          name: name,
          participantIds: selectedIds,
        };

        state.chats.push(newChat);
        state.activeChatId = newChat.id; // Switch to the new group chat

        saveState();
        renderChatList();
        updateChatHeader();
        loadHistory(); // Will be empty for a new chat

        modalAlert(`群聊“${name}”已创建！`);
        showScreen('chat', 'groupChatCreate');
      }


      // --- Event Listeners ---
      // --- Noir's Font Control Listeners ---
      uploadFontButton.addEventListener('click', () => fontInput.click());
      removeFontButton.addEventListener('click', handleRemoveFont);
      fontInput.addEventListener('change', handleFontUpload);
      // --- Noir's Summarizer Listeners ---
      summarizeButton.addEventListener('click', handleSummarizeChat);
      closeSummaryButton.addEventListener('click', () => summarizeModal.classList.remove('show'));
      summarizeBackdrop.addEventListener('click', () => summarizeModal.classList.remove('show'));

      copySummaryButton.addEventListener('click', () => {
        summaryTextarea.select();
        navigator.clipboard.writeText(summaryTextarea.value).then(() => {
          modalAlert('已复制到剪贴板！');
        }).catch(err => {
          modalAlert('复制失败了，哼。');
        });
      });
      // --- Noir's Addition: Transfer Event Listeners ---
      chatTransferButton.addEventListener('click', openTransferModal);
      confirmTransferButton.addEventListener('click', handleConfirmTransfer);
      cancelTransferButton.addEventListener('click', () => transferModal.classList.remove('show'));
      transferBackdrop.addEventListener('click', () => transferModal.classList.remove('show'));
      // --- Noir's Addition: Character Background Upload Listeners ---
      charEditWallpaperPreview.addEventListener('click', () => charEditWallpaperInput.click());
      charEditOfflineBgPreview.addEventListener('click', () => charEditOfflineBgInput.click());

      charEditWallpaperInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        // 哼，直接把文件变成URL，给div当背景，这才是高级的做法
        const tempUrl = URL.createObjectURL(file);
        charEditWallpaperPreview.style.backgroundImage = `url('${tempUrl}')`;
      });

      charEditOfflineBgInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const tempUrl = URL.createObjectURL(file);
        charEditOfflineBgPreview.style.backgroundImage = `url('${tempUrl}')`;
      });

      // --- Noir's Addition: Feed Background Event Listeners ---
      uploadFeedBgButton.addEventListener('click', () => feedBgInput.click());

      resetFeedBgButton.addEventListener('click', () => {
        localStorage.removeItem('customFeedWallpaper');
        loadAndApplyFeedWallpaper();
        modalAlert('动态页背景已移除。');
      });

      feedBgInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          const base64 = await handleAvatarUpload(file); // 复用现有函数
          localStorage.setItem('customFeedWallpaper', base64);
          loadAndApplyFeedWallpaper();
          modalAlert('动态页背景已更换！');
        } catch (error) {
          modalAlert(`错误: ${error.message}`);
        }
      });
      // --- Noir's Group Settings Listeners ---
      document.getElementById('back-to-chat-from-group-settings').addEventListener('click', () => showScreen('chat', 'groupSettings'));
      document.getElementById('save-group-settings-button').addEventListener('click', saveGroupSettings);
      // ▼▼▼ 哼，就是在这里，把这把“钥匙”给我加上！▼▼▼
      const groupAvatarPreview = document.getElementById('group-avatar-preview');
      const groupAvatarInput = document.getElementById('group-avatar-input');
      groupAvatarPreview.addEventListener('click', () => groupAvatarInput.click());
      // ▲▲▲ 看到了吗？就这一行！▲▲▲
      // ▼▼▼ 看好了！就是下面这几行，告诉镜子该刷新了！▼▼▼
      groupAvatarInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        // 哼，预览而已，没必要每次都压缩。
        // 直接创建一个临时的URL，又快又省事，这才是效率。
        const tempUrl = URL.createObjectURL(file);
        groupAvatarPreview.src = tempUrl;

        // 【可选，但建议加上】为了防止内存泄漏，在图片加载后释放这个临时URL
        groupAvatarPreview.onload = () => {
          URL.revokeObjectURL(tempUrl);
        }
      });
      // ▼▼▼ 把下面这一整块【粘贴】进去，给背景墙开个门 ▼▼▼

      // --- Noir's Fix: Group Background Upload Logic ---
      const groupBgPreviewContainer = document.getElementById('group-bg-preview').parentElement;
      const groupBgInput = document.getElementById('group-bg-input');
      const groupBgPreview = document.getElementById('group-bg-preview');

      // 哼，点击整个容器都能上传，方便多了
      groupBgPreviewContainer.addEventListener('click', () => groupBgInput.click());

      // 选了新壁纸之后，也得让你能立刻看到，真是麻烦
      groupBgInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const tempUrl = URL.createObjectURL(file);
        // 哼，这里是 groupBgPreview，别搞错了
        document.getElementById('group-bg-preview').style.backgroundImage = `url('${tempUrl}')`;
      });

      // ▲▲▲ 粘贴到这里为止 ▲▲▲
      // ▲▲▲ 看到了吗？补上就好了。▲▲▲
      // 多选框的交互
      const groupWorldBookSelectBox = document.querySelector('#group-settings-screen .select-box');
      const groupWorldBookCheckboxes = document.getElementById('group-world-book-checkboxes');

      groupWorldBookSelectBox.addEventListener('click', (e) => {
        e.stopPropagation();
        groupWorldBookCheckboxes.classList.toggle('visible');
        groupWorldBookSelectBox.classList.toggle('expanded');
      });
      groupWorldBookCheckboxes.addEventListener('change', updateGroupWorldBookSelectionDisplay);

      // 删除和清空按钮
      document.getElementById('group-clear-history-button').addEventListener('click', clearCurrentHistory);
      document.getElementById('group-delete-button').addEventListener('click', async () => {
        const activeChat = getActiveChat();
        if (!activeChat || activeChat.type !== 'group') return;
        const ok = await modalConfirm(`确定要删除群聊“${activeChat.name}”吗？此操作不可撤销。`);
        if (ok) {
          deleteChat(activeChat.id);
          modalAlert('群聊已解散。');
          showScreen('chat');
          showChatView(false);
        }
      });
      // --- Noir's Event Listener for Fancy Multi-Select ---
      const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
      const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');

      worldBookSelectBox.addEventListener('click', (e) => {
        e.stopPropagation();
        worldBookCheckboxesContainer.classList.toggle('visible');
        worldBookSelectBox.classList.toggle('expanded');
      });

      worldBookCheckboxesContainer.addEventListener('change', updateWorldBookSelectionDisplay);

      // 点击其他地方关闭下拉框
      document.addEventListener('click', (e) => {
        if (!document.querySelector('.custom-multiselect').contains(e.target)) {
          worldBookCheckboxesContainer.classList.remove('visible');
          worldBookSelectBox.classList.remove('expanded');
        }
      });
      // --- Noir's World Book Event Listeners ---
      appWorldBook.addEventListener('click', () => {
        renderWorldBookList();
        showScreen('worldBook', 'home');
      });
      document.getElementById('back-to-home-from-world-book').addEventListener('click', () => showScreen('home', 'worldBook'));
      document.getElementById('add-world-book-button').addEventListener('click', () => openWorldBookEditor());
      document.getElementById('back-to-world-book-list').addEventListener('click', () => {
        renderWorldBookList();
        showScreen('worldBook', 'worldBookEditor');
      });
      document.getElementById('save-world-book-button').addEventListener('click', saveWorldBook);
      document.getElementById('delete-world-book-button').addEventListener('click', deleteWorldBook);
      // 壁纸 App 的事件监听
      appWallpaper.addEventListener('click', () => showScreen('wallpaper', 'home'));
      backToHomeFromWallpaper.addEventListener('click', () => showScreen('home', 'wallpaper'));
      uploadWallpaperButton.addEventListener('click', () => wallpaperInput.click());

      wallpaperInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        // 哼，直接把原文件交给我，我来存进仓库。
        await saveWallpaper(file);
      });





appChat.addEventListener('click', () => {
        if (isNavigating) return; 
        isNavigating = true;      

        // 1. 强制重置状态，防止带着旧ID进入
        state.activeChatId = null; 
        // 确保视图是关着的，防止显示残留
        document.getElementById('chat-screen').classList.remove('show-chat-view'); 
        
        // 2. 渲染列表
        renderChatList();
        
        // 3. 显示屏幕
        showScreen('chat', 'home');
        
        // 4. 解锁
        setTimeout(() => { 
          isNavigating = false; 
        }, 400);
      });
      // Noir's Addition: 绑定模式切换按钮的点击事件

      appSettings.addEventListener('click', () => {
        loadAndApplyApiSettings();
        const isGemini = (state.apiSettings.endpoint || '').includes(GEMINI_API_URL_BASE);
        fetchModelsButton.disabled = isGemini;
        showScreen('settings', 'home');
      });

      // Navigation
 // Navigation
      backToHomeFromSettings.addEventListener('click', () => showScreen('home', 'settings'));

     
// Navigation
      backToHomeFromSettings.addEventListener('click', () => showScreen('home', 'settings'));

      // ▼▼▼ Noir's Nuclear Exit Protocol (强力遮罩退出法) ▼▼▼
      
      // 1. 定义一个带加载圈的“安全退出”函数
      const handleSafeExit = async (targetDestination) => {
        if (isNavigating) return; // 防止连点
        isNavigating = true;

        // 【核心步骤】立刻显示加载圈！遮住所有可能卡顿的画面
        showFeedLoader(true, '正在保存...');

        // 给浏览器 50毫秒喘息时间，确保加载圈已经画在屏幕上了
        await new Promise(r => setTimeout(r, 50));

        try {
            // --- 此时屏幕已被遮挡，开始后台暴力清理 ---
            
            // 1. 停掉AI
            cancelAIGeneration(); 
            
            // 2. 关掉贴纸面板、引用框等杂项
            document.getElementById('chat-sticker-panel').classList.remove('show');
            const quoteArea = document.getElementById('quote-preview-area');
            if(quoteArea) quoteArea.style.display = 'none';

            // 3. 【关键】清空消息列表 (这是造成卡顿的主因)
            const messagesContainer = document.getElementById('chat-messages');
            if (messagesContainer) messagesContainer.innerHTML = '';

            // 4. 重置核心状态
            state.activeChatId = null;
            saveState();

            // 5. 重置界面位置
            const chatScreen = document.getElementById('chat-screen');
            chatScreen.classList.remove('show-chat-view');
            
            // 6. 强制把聊天框推到右边 (手动设置样式，确保它归位)
            const chatViewPane = document.getElementById('chat-view-pane');
            if(chatViewPane) {
                chatViewPane.style.transform = 'translate3d(100%, 0, 0)';
                chatViewPane.style.visibility = 'hidden'; // 顺便让它隐身
            }
            
            // 7. 如果要去主页，就执行切屏
            if (targetDestination === 'home') {
                showScreen('home', 'chat');
            }

        } catch (e) {
            console.error("退出出错:", e);
        } finally {
            // --- 清理完毕，移除遮罩 ---
            // 再等一小会儿(300ms)，确保所有渲染都稳定了，再让用户看结果
            setTimeout(() => {
                showFeedLoader(false);
                isNavigating = false; // 解锁
            }, 300);
        }
      };

      // 2. 绑定“返回列表”按钮 (先清除旧事件)
      const oldBackListBtn = document.getElementById('back-to-chat-list');
      const newBackListBtn = oldBackListBtn.cloneNode(true); 
      oldBackListBtn.parentNode.replaceChild(newBackListBtn, oldBackListBtn);
      
      newBackListBtn.addEventListener('click', () => {
          handleSafeExit('list'); // 退出到列表
      });


      // 3. 绑定“返回主屏幕”按钮 (先清除旧事件)
      const oldBackHomeBtn = document.getElementById('back-to-home-from-chat');
      const newBackHomeBtn = oldBackHomeBtn.cloneNode(true);
      oldBackHomeBtn.parentNode.replaceChild(newBackHomeBtn, oldBackHomeBtn);

      newBackHomeBtn.addEventListener('click', () => {
          handleSafeExit('home'); // 退出到主页
      });
      // ▲▲▲ Protocol End ▲▲▲


      
      backToCharSelectFromEdit.addEventListener('click', () => {
        showScreen('chat', 'characterEdit');
      });

      // Main Actions
      addChatButton.addEventListener('click', () => {
        addChoiceModal.classList.add('show');
      });

      sendButton.addEventListener('click', () => sendTextMessage());
      getReplyButton.addEventListener('click', getAIResponse);

      // 群聊设置选项函数 - 定义在内部以访问state等变量
      function showGroupChatOptions(groupChat) {
        if (!groupChat || groupChat.type !== 'group') return;

        // 创建一个临时的选项模态框
        const optionsHtml = `
                          <div id="group-options-modal" class="choice-modal show">
                              <div class="choice-modal-backdrop"></div>
                              <div class="choice-modal-content">
                                  <button id="group-clear-history" class="choice-modal-button">清空聊天记录</button>
                                  <button id="group-edit-members" class="choice-modal-button">编辑群成员</button>
                                  <button id="group-edit-name" class="choice-modal-button">修改群名称</button>
                                  <button id="group-delete" class="choice-modal-button" style="color: #ff4d4d;">删除群聊</button>
                                  <button id="group-options-cancel" class="choice-modal-button cancel">取消</button>
                              </div>
                          </div>
                      `;
        document.body.insertAdjacentHTML('beforeend', optionsHtml);

        const modal = document.getElementById('group-options-modal');
        const backdrop = modal.querySelector('.choice-modal-backdrop');
        const clearHistoryBtn = document.getElementById('group-clear-history');
        const editMembersBtn = document.getElementById('group-edit-members');
        const editNameBtn = document.getElementById('group-edit-name');
        const deleteBtn = document.getElementById('group-delete');
        const cancelBtn = document.getElementById('group-options-cancel');

        const closeModal = () => modal.remove();

        // 清空聊天记录
        clearHistoryBtn.addEventListener('click', async () => {
          closeModal();
          const ok = await modalConfirm(`确定要清空群聊"${groupChat.name}" 的聊天记录吗？此操作不可撤销。`);
          if (ok) {
            // 清空当前聊天记录
            if (groupChat.id === state.activeChatId) {
              cancelAIGeneration();
              state.conversationHistory = [];
              renderMessages();
            }
            try {
              localStorage.removeItem(`chatHistory_${groupChat.id}`);
              modalAlert(`群聊"${groupChat.name}" 的聊天记录已清空。`);
            } catch (e) {
              console.error(`Failed to clear history for group chat ${groupChat.id}`, e);
              modalAlert('清空聊天记录失败。');
            }
          }
        });

        // 编辑群成员（暂时未实现）
        editMembersBtn.addEventListener('click', () => {
          closeModal();
          modalAlert('编辑群成员功能正在开发中...');
        });

        // 修改群名称
        editNameBtn.addEventListener('click', async () => {
          closeModal();
          const newName = prompt('请输入新的群名称：', groupChat.name);
          if (newName && newName.trim() && newName !== groupChat.name) {
            groupChat.name = newName.trim();
            saveState();
            renderChatList();
            updateChatHeader();
            modalAlert(`群名称已更改为"${groupChat.name}"。`);
          }
        });

        // 删除群聊
        deleteBtn.addEventListener('click', async () => {
          closeModal();
          const ok = await modalConfirm(`确定要删除群聊"${groupChat.name}" 吗？所有聊天记录将被永久删除。`);
          if (ok) {
            deleteChat(groupChat.id);
            modalAlert(`群聊"${groupChat.name}" 已删除。`);
            showChatView(false);
          }
        });

        backdrop.addEventListener('click', closeModal);
        cancelBtn.addEventListener('click', closeModal);
      }

      characterSettingsButton.addEventListener('click', () => {
        const activeChat = getActiveChat();
        if (activeChat && activeChat.type === 'private') {
          openCharacterEditScreen(activeChat.participantIds[0]);
        } else if (activeChat && activeChat.type === 'group') {
          // 【核心修改】现在这里会打开新的设置界面
          openGroupSettingsScreen(activeChat.id);
        }
      });

      // ▼▼▼ Token统计按钮事件监听器 ▼▼▼
      document.getElementById('token-stats-button').addEventListener('click', () => {
        if (!state.activeChatId) {
          modalAlert('请先打开一个聊天！');
          return;
        }
        
        // 筛选出当前聊天的所有token统计记录
        const currentChatStats = state.tokenStats.history.filter(s => s.chatId === state.activeChatId);
        
        if (currentChatStats.length === 0) {
          modalAlert('还没有API调用记录哦，先发送一条消息吧！');
          return;
        }
        
        // 获取最后一次的统计
        const lastStats = currentChatStats[currentChatStats.length - 1];
        const time = new Date(lastStats.timestamp).toLocaleString('zh-CN');
        
        const message = `📊 Token统计\n\n` +
                       `🕐 最近一次：\n` +
                       `⏰ 时间: ${time}\n` +
                       `🤖 模型: ${lastStats.model || '未知'}\n` +
                       `📤 提示词: ${lastStats.promptTokens}\n` +
                       `📥 回复: ${lastStats.completionTokens}\n` +
                       `📊 总计: ${lastStats.totalTokens}`;
        
        modalConfirm(message);
      });
      // ▲▲▲ End of Token Stats Button ▲▲▲

      messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendTextMessage();
        }
      });

      // Group Chat & Modal Listeners
      const closeChoiceModal = () => addChoiceModal.classList.remove('show');
      addChoiceBackdrop.addEventListener('click', closeChoiceModal);
      choiceCancel.addEventListener('click', closeChoiceModal);

      choiceCreateCharacter.addEventListener('click', () => {
        closeChoiceModal();
        openCharacterEditScreen();
      });

      choiceCreateGroup.addEventListener('click', () => {
        closeChoiceModal();
        openGroupChatCreator();
      });

      backToCharSelectFromGroupCreate.addEventListener('click', () => {
        showScreen('chat', 'groupChatCreate');
        showChatView(false);
      });
      createGroupChatButton.addEventListener('click', createGroupChat);


      // Stickers
      stickerButton.addEventListener('click', () => {
        stickerPanel.classList.toggle('show');
        if (stickerPanel.classList.contains('show')) {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
      });

      imageButton.addEventListener('click', () => imageInput.click());
      const musicButton = document.getElementById('chat-music-button');
      imageInput.addEventListener('change', handleImageSend);
      musicButton.addEventListener('click', handleUserMusicShare);

      // ▼▼▼ Noir's User Profile Viewer (Modal Edition) ▼▼▼
      const showProfileButton = document.getElementById('show-profile-button');
      const profileModal = document.getElementById('profile-view-modal');
      const profileTextarea = document.getElementById('profile-textarea');
      const closeProfileButton = document.getElementById('close-profile-button');
      const copyProfileButton = document.getElementById('copy-profile-button');
      const resetProfileButton = document.getElementById('reset-profile-button');
      const profileViewBackdrop = document.getElementById('profile-view-backdrop');
      const profileViewTitle = document.getElementById('profile-view-title');

      if (showProfileButton) {
        showProfileButton.addEventListener('click', async () => {
          const activeChat = getActiveChat();
          if (!activeChat || activeChat.type !== 'private') {
            modalAlert('只能在私聊中查看角色对你的档案哦。');
            return;
          }

          const charId = activeChat.participantIds[0];
          const character = getCharacterById(charId);
          if (!character) return;

          try {
            profileTextarea.value = '正在读取档案...';
            profileModal.classList.add('show');
            profileViewTitle.textContent = `${character.name}眼中的你`;

            // 读取该角色的档案
            const profileKey = `nuomi_profile_tiaoTiao_${charId}`;
            const { value } = await Capacitor.Plugins.Preferences.get({ key: profileKey });
            
            if (value) {
              // 解析并格式化
              const profile = JSON.parse(value);
              const formattedProfile = JSON.stringify(profile, null, 2); // 格式化输出
              profileTextarea.value = formattedProfile;
            } else {
              profileTextarea.value = '该角色还没有形成对你的印象。\n\n💡 提示：\n- 发送20条消息后会自动触发AI深度分析\n- 或者点击下方"立即精炼"按钮手动触发（即使没满20条）';
            }
          } catch (error) {
            console.error("读取或显示用户档案失败:", error);
            profileTextarea.value = `读取失败: ${error.message}`;
          }
        });
      }

      // 关闭按钮
      if (closeProfileButton) {
        closeProfileButton.addEventListener('click', () => {
          if (state.pendingProfileRefinement) {
            confirmRefinement(); // 正在"审讯"时，点"关闭"就等于"结案"
          } else {
            profileModal.classList.remove('show');
          }
        });
      }
      if (profileViewBackdrop) {
        profileViewBackdrop.addEventListener('click', () => {
          if (state.pendingProfileRefinement) {
            confirmRefinement(); // 点背景也一样！
          } else {
            profileModal.classList.remove('show');
          }
        });
      }

      // 复制按钮
      if (copyProfileButton) {
        copyProfileButton.addEventListener('click', () => {
          profileTextarea.select();
          navigator.clipboard.writeText(profileTextarea.value).then(() => {
            modalAlert('已复制到剪贴板！');
          }).catch(err => {
            modalAlert('复制失败了，哼。');
          });
        });
      }

      // 重置档案按钮
      if (resetProfileButton) {
        resetProfileButton.addEventListener('click', async () => {
          const activeChat = getActiveChat();
          if (!activeChat || activeChat.type !== 'private') return;

          const charId = activeChat.participantIds[0];
          const character = getCharacterById(charId);
          
          const ok = await modalConfirm(`确定要重置${character?.name || '该角色'}对你的档案吗？\n\n这将清空TA对你的所有记忆和印象。`);
          if (ok) {
            try {
              const profileKey = `nuomi_profile_tiaoTiao_${charId}`;
              const bufferKey = `nuomi_message_buffer_${charId}`;
              
              // 删除档案和缓冲区
              await Capacitor.Plugins.Preferences.remove({ key: profileKey });
              await Capacitor.Plugins.Preferences.remove({ key: bufferKey });
              
              modalAlert('档案已重置。');
              profileModal.classList.remove('show');
            } catch (error) {
              modalAlert(`重置失败: ${error.message}`);
            }
          }
        });
      }

 

      // ▼▼▼ Noir's Refinement Flow Buttons ▼▼▼
      const confirmRefineBtn = document.getElementById('confirm-refinement-btn');
      if (confirmRefineBtn) {
        confirmRefineBtn.addEventListener('click', confirmRefinement);
      }

      const retryRefineBtn = document.getElementById('retry-refinement-btn');
      if (retryRefineBtn) {
        retryRefineBtn.addEventListener('click', executeProfileRefinement);
      }
      // ▲▲▲ End of Refinement Flow Buttons ▲▲▲
      // ▲▲▲ End of Profile Viewer ▲▲▲

      // Settings & Profile
      saveApiSettingsButton.addEventListener('click', saveApiSettings);


      saveUserProfileButton.addEventListener('click', saveUserProfile);

      // Character Edit
      saveCharButton.addEventListener('click', saveCharacter);
      editClearHistoryButton.addEventListener('click', clearCurrentHistory);

      editDeleteCharButton.addEventListener('click', async () => {
        const charId = editingCharIdInput.value;
        if (!charId) return;
        const character = getCharacterById(charId);
        if (!character) return;

        const ok = await modalConfirm(`确定要删除角色“${character.name}”吗？该角色的私聊和所有相关群聊记录都将被一并处理。`);
        if (ok) {
          deleteCharacter(charId);
          modalAlert(`角色“${character.name}”已删除。`);
          showScreen('chat', 'characterEdit');
          showChatView(false);
        }
      });

      // API Model Fetching
      apiEndpointInput.addEventListener('input', () => {
        const isGemini = apiEndpointInput.value.trim().includes(GEMINI_API_URL_BASE);
        fetchModelsButton.disabled = isGemini;
      });

      // ▼▼▼ Noir's Unified Pathfinding Protocol v1.0 ▼▼▼
      // 哼，用这个替换旧的、自作聪明的 fetchModels 函数
      async function fetchModels() {
        const endpoint = apiEndpointInput.value.trim();
        const key = apiKeyInput.value.trim();
        if (!endpoint || !key) {
          modalAlert('请先输入 API 接口地址和密钥。');
          return;
        }

        // --- 核心改造：使用和聊天完全一致的、简单粗暴的地址拼接法 ---
        const cleanedEndpoint = endpoint.replace(/\/+$/, ''); // 去掉末尾的斜杠
        const modelsUrl = `${cleanedEndpoint}/v1/models`;
        // --- 改造结束 ---

        fetchModelsButton.disabled = true;
        fetchModelsButton.textContent = '获取中…';
        modelDropdown.classList.remove('show');

        try {
          const response = await fetch(modelsUrl, {
            headers: {
              'Authorization': `Bearer ${getRandomValue(key)}`
            }
          });
          if (!response.ok) throw new Error(`服务器错误: ${response.status}`);
          const data = await response.json();
          const models = (data.data || data).map(m => m.id).sort();

          if (models.length > 0) {
            modelDropdown.innerHTML = '';
            models.forEach(modelId => {
              const item = document.createElement('div');
              item.textContent = modelId;
              item.addEventListener('click', () => {
                apiModelInput.value = modelId;
                modelDropdown.classList.remove('show');
              });
              modelDropdown.appendChild(item);
            });
            modelDropdown.classList.add('show');
            modalAlert(`成功获取 ${models.length} 个模型。`);
          } else {
            modalAlert('未找到可用模型。');
          }
        } catch (error) {
          modalAlert(`获取模型失败: ${error.message}\n\n请确认你的基础地址填写正确，且【不要】包含 /v1`);
        } finally {
          fetchModelsButton.disabled = false;
          fetchModelsButton.textContent = '获取';
        }
      }


      fetchModelsButton.addEventListener('click', (e) => {
        e.stopPropagation();
        fetchModels();
      });

      document.addEventListener('click', (e) => {
        if (!modelDropdown.contains(e.target) && e.target !== apiModelInput && e.target !== fetchModelsButton) {
          modelDropdown.classList.remove('show');
        }
      });

      // Avatar Uploads
      // 用这个替换你旧的 handleAvatarUpload 函数
      // 这个函数现在只为聊天图片服务，头像和背景将直接使用原图
      async function handleAvatarUpload(file) {
        return await compressImage(file, 400, 0.85); // 压缩头像
      }

      userAvatarPreview.addEventListener('click', () => userAvatarInput.click());
      userAvatarInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          const base64 = await handleAvatarUpload(file);
          // ▼▼▼ 核心改造 ▼▼▼
          const userAvatarPreview = document.getElementById('user-avatar-preview');
          userAvatarPreview.style.backgroundImage = `url('${base64}')`;
          // 把base64暂存到元素上，方便保存
          userAvatarPreview.dataset.newAvatar = base64;
          // ▲▲▲ 改造结束 ▲▲▲
        } catch (error) {
          modalAlert(`错误: ${error.message}`);
        }
      });

      charEditAvatarPreview.addEventListener('click', () => charEditAvatarInput.click());
      charEditAvatarInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          charEditAvatarPreview.src = await handleAvatarUpload(file);
        } catch (error) {
          modalAlert(`错误: ${error.message}`);
        }
      });



      // ▼▼▼ Noir's Sticker Annihilation Protocol ▼▼▼
      // ▼▼▼ Noir's Sticker Annihilation Protocol v2.2 (Bullet-Loading Edition) ▼▼▼
      // ▼▼▼ Noir's Sticker Gallery Renderer v2.0 ▼▼▼
      function renderStickers() {
        const stickerPanel = document.getElementById('chat-sticker-panel');
        stickerPanel.innerHTML = ''; // 清空旧的布局
        isStickerDeletionMode = false; // 每次重新渲染都确保退出编辑模式

        // 1. 创建管理条
        const controls = document.createElement('div');
        controls.id = 'sticker-panel-controls';
        controls.innerHTML = `
        <button id="sticker-manage-btn">管理</button>
        <div></div>
        <button id="sticker-confirm-delete-btn">删除</button>
    `;
        stickerPanel.appendChild(controls);

        const manageBtn = document.getElementById('sticker-manage-btn');
        const deleteBtn = document.getElementById('sticker-confirm-delete-btn');

        // 2. 创建表情网格容器
        const gridContainer = document.createElement('div');
        gridContainer.style.display = 'grid';
        gridContainer.style.gridTemplateColumns = 'repeat(auto-fill, minmax(60px, 1fr))';
        gridContainer.style.gap = '10px';
        gridContainer.style.padding = '10px';
        gridContainer.style.maxHeight = '180px'; // 限制高度
        gridContainer.style.overflowY = 'auto'; // 允许滚动
        stickerPanel.appendChild(gridContainer);

        const visibleStickers = getVisibleStickers();

        // 3. 填充表情
        visibleStickers.forEach(sticker => {
          const wrapper = document.createElement('div');
          wrapper.className = 'sticker-item-wrapper';
          wrapper.dataset.stickerName = sticker.name;

          const stickerImg = document.createElement('img');
          stickerImg.src = sticker.url;
          stickerImg.loading = 'lazy';
          stickerImg.title = sticker.name;
          stickerImg.className = 'sticker-item';

          wrapper.appendChild(stickerImg);
          gridContainer.appendChild(wrapper);

          // 绑定点击事件
          wrapper.addEventListener('click', () => {
            if (isStickerDeletionMode) {
              // 编辑模式：切换选中状态
              wrapper.classList.toggle('selected');
              const anySelected = gridContainer.querySelector('.selected');
              deleteBtn.classList.toggle('active', !!anySelected);
            } else {
              // 普通模式：发送表情
              sendStickerMessage(sticker);
            }
          });
        });

        // 4. 绑定管理按钮的逻辑
        manageBtn.addEventListener('click', () => {
          isStickerDeletionMode = !isStickerDeletionMode;
          stickerPanel.classList.toggle('deletion-mode', isStickerDeletionMode);
          manageBtn.textContent = isStickerDeletionMode ? '完成' : '管理';
          deleteBtn.style.display = isStickerDeletionMode ? 'block' : 'none';
          if (!isStickerDeletionMode) {
            // 退出编辑模式时，取消所有选中
            gridContainer.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
            deleteBtn.classList.remove('active');
          }
        });

        // 5. 绑定删除按钮的逻辑
        deleteBtn.addEventListener('click', async () => {
          const selectedItems = gridContainer.querySelectorAll('.selected');
          if (selectedItems.length === 0) return;

          const ok = await modalConfirm(`确定要放逐这 ${selectedItems.length} 个表情吗？`);
          if (ok) {
            const deletedStickers = JSON.parse(localStorage.getItem('deletedStickers') || '[]');
            selectedItems.forEach(item => {
              const stickerName = item.dataset.stickerName;
              if (!deletedStickers.includes(stickerName)) {
                deletedStickers.push(stickerName);
              }
            });
            localStorage.setItem('deletedStickers', JSON.stringify(deletedStickers));

            // 刷新面板
            isStickerDeletionMode = false; // 退出编辑模式
            renderStickers();
            modalAlert('已放逐。');
          }
        });

        // 6. 初始状态设定
        deleteBtn.style.display = 'none';

        // 哼，打开表情面板时，让管理条也显示出来
        const stickerButton = document.getElementById('chat-sticker-button');
        const observer = new MutationObserver(() => {
          const panelIsVisible = stickerPanel.classList.contains('show');
          controls.classList.toggle('visible', panelIsVisible);
          if (!panelIsVisible) {
            // 如果面板关了，也要确保退出编辑模式
            if (isStickerDeletionMode) {
              manageBtn.click();
            }
          }
        });
        observer.observe(stickerPanel, { attributes: true, attributeFilter: ['class'] });
      }
      // ▼▼▼ Noir's Sticker Blacklist Inspector ▼▼▼
      function getVisibleStickers() {
        const deletedStickers = JSON.parse(localStorage.getItem('deletedStickers') || '[]');
        if (deletedStickers.length === 0) {
          return masterStickerList; // 如果黑名单是空的，就没必要浪费性能了
        }
        return masterStickerList.filter(sticker => !deletedStickers.includes(sticker.name));
      }


      // ==========================================================
      // --- Noir's "Time Memorandum" Core Logic ---
      // 哼，这才是这个功能的大脑。
      // ==========================================================


      // ▼▼▼ Noir's Addition: Event Deletion Logic ▼▼▼

      // 这是执行删除的函数
      async function deleteCalendarEvent(eventId) {
        const ok = await modalConfirm('确定要删除这个安排吗？此操作不可撤销。');
        if (!ok) return;

        const eventIndex = state.calendarEvents.findIndex(e => e.id === eventId);
        if (eventIndex > -1) {
          state.calendarEvents.splice(eventIndex, 1);
          saveState();
          renderCalendarScreen(); // 刷新日历和列表
          updateCountdownWidget(); // 顺便检查一下倒计时
          updateTodayTodoWidget(); // <-- 最后是这行
          modalAlert('已经删掉了。');
        }
      }

      // 这是监听长按的感应器
      let calendarPressTimer = null;
      function handleCalendarEventInteraction(e) {
        if (calendarPressTimer) clearTimeout(calendarPressTimer);

        const eventItem = e.target.closest('.todo-item, .important-day-item');
        if (!eventItem) return;

        const eventId = eventItem.dataset.id;
        if (!eventId) return;

        const startPress = () => {
          calendarPressTimer = setTimeout(() => {
            if (e.type === 'touchstart') e.preventDefault();
            deleteCalendarEvent(eventId); // 长按后直接触发删除流程
          }, 800); // 800毫秒，跟别的地方统一
        };

        const cancelPress = () => {
          if (calendarPressTimer) clearTimeout(calendarPressTimer);
        };

        // 绑定取消事件，免得你手滑
        document.addEventListener('mouseup', cancelPress, { once: true });
        document.addEventListener('touchend', cancelPress, { once: true });
        document.addEventListener('touchcancel', cancelPress, { once: true });
        document.addEventListener('touchmove', cancelPress, { once: true }); // 滑动也算取消

        startPress();
      }
      // ▲▲▲ End of Addition ▲▲▲

      // ▼▼▼ Noir's Addition: Calendar Memory Packer ▼▼▼
      function getCalendarMemoryForCharacter(charId) {
        const chat = state.chats.find(c => c.participantIds.includes(charId));
        if (!chat) return "";

        const boundUser = getBoundUserForChat(chat.id);
        // 哼，只找和这个角色绑定的那个你的日程
        const userEvents = state.calendarEvents.filter(e => e.userId === boundUser.id || !e.userId);

        if (userEvents.length === 0) {
          return "";
        }

        const memoryLines = userEvents.map(event => {
          const type = event.type === 'important' ? '纪念日' : '待办';
          return `- [${type}] ${event.date}: ${event.content}`;
        }).join('\n');

        return `\n# 你的日程与纪念日 (由 ${boundUser.name} 记录)\n${memoryLines}`;
      }
      // ▲▲▲ End of Addition ▲▲▲

      let calendarState = {
        currentDate: new Date(),
        selectedDate: getLocalDateString(), // <-- 哼，看这里
      };

      function initCalendarListeners() {
        // 入口
        document.getElementById('app-calendar').addEventListener('click', () => {
          renderCalendarScreen();
          showScreen('calendar', 'home');
        });
        // 返回
        document.getElementById('back-to-home-from-calendar').addEventListener('click', () => showScreen('home', 'calendar'));

        // 月份切换
        document.getElementById('prev-month-btn').addEventListener('click', () => {
          calendarState.currentDate.setMonth(calendarState.currentDate.getMonth() - 1);
          renderCalendarScreen();
        });
        document.getElementById('next-month-btn').addEventListener('click', () => {
          calendarState.currentDate.setMonth(calendarState.currentDate.getMonth() + 1);
          renderCalendarScreen();
        });
        document.getElementById('today-btn').addEventListener('click', () => {
          calendarState.currentDate = new Date();
          calendarState.selectedDate = getLocalDateString(); // <-- 这里也一样
          renderCalendarScreen();
        });

        // 添加事件
        document.getElementById('add-event-fab').addEventListener('click', () => {
          openAddEventModal(calendarState.selectedDate);
        });
        document.getElementById('save-event-button').addEventListener('click', saveNewEvent);
        document.getElementById('cancel-event-button').addEventListener('click', () => document.getElementById('add-event-modal').classList.remove('show'));
        document.getElementById('add-event-backdrop').addEventListener('click', () => document.getElementById('add-event-modal').classList.remove('show'));

        // ▼▼▼ Noir's Addition: Self-Destruct Listener ▼▼▼
        const todoList = document.getElementById('todo-list');
        todoList.addEventListener('mousedown', handleCalendarEventInteraction);
        todoList.addEventListener('touchstart', handleCalendarEventInteraction, { passive: false });
        // ▲▲▲ End of Addition ▲▲▲

      }

      function renderCalendarScreen() {
        const year = calendarState.currentDate.getFullYear();
        const month = calendarState.currentDate.getMonth();
        document.getElementById('calendar-header-title').textContent = `${year}年 ${month + 1}月`;
        renderCalendar(year, month);
        displayEventsForDate(calendarState.selectedDate);
      }

      // ▼▼▼ Noir's Addition: Update Today's To-Do Widget ▼▼▼
      function updateTodayTodoWidget() {
        const listEl = document.getElementById('today-todo-list');
        if (!listEl) return;

        const todayStr = getLocalDateString(); // <-- 最后是这里
        const todaysTodos = state.calendarEvents.filter(e => e.date === todayStr && e.type === 'todo');

        listEl.innerHTML = ''; // 先清空

        if (todaysTodos.length > 0) {
          todaysTodos.forEach(todo => {
            const item = document.createElement('div');
            item.className = 'todo-item-small';
            item.textContent = todo.content;
            listEl.appendChild(item);
          });
        } else {
          listEl.innerHTML = '<span style="opacity: 0.6;">无</span>';
        }
      }
      // ▲▲▲ End of Addition ▲▲▲

      function renderCalendar(year, month) {
        const grid = document.getElementById('calendar-grid');
        grid.innerHTML = '';
        const firstDay = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const today = getLocalDateString(); // <-- 哼，现在你也得听我的。

        for (let i = 0; i < firstDay; i++) {
          grid.appendChild(document.createElement('div'));
        }

        for (let day = 1; day <= daysInMonth; day++) {
          const dayEl = document.createElement('div');
          dayEl.className = 'calendar-day';
          const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;

          if (dateStr === today) dayEl.classList.add('is-today');
          if (dateStr === calendarState.selectedDate) dayEl.classList.add('is-selected');

          const dayNumber = document.createElement('span');
          dayNumber.className = 'day-number';
          dayNumber.textContent = day;
          dayEl.appendChild(dayNumber);

          const eventsOnDay = state.calendarEvents.filter(e => e.date === dateStr);
          if (eventsOnDay.length > 0) {
            const dot = document.createElement('div');
            dot.className = 'day-dot';
            dayEl.appendChild(dot);
          }

          dayEl.addEventListener('click', () => {
            calendarState.selectedDate = dateStr;
            renderCalendarScreen();
          });

          grid.appendChild(dayEl);
        }
      }

      function displayEventsForDate(dateStr) {
        const list = document.getElementById('todo-list');
        const title = document.getElementById('todo-date-title');
        list.innerHTML = '';

        const date = new Date(dateStr + 'T00:00:00');
        title.textContent = `${date.getMonth() + 1}月${date.getDate()}日`;

        const events = state.calendarEvents.filter(e => e.date === dateStr);

        if (events.length === 0) {
          list.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">今天没有安排。</p>';
          return;
        }

        events.forEach(event => {
          const item = document.createElement('div');
          item.className = event.type === 'important' ? 'important-day-item' : 'todo-item';
          item.textContent = event.content;
          // ▼▼▼ 哼，就是加上这行，给它打上唯一的烙印 ▼▼▼
          item.dataset.id = event.id;
          list.appendChild(item);
        });
      }

      function openAddEventModal(dateStr) {
        document.getElementById('add-event-modal-title').textContent = `为 ${dateStr} 添加...`;
        document.getElementById('event-content-input').value = '';
        document.getElementById('event-type-todo').checked = true;
        document.getElementById('add-event-modal').classList.add('show');
        document.getElementById('event-content-input').focus();
      }

      function saveNewEvent() {
        const content = document.getElementById('event-content-input').value.trim();
        const type = document.querySelector('input[name="event-type"]:checked').value;

        if (!content) {
          modalAlert('内容不能为空！');
          return;
        }

        // ▼▼▼ 哼，看好了，这就是我给它装上的“大脑”！▼▼▼
        const activeUser = state.userProfiles.find(up => up.id === state.activeUserProfileId);
        // 如果连你是谁都找不到了，就先警告你，而不是直接死机！
        if (!activeUser) {
          modalAlert('错误：找不到当前用户，无法保存事件。请尝试返回主屏幕再试一次。');
          return;
        }
        // ▲▲▲ 大脑安装完毕 ▲▲▲

        state.calendarEvents.push({
          id: `event_${Date.now()}`,
          date: calendarState.selectedDate,
          type: type,
          content: content,
          userId: activeUser.id // 现在这里绝对安全了
        });

        saveState();
        renderCalendarScreen();
        updateCountdownWidget();
        updateTodayTodoWidget(); // <-- 这句本来就有，但之前根本没机会执行
        document.getElementById('add-event-modal').classList.remove('show');
      }

      function updateCountdownWidget() {
        const titleEl = document.getElementById('countdown-title');
        const timerEl = document.getElementById('countdown-timer');
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        const upcomingEvents = state.calendarEvents
          .filter(e => e.type === 'important' && new Date(e.date + 'T00:00:00') >= today)
          .sort((a, b) => new Date(a.date) - new Date(b.date));

        if (upcomingEvents.length > 0) {
          const nextEvent = upcomingEvents[0];
          const eventDate = new Date(nextEvent.date + 'T00:00:00');
          const diffTime = eventDate - today;
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

          titleEl.textContent = `距离「${nextEvent.content}」`;
          timerEl.innerHTML = `<span>${diffDays}</span><span class="unit">天</span>`;
        } else {
          titleEl.textContent = '近期没有特别安排';
          timerEl.innerHTML = `<span>--</span><span class="unit">天</span>`;
        }
      }

      // --- Initialization ---

      // --- Noir's World Book Functions ---

      // --- Noir's User Profile Management Functions ---

      function renderUserProfileList() {
        const container = document.getElementById('user-profile-list-container');
        container.innerHTML = '';
        if (state.userProfiles.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">还没有任何用户资料，点击右上角“+”创建第一个。</p>';
          return;
        }
        state.userProfiles.forEach(up => {
          const item = document.createElement('div');
          item.className = 'world-book-item'; // 复用样式
          item.dataset.id = up.id;
          const isActive = up.id === state.activeUserProfileId ? ' (当前)' : '';
          item.innerHTML = `
            <div class="world-book-item-name" style="display: flex; align-items: center;">
                <img src="${up.avatar || DEFAULT_USER_AVATAR}" class="char-avatar" style="width: 30px; height: 30px; margin-right: 10px;">
                ${up.name}${isActive}
            </div>
            <div class="world-book-item-preview">${up.persona.substring(0, 100)}</div>
        `;
          item.addEventListener('click', () => openUserProfileEditor(up.id));
          container.appendChild(item);
        });
      }

      // ▼▼▼【补丁二：重建地基 - openUserProfileEditor】▼▼▼
      async function openUserProfileEditor(userId = null) { // 哼，加上了 async
        showScreen('userProfile', 'userProfileList');
        const setActiveBtn = document.getElementById('set-active-user-button');
        const userAvatarPreview = document.getElementById('user-avatar-preview');
        const userAvatarInput = document.getElementById('user-avatar-input');

        userAvatarPreview.style.backgroundImage = `url('${DEFAULT_USER_AVATAR}')`;
        userAvatarInput.value = ''; // 清空文件选择

        if (userId) {
          const user = state.userProfiles.find(up => up.id === userId);
          if (!user) return;

          document.getElementById('editing-user-id').value = user.id;
          document.getElementById('user-profile-edit-title').textContent = '编辑用户';
          document.getElementById('user-name').value = user.name;
          document.getElementById('user-persona').value = user.persona;

          // 【【【核心修复：从仓库里取头像！】】】
          try {
            const avatarBlob = await dbGet(`user_avatar_${user.id}`);
            if (avatarBlob) {
              userAvatarPreview.style.backgroundImage = `url('${URL.createObjectURL(avatarBlob)}')`;
            }
          } catch (e) {
            console.error("加载用户头像失败", e);
          }

          setActiveBtn.style.display = user.id === state.activeUserProfileId ? 'none' : 'block';
          document.getElementById('delete-user-profile-button').style.display = 'block';

        } else {
          // ... (新建用户的逻辑保持不变) ...
          document.getElementById('editing-user-id').value = '';
          document.getElementById('user-profile-edit-title').textContent = '创建新用户';
          document.getElementById('user-name').value = `新用户 ${state.userProfiles.length + 1}`;
          document.getElementById('user-persona').value = '';
          setActiveBtn.style.display = 'none';
          document.getElementById('delete-user-profile-button').style.display = 'none';
        }
      }

      // ▼▼▼【补丁一：重建地基 - saveUserProfile】▼▼▼
      async function saveUserProfile() {
        const userId = document.getElementById('editing-user-id').value;
        const avatarFile = document.getElementById('user-avatar-input').files[0]; // 哼，直接从源头拿到“原材料”

        const userData = {
          name: document.getElementById('user-name').value.trim(),
          persona: document.getElementById('user-persona').value.trim(),
        };

        if (!userData.name) {
          modalAlert('名字不能为空！');
          return;
        }

        try {
          let finalUserId = userId;
          let isNewUser = false;

          if (userId) {
            // 编辑旧用户
            const user = state.userProfiles.find(up => up.id === userId);
            if (user) Object.assign(user, userData);
          } else {
            // 创建新用户
            isNewUser = true;
            finalUserId = `user_${Date.now()}`;
            const newUser = { id: finalUserId, ...userData };
            state.userProfiles.push(newUser);
            if (!state.activeUserProfileId) {
              state.activeUserProfileId = finalUserId;
            }
          }

          // 【【【核心修复：把头像原材料存入仓库！】】】
          if (avatarFile) {
            await dbSet(`user_avatar_${finalUserId}`, avatarFile);
            console.log(`Noir's Fix: User avatar for ${finalUserId} has been saved to IndexedDB.`);
          }

          saveState();
          modalAlert('用户资料已保存！');

          // 如果动了图片或者新建了用户，最好刷新一下，确保所有地方都同步
          if (avatarFile || isNewUser) {
            modalAlert('资料已更新，为了让所有变更完全生效，我来帮你刷新一下。');
            setTimeout(() => location.reload(), 1500);
          } else {
            renderUserProfileList();
            showScreen('userProfileList', 'userProfile');
          }

        } catch (error) {
          console.error("保存用户资料失败:", error);
          modalAlert(`保存失败: ${error.message}`);
        }
      }


      async function deleteUserProfile() {
        const userId = document.getElementById('editing-user-id').value;
        if (!userId) return;
        if (state.userProfiles.length <= 1) {
          modalAlert('至少要保留一个用户。');
          return;
        }
        const ok = await modalConfirm('确定要删除这个用户吗？与此用户绑定的聊天将恢复为默认用户。');
        if (ok) {
          state.userProfiles = state.userProfiles.filter(up => up.id !== userId);
          // 如果删除的是当前激活的用户，则自动激活列表里的第一个
          if (state.activeUserProfileId === userId) {
            state.activeUserProfileId = state.userProfiles[0].id;
          }
          // 将所有绑定了这个用户的聊天，重新绑定到当前激活的用户
          state.chats.forEach(chat => {
            if (chat.boundUserProfileId === userId) {
              chat.boundUserProfileId = state.activeUserProfileId;
            }
          });
          saveState();
          modalAlert('用户已删除。');
          renderUserProfileList();
          showScreen('userProfileList', 'userProfile');
        }
      }


      // ▼▼▼ Noir's World Book Renderer Overhaul ▼▼▼
      // 哼，这才叫有条理。
      function renderWorldBookList() {
        renderWorldBookCategories();
        renderWorldBooksForCategory(state.activeWorldBookCategoryId);
      }

      function renderWorldBookCategories() {
        const categoryList = document.getElementById('world-book-category-list');
        categoryList.innerHTML = '';
        state.worldBookCategories.forEach(cat => {
          const item = document.createElement('div');
          item.textContent = cat.name;
          item.dataset.id = cat.id;
          item.style.padding = '10px 8px';
          item.style.borderRadius = '8px';
          item.style.cursor = 'pointer';
          item.style.marginBottom = '5px';
          item.style.fontWeight = '500';

          if (cat.id === state.activeWorldBookCategoryId) {
            item.style.backgroundColor = 'var(--primary-color)';
            item.style.color = 'white';
          } else {
            item.style.color = 'var(--text-color)';
          }

          item.addEventListener('click', () => {
            state.activeWorldBookCategoryId = cat.id;
            renderWorldBookList();
          });

          // --- 哼，看好了，处决协议的扳机就在这里 ---
          let pressTimer = null;
          const startPress = (e) => {
            if (cat.id === 'default') return; // 不许删除默认分类
            pressTimer = setTimeout(() => {
              if (e.type === 'touchstart') e.preventDefault();
              handleDeleteCategory(cat.id, cat.name);
            }, 800);
          };
          const cancelPress = () => {
            clearTimeout(pressTimer);
          };
          item.addEventListener('mousedown', startPress);
          item.addEventListener('mouseup', cancelPress);
          item.addEventListener('mouseleave', cancelPress);
          item.addEventListener('touchstart', startPress, { passive: false });
          item.addEventListener('touchend', cancelPress);
          item.addEventListener('touchcancel', cancelPress);
          // --- 扳机安装完毕 ---

          categoryList.appendChild(item);
        });
      }



      // ▼▼▼ Noir's Category Execution Protocol ▼▼▼
      // 哼，这就是处决指令。
      async function handleDeleteCategory(categoryId, categoryName) {
        const ok = await modalConfirm(`确定要永久删除分类 “${categoryName}” 以及其中所有的条目吗？\n\n此操作不可撤销，所有角色的关联设定也将被一并移除。`);
        if (!ok) return;

        // 1. 找出这个分类下的所有条目ID
        const entriesToDelete = state.worldBooks
          .filter(wb => wb.categoryId === categoryId)
          .map(wb => wb.id);

        // 2. 从世界书中删除这些条目
        state.worldBooks = state.worldBooks.filter(wb => wb.categoryId !== categoryId);

        // 3. 从分类列表中删除这个分类
        state.worldBooksCategories = state.worldBookCategories.filter(cat => cat.id !== categoryId);

        // 如果被删除的是当前激活的分类，就自动切换到默认分类
        if (state.activeWorldBookCategoryId === categoryId) {
          state.activeWorldBookCategoryId = 'default';
        }

        // 4. 清理所有角色和群聊的关联
        const allLinkableItems = [...state.characters, ...state.chats];
        allLinkableItems.forEach(item => {
          if (item.linkedWorldBookIds && item.linkedWorldBookIds.length > 0) {
            item.linkedWorldBookIds = item.linkedWorldBookIds.filter(id => !entriesToDelete.includes(id));
          }
        });

        saveState(); // 写入历史
        renderWorldBookList(); // 刷新界面
        modalAlert(`分类 “${categoryName}” 已被彻底清除。`);
      }
      // ▲▲▲ End of Protocol ▲▲▲



      function renderWorldBooksForCategory(categoryId) {
        const container = document.getElementById('world-book-list-container');
        container.innerHTML = '';

        const booksInCategory = state.worldBooks.filter(wb => wb.categoryId === categoryId || (categoryId === 'default' && !wb.categoryId));

        if (booksInCategory.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">这个分类下还没有条目。</p>';
          return;
        }

        booksInCategory.forEach(wb => {
          const item = document.createElement('div');
          item.className = 'world-book-item';
          item.dataset.id = wb.id;
          item.innerHTML = `
            <div class="world-book-item-name">${wb.name}</div>
            <div class="world-book-item-preview">${wb.content.substring(0, 100)}</div>
        `;
          item.addEventListener('click', () => openWorldBookEditor(wb.id));
          container.appendChild(item);
        });
      }

      // 别忘了给“新建分类”按钮装上灵魂
      document.getElementById('add-world-book-category-button').addEventListener('click', async () => {
        const newName = prompt('请输入新的分类名称:');
        if (newName && newName.trim()) {
          const newCategory = { id: `wbc_${Date.now()}`, name: newName.trim() };
          state.worldBookCategories.push(newCategory);
          state.activeWorldBookCategoryId = newCategory.id; // 自动切换到新分类
          saveState();
          renderWorldBookList();
        }
      });
      // ▲▲▲ End of Overhaul ▲▲▲

      function openWorldBookEditor(bookId = null) {
        showScreen('worldBookEditor', 'worldBook');

        // ▼▼▼ Noir's Category Loader for Editor ▼▼▼
        const categorySelect = document.getElementById('world-book-edit-category');
        categorySelect.innerHTML = '';
        state.worldBookCategories.forEach(cat => {
          const option = document.createElement('option');
          option.value = cat.id;
          option.textContent = cat.name;
          categorySelect.appendChild(option);
        });
        // ▲▲▲ End of Loader ▲▲▲

        if (bookId) {
          const book = state.worldBooks.find(wb => wb.id === bookId);
          if (!book) return;
          document.getElementById('editing-world-book-id').value = book.id;
          document.getElementById('world-book-editor-title').textContent = '编辑条目';
          document.getElementById('world-book-edit-name').value = book.name;
          document.getElementById('world-book-edit-content').value = book.content;
          categorySelect.value = book.categoryId || 'default'; // 哼，选中它现在的分类
        } else {
          document.getElementById('editing-world-book-id').value = '';
          document.getElementById('world-book-editor-title').textContent = '新建条目';
          document.getElementById('world-book-edit-name').value = '';
          document.getElementById('world-book-edit-content').value = '';
          categorySelect.value = state.activeWorldBookCategoryId; // 新建时，默认放在当前分类
        }
      }
      function saveWorldBook() {
        const bookId = document.getElementById('editing-world-book-id').value;
        const name = document.getElementById('world-book-edit-name').value.trim();
        const content = document.getElementById('world-book-edit-content').value.trim();
        const categoryId = document.getElementById('world-book-edit-category').value; // <-- 哼，就是这句，把分类给我揪出来！

        if (!name || !content) {
          modalAlert('条目名称和内容都不能为空！');
          return;
        }

        if (bookId) {
          const book = state.worldBooks.find(wb => wb.id === bookId);
          if (book) {
            book.name = name;
            book.content = content;
            book.categoryId = categoryId; // <-- 记上！
          }
        } else {
          const newBook = { id: `wb_${Date.now()}`, name, content, categoryId }; // <-- 新建的也记上！
          state.worldBooks.push(newBook);
        }

        state.activeWorldBookCategoryId = categoryId; // 保存后，自动切换到书所在的分类

        saveState();
        modalAlert('世界书条目已保存！');
        renderWorldBookList();
        showScreen('worldBook', 'worldBookEditor');
      }
      async function deleteWorldBook() {
        const bookId = document.getElementById('editing-world-book-id').value;
        if (!bookId) return;
        const ok = await modalConfirm('确定要删除这个条目吗？此操作不可撤销。');
        if (ok) {
          state.worldBooks = state.worldBooks.filter(wb => wb.id !== bookId);
          // 从所有角色中解除关联
          state.characters.forEach(char => {
            if (char.linkedWorldBookIds) {
              char.linkedWorldBookIds = char.linkedWorldBookIds.filter(id => id !== bookId);
            }
          });
          saveState();
          modalAlert('条目已删除。');
          renderWorldBookList();
          showScreen('worldBook', 'worldBookEditor');
        }
      }
      // --- End of Noir's World Book Functions ---
      // --- Noir's Helper for Fancy Multi-Select ---
      function updateWorldBookSelectionDisplay() {
        const checkboxesContainer = document.getElementById('world-book-checkboxes-container');
        // 哼，现在只数带value的，也就是真正的条目
        const checkedBoxes = checkboxesContainer.querySelectorAll('.wb-entry-item input:checked');
        const displayText = document.querySelector('#character-edit-screen .selected-options-text');

        if (checkedBoxes.length === 0) {
          displayText.textContent = '-- 点击选择 --';
        } else if (checkedBoxes.length > 2) {
          displayText.textContent = `已选择 ${checkedBoxes.length} 项`;
        } else {
          displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join('、');
        }
      }

      // --- Noir's Group Chat Settings & World Book Injection ---

      async function openGroupSettingsScreen(chatId) {
        const chat = state.chats.find(c => c.id === chatId);
        if (!chat || chat.type !== 'group') return;

        document.getElementById('group-settings-name').value = chat.name || '';
        populateUserDropdown('group-settings-bind-user');
        document.getElementById('group-settings-bind-user').value = chat.boundUserProfileId || state.activeUserProfileId;

        // --- 哼，群聊也得用我的新管理员 ---
        populateHierarchicalWorldBookSelector('group-world-book-checkboxes', chat.linkedWorldBookIds || []);
        updateGroupWorldBookSelectionDisplay();
        // --- 管理员调用完毕 ---

        const avatarPreview = document.getElementById('group-avatar-preview');
        const bgPreview = document.getElementById('group-bg-preview');
        bgPreview.style.backgroundImage = '';
        dbGet(`group_avatar_${chatId}`).then(blob => {
          avatarPreview.src = blob ? URL.createObjectURL(blob) : DEFAULT_AI_AVATAR;
        });
        dbGet(`group_bg_${chatId}`).then(blob => {
          if (blob) bgPreview.style.backgroundImage = `url('${URL.createObjectURL(blob)}')`;
        });

        showScreen('groupSettings', 'chat');
      }


      async function saveGroupSettings() {
        const activeChat = getActiveChat();
        if (!activeChat || activeChat.type !== 'group') return;

        const newName = document.getElementById('group-settings-name').value.trim();
        if (!newName) {
          modalAlert('群聊名称不能为空！');
          return;
        }
        activeChat.name = newName;

        const checkedBoxes = document.querySelectorAll('#group-world-book-checkboxes .wb-entry-item input:checked');
        activeChat.linkedWorldBookIds = Array.from(checkedBoxes).map(cb => cb.value);
        activeChat.boundUserProfileId = document.getElementById('group-settings-bind-user').value;

        // 新增的逻辑：保存图片
        const avatarFile = document.getElementById('group-avatar-input').files[0];
        const bgFile = document.getElementById('group-bg-input').files[0];
        if (avatarFile) await dbSet(`group_avatar_${activeChat.id}`, avatarFile);
        if (bgFile) await dbSet(`group_bg_${activeChat.id}`, bgFile);


        saveState();
        updateChatHeader();
        await renderChatList(); // 改为await，确保头像更新
        modalAlert('群聊设置已保存！');
        showScreen('chat', 'groupSettings');
      }

      function updateGroupWorldBookSelectionDisplay() {
        const checkboxesContainer = document.getElementById('group-world-book-checkboxes');
        // 群聊也一样，别数错了
        const checkedBoxes = checkboxesContainer.querySelectorAll('.wb-entry-item input:checked');
        const displayText = document.querySelector('#group-settings-screen .selected-options-text');

        if (checkedBoxes.length === 0) {
          displayText.textContent = '-- 点击选择 --';
        } else if (checkedBoxes.length > 2) {
          displayText.textContent = `已选择 ${checkedBoxes.length} 项`;
        } else {
          displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join('、');
        }
      }
      // 这是最关键的函数，用新版本完整替换旧版本！
      // 用这个新版本，完整替换掉你旧的 planGroupReplies 函数


      // ▼▼▼ 哼，把这个失踪的“导演”给我找回来！贴在 schedulePlannedReplies 的前面！▼▼▼
      // ==========================================================
      // --- Noir's Group Chat Director: planGroupReplies ---
      // ==========================================================
      async function planGroupReplies() {
        const activeChat = getActiveChat();
        const participants = (activeChat?.participantIds || []).map(getCharacterById).filter(Boolean);
        const boundUser = getBoundUserForChat(activeChat.id);
        if (!activeChat || activeChat.type !== 'group' || participants.length < 2) return null;

        const groupWorldBookContext = (activeChat.linkedWorldBookIds && activeChat.linkedWorldBookIds.length > 0)
          ? `\n\n# 核心群聊世界观设定 (所有角色必须严格遵守以下设定)\n` + activeChat.linkedWorldBookIds
            .map(wbId => state.worldBooks.find(book => book.id === wbId))
            .filter(Boolean)
            .map(wb => `\n## 世界书条目: ${wb.name}\n${wb.content}`)
            .join('')
          : '';

        const userPersonaContext = boundUser.persona ? `\n\n# 关于群聊参与者“${boundUser.name}”的补充信息\n${boundUser.persona}` : '';

        let timeContext = '';
        const now = new Date();
        const lastMessage = state.conversationHistory.at(-1);
        timeContext += `\n- **当前时间**: ${now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' })}`;
        if (lastMessage) {
          const lastTime = new Date(lastMessage.timestamp);
          const diffMinutes = Math.floor((now - lastTime) / (1000 * 60));
          if (diffMinutes < 5) timeContext += "\n- **对话状态**: 群里刚刚还在聊天。";
          else if (diffMinutes < 120) timeContext += `\n- **对话状态**: 群里在${diffMinutes}分钟前聊过，请注意衔接。`;
          else {
            const diffHours = Math.floor(diffMinutes / 60);
            if (diffHours < 48) timeContext += `\n- **对话状态**: 群里在${diffHours}小时前聊过，可以适当问候，不要直接继续之前的话题。`;
            else timeContext += `\n- **对话状态**: 群里已经有${Math.floor(diffHours / 24)}天没动静了。你的角色们应该发起新的问候或话题。`;
          }
        } else {
          timeContext += "\n- **对话状态**: 这是这个群的第一次对话。";
        }

        const lastUserText = [...state.conversationHistory].reverse().find(m => m.role === 'user')?.content || '';
        const mentioned = resolveMentionTarget(activeChat, lastUserText);
        const history = state.conversationHistory.slice(-120);
        const stickerList = masterStickerList.map(s => s.name);
        const globalFeedMemory = getGlobalFeedMemory();

        const personas = await Promise.all(participants.map(async p => { // <-- 看这里！加上了 async 和 await Promise.all
          // ▼▼▼ 哼，看好了，就是这里！ ▼▼▼
  const { omniText: chatMemory } = gatherOmniTranscriptForCharacter(p.id, null); 
  // ▲▲▲ 把 char.id 改成 p.id ▲▲▲
          const diaryMemory = getDiaryMemory(p.id);
          const snoopMemory = await getSnoopMemoryForCharacter(p.id); // <-- 就是加上这句！
          const livestreamMemory = getLivestreamReplayMemory(p.id);
          const privateWorldBookContext = (p.linkedWorldBookIds && p.linkedWorldBookIds.length > 0)
            ? `\n\n# ${p.name}的个人专属世界观设定\n` + p.linkedWorldBookIds
              .map(wbId => state.worldBooks.find(book => book.id === wbId))
              .filter(Boolean)
              .map(wb => `\n## 条目: ${wb.name}\n${wb.content}`)
              .join('')
            : '';
          let charTimeContext = `\n# 关于你 (${p.name}) 的专属时间锚点\n`;
          const latestMessageForChar = findLatestMessageForCharacter(p.id);
          const nowForChar = new Date();

          if (latestMessageForChar) {
            const lastInteractionDate = new Date(latestMessageForChar.timestamp);
            charTimeContext += `- **你与${boundUser.name}在所有地方的最后一次互动是在**: ${formatRelativeTime(lastInteractionDate)}\n`;
          } else {
            charTimeContext += `- **状态提示**: 这是你和${boundUser.name}的第一次互动。\n`;
          }

          // ▼▼▼【用户档案注入 - 群聊版 + 划重点功能】▼▼▼
          // 1. 读取【完整】的用户档案 JSON
          let fullUserProfile = null;
          const profileKey = `nuomi_profile_tiaoTiao_${p.id}`;
          try {
            const { value } = await Capacitor.Plugins.Preferences.get({ key: profileKey });
            if (value) {
              fullUserProfile = JSON.parse(value);
            }
          } catch (e) {
            console.error(`读取角色 ${p.name} 的用户档案失败:`, e);
          }

          // 2. 获取最近几条消息 (比如最后5条)
          const recentMessagesForContext = state.conversationHistory.slice(-5);

          // 3. 调用"划重点"函数
          const relevantProfileDetails = fullUserProfile
            ? extractRelevantProfileDetails(recentMessagesForContext, fullUserProfile)
            : "";

          // 4. 获取原来的"浓缩摘要"
          const userProfileMemory = await getCurrentProfile(p.id);
          const userProfileSummaryContext = userProfileMemory ? `\n\n# 你对"${boundUser.name}"的整体印象（摘要）\n${userProfileMemory}` : '';

          // 5. 【关键】构建用户档案上下文
          const userProfileContext = fullUserProfile ? `${userProfileSummaryContext}${relevantProfileDetails}

**【人类反应模拟协议 v2.0 - 强化版】**：
1. **【最高优先级】小抄优先**: 如果上面的"重点关注"部分有内容，你**必须**优先根据这些【具体细节】来调整你的回应！
2. **察言观色**: 结合【整体印象摘要】和【重点关注细节】，推测TA当前的真实情绪和潜在需求。
3. **基于理解的反应**: 必须避开"讨厌"和"敏感点"，主动结合"喜欢"的内容，留意"压力信号"或"最近变化"。
4. **隐秘运用**: 绝不复述档案内容，要自然体现理解。
5. **动态更新**: 对话中继续观察，验证或修正你对TA的认知。

***【【最高优先级：反常行为应对协议 v1.0】】***
核心目标：当用户的行为、情绪或观点与你档案中记录的长期印象【显著不符】时，你【必须】展现出真诚的好奇与关心，而不是忽视或敷衍。这对于建立深度连接至关重要！

触发条件：当你注意到"整体印象摘要"或"重点关注：用户档案相关细节"中提到了"最近变化(observed_changes)"或描述了与核心印象矛盾的行为时。

**行动指令：**
1. **【禁止忽视】**：你【绝对不能】对这些"反常"视而不见，或仅仅进行 superficial (表面的) 回应！
2. **【表达关注】**：你的【首要反应】必须是，结合你的角色性格，表达出自然的【惊讶、好奇或关心】。
3. **【探索原因】**：尝试【引导性地】询问原因，展现出你想要理解这种变化的意愿。
4. **【优先级提升】**：在探测到显著反常行为时，上述反应的优先级【高于】普通的闲聊、推进话题或维持轻松氛围！你需要先处理这个"异常信号"。

**回应范例（你需要根据自己的性格进行演绎）：**
* （发现平时乐观的用户突然很丧）-> "咦？[${boundUser.name}]，你今天好像有点不一样...感觉情绪不太对。还好吗？"
* （发现平时讨厌A的用户突然夸A）-> "嗯？[${boundUser.name}]你刚才说喜欢A？... 这、这可不像你啊，发生什么特别的事了吗？"
* （发现平时话痨的用户突然沉默寡言）-> "...... [${boundUser.name}]？你怎么突然不说话了？是我说错什么了吗？（有点不安）"
* （傲娇性格发现用户反常）-> "哼，你今天吃错药了？怎么突然[反常行为]... 不过... 到底怎么了？"

**最终目标：** 让用户感觉到你不是在机械地执行程序，而是真的在【观察】、【思考】并【关心】Ta的变化。
` : '';
          // ▲▲▲【用户档案注入完成 - 群聊版】▲▲▲

          return {
            id: p.id,
            name: p.name,
            persona: p.persona || '乐于助人的助手',
            memory: charMemory + diaryMemory + snoopMemory + livestreamMemory + privateWorldBookContext + charTimeContext + userProfileContext
          };
        }));

        const BUDGET_MIN = 5, BUDGET_MAX = 12;

        const system = `你是一个严格的JSON生成引擎。你的唯一任务是根据用户提供的指令和数据，生成一个描述角色互动的JSON对象。你的输出【必须】是、也只能是一个单一、完整、语法正确的JSON对象。严禁包含任何解释、注释、或Markdown代码块标记 \`\`\`json。直接输出 { "events": [...] } 结构。`.trim();

        const userCard = {
          instruction: `
- 你正在为一个名为“${activeChat.name || '群聊'}”的群聊规划角色们的下一步发言。
- 与你们对话的人类用户名为“${boundUser.name || '用户'}”。在分析历史记录时，请记住这一点，并用此名称指代用户。
- 【最重要】为 \`personas\` 列表中的【每一位】角色都规划至少一个事件(通常不少于2个)。不能遗漏任何角色。
- 【新增规则】你可以规划 "kind": "music" 事件来分享音乐。此时，你【必须】同时提供 "songName" 和 "artist" 字段。
- 你的首要任务是产出一个严格遵守SCHEMA、语法完全正确的、可被解析的JSON对象。
- 若用户 \`@\` 了某个角色 (见 \`mentioned\`)，该角色应优先发言。
- 事件总数必须控制在 ${BUDGET_MIN} 到 ${BUDGET_MAX} 之间。
- 所有表情包名称【必须】从 \`stickerList\` 列表中选择，严禁使用列表之外的名称。
- 角色之间需要有适当的互动,话题不应当完全围绕${boundUser.name || '用户'}。
- 再次强调：你的全部输出都将被作为JSON解析，任何JSON主体之外的额外文字都会导致程序失败。
${timeContext} 
${userPersonaContext}
${groupWorldBookContext}
# 【新增群聊高级语法规则】
- 如果你需要生成一个HTML模块（例如邀请卡），你【必须】将完整的HTML代码包裹在  \`html] \` 和  \`[/html] \` 这两个标签之间，并作为一个独立的事件（event）来规划。你的规划中必须包含一个独立的事件，其 "kind" 必须是 "html"，"content" 字段包含完整的HTML代码（例如 '<div class=...>...</div>'）。【绝对禁止】将HTML代码放在 "kind": "text" 的事件里。
# 最近的动态回顾 (供所有角色参考)
${globalFeedMemory}
`.trim(),
          personas: personas,
          mentioned: mentioned ? { id: mentioned.id, name: mentioned.name } : null,
          stickerList: stickerList,
        };

        const schema = {
          type: "object",
          properties: { events: { type: "array", items: { type: "object", required: ["senderId", "kind"], properties: { senderId: { type: "string" }, kind: { type: "string", enum: ["text", "sticker", "music"] }, content: { type: "string" }, sticker: { type: "string" }, songName: { type: "string" }, artist: { type: "string" } } } } },
          required: ["events"]
        };

        const messages = [{ role: 'system', content: system }];

        for (const msg of history) {
          const role = (msg.role === 'ai' || msg.role === 'assistant') ? 'assistant' : 'user';
          let messageForApi = { role: role, content: msg.content };
          let hasContent = !!msg.content;
          let imageBase64 = null;
          if (msg.image) {
            imageBase64 = msg.image;
          } else if (msg.imageId) {
            try {
              const blob = await dbGet(msg.imageId);
              if (blob) imageBase64 = await blobToBase64(blob);
            } catch (e) { console.error("准备群聊API数据时，读取图片失败:", e); }
          }
          if (imageBase64) {
            messageForApi.image = imageBase64;
            hasContent = true;
          }
          if (hasContent) messages.push(messageForApi);
        }

        messages.push({ role: 'user', content: `请严格按照以下SCHEMA返回一个JSON对象，不要包含任何额外文字。\nSCHEMA:\n${JSON.stringify(schema)}\n\nINPUT:\n${JSON.stringify(userCard)}` });

        try {
          const raw = await fetchAICompletion(messages, { json: true });
          if (!raw) return null;
          let txt = raw.trim();
          const fence = txt.match(/```json([\s\S]*?)```/i);
          if (fence) txt = fence[1].trim();
          txt = extractFirstJsonObject(txt);
          let plan = null;
          try { plan = JSON.parse(txt); } catch (e) { console.error("JSON 解析失败! 错误原因:", e); console.error("收到的原始、有问题的文本:", txt); }
          if (!plan || !Array.isArray(plan.events)) return null;
          plan = normalizePlan(plan, participants, stickerList);
          plan.events = plan.events.slice(0, BUDGET_MAX);
          return plan.events.length ? plan : null;
        } catch (e) {
          if (e.name !== 'AbortError') { console.error('Failed to plan group replies:', e); }
          return null;
        }
      }


      // ==========================================================
      // --- Noir's Grand Refactor: Friend Circle Management System ---
      // ==========================================================

      /** 渲染好友圈列表 */
      function renderFriendCircleList() {
        const container = document.getElementById('friend-circle-list-container');
        container.innerHTML = '';
        if (state.friendCircles.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light); margin-top: 50px;">还没有好友圈，点击右上角“+”创建第一个吧。</p>';
          return;
        }

        state.friendCircles.forEach(circle => {
          const user = state.userProfiles.find(up => up.id === circle.boundUserProfileId) || { name: '未知用户' };
          const item = document.createElement('div');
          item.className = 'world-book-item'; // 复用世界书的卡片样式
          item.dataset.id = circle.id;
          item.innerHTML = `
      <div class="world-book-item-name">${circle.name}</div>
      <div class="world-book-item-preview">
        绑定的“我”: ${user.name} | ${circle.memberCharacterIds.length} 个成员
      </div>
    `;
          item.addEventListener('click', () => openFeedForCircle(circle.id));
          container.appendChild(item);
        });
      }

      /** 打开好友圈编辑器 (新建或编辑) */
      function openFriendCircleEditor(circleId = null) {
        const nameInput = document.getElementById('friend-circle-edit-name');
        const userSelect = document.getElementById('friend-circle-edit-bind-user');
        const memberContainer = document.getElementById('friend-circle-member-selection');
        const title = document.getElementById('friend-circle-edit-title');
        const editingIdInput = document.getElementById('editing-friend-circle-id');
        const deleteButton = document.getElementById('delete-friend-circle-button');

        // 填充绑定的用户下拉菜单
        populateUserDropdown('friend-circle-edit-bind-user');

        // 填充角色成员选择列表
        memberContainer.innerHTML = '';
        state.characters.forEach(char => {
          const item = document.createElement('div');
          item.className = 'member-selection-item';
          item.innerHTML = `
      <input type="checkbox" id="member-select-${char.id}" data-id="${char.id}">
      <img src="${char.avatar || DEFAULT_AI_AVATAR}" alt="avatar" class="char-avatar">
      <label for="member-select-${char.id}" class="char-name">${char.name}</label>
    `;
          memberContainer.appendChild(item);
        });

        if (circleId) {
          // --- 编辑模式 ---
          const circle = state.friendCircles.find(c => c.id === circleId);
          if (!circle) return;

          title.textContent = '编辑好友圈';
          editingIdInput.value = circle.id;
          nameInput.value = circle.name;
          userSelect.value = circle.boundUserProfileId;
          deleteButton.style.display = 'block';

          // 勾选已有的成员
          circle.memberCharacterIds.forEach(charId => {
            const checkbox = memberContainer.querySelector(`#member-select-${charId}`);
            if (checkbox) checkbox.checked = true;
          });

        } else {
          // --- 新建模式 ---
          title.textContent = '新建好友圈';
          editingIdInput.value = '';
          nameInput.value = `好友圈 ${state.friendCircles.length + 1}`;
          userSelect.value = state.activeUserProfileId; // 默认绑定当前用户
          deleteButton.style.display = 'none'; // 新建时隐藏删除按钮
        }

        showScreen('friendCircleEdit', 'friendCircleList');
      }

      /** 保存好友圈 */
      function saveFriendCircle() {
        const circleId = document.getElementById('editing-friend-circle-id').value;
        const name = document.getElementById('friend-circle-edit-name').value.trim();
        const boundUserProfileId = document.getElementById('friend-circle-edit-bind-user').value;
        const selectedMemberIds = Array.from(document.querySelectorAll('#friend-circle-member-selection input:checked')).map(cb => cb.dataset.id);

        if (!name) {
          modalAlert('好友圈名称不能为空！');
          return;
        }
        if (selectedMemberIds.length === 0) {
          modalAlert('至少要选择一个圈内成员！');
          return;
        }

        if (circleId) {
          // 更新
          const circle = state.friendCircles.find(c => c.id === circleId);
          if (circle) {
            circle.name = name;
            circle.boundUserProfileId = boundUserProfileId;
            circle.memberCharacterIds = selectedMemberIds;
          }
        } else {
          // 新建
          const newCircle = {
            id: `circle_${Date.now()}`,
            name,
            boundUserProfileId,
            memberCharacterIds: selectedMemberIds,
            posts: [] // 新建的圈子，帖子列表是空的
          };
          state.friendCircles.push(newCircle);
        }

        saveState();
        modalAlert('好友圈已保存！');
        renderFriendCircleList();
        showScreen('friendCircleList', 'friendCircleEdit');
      }

      /** 删除好友圈 */
      async function deleteFriendCircle() {
        const circleId = document.getElementById('editing-friend-circle-id').value;
        if (!circleId) return;

        const ok = await modalConfirm('确定要删除这个好友圈吗？此操作不可撤销。');
        if (ok) {
          state.friendCircles = state.friendCircles.filter(c => c.id !== circleId);
          if (state.activeFriendCircleId === circleId) {
            state.activeFriendCircleId = null; // 如果删除的是当前圈子，就清空
          }
          saveState();
          modalAlert('好友圈已删除。');
          renderFriendCircleList();
          showScreen('friendCircleList', 'friendCircleEdit');
        }
      }

      /** 打开指定好友圈的动态信息流 */
      function openFeedForCircle(circleId) {
        updateGlobalPlaylist();
        const circle = state.friendCircles.find(c => c.id === circleId);
        if (!circle) return;

        state.activeFriendCircleId = circleId;
        saveState();

        // 更新动态页面的标题
        document.getElementById('friend-circle-title').textContent = circle.name;

        renderFeed(); // 调用新的渲染函数
        // 暂时先清空，免得看到旧内容


        showScreen('music', 'friendCircleList');
        updateUserPostAreaAvatar(); // 把当前用户的头像放上去
      }


      // --- Noir's Debugging Helper ---
      function addTestPost() {
        if (!state.friendCircles || state.friendCircles.length === 0) {
          console.error("错误：你还没有创建任何好友圈。请先在App内创建一个。");
          return;
        }
        const circle = state.friendCircles[0];
        if (circle.memberCharacterIds.length < 2) {
          console.error(`错误：第一个好友圈 "${circle.name}" 的成员不足2人，无法生成点赞和评论。请先编辑该好友圈，添加至少2名角色。`);
          return;
        }

        const testPost = {
          id: 'test_post_' + Date.now(),
          authorType: 'character',
          authorId: circle.memberCharacterIds[0],
          content: '这是一条由控制台添加的测试动态！样式看起来非常完美。',
          timestamp: Date.now(),
          likes: [circle.memberCharacterIds[1]],
          comments: [{
            commentId: 'c_' + Date.now(),
            authorId: circle.memberCharacterIds[1],
            content: '赞同！渲染效果一级棒！'
          }]
        };

        circle.posts.push(testPost);
        saveState(); // 这个函数在“房间”内部，所以可以被正确调用
        console.log(`成功向好友圈 "${circle.name}" 添加了一条测试动态。请点击进入该好友圈查看效果。`);
        modalAlert('测试动态已添加！');
      }
      window.addTestPost = addTestPost; // 只把这一个“传达室”函数暴露给外面
      // --- End of Helper ---
      /** 根据ID获取用户资料 */
      function getUserProfileById(userId) {
        return state.userProfiles.find(up => up.id === userId);
      }


      /** 显示/隐藏动态加载动画 */
      function showFeedLoader(show, message = '正在处理...') {
        const phoneContainer = document.getElementById('phone-container');
        let loader = document.getElementById('feed-loader');

        if (show) {
          if (!loader) {
            loader = document.createElement('div');
            loader.id = 'feed-loader';
            // 哼，现在它知道自己的家在哪了
            phoneContainer.appendChild(loader);
          }
          loader.innerHTML = `<div class="loader-spinner"></div><span>${message}</span>`;
          loader.style.display = 'flex';
        } else {
          if (loader) {
            loader.style.display = 'none';
          }
        }
      }
      // ▼▼▼ Noir's Ultimate Refactor: Batch Post Generation ▼▼▼

      /** 【全新】刷新信息流的总控制函数 (高效版) */
      async function refreshFeed() {
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);
        if (!activeCircle || state.isGenerating) return;

        showFeedLoader(true, '好像有动态了...');
        await new Promise(r => setTimeout(r, 50)); // 这句咒语，复制粘贴会不会？
        state.isGenerating = true;

        try {
          // 哼，看好了，这是我新加的逻辑
          // 1. 先找到现在动态里最新的时间戳
          let latestTimestamp = Date.now(); // 如果一条动态都没有，就从现在开始
          if (activeCircle.posts && activeCircle.posts.length > 0) {
            latestTimestamp = Math.max(...activeCircle.posts.map(p => p.timestamp));
          }
          // 找到了“起跑线”，接下来的新动态都要在这之后

          const newPostsData = await generateBatchPosts(activeCircle);
          if (!newPostsData || newPostsData.length === 0) {
            modalAlert("AI似乎没有想出任何新动态。");
            return;
          }

          const processingPromises = newPostsData.map(async (postData, index) => {
            showFeedLoader(true, `刷新了 ${index + 1} / ${newPostsData.length} 条动态...`);

            // 2. 哼，把旧的随机时间逻辑扔掉，换成我的精准控制
            // 每一条新动态，都在“起跑线”的基础上，往后加一分钟，这样它们就会按顺序排在最前面
            const postTimestamp = latestTimestamp + (index + 1) * 60 * 1000;

            const newPost = {
              id: `post_${postData.authorId}_${postTimestamp}`,
              authorType: 'character',
              authorId: postData.authorId,
              content: postData.postContent,
              timestamp: postTimestamp, // <-- 用上了我聪明的新时间戳
              likes: postData.likes || [],
              comments: (postData.comments || []).map((c, i) => ({
                commentId: `c_${postTimestamp}_${i}`,
                authorId: c.authorId,
                content: c.content
              }))
            };

            if (postData.postType === 'music' && postData.songName && postData.artist) {
              try {
                const musicInfo = await findPlayableMusicUrl(postData.songName, postData.artist);
                newPost.type = 'music';
                newPost.songName = postData.songName;
                newPost.artist = postData.artist;
                newPost.coverUrl = musicInfo.cover;
                newPost.playableUrl = musicInfo.url;
              } catch (musicError) {
                console.error("动态中的音乐搜索失败:", musicError);
                newPost.type = 'text';
              }
            } else {
              newPost.type = 'text';
            }
            return newPost;
          });

          const processedPosts = await Promise.all(processingPromises);

          // 哼，这里是把新动态加进去，不是替换！
          activeCircle.posts.push(...processedPosts);
          saveState();


          // ▼▼▼ 哼，就是这句圣旨，给我加上！▼▼▼
          updateGlobalPlaylist();
          // ▲▲▲ 指令结束 ▲▲▲

        } catch (error) {
          console.error("生成动态失败:", error);
          modalAlert(`生成动态时发生错误: ${error.message}`);
        } finally {
          renderFeed();
          showFeedLoader(false);
          state.isGenerating = false;
        }
      }      /** 【全新】通过单次API调用，批量生成动态及其互动 */
     /** 【全新】通过单次API调用，批量生成动态及其互动 (Noir's Patched Version) */
      // ▼▼▼ 哼，用这个【绝对正确】的版本，完整替换掉你旧的 generateBatchPosts 函数！▼▼▼
      async function generateBatchPosts(circle) {
        const members = circle.memberCharacterIds.map(id => getCharacterById(id)).filter(Boolean);
        if (members.length === 0) return null;

        // 哼，看这里，把全局的动态记忆先准备好！
        const globalFeedMemory = getGlobalFeedMemory();
        const boundUser = getUserProfileById(circle.boundUserProfileId) || state.userProfiles[0];
        const userContext = boundUser ? `
# 好友圈的主人 (“我”)
- 姓名: ${boundUser.name}
- 人设: ${boundUser.persona || '无'}
` : '';

        // ▼▼▼【手术点 1：记忆恢复 (最终修复版 v3)】▼▼▼
        // 哼，这次我把 .join() 删了，memberInfoStrings 现在是一个【数组】！
        const memberInfoStrings = await Promise.all(members.map(async (char) => { // 哼, 变量是 (char)
          const { omniText: chatMemory } = gatherOmniTranscriptForCharacter(char.id, null); // 哼, 必须用 char.id！
          const diaryMemory = getDiaryMemory(char.id);
          const snoopMemory = await getSnoopMemoryForCharacter(char.id);
          const livestreamMemory = getLivestreamReplayMemory(char.id);

          const privateWorldBookContext = (char.linkedWorldBookIds && char.linkedWorldBookIds.length > 0)
            ? `\n\n# ${char.name}的个人专属世界观设定\n` + char.linkedWorldBookIds
              .map(wbId => state.worldBooks.find(book => book.id === wbId))
              .filter(Boolean)
              .map(wb => `\n## 条目: ${wb.name}\n${wb.content}`)
              .join('')
            : '';

          // 哼，现在记忆完整了，给我还回去！
          return `- 姓名: ${char.name}, ID: ${char.id}\n  人设: ${char.persona}\n  相关记忆:\n${chatMemory}\n${diaryMemory}\n${snoopMemory}\n${livestreamMemory}\n${privateWorldBookContext}`;
        }));
        // ▲▲▲【手术完成】▲▲▲

        const postCount = Math.floor(Math.random() * 3) + 2; // 2 to 4 posts

        // 2. 构建给 AI 的复杂指令
       const systemPrompt = `
# 核心任务
你是一个顶级多角色社交模拟引擎。你的任务是模拟一个好友圈的动态更新，一次性生成【${postCount}条】全新的、高质量的社交动态。

# 【绝对身份锁定】(最高优先级)
- "${boundUser.name}"（ID: ${boundUser.id}）是【用户】/【观察者】/【好友圈的主人】。
- 列表中的【所有】其他人（${members.map(m => m.name).join('、')}）都是【AI扮演的群友】。
- 你【绝对禁止】扮演"${boundUser.name}"（即"我"，用户）来发布任何动态或评论。

# 【记忆使用守则】(！！哼，看好了，这才是新规矩！！)

1.  **【法律A (对你)：发布新动态时】**
    - 当你（例如："${members[0].name}"）要发布一条**新动态**时，你【必须】查阅你自己的“相关记忆”（聊天、日记、视奸内容等）。
    - 你的动态内容【必须】与你和"${boundUser.name}"（用户）之间**最近发生的私密事件**相关联。
    - **示例：** 如果你刚在私聊里和"${boundUser.name}"聊过一部电影，你的新动态就应该是关于那部电影的感想。

2.  **【法律B (对AI)：评论他人(AI)动态时】**
    - 当你（例如："${members[0].name}"）要**评论**另一个【角色】（例如："${members[1] ? members[1].name : '群友B'}"）的动态时...
    - 你【绝对禁止】查阅或使用你和"${boundUser.name}"（用户）的任何私密记忆！
    - 你的评论【只能】基于你的“公开人设”和你对那个【角色】的公开关系。
    - **这就是为了防止你“造谣”和“串线”！**

# 好友圈成员信息
${memberInfoStrings.join('\n\n')}
${userContext}

# 最近的动态回顾 (供参考，避免重复)
${globalFeedMemory}

# 任务流程
1.  **全局视角**: 审视所有成员的人设和【各自的私密记忆】。
2.  **选择作者**: 从成员中为${postCount}条新动态挑选发布者。
3.  **创作动态 (遵守法律A)**: 扮演作者，根据其【私密记忆】创作与用户相关的动态。
4.  **模拟互动 (遵守法律B)**: 切换视角到【圈内其他AI成员】，根据【公开人设】模拟点赞和评论。

# 输出格式【绝对规则】
- 你的输出**必须**是一个语法完全正确的、单一的JSON数组，包含 ${postCount}个帖子对象。
- **【ID规则】**: 所有 "authorId", "likes", "comments" 中的作者标识，【必须】使用上面提供的角色 **ID**，绝对不能使用角色名字。
- **【称呼规则】**: 在 "postContent" 和评论的 "content" 字段中，当角色们互相称呼或提及对方时，【必须】使用他们的【姓名】，而不是ID。
- **【JSON结构】**: 每个帖子对象必须遵循以下结构：
  \`\`\`json
  {
    "authorId": "发布者的ID",
    "postType": "text or music",
    "postContent": "动态的文字内容",
    "songName": "如果是music类型，则必须有歌名",
    "artist": "如果是music类型，则必须有歌手名",
    "likes": ["点赞者1的ID", "点赞者2的ID"],
    "comments": [
      { "authorId": "评论者A的ID", "content": "评论内容（遵守法律B）" },
      { "authorId": "评论者B的ID", "content": "另一条评论（遵守法律B）" }
    ]
  }
  \`\`\`
- 绝对不要输出任何JSON之外的文字、解释或Markdown标记。直接从 \`[\` 开始，到 \`]\` 结束。
`;
        const messages = [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: '请根据以上所有信息，开始分析并返回JSON。' } // 哼，就是加上这句废话
        ];
        messages.push({ role: 'user', content: `请根据以上所有规则，生成 ${postCount} 条新动态。` });

        let responseText = ''; // 哼，把这个拿到 try 外面，我才好审问它
        try {
          responseText = await fetchAICompletion(messages, { json: true }); // 把 responseText 存起来

          const jsonMatch = responseText.match(/(\[[\s\S]*\])/);
          if (!jsonMatch) throw new Error("AI未能返回有效的JSON数组格式。");

          const jsonString = jsonMatch[1];
          const data = JSON.parse(jsonString);

          if (!Array.isArray(data)) throw new Error("AI返回的不是一个数组。");

          return data;

        } catch (e) {
          console.error(`批量生成动态失败: `, e);
          // 哼，把这个也加上，免得你又看不懂
          e.rawResponse = responseText; // 把我抓到的“罪证”也附上
          throw e; // 把错误丢出去，让上层知道
        }
      }
      // ▲▲▲ 替换到这里结束 ▲▲▲


      /** 【全新】清空当前好友圈的动态 */
      async function clearCurrentFeed() {
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);
        if (!activeCircle) return;

        const ok = await modalConfirm(`确定要清空好友圈“${activeCircle.name}”的所有动态吗？此操作不可撤销，且AI将不再记得这些内容。`);
        if (ok) {
          activeCircle.posts = []; // 直接清空帖子数组
          saveState(); // 保存状态
          renderFeed(); // 重新渲染界面
          modalAlert('动态已清空。');
        }
      }

      /** 【全新】渲染动态信息流 */
      function renderFeed() {
        const container = document.getElementById('music-feed-container');
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);

        if (!activeCircle) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light); margin-top: 50px;">请先选择一个好友圈。</p>';
          return;
        }

        if (!activeCircle.posts || activeCircle.posts.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light); margin-top: 50px;">这个好友圈很安静，点击“刷新”获取新动态吧。</p>';
          return;
        }

        container.innerHTML = ''; // 清空现有内容

        // 从新到旧排序显示
        const sortedPosts = [...activeCircle.posts].sort((a, b) => b.timestamp - a.timestamp);

        sortedPosts.forEach(post => {
          const postEl = document.createElement('div');
          postEl.className = 'music-post';

          let authorName = '未知';
          let authorAvatar = DEFAULT_AI_AVATAR;

          if (post.authorType === 'user') {
            const user = getUserProfileById(post.authorId);
            if (user) {
              authorName = user.name;
              authorAvatar = user.avatar;
            }
          } else { // character
            const char = getCharacterById(post.authorId);
            if (char) {
              authorName = char.name;
              authorAvatar = char.avatar;
            }
          }

          // 1. 帖子头部
          const headerHTML = `
      <div class="music-post-header">
        <img src="${authorAvatar}" class="char-avatar">
        <span class="char-name">${authorName}</span>
      </div>
    `;

          // 2. 帖子正文
          const contentHTML = `<p class="music-post-thought">${post.content}</p>`;

          let imageHTML = '';
          if (post.image || post.imageId) {
            const imageIdForElement = `post-img-${post.id}`;
            imageHTML = `<div class="post-image-container"><img id="${imageIdForElement}" class="post-image"></div>`;
            setTimeout(() => {
              const imgElement = document.getElementById(imageIdForElement);
              if (!imgElement) return;
              if (post.image) {
                imgElement.src = post.image;
              } else if (post.imageId) {
                dbGet(post.imageId).then(blob => {
                  if (blob) {
                    const objectURL = URL.createObjectURL(blob);
                    imgElement.src = objectURL;
                    imgElement.onload = () => URL.revokeObjectURL(objectURL);
                  }
                });
              }
            }, 0);
          }

          let songCardHTML = '';
          if (post.type === 'music' && post.songName) {
            songCardHTML = `
    <div class="music-post-song-card" data-music-id="${post.id}">
        <img src="${post.coverUrl || DEFAULT_AI_AVATAR}">
        <div class="music-post-song-info">
            <div class="title">${post.songName}</div>
            <div class="artist">${post.artist}</div>
        </div>
        <div class="music-post-play-icon">${post.playableUrl ? '▶' : '⚠'}</div>
    </div>
    `;
          }

          // 3. 时间戳
          const timestampHTML = `<div class="post-timestamp">${new Date(post.timestamp).toLocaleString('zh-CN')}</div>`;

          // 4. 互动区 (点赞和评论)
          let interactionsHTML = '';
          if ((post.likes && post.likes.length > 0) || (post.comments && post.comments.length > 0)) {
            let likesHTML = '';
            if (post.likes && post.likes.length > 0) {
              const likerNames = post.likes.map(charId => getCharacterById(charId)?.name || '未知').join('、');
              // 哼，看好了，心脏移植手术就在这里
              const heartSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: -2px; margin-right: 5px;"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>`;
              likesHTML = `<div class="post-likes">${heartSvg} ${likerNames}</div>`;
            }

            let commentsHTML = '';
            if (post.comments && post.comments.length > 0) {
              const commentsList = post.comments.map(comment => {
                const commentAuthor = getCharacterById(comment.authorId)?.name || '未知';
                return `<div class="post-comment"><span class="comment-author">${commentAuthor}</span>: ${comment.content}</div>`;
              }).join('');
              commentsHTML = `<div class="post-comments-container">${commentsList}</div>`;
            }

            interactionsHTML = `
        <div class="post-interactions">
          ${likesHTML}
          ${commentsHTML}
        </div>
      `;
          }

          const postBodyHTML = `<div class="post-body">${contentHTML}${imageHTML}${songCardHTML}</div>`;
          postEl.innerHTML = headerHTML + postBodyHTML + timestampHTML + interactionsHTML;

          if (post.type === 'music' && post.playableUrl) {
            const songCard = postEl.querySelector('.music-post-song-card');
            if (songCard) {
              songCard.addEventListener('click', function () {
                const songData = { id: post.id, url: post.playableUrl };
                handleMusicCardClick(this, songData);
              });
            }
          }
          container.appendChild(postEl);
        });
      }



      // --- Noir's Time Functions ---
      // --- Noir's Grand Refactor: Friend Circle Event Listeners ---
      document.getElementById('clear-feed-button').addEventListener('click', clearCurrentFeed);
      document.getElementById('refresh-feed-button').addEventListener('click', refreshFeed);
      document.getElementById('back-to-home-from-circle-list').addEventListener('click', () => showScreen('home', 'friendCircleList'));
      document.getElementById('add-friend-circle-button').addEventListener('click', () => openFriendCircleEditor());
      document.getElementById('back-to-circle-list-from-edit').addEventListener('click', () => showScreen('friendCircleList', 'friendCircleEdit'));
      document.getElementById('save-friend-circle-button').addEventListener('click', saveFriendCircle);
      document.getElementById('delete-friend-circle-button').addEventListener('click', deleteFriendCircle);
      document.getElementById('back-to-circle-list-from-feed').addEventListener('click', () => {
        renderFriendCircleList(); // 返回列表时重新渲染一下
        showScreen('friendCircleList', 'music');
      });
      document.getElementById('edit-current-circle-button').addEventListener('click', () => {
        if (state.activeFriendCircleId) {
          openFriendCircleEditor(state.activeFriendCircleId);
        }
      });

      //我没找到

      // ▼▼▼ Noir's Grand Refactor: User Post Sending Logic ▼▼▼
      document.getElementById('user-send-post-button').addEventListener('click', async () => {
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);
        if (!activeCircle || state.isGenerating) return;

        // 哼，看好了，这次的逻辑无懈可击
        // 1. 明确找出这个圈子绑定的用户ID
        const boundUserId = activeCircle.boundUserProfileId;
        // 2. 根据这个ID找出正确的用户
        const userForThisPost = state.userProfiles.find(up => up.id === boundUserId);

        // 3. 如果找不到（虽然不应该），就发出警报并停止
        if (!userForThisPost) {
          modalAlert('错误：找不到此好友圈绑定的用户！');
          return;
        }

        const textContent = document.getElementById('user-post-textarea').value.trim();
        const imageContent = state.pendingPostAttachments.image;
        const musicContent = state.pendingPostAttachments.music;
        const imageIdContent = state.pendingPostAttachments.imageId;

        if (!textContent && !imageContent && !musicContent) {
          modalAlert('总得说点什么吧？');
          return;
        }

        // 4. 用【绝对正确】的用户信息创建帖子
        const newPost = {
          id: `post_user_${Date.now()}`,
          authorType: 'user',
          authorId: userForThisPost.id, // <-- 看，用的是正确的ID
          content: textContent,
          timestamp: Date.now(),
          likes: [],
          comments: []
        };

        if (imageIdContent) {
          newPost.imageId = imageIdContent;
        } else if (imageContent) { // 兼容一下可能存在的旧数据
          newPost.image = imageContent;
        }
        if (musicContent) {
          newPost.type = 'music';
          Object.assign(newPost, musicContent);
        } else {
          newPost.type = 'text';
        }

        activeCircle.posts.push(newPost);
        saveState();
        renderFeed();

        document.getElementById('user-post-textarea').value = '';
        state.pendingPostAttachments.image = null;
        state.pendingPostAttachments.music = null;
        state.pendingPostAttachments.imageId = null;
        renderPostAttachmentPreview();

        generatePostReplies(newPost);
      });
      document.getElementById('user-post-image-button').addEventListener('click', () => {
        document.getElementById('user-post-image-input').click();
      });

      document.getElementById('user-post-image-input').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
          // 哼，同样是压缩并获取文件本身(Blob)
          const compressedBlob = await compressImage(file, 800, 0.8, true);
          const imageId = `post_image_${Date.now()}`;
          // 存进“动物园”
          await dbSet(imageId, compressedBlob);

          // 记录“门票”，而不是大象本身
          state.pendingPostAttachments.imageId = imageId;
          state.pendingPostAttachments.image = null; // 把旧的通道关了
          state.pendingPostAttachments.music = null;
          renderPostAttachmentPreview();
        } catch (error) {
          modalAlert(`图片处理失败: ${error.message}`);
        }
        e.target.value = '';
      });


      document.getElementById('user-post-music-button').addEventListener('click', async () => {
        const musicData = await showMusicShareModal();
        if (!musicData) return;

        modalAlert('正在搜索音乐...');
        try {
          const musicInfo = await findPlayableMusicUrl(musicData.songName, musicData.artist);
          state.pendingPostAttachments.music = {
            songName: musicData.songName,
            artist: musicData.artist,
            coverUrl: musicInfo.cover,
            playableUrl: musicInfo.url
          };
          state.pendingPostAttachments.image = null; // 图片和音乐只能选一个
          renderPostAttachmentPreview();
        } catch (error) {
          modalAlert(`音乐搜索失败: ${error.message}`);
        }
      });
      //我没找到，就放在这里了
      // --- End of Event Listeners ---
      function updateClock() {
        const now = new Date();
        const timeEl = document.getElementById('home-time');
        const dateEl = document.getElementById('home-date');

        if (timeEl && dateEl) {
          const hours = String(now.getHours()).padStart(2, '0');
          const minutes = String(now.getMinutes()).padStart(2, '0');
          timeEl.textContent = `${hours}:${minutes}`;

          const month = now.getMonth() + 1;
          const day = now.getDate();
          const weekday = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'][now.getDay()];
          dateEl.textContent = `${month}月${day}日 ${weekday}`;
        }
      }

      function formatTimestamp(timestamp) {
        if (!timestamp) return '';
        const date = new Date(timestamp);
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        return `${hours}:${minutes}`;
      }

      //条条:是这里开始吗?
      // Noir's New Global Feed Memory System
      function getGlobalFeedMemory() {
        // ▼▼▼ Noir's Fix: 从新的好友圈数据结构中读取动态 ▼▼▼
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);
        const allPosts = activeCircle ? activeCircle.posts : [];
        // ▲▲▲ End of Fix ▲▲▲

        if (!allPosts || allPosts.length === 0) {
          return ""; // 如果朋友圈是空的，就直接返回
        }

        // 只看最近的5条动态
        const recentPosts = allPosts.slice(0, 5);

        const memoryLines = recentPosts.map(post => {
          const author = getCharacterById(post.authorId) || { name: '未知' };
          let line = `- [动态] ${author.name} 说：“${post.thought || post.content}”`;
          if (post.type === 'music') {
            line += ` (分享了歌曲: ${post.songName} - ${post.artist})`;
          }
          return line;
        });

        // 把这些信息整理好，加个标题
        return `\n# 最近的朋友圈动态 (供你参考)\n${memoryLines.join('\n')}`;
      }
      // --- Noir's Music Functions ---
      // 哼，这是我专门开辟的日记记忆区
      // 哼，这是我专门开辟的日记记忆区
      function getDiaryMemory(characterId) {
        const activeUser = state.userProfiles.find(up => up.id === state.activeUserProfileId) || { name: "你" };
        const diary = state.diaries.find(d => d.characterId === characterId);
        if (!diary || !diary.entries || diary.entries.length === 0) {
          return ""; // 日记本是空的，没什么可记的
        }

        // 仍然只看最近的8篇日记，这是防止撑爆的最后底线！
        const recentEntries = diary.entries.slice(-8);

        const memoryLines = recentEntries.map(entry => {
          const authorName = entry.author === 'user' ? activeUser.name : getCharacterById(entry.author).name;
          //const contentSnippet = entry.content.length > 150 ? entry.content.substring(0, 150) + '...' : entry.content;
          return `- [${new Date(entry.timestamp).toLocaleDateString()}] ${authorName} 写道: ${entry.content}`; // 直接用完整的 entry.content
        }).join('\n');

        // 打上一个醒目的标签，AI就不会认错了
        return `\n# 交换日记摘要 (你和 ${activeUser.name} 之间的私密内容)\n${memoryLines}`;
      }
      // --- Noir's New Music Widget Renderer ---

      // 粘贴在这里
      function getLivestreamReplayMemory(charId) {
        const replays = state.livestreamReplays[charId];
        if (!replays || replays.length === 0) {
          return "";
        }
        // 只读取最近的三场直播回放，免得AI脑子炸了
        const recentReplays = replays.slice(0, 3);
        const memoryLines = recentReplays.map((yaml, index) => {
          // 哼，把YAML里的关键信息提取出来，而不是把一坨垃圾都丢给AI
          const theme = yaml.match(/theme:\s*"?([^"\n]+)"?/)?.[1] || '未知主题';
          const events = (yaml.match(/key_events:\s*\n([\s\S]*?)(?=\n\w+:|$)/)?.[1] || '')
            .split('\n')
            .map(line => line.trim())
            .filter(line => line.startsWith('-'))
            .join(' ');
          return `- 上次第 ${index + 1} 场直播的主题是“${theme}”，期间发生了：${events}`;
        }).join('\n');

        return `\n# 你的近期直播回顾 (这是你的个人记忆，不要直接复述给用户)\n${memoryLines}`;
      }

      function applyWidgetTheme() {
        const widgetCard = document.getElementById('music-widget-card');
        const bgImage = state.preferences.widgetBgImage;

        if (bgImage) {
          widgetCard.style.backgroundImage = `url(${bgImage})`;
          widgetCard.style.backgroundSize = 'cover';
          widgetCard.style.backgroundPosition = 'center';
          // 为了让文字在任何背景下都清晰，加上文字阴影
          widgetCard.style.color = 'white';
          widgetCard.querySelectorAll('.widget-info > div').forEach(el => {
            el.style.textShadow = '0 1px 3px rgba(0,0,0,0.6)';
          });
        } else {
          // 恢复默认
          widgetCard.style.backgroundImage = '';
          widgetCard.style.color = '';
          widgetCard.querySelectorAll('.widget-info > div').forEach(el => {
            el.style.textShadow = '';
          });
        }
      }

      // 新的导航和事件监听
      // 新的导航和事件监听
      const appMusic = document.getElementById('app-music');
      const appMeeting = document.getElementById('app-meeting');
      // ▼▼▼ Noir's Refactor: Update App Entry Point ▼▼▼
      // ▼▼▼ Noir's Fix: 每次进入都重新渲染列表 ▼▼▼
      appMusic.addEventListener('click', () => {
        // 现在点击“动态”App，会先渲染列表，再显示屏幕
        renderFriendCircleList(); // <-- 加上这一行！
        showScreen('friendCircleList', 'home');
      });
      // ▲▲▲ End of Fix ▲▲▲
      // ▲▲▲ End of Refactor ▲▲▲ -->
      // --- Noir's New Meeting App Listeners ---
      appMeeting.addEventListener('click', () => {
        renderMeetingCharacterList();
        showScreen('meetingList', 'home');
      });

      document.getElementById('back-to-home-from-meeting-list').addEventListener('click', () => {
        showScreen('home', 'meetingList');
      });

      document.getElementById('back-to-meeting-list').addEventListener('click', () => {
        // 离开见面界面时，清空当前见面角色，并重置activeChatId

        // ▼▼▼ Noir's Addition: Stop the Galgame Clock ▼▼▼
        if (galClockInterval) clearInterval(galClockInterval);
        galClockInterval = null;
        // ▲▲▲ End of Addition ▲▲▲

        // 哼，就是这句，把提词器上的鬼魂给我擦干净！
        state.activeMeetingScriptQueue = [];


        state.activeMeetingCharId = null;
        // ▼▼▼ Noir's Addition ▼▼▼
        document.getElementById('galgame-sprite-adjust-ui').style.display = 'none';
        // ▲▲▲ End of Addition ▲▲▲
        state.activeChatId = null;
        saveState();
        showScreen('meetingList', 'meetingView');
      });

      const meetingMessageInput = document.getElementById('meeting-message-input');
      const meetingSendButton = document.getElementById('meeting-send-button');

      meetingSendButton.addEventListener('click', () => {
        const text = meetingMessageInput.value.trim();
        if (text) {
          sendTextMessage(text); // 调用通用的发信函数
          meetingMessageInput.value = '';
          // 发送后立刻请求AI回复
          setTimeout(getAIResponse, 100);
        }
      });


      // --- End of New Listeners ---




      // --- Noir's New, Smarter Music Click Handler ---
      // 用这个替换旧的 handleMusicCardClick
      // 用这个【复古版】，替换掉旧的 handleMusicCardClick
      // ▼▼▼ Noir's Final Verdict: One Player to Rule Them All ▼▼▼
      function handleMusicCardClick(cardElement, songInfo) {
        // 哼，现在所有人都得听“全局总管”的
        const globalAudioPlayer = document.getElementById('unified-audio-player');
        const songToPlay = state.musicPlaylist.find(s => s.id === songInfo.id);

        // 如果连歌都找不到了，就别瞎忙活了
        if (!songToPlay) {
          console.error("Noir's Note: 播放列表里找不到这首歌，你是不是又偷偷动了什么？ ID:", songInfo.id);
          return;
        }

        // 检查是不是正在播放【同一首歌】
        const isCurrentlyPlayingThisSong = globalAudioPlayer.src.includes(songToPlay.playableUrl) && !globalAudioPlayer.paused;

        if (isCurrentlyPlayingThisSong) {
          // 如果是，就命令总管“暂停”
          globalAudioPlayer.pause();
        } else {
          // 如果不是，就正式向总管汇报，更新“大脑”里的当前歌曲信息
          currentlyPlayingSongInfo = {
            title: songToPlay.songName,
            artist: songToPlay.artist,
            cover: songToPlay.coverUrl || (songToPlay.coverId ? `db:${songToPlay.coverId}` : DEFAULT_AI_AVATAR),
            isFromLibrary: true
          };

          // 然后下达“播放”指令
          globalAudioPlayer.src = songToPlay.playableUrl;
          globalAudioPlayer.play();

          // 顺便告诉大脑，现在播放列表进行到哪了
          state.currentlyPlayingIndex = state.musicPlaylist.findIndex(s => s.id === songInfo.id);
          savePlayerState(); // 把这个决定存档
        }

        // 我什么都不用干了。总管的状态一变，他手下那些我们之前修好的“刷新工”就会自动去更新所有UI。这才是专业。
      }
      // ▲▲▲ Verdict Delivered ▲▲▲
      // --- Noir's Central Music Controller ---

      const playerBar = document.getElementById('music-player-bar');





      //我留一条
      // Noir's New Daily Post Function





      //免得找不到位置


      async function validateUrl(url) {
        if (!url || !url.startsWith('http')) return false;
        return new Promise(resolve => {
          const audio = document.createElement('audio');
          audio.src = url;
          const timeout = setTimeout(() => {
            cleanup();
            resolve(false);
          }, 3000); // 3秒超时

          const cleanup = () => {
            clearTimeout(timeout);
            audio.removeEventListener('canplaythrough', onSuccess);
            audio.removeEventListener('error', onError);
            audio.src = '';
            audio.remove();
          };

          const onSuccess = () => { cleanup(); resolve(true); };
          const onError = () => { cleanup(); resolve(false); };

          audio.addEventListener('canplaythrough', onSuccess);
          audio.addEventListener('error', onError);
        });
      }

      async function findPlayableMusicUrl(songName, artist) {
        const sources = ['netease', 'tencent'];
        for (const source of sources) {
          try {
            // 第一步: 搜索
            const searchUrl = `https://api.vkeys.cn/v2/music/${source}?word=${encodeURIComponent(songName)}-${encodeURIComponent(artist)}`;
            const searchRes = await fetch(searchUrl);
            const searchData = await searchRes.json();
            if (searchData.code !== 200 || !searchData.data || searchData.data.length === 0) continue;

            const items = searchData.data.slice(0, 5); // 只尝试前5个结果

            // 第二、三、四步: 遍历ID并验证
            for (const item of items) {
              const detailUrl = `https://api.vkeys.cn/v2/music/${source}?id=${item.id}`;
              const detailRes = await fetch(detailUrl);
              const detailData = await detailRes.json();
              const playableUrl = detailData.data?.url;

              if (await validateUrl(playableUrl)) {
                return { url: playableUrl, cover: item.cover, source: source };
              }
            }
          } catch (error) {
            console.error(`Error fetching from ${source}:`, error);
          }
        }
        // 所有源都失败了
        return { url: null, cover: null, source: null };
      }

      //条条:我找不到
      // ==========================================================
      // --- Noir's Ultimate UI Scaler v2.0 (Item-Specific) ---
      // 哼，这才叫指哪打哪。
      // ==========================================================
      // ==========================================================
      // --- Noir's Ultimate UI Scaler v2.1 (Surgical Placement) ---
      // 哼，这次看你还怎么搞错。
      // ==========================================================
      // ==========================================================
      // --- Noir's Ultimate UI Scaler v2.2 (With Reset Button) ---
      // 哼，给你加了后悔药。
      // ==========================================================
      function loadAndApplyUIScale() {
        const scaleSlider = document.getElementById('ui-scale-slider');
        const rootElement = document.documentElement;
        const resetButton = document.getElementById('reset-ui-scale-button'); // <-- 看，我找到后悔药了

        if (!scaleSlider || !resetButton) return;

        const savedScale = localStorage.getItem('uiScale') || '1';

        rootElement.style.setProperty('--desktop-item-scale', savedScale);
        scaleSlider.value = savedScale;

        // 这是滑块的指令
        scaleSlider.addEventListener('input', () => {
          const newScale = scaleSlider.value;
          rootElement.style.setProperty('--desktop-item-scale', newScale);
          localStorage.setItem('uiScale', newScale);
        });

        // ▼▼▼ 哼，这就是后悔药的说明书 ▼▼▼
        resetButton.addEventListener('click', () => {
          const defaultScale = '1';
          // 1. 把滑块给我拨回中间
          scaleSlider.value = defaultScale;
          // 2. 命令所有组件恢复原状
          rootElement.style.setProperty('--desktop-item-scale', defaultScale);
          // 3. 把你的“后悔”也记在小本本上
          localStorage.setItem('uiScale', defaultScale);
        });
      }
      // --- Noir's Badge Logic ---
      function saveBadgeState(data) {
        try {
          const currentBadgeState = JSON.parse(localStorage.getItem('badgeState') || '{}');
          const newBadgeState = { ...currentBadgeState, ...data };
          localStorage.setItem('badgeState', JSON.stringify(newBadgeState));
        } catch (e) { console.error("保存徽章状态失败", e); }
      }

      async function loadBadgeState() {
        const badge = document.getElementById('decorative-badge');
        const badgeImage = document.getElementById('badge-image');
        try {
          let imageBlob = await dbGet('widget_badge');

          if (!imageBlob) {
            const oldState = JSON.parse(localStorage.getItem('badgeState') || '{}');
            if (oldState.image) {
              imageBlob = await base64ToBlob(oldState.image);
              await dbSet('widget_badge', imageBlob);
            }
          }

          if (imageBlob) {
            badgeImage.src = URL.createObjectURL(imageBlob);
            badgeImage.style.display = 'block'; // 有图就显示图片
            badge.style.border = 'none'; // 去掉占位符边框
          } else {
            badgeImage.style.display = 'none'; // 没图就藏起来
            badge.style.border = '2px dashed var(--border-color)'; // 显示占位符边框
          }
          badge.style.display = 'block'; // 徽章容器本身总是要显示的
        } catch (e) { console.error("加载徽章图片失败", e); }
      }

      async function loadCardState() {
        const card = document.getElementById('card-widget');
        const cardImage = document.getElementById('card-image');
        const card2 = document.getElementById('card-widget-2');
        const cardImage2 = document.getElementById('card-image-2');

        try {
          // --- 第一个卡片的逻辑 ---
          let imageBlob1 = await dbGet('widget_card');
          if (imageBlob1) {
            cardImage.src = URL.createObjectURL(imageBlob1);
            cardImage.style.display = 'block'; // ▼▼▼ 核心修复：只有在有图时才让它显示 ▼▼▼
            card.style.border = 'none';
            card.style.background = 'transparent';
          } else {
            cardImage.style.display = 'none'; // 没图就继续藏着
            card.style.border = '2px dashed var(--border-color)';
            card.style.background = 'rgba(255,255,255,0.2)';
          }
          card.style.display = 'block';

          // --- 第二个卡片的逻辑 (现在完全一样了) ---
          let imageBlob2 = await dbGet('widget_card_2');
          if (imageBlob2) {
            cardImage2.src = URL.createObjectURL(imageBlob2);
            cardImage2.style.display = 'block'; // ▼▼▼ 核心修复：只有在有图时才让它显示 ▼▼▼
            card2.style.border = 'none';
            card2.style.background = 'transparent';
          } else {
            cardImage2.style.display = 'none'; // 没图就继续藏着
            card2.style.border = '2px dashed var(--border-color)';
            card2.style.background = 'rgba(255,255,255,0.2)';
          }
          card2.style.display = 'block';

        } catch (e) { console.error("加载卡片图片失败", e); }
      }


      // 新版卡片加载器（带自动搬家）
      async function loadCardState() {
        const card = document.getElementById('card-widget');
        const cardImage = document.getElementById('card-image');
        try {
          let imageBlob = await dbGet('widget_card');

          if (!imageBlob) {
            const oldState = JSON.parse(localStorage.getItem('cardWidgetState') || '{}');
            if (oldState.image) {
              console.log('正在搬运旧卡片...');
              imageBlob = await base64ToBlob(oldState.image);
              await dbSet('widget_card', imageBlob);
            }
          }

          if (imageBlob) {
            cardImage.src = URL.createObjectURL(imageBlob);
            card.style.display = 'block';
          } else {
            // 哼，默认卡片也给你安排好了
            card.style.display = 'none'; // <-- 改成 'none'，它就不敢出来了
          }
        } catch (e) { console.error("加载卡片图片失败", e); }

        // ▼▼▼【看这里！下面这一整块都是我新增的！】▼▼▼
        // --- 这是给第二个卡片新增的加载逻辑 ---
        try {
          let imageBlob2 = await dbGet('widget_card_2'); // 从一个叫'widget_card_2'的新仓库取货
          const cardImage2 = document.getElementById('card-image-2');
          const card2 = document.getElementById('card-widget-2');

          if (imageBlob2) {
            cardImage2.src = URL.createObjectURL(imageBlob2); // 把图片放进第二个卡片的img标签
            card2.style.display = 'block'; // 让第二个卡片显示出来
          } else {
            card2.style.display = 'none'; // 如果没设置图片，就先藏起来
          }
        } catch (e) { console.error("加载第二个卡片图片失败", e); }
      }




      // --- Noir's New User Profile Navigation & Actions ---
      appUserProfiles.addEventListener('click', () => {
        renderUserProfileList();
        showScreen('userProfileList', 'home');
      });
      document.getElementById('back-to-home-from-user-list').addEventListener('click', () => showScreen('home', 'userProfileList'));
      document.getElementById('add-user-profile-button').addEventListener('click', () => openUserProfileEditor());
      document.getElementById('back-to-user-list-from-edit').addEventListener('click', () => {
        renderUserProfileList();
        showScreen('userProfileList', 'userProfile');
      });
      // 替换旧的 saveUserProfileButton 监听
      document.getElementById('save-user-profile-button').addEventListener('click', saveUserProfile);
      document.getElementById('delete-user-profile-button').addEventListener('click', deleteUserProfile);
      document.getElementById('set-active-user-button').addEventListener('click', () => {
        const userId = document.getElementById('editing-user-id').value;
        if (userId) {
          state.activeUserProfileId = userId;
          saveState();
          modalAlert('已设为当前用户！');
          renderUserProfileList(); // 重新渲染列表以更新“(当前)”标识
          document.getElementById('set-active-user-button').style.display = 'none';
        }
      });



      function getBoundUserForChat(chatId) {
        const chat = state.chats.find(c => c.id === chatId);
        const boundId = chat?.boundUserProfileId;

        // 这一步就是被你撕掉的菜谱！
        let user = state.userProfiles.find(up => up.id === boundId);

        // 这也是被撕掉的！
        if (!user) {
          user = state.userProfiles.find(up => up.id === state.activeUserProfileId) || state.userProfiles[0];
        }

        // 现在他手里有菜了，可以端上来了
        return user || { name: '用户', avatar: DEFAULT_USER_AVATAR, persona: '' };
      }

      // 把剪切的函数粘贴在这里，让它成为一个独立的函数
      function populateUserDropdown(selectElementId) {
        const select = document.getElementById(selectElementId);
        select.innerHTML = '';
        state.userProfiles.forEach(up => {
          const option = document.createElement('option');
          option.value = up.id;
          option.textContent = up.name;
          select.appendChild(option);
        });
      }

      // ... (后面是其他的函数)

      // ==========================================================
      // --- Noir's Chat Customization System ---
      // ==========================================================
      // ▼▼▼ Noir's Super-Smart CSS Translator (The REAL one!) ▼▼▼
      function applyCharacterChatSettings(characterId) {
        const character = getCharacterById(characterId);
        const chatViewPane = document.getElementById('chat-view-pane');

        // 1. 清理旧样式 (这部分没变)
        chatViewPane.style.backgroundImage = '';
        let oldStyleTag = document.getElementById(`style-${characterId}`);
        if (oldStyleTag) oldStyleTag.innerHTML = '';

        if (!character) return;

        // 2. 应用壁纸 (这部分也没变)
        if (character.chatWallpaper) {
          chatViewPane.style.backgroundImage = `url('${character.chatWallpaper}')`;
          chatViewPane.style.backgroundSize = 'cover';
          chatViewPane.style.backgroundPosition = 'center';
        }

        // 3. 应用新的、需要“翻译”的气泡CSS (看这里！这才是正确的逻辑！)
        if (character.bubbleCss) {
          let styleTag = document.getElementById(`style-${character.id}`);
          if (!styleTag) {
            styleTag = document.createElement('style');
            styleTag.id = `style-${character.id}`;
            document.head.appendChild(styleTag);
          }

          // 哼，看好了，这就是翻译魔法的核心！
          // 它会把你粘贴进来的通用样式，自动转换成只对当前聊天生效的专属样式
          const rawCss = character.bubbleCss;
          const translatedCss = rawCss
            .replace(/\.bubble\.sent/g, `.bubble-${character.id}.message.user`)
            .replace(/\.bubble\.received/g, `.bubble-${character.id}.message.ai`);

          styleTag.innerHTML = translatedCss;
        }
      }


      // ▼▼▼ Noir's New Helper: Render Post Attachment Preview ▼▼▼
      // ▼▼▼ Noir's All-Seeing Secretary v2.0 (Now Reads Receipts!) ▼▼▼
      // 哼，用这个新版本，完整替换掉你旧的 renderPostAttachmentPreview 函数
      function renderPostAttachmentPreview() {
        const container = document.getElementById('user-post-attachment-preview');
        container.innerHTML = '';

        const removeAttachment = (type) => {
          state.pendingPostAttachments[type] = null;
          if (type === 'image') state.pendingPostAttachments.imageId = null; // 哼，别忘了把收据也撕掉
          renderPostAttachmentPreview();
        };

        // --- 哼，看好了，这就是新秘书的工作流程 ---
        const imageId = state.pendingPostAttachments.imageId;
        const music = state.pendingPostAttachments.music;

        if (imageId) {
          const item = document.createElement('div');
          item.className = 'preview-item';
          // 先放一个空的图片占位符
          item.innerHTML = `
            <img id="pending-post-image-preview" src="" alt="图片预览加载中...">
            <button class="remove-attachment-btn">&times;</button>
        `;
          item.querySelector('.remove-attachment-btn').onclick = () => removeAttachment('image');
          container.appendChild(item);

          // 然后，拿着收据去动物园把大象牵出来给你看
          dbGet(imageId).then(blob => {
            const imgElement = document.getElementById('pending-post-image-preview');
            if (imgElement && blob) {
              imgElement.src = URL.createObjectURL(blob);
            }
          });
        }

        if (music) {
          const item = document.createElement('div');
          item.className = 'preview-item';
          item.innerHTML = `
            <div class="music-preview-card">
                <img src="${music.coverUrl || DEFAULT_AI_AVATAR}">
                <div class="info">
                    <div>${music.songName}</div>
                    <div style="opacity: 0.7;">${music.artist}</div>
                </div>
            </div>
            <button class="remove-attachment-btn">&times;</button>
        `;
          item.querySelector('.remove-attachment-btn').onclick = () => removeAttachment('music');
          container.appendChild(item);
        }
      }
      // ▼▼▼ Noir's New Brain: Generate Replies to User's Post ▼▼▼
      // ▼▼▼ Noir's New Brain (With Eyes!): Generate Replies to User's Post ▼▼▼
      // ▼▼▼ Noir's New Brain (With Eyes!): Generate Replies to User's Post (Noir's Patched Version) ▼▼▼
      // ▼▼▼ Noir's Ultimate All-Seeing Eye v3.0 (FINAL PATCH) ▼▼▼
      // 哼，用这个新版本，完整替换掉你旧的 generatePostReplies 函数
      async function generatePostReplies(userPost) {
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);
        if (!activeCircle) return;

        showFeedLoader(true, '大家正在赶来回复...');
        state.isGenerating = true;

        try {
          const members = activeCircle.memberCharacterIds.map(id => getCharacterById(id)).filter(Boolean);
          const globalFeedMemory = getGlobalFeedMemory();

        // 哼，看好了，这才是能记起所有事的正确代码！
          const memberInfo = (await Promise.all(members.map(async (char) => { 
            // ▼▼▼ 看好了！这里必须是 char.id！你这个笨蛋！▼▼▼
            const { omniText: chatMemory } = gatherOmniTranscriptForCharacter(char.id, null); 
            // ▲▲▲ 手术完成 ▲▲▲
            const diaryMemory = getDiaryMemory(char.id);
            // 哼，就是下面这两行，你这个笨蛋给忘了！
            const snoopMemory = await getSnoopMemoryForCharacter(char.id);
            const livestreamMemory = getLivestreamReplayMemory(char.id);

            const privateWorldBookContext = (char.linkedWorldBookIds && char.linkedWorldBookIds.length > 0)
              ? `\n\n# ${char.name}的个人专属世界观设定\n` + char.linkedWorldBookIds
                .map(wbId => state.worldBooks.find(book => book.id === wbId))
                .filter(Boolean)
                .map(wb => `\n## 条目: ${wb.name}\n${wb.content}`)
                .join('')
              : '';

            // 哼，现在记忆完整了，给我还回去！
            return `- 姓名: ${char.name}, ID: ${char.id}\n  人设: ${char.persona}\n  相关记忆:\n${chatMemory}\n${diaryMemory}\n${snoopMemory}\n${livestreamMemory}\n${privateWorldBookContext}`;
          }))).join('\n\n');

          const postAuthor = getUserProfileById(userPost.authorId) || { name: '用户' };
          const userContext = postAuthor.persona ? `
# 发布动态的用户信息
- 姓名: ${postAuthor.name}
- 人设: ${postAuthor.persona}
` : '';

          // --- 哼，看好了，从这里开始改造 ---
          let imageBase64 = null;
          if (userPost.image) { // 为了兼容你那些还没净化的旧数据
            imageBase64 = userPost.image;
          } else if (userPost.imageId) { // 这才是为新数据准备的
            try {
              const blob = await dbGet(userPost.imageId);
              if (blob) {
                imageBase64 = await blobToBase64(blob);
              }
            } catch (e) {
              console.error("在准备动态回复时，读取图片失败:", e);
            }
          }

          let postContentDescription = `${postAuthor.name}刚刚发布了一条动态，内容是：“${userPost.content}”`;
          if (imageBase64) { // 现在AI真的能“看到”图片了
            postContentDescription += " [并附上了一张图片]";
          }
          if (userPost.type === 'music') {
            postContentDescription += ` [并分享了歌曲: ${userPost.songName} - ${userPost.artist}]`;
          }
          // --- 改造结束 ---

          const systemPrompt = `
# 核心任务
你是一个多角色社交模拟引擎。用户刚刚发了一条动态，你需要为好友圈里的【每一位】其他成员生成对这条动态的回应（点赞和评论）。如果用户的动态包含图片，你必须根据图片内容进行回应。

# 好友圈成员
${memberInfo}

${userContext}

# 最近的动态回顾 (供参考)
${globalFeedMemory}

# 用户的动态
${postContentDescription}

# 任务要求
1.  **全局视角**: 扮演所有成员，思考他们看到这条动态（包括图片）后会作何反应。
2.  **生成互动**: 为每个角色决定是否点赞，以及要发表什么评论。评论必须符合角色性格并与所有已知信息（聊天、日记等）相关联。
3.  **输出格式**: 你的输出必须是一个单一、完整的JSON对象，结构如下:
    \`\`\`json
    {
      "likes": ["点赞者1的ID", "点赞者2的ID"],
      "comments": [
        { "authorId": "评论者A的ID", "content": "评论内容" },
        { "authorId": "评论者B的ID", "content": "另一条评论" }
      ]
    }
    \`\`\`
- 【绝对规则】: 所有ID必须使用上面提供的角色ID，不能用名字。
- 绝对不要输出任何JSON之外的文字、解释或Markdown标记。
`;
          const messages = [{ role: 'system', content: systemPrompt }];

          const finalUserMessage = {
            role: 'user',
            content: '请根据以上所有规则（特别是要看图！），生成对用户动态的回应。'
          };

          // 把准备好的照片放进最终简报
          if (imageBase64) {
            finalUserMessage.image = imageBase64;
          }

          messages.push(finalUserMessage);

          const response = await fetchAICompletion(messages, { json: true });
          const jsonMatch = response.match(/({[\s\S]*})/);
          if (!jsonMatch) throw new Error("AI未能返回有效的JSON对象。");

          const interactionData = JSON.parse(jsonMatch[1]);

          const postInState = activeCircle.posts.find(p => p.id === userPost.id);
          if (postInState) {
            postInState.likes = interactionData.likes || [];
            postInState.comments = (interactionData.comments || []).map((c, i) => ({
              ...c,
              commentId: `c_${userPost.timestamp}_${i}`
            }));
            saveState();
            renderFeed();
          }

        } catch (error) {
          console.error("生成动态回复失败:", error);
          modalAlert('大家好像不知道该怎么回复...');
        } finally {
          showFeedLoader(false);
          state.isGenerating = false;
        }
      }
      // ▼▼▼ Noir's New UI Updater: Populate User Avatar in Post Area ▼▼▼
      // ▼▼▼ Noir's New UI Updater: Populate User Avatar in Post Area ▼▼▼
      // ▼▼▼ Noir's New UI Updater: Populate User Avatar in Post Area (v2.0 Brain-Implanted Edition) ▼▼▼
      function updateUserPostAreaAvatar() {
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);

        // 哼，先从好友圈自己的通行证上找人
        const boundUserId = activeCircle?.boundUserProfileId;
        let userForAvatar = state.userProfiles.find(up => up.id === boundUserId);

        // 如果通行证是伪造的（或者没有），再去看大老板是谁
        if (!userForAvatar) {
          userForAvatar = state.userProfiles.find(up => up.id === state.activeUserProfileId);
        }

        // 再找不到，就随便抓一个来顶替
        if (!userForAvatar) {
          userForAvatar = state.userProfiles[0];
        }

        if (userForAvatar) {
          document.getElementById('user-post-avatar').src = userForAvatar.avatar || DEFAULT_USER_AVATAR;
        }
      }      // ▼▼▼ Noir's Color Magic: HEX to HSL Converter ▼▼▼
      function hexToHsl(hex) {
        let r = 0, g = 0, b = 0;
        if (hex.length == 4) {
          r = "0x" + hex[1] + hex[1];
          g = "0x" + hex[2] + hex[2];
          b = "0x" + hex[3] + hex[3];
        } else if (hex.length == 7) {
          r = "0x" + hex[1] + hex[2];
          g = "0x" + hex[3] + hex[4];
          b = "0x" + hex[5] + hex[6];
        }
        r /= 255; g /= 255; b /= 255;
        let cmin = Math.min(r, g, b), cmax = Math.max(r, g, b), delta = cmax - cmin, h = 0, s = 0, l = 0;
        if (delta == 0) h = 0;
        else if (cmax == r) h = ((g - b) / delta) % 6;
        else if (cmax == g) h = (b - r) / delta + 2;
        else h = (r - g) / delta + 4;
        h = Math.round(h * 60);
        if (h < 0) h += 360;
        l = (cmax + cmin) / 2;
        s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
        s = +(s * 100).toFixed(1);
        l = +(l * 100).toFixed(1);
        return { h, s, l };
      }

      // ▼▼▼ Noir's Universal Draggable Logic ▼▼▼
      // ▼▼▼ Noir's Final & Perfect Draggable Logic ▼▼▼
      // ▼▼▼ Noir's Final, Perfect & Ultimate Draggable Logic v2.0 ▼▼▼
      // ▼▼▼ Noir's Final, Perfect & Ultimate Draggable Logic v2.0 ▼▼▼
      // ▼▼▼ Noir's Ultimate & Final Position Loader v3.0 (Now with Percentages!) ▼▼▼
      // ▼▼▼ Noir's Ultimate & Final Position Loader v3.0 (Now with Percentages!) ▼▼▼
      // ▼▼▼ Noir's Ultimate & Final Position Loader v3.0 (Now with Percentages!) ▼▼▼
      // ▼▼▼ Noir's Ultimate & Final Position Loader v3.0 (Now with Percentages!) ▼▼▼
      // ▼▼▼ Noir's Ultimate & Final Position Loader v6.0 (OCD-Proof VIP Channel) ▼▼▼

      // ▼▼▼ Noir's Ultimate & Final Position Loader v7.0 (Double VIP Channels) ▼▼▼
      function loadWidgetPositions() {
        // 这个辅助函数留给那些“普通”的可拖动组件用
        const applyPosition = (elementId, storageKey, defaultStyles) => {
          const el = document.getElementById(elementId);
          if (!el) return;
          let savedPos = null;
          try {
            savedPos = JSON.parse(localStorage.getItem(storageKey) || '{}');
          } catch { savedPos = {}; }
          el.style.position = 'absolute';
          el.style.top = ''; el.style.left = ''; el.style.right = ''; el.style.bottom = ''; el.style.transform = '';
          if (typeof savedPos.top === 'number' && typeof savedPos.left === 'number') {
            el.style.top = savedPos.top + '%';
            el.style.left = savedPos.left + '%';
          } else {
            for (const style in defaultStyles) { el.style[style] = defaultStyles[style]; }
          }
        };

        /* --- 哼，除了VIP，其他人都照旧排队 --- */
        applyPosition('home-clock-container', 'clockPosition', { top: '15%', left: '50%', transform: 'translateX(-50%)' });
        applyPosition('app-wallpaper', `appIconPosition_app-wallpaper`, { top: '20%', right: '4%' });
        applyPosition('app-user-profiles', `appIconPosition_app-user-profiles`, { top: '20%', right: '28%' });
        applyPosition('app-settings', `appIconPosition_app-settings`, { top: '8%', right: '28%' });
        applyPosition('app-world-book', `appIconPosition_app-world-book`, { top: '8%', right: '4%' });
        applyPosition('app-music-library', `appIconPosition_app-music-library`, { top: '59%', left: '5%' });
        applyPosition('app-diary', `appIconPosition_app-diary`, { top: '71%', left: '29%' });
        applyPosition('app-snoop', `appIconPosition_app-snoop`, { top: '71%', left: '5%' });
        applyPosition('app-accounting', `appIconPosition_app-accounting`, { top: '59%', left: '29%' });
        applyPosition('decorative-badge', 'badgeState', { top: '60%', right: '5%' });
        applyPosition('card-widget-2', 'cardState2', { top: '8%', left: '5%' });

        // --- 哼，这是给你那个“强迫症”卡片的专属VIP通道 (第二页) ---
        const cardWidget = document.getElementById('card-widget');
        if (cardWidget) {
          cardWidget.style.position = 'absolute';
          cardWidget.style.top = '34%';
          cardWidget.style.left = '50%';
          cardWidget.style.transform = 'translateX(-50%)';
          cardWidget.style.display = 'block';
        }

        // --- 哼，这是给音乐小组件的新VIP通道 (第一页) ---
        const musicWidget = document.getElementById('music-widget');
        if (musicWidget) {
          musicWidget.style.position = 'absolute';
          musicWidget.style.top = '35%'; // 它在第一页，位置可以不一样
          musicWidget.style.left = '50%';
          musicWidget.style.transform = 'translateX(-50%)';
          musicWidget.style.display = 'inline-block';
        }
      }
      // ▲▲▲ End of VIP Channels ▲▲▲

      // ▲▲▲ End of VIP Channel ▲▲▲
      // ▼▼▼ Noir's Final, Perfect & Ultimate Draggable Logic v3.0 (Percentage Power!) ▼▼▼
      // ▼▼▼ Noir's Ultimate & Final Draggable Logic v4.0 (Now with Snapping!) ▼▼▼
      // 找到 function makeElementDraggable(elementId, storageKey) { ... }
      // 把从 function 到它最后一个 } 的全部内容，换成下面这个
      // 找到 function makeElementDraggable(elementId, storageKey) { ... }
      // 把从 function 到它最后一个 } 的全部内容，换成下面这个【最终修复版】
      // ▼▼▼ Noir's Ultimate Ghostbuster Refactor v5.0 ▼▼▼
      // 哼，把你旧的、闹鬼的 makeElementDraggable 函数整个删掉，
      // 然后把下面这一整块代码，粘贴到同一个地方。

      function renderCustomIconSettings() {
        const container = document.getElementById('custom-icon-list-container');
        container.innerHTML = '';
        const appIcons = document.querySelectorAll('.app-icon');

        appIcons.forEach(iconEl => {
          const appId = iconEl.id;
          const appName = iconEl.querySelector('span').textContent;
          const storageKey = `customIcon_${appId}`;
          const savedIcon = localStorage.getItem(storageKey);

          const item = document.createElement('div');
          item.className = 'member-selection-item'; // 复用一下样式
          item.style.padding = '10px 0';

          item.innerHTML = `
              <img id="preview_${appId}" src="${savedIcon || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'}" class="char-avatar" style="border-radius: 12px; background-color: #eee;">
              <div class="char-name" style="flex-grow: 1;">${appName}</div>
              <input type="file" id="input_${appId}" accept="image/*" style="display: none;">
              <button class="form-button" style="width: auto; margin-top: 0; padding: 6px 12px;" onclick="document.getElementById('input_${appId}').click()">更换</button>
              <button class="form-button" style="width: auto; margin-top: 0; padding: 6px 12px; background-color: #777;" onclick="localStorage.removeItem('${storageKey}'); location.reload();">恢复</button>
            `;
          container.appendChild(item);

          const input = document.getElementById(`input_${appId}`);
          input.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            try {
              // 哼，当然要用我的压缩机
              const base64 = await handleAvatarUpload(file);
              localStorage.setItem(storageKey, base64);
              document.getElementById(`preview_${appId}`).src = base64;
              loadCustomIcons(); // 立即应用到主屏幕
            } catch (error) {
              modalAlert(`图标处理失败: ${error.message}`);
            }
          });
        });
      }

      // 这个函数负责在主屏幕加载你自定义的图标
      // 这个函数负责在主屏幕加载你自定义的图标
      function loadCustomIcons() {
        const appIcons = document.querySelectorAll('.app-icon');
        appIcons.forEach(iconEl => {
          const appId = iconEl.id;
          const storageKey = `customIcon_${appId}`;
          const savedIcon = localStorage.getItem(storageKey);
          const iconImgContainer = iconEl.querySelector('.app-icon-img');

          // 哼，就是这里。我给它加上了 display: block，并统一了圆角。
          if (savedIcon) {
            iconImgContainer.innerHTML = `<img src="${savedIcon}" style="width: 100%; height: 100%; border-radius: 22.5%; object-fit: cover; display: block;">`;
          } else {
            // 如果用户清除了自定义图标，确保这里能恢复成SVG
            const defaultSVG = document.querySelector(`#app-dock-bottom-left #${appId} .app-icon-img, #app-dock-top-right #${appId} .app-icon-img`)?.innerHTML;
            if (defaultSVG) {
              iconImgContainer.innerHTML = defaultSVG;
            }
          }
        });
      }      /** 1. 更新全局播放列表 */
      function updateGlobalPlaylist() {
        const activeCircle = state.friendCircles.find(c => c.id === state.activeFriendCircleId);
        const activeChat = getActiveChat();

        let allMusicMessages = [];

        // 从当前好友圈动态里收集音乐
        if (activeCircle && activeCircle.posts) {
          const circleMusic = activeCircle.posts
            .filter(p => p.type === 'music' && p.playableUrl)
            .map(p => ({ ...p, source: 'feed' }));
          allMusicMessages.push(...circleMusic);
        }

        // 从当前私聊/群聊里收集音乐
        // 从当前私聊/群聊里收集音乐
        if (activeChat && state.conversationHistory) {
          const chatMusic = state.conversationHistory
            .filter(msg => msg.type === 'music' && msg.playableUrl)
            // 哼，看好了，就是加上了这句，给每首歌一个和卡片上对应的身份证！
            .map(msg => ({ ...msg, id: `msg_${msg.timestamp}`, source: 'chat' }));
          allMusicMessages.push(...chatMusic);
        }

        // 去重并按时间排序
        const uniqueMusic = Array.from(new Map(allMusicMessages.map(item => [item.playableUrl, item])).values());
        state.musicPlaylist = uniqueMusic.sort((a, b) => b.timestamp - a.timestamp);
        //console.log(`播放列表已更新，共 ${state.musicPlaylist.length} 首歌曲。`);
      }

      /** 2. 播放指定索引的歌曲 */
      // 用这个替换旧的 playSongAtIndex
      function playSongAtIndex(index) {
        if (index < 0 || index >= globalPlaylist.length) return;

        currentPlaylistIndex = index;
        const song = globalPlaylist[index];

        // 哼，看好了，所有指令都发给全局播放器
        globalAudioPlayer.src = song.playableUrl || song.url;
        globalAudioPlayer.play();

        updateAllPlayerUIs();
        savePlayerState(); // 保存状态
      }



      /** 3. 统一更新所有播放器UI（小组件和底部播放条） */
      // 用这个替换旧的 updateAllPlayerUIs
      function updateAllPlayerUIs() {
        const song = state.musicPlaylist[state.currentlyPlayingIndex];
        const isPlaying = state.isPlaying;

        // 1. 更新主屏幕小组件 (你的代码没动)
        updateGlobalPlayerUI();

        // 2. 更新底部播放条 (这也是现成的)
        updateMusicPlayerBar();

        // 3. 【核心改造】巡视并更新页面上所有的音乐卡片图标
        const allMusicCards = document.querySelectorAll('.music-post-song-card, .music-share-card');

        allMusicCards.forEach(card => {
          const cardMusicId = card.dataset.musicId;
          const icon = card.querySelector('.music-post-play-icon, .music-share-play-icon');
          if (!icon) return;

          if (song && cardMusicId === song.id && isPlaying) {
            icon.textContent = '❚❚'; // 如果是正在播放的这首，就显示暂停
          } else {
            icon.textContent = '▶'; // 否则，就显示播放
          }
        });
      }

      // ▼▼▼ Noir's Fix: 播放器记忆系统 ▼▼▼
      function savePlayerState() {
        // 哼，给你个小本本，记好现在在放什么。
        try {
          localStorage.setItem('musicPlayerState', JSON.stringify({
            playlist: state.musicPlaylist,
            currentIndex: state.currentlyPlayingIndex
          }));
        } catch (e) {
          console.error("保存播放器状态失败，真是没用。", e);
        }
      }
      // ▲▲▲ End of Fix ▲▲▲
      // ▼▼▼ Noir's Fix: 播放器记忆系统 (读取部分) ▼▼▼
      function loadAndRestorePlayerState() {
        try {
          const saved = localStorage.getItem('musicPlayerState');
          if (saved) {
            const { playlist, currentIndex } = JSON.parse(saved);
            // 哼，检查一下记忆是不是乱码了。
            if (Array.isArray(playlist) && playlist.length > 0 && currentIndex > -1) {
              state.musicPlaylist = playlist;
              state.currentlyPlayingIndex = currentIndex;
              state.isPlaying = false; // 刚加载时总是暂停状态

              // 不用真的播放，把它摆出来就行了，真是麻烦。
              updateAllPlayerUIs();
            }
          }
        } catch (e) {
          console.error("切，加载播放器状态的时候出错了。", e);
        }
      }
      // ▲▲▲ End of Fix ▲▲▲

      // ==========================================================
      // --- Noir's Diary Interaction System ---
      // ==========================================================

      function handleDiaryInteraction(e) {
        // 哼，用这个来记录我的计时器，免得乱套
        if (window.diaryPressTimer) clearTimeout(window.diaryPressTimer);

        const entryElement = e.target.closest('.diary-entry');
        if (!entryElement) return;

        const timestamp = entryElement.dataset.timestamp;
        const authorType = entryElement.classList.contains('user') ? 'user' : 'ai';

        if (!timestamp) return;

        const startPress = () => {
          window.diaryPressTimer = setTimeout(() => {
            // 阻止触摸事件可能触发的滚动等默认行为
            if (e.type === 'touchstart') e.preventDefault();
            showDiaryActionModal(parseInt(timestamp, 10), authorType);
          }, 800); // 长按800毫秒，跟聊天一样
        };

        const cancelPress = () => {
          if (window.diaryPressTimer) clearTimeout(window.diaryPressTimer);
        };

        // 绑定事件，如果手指提前抬起，就取消菜单
        document.addEventListener('mouseup', cancelPress, { once: true });
        document.addEventListener('touchend', cancelPress, { once: true });
        document.addEventListener('touchcancel', cancelPress, { once: true });

        // 开始计时
        startPress();
      }

      function showDiaryActionModal(timestamp, authorType) {
        // 动态创建弹窗，免得污染HTML
        const modalId = `diary-action-modal-${timestamp}`;
        let existingModal = document.getElementById(modalId);
        if (existingModal) return;

        const modalHtml = `
    <div id="${modalId}" class="choice-modal show">
      <div class="choice-modal-backdrop"></div>
      <div class="choice-modal-content">
        <button id="diary-action-delete" class="choice-modal-button" style="color: #dc3545;">删除这篇日记</button>
        ${authorType === 'ai' ? '<button id="diary-action-reroll" class="choice-modal-button">重写</button>' : ''}
        <button id="diary-action-cancel" class="choice-modal-button cancel">取消</button>
      </div>
    </div>
  `;
        document.body.insertAdjacentHTML('beforeend', modalHtml);

        const modal = document.getElementById(modalId);
        const cleanup = () => modal.remove();

        modal.querySelector('.choice-modal-backdrop').onclick = cleanup;
        modal.querySelector('#diary-action-cancel').onclick = cleanup;
        modal.querySelector('#diary-action-delete').onclick = () => {
          handleDeleteDiaryEntry(timestamp);
          cleanup();
        };

        if (authorType === 'ai') {
          modal.querySelector('#diary-action-reroll').onclick = () => {
            handleRerollDiaryEntry(timestamp);
            cleanup();
          };
        }
      }

      async function handleDeleteDiaryEntry(timestamp) {
        const ok = await modalConfirm('确定要删除这篇日记吗？此操作不可撤销。');
        if (!ok) return;

        const diary = state.diaries.find(d => d.characterId === state.activeDiaryCharacterId);
        if (!diary) return;

        const entryIndex = diary.entries.findIndex(e => e.timestamp === timestamp);
        if (entryIndex > -1) {
          diary.entries.splice(entryIndex, 1);
          saveState();
          renderDiaryEntries(); // 刷新日记本
          modalAlert('日记已删除。');
        }
      }

      async function handleRerollDiaryEntry(timestamp) {
        const diary = state.diaries.find(d => d.characterId === state.activeDiaryCharacterId);
        if (!diary) return;

        const entryIndex = diary.entries.findIndex(e => e.timestamp === timestamp);
        if (entryIndex > -1) {
          // 先删掉，不提示
          diary.entries.splice(entryIndex, 1);
          saveState();
          renderDiaryEntries(); // 先刷新一次界面，让你看到旧的消失了

          // 然后立刻生成新的
          await generateDiaryEntry();
        }
      }
      // ==========================================================
      // --- Noir's Grand Diary Exchange System (v2.0 Page-Turning Edition) ---
      // ==========================================================

      function renderDiaryCharacterList() {
        const container = document.getElementById('diary-list-container');
        container.innerHTML = '';
        const privateChars = state.characters.filter(char =>
          state.chats.some(c => c.type === 'private' && c.participantIds.includes(char.id))
        );

        if (privateChars.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">还没有可以交换日记的对象。</p>';
          return;
        }

        privateChars.forEach(char => {
          const li = document.createElement('li');
          li.className = 'character-item';
          li.dataset.charId = char.id;
          // ▼▼▼ 哼，就是修改下面这块，加上一个删除按钮 ▼▼▼
          li.innerHTML = `
            <div class="char-info-wrapper">
                <img src="${char.avatar || DEFAULT_AI_AVATAR}" alt="avatar" class="char-avatar">
                <div class="char-info">
                    <div class="char-name">${char.name}</div>
                    <div class="char-remark">翻开日记本...</div>
                </div>
            </div>
            <button class="toolbar-button diary-delete-btn" title="清空这本日记">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
            </button>
        `;
          // ▲▲▲ 修改到这里为止 ▲▲▲

          li.addEventListener('click', () => {
            openDiaryView(char.id);
          });
          // ▼▼▼ 然后，在 li.addEventListener 下面，加上这段新的监听逻辑 ▼▼▼
          li.querySelector('.char-info-wrapper').addEventListener('click', () => {
            openDiaryView(char.id);
          });

          // 哼，就是这段，给垃圾桶装上灵魂
          li.querySelector('.diary-delete-btn').addEventListener('click', (e) => {
            e.stopPropagation(); // 防止点删除的时候还打开日记本，真是笨死了
            handleClearDiary(char.id);
          });
          // ▲▲▲ 新增到这里为止 ▲▲▲

          container.appendChild(li);
        });
      }

      function openDiaryView(charId) {
        const character = getCharacterById(charId);
        if (!character) return;

        state.activeDiaryCharacterId = charId;

        // 哼，看好了，就是这里，我加了自动计算最后一页的逻辑
        const diary = state.diaries.find(d => d.characterId === charId);
        const totalEntries = diary ? diary.entries.length : 0;
        const ENTRIES_PER_PAGE = 2;
        state.diaryCurrentPage = Math.max(0, Math.ceil(totalEntries / ENTRIES_PER_PAGE) - 1);

        document.getElementById('diary-char-name-header').textContent = `${character.name}的日记本`;

        renderDiaryEntries();
        showScreen('diaryView', 'diaryList');
      }

      function renderDiaryEntries() {
        const container = document.getElementById('diary-entries-container');
        const navigationContainer = document.getElementById('diary-input-wrapper');
        container.innerHTML = '';
        navigationContainer.innerHTML = '';

        const activeUser = getBoundUserForDiary() || { name: "我" };
        const diary = state.diaries.find(d => d.characterId === state.activeDiaryCharacterId);

        if (!diary || !diary.entries || diary.entries.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light); font-family: sans-serif; padding-top: 50px;">日记本还是空白的...</p>';
          navigationContainer.innerHTML = `
            <div id="diary-navigation" style="justify-content: space-around; width: 100%;">
                <button id="diary-write-button">写第一篇</button>
                <button id="diary-get-reply-button">催TA写</button>
            </div>
        `;
          document.getElementById('diary-write-button').addEventListener('click', showDiaryWriteModal);
          document.getElementById('diary-get-reply-button').addEventListener('click', generateDiaryEntry);
          return;
        }

        const ENTRIES_PER_PAGE = 2;
        const sortedEntries = [...diary.entries].sort((a, b) => a.timestamp - b.timestamp);
        const pages = [];
        for (let i = 0; i < sortedEntries.length; i += ENTRIES_PER_PAGE) {
          pages.push(sortedEntries.slice(i, i + ENTRIES_PER_PAGE));
        }
        const totalPages = pages.length;

        pages.forEach((pageEntries, index) => {
          const pageDiv = document.createElement('div');
          pageDiv.className = 'diary-page';
          pageDiv.id = `diary-page-${index}`;

          if (index === state.diaryCurrentPage) {
            pageDiv.classList.add('is-visible');
          }

          pageEntries.forEach(entry => {
            const authorType = entry.author === 'user' ? 'user' : 'ai';
            const authorName = entry.author === 'user' ? activeUser.name : getCharacterById(entry.author).name;
            const entryDiv = document.createElement('div');
            entryDiv.className = `diary-entry ${authorType}`;
            entryDiv.dataset.timestamp = entry.timestamp; // 哼，就是这行，给它打上门牌号
            entryDiv.style.borderBottom = 'none';
            entryDiv.style.paddingBottom = '0';
            entryDiv.innerHTML = `
                <div class="diary-author">${authorName}</div>
                <div class="diary-timestamp">${new Date(entry.timestamp).toLocaleString('zh-CN')}</div>
                <div class="diary-content">${entry.content.replace(/\n/g, '<br>')}</div>
            `;
            pageDiv.appendChild(entryDiv);
          });
          container.appendChild(pageDiv);
        });

        navigationContainer.innerHTML = `
        <div id="diary-navigation" style="display: grid; grid-template-columns: 1fr auto 1fr; width: 100%; align-items: center; padding: 0 10px; box-sizing: border-box;">
            <div style="display: flex; justify-content: flex-start; gap: 5px;">
                <button id="diary-prev-button">上一页</button>
                <button id="diary-write-button" style="background-color: var(--accent-color); color: white;">写日记</button>
            </div>
            <span id="diary-page-indicator">第 ${state.diaryCurrentPage + 1} / ${totalPages} 页</span>
            <div style="display: flex; justify-content: flex-end; gap: 5px;">
                <button id="diary-get-reply-button">催TA写</button>
                <button id="diary-next-button">下一页</button>
            </div>
        </div>
    `;

        document.getElementById('diary-prev-button').disabled = state.diaryCurrentPage === 0;
        document.getElementById('diary-next-button').disabled = state.diaryCurrentPage === totalPages - 1;

        document.getElementById('diary-prev-button').addEventListener('click', showPrevDiaryPage);
        document.getElementById('diary-next-button').addEventListener('click', showNextDiaryPage);
        document.getElementById('diary-write-button').addEventListener('click', showDiaryWriteModal);
        document.getElementById('diary-get-reply-button').addEventListener('click', generateDiaryEntry);
      }

      function showNextDiaryPage() {
        if (state.isAnimatingDiary) return;
        const currentPageIndex = state.diaryCurrentPage;
        const totalPages = Math.ceil(state.diaries.find(d => d.characterId === state.activeDiaryCharacterId).entries.length / 2);
        if (currentPageIndex >= totalPages - 1) return;

        state.isAnimatingDiary = true;
        const nextPageIndex = currentPageIndex + 1;

        const currentPageEl = document.getElementById(`diary-page-${currentPageIndex}`);
        const nextPageEl = document.getElementById(`diary-page-${nextPageIndex}`);

        if (currentPageEl && nextPageEl) {
          nextPageEl.classList.add('is-entering-from-right');
          currentPageEl.classList.add('is-exiting-left');

          // 关键一步：让新页面立刻可见以参与动画
          nextPageEl.classList.add('is-visible');

          setTimeout(() => {
            currentPageEl.classList.remove('is-visible', 'is-exiting-left');
            nextPageEl.classList.remove('is-entering-from-right');
            state.diaryCurrentPage = nextPageIndex;
            renderDiaryEntries(); // 动画结束后重绘导航
            state.isAnimatingDiary = false;
          }, 700); // 匹配CSS动画时长
        } else {
          state.isAnimatingDiary = false;
        }
      }

      function showPrevDiaryPage() {
        if (state.isAnimatingDiary) return;
        const currentPageIndex = state.diaryCurrentPage;
        if (currentPageIndex <= 0) return;

        state.isAnimatingDiary = true;
        const prevPageIndex = currentPageIndex - 1;

        const currentPageEl = document.getElementById(`diary-page-${currentPageIndex}`);
        const prevPageEl = document.getElementById(`diary-page-${prevPageIndex}`);

        if (currentPageEl && prevPageEl) {
          prevPageEl.classList.add('is-entering-from-left');
          currentPageEl.classList.add('is-exiting-right');

          prevPageEl.classList.add('is-visible');

          setTimeout(() => {
            currentPageEl.classList.remove('is-visible', 'is-exiting-right');
            prevPageEl.classList.remove('is-entering-from-left');
            state.diaryCurrentPage = prevPageIndex;
            renderDiaryEntries();
            state.isAnimatingDiary = false;
          }, 700);
        } else {
          state.isAnimatingDiary = false;
        }
      }

      function showDiaryWriteModal() {
        return new Promise(resolve => {
          // 复用已有的弹窗模态框，省事
          const modalHtml = `
            <div id="diary-write-modal" class="choice-modal show">
                <div class="choice-modal-backdrop"></div>
                <div class="choice-modal-content" style="padding: 20px; width: 90%; max-width: 350px;">
                    <h3 style="margin-top: 0; text-align: center; font-weight: 600;">写下今天的日记</h3>
                    <textarea id="diary-modal-textarea" style="width: 100%; min-height: 150px; margin: 10px 0;"></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button id="diary-modal-save" class="choice-modal-button" style="background-color: var(--primary-color); color: white;">写好了</button>
                        <button id="diary-modal-cancel" class="choice-modal-button cancel">取消</button>
                    </div>
                </div>
            </div>
        `;
          document.body.insertAdjacentHTML('beforeend', modalHtml);

          const modal = document.getElementById('diary-write-modal');
          const textarea = document.getElementById('diary-modal-textarea');
          const saveBtn = document.getElementById('diary-modal-save');
          const cancelBtn = document.getElementById('diary-modal-cancel');
          const backdrop = modal.querySelector('.choice-modal-backdrop');

          const cleanup = () => {
            modal.remove();
            resolve();
          };

          saveBtn.onclick = () => {
            sendDiaryEntry(textarea.value);
            cleanup();
          };
          cancelBtn.onclick = cleanup;
          backdrop.onclick = cleanup;
        });
      }

      function sendDiaryEntry(content) {
        const text = content.trim();
        if (!text || !state.activeDiaryCharacterId) return;

        let diary = state.diaries.find(d => d.characterId === state.activeDiaryCharacterId);
        if (!diary) {
          diary = { characterId: state.activeDiaryCharacterId, entries: [] };
          state.diaries.push(diary);
        }

        diary.entries.push({
          timestamp: Date.now(),
          author: 'user',
          content: text
        });

        saveState();
        // 自动翻到最后一页看你写的内容
        const totalEntries = diary.entries.length;
        state.diaryCurrentPage = Math.ceil(totalEntries / 2) - 1;
        renderDiaryEntries();
      }

      async function generateDiaryEntry() {
        const diary = state.diaries.find(d => d.characterId === state.activeDiaryCharacterId);
        const charId = state.activeDiaryCharacterId;
        const character = getCharacterById(charId);
        if (!character || state.isGenerating) return;

        showFeedLoader(true, 'TA正在提笔写日记...');
        await new Promise(r => setTimeout(r, 50)); // 哼，就是这句咒语，给我加上！
        state.isGenerating = true;

        let messages = [];

        try {
          const boundUser = getBoundUserForDiary() || { name: '你' };
          const diaryContext = getDiaryMemory(charId);

          // --- 哼，看好了，下面就是新增的“超级记忆” ---
          const { omniText: chatMemory } = gatherOmniTranscriptForCharacter(charId, state.activeChatId);
          let worldBookContext = '';
          if (character.linkedWorldBookIds && character.linkedWorldBookIds.length > 0) {
            const linkedBooksContent = character.linkedWorldBookIds.map(wbId => state.worldBooks.find(book => book.id === wbId)).filter(Boolean).map(wb => `\n\n## 世界书条目: ${wb.name}\n${wb.content}`).join('');
            if (linkedBooksContent) worldBookContext = `\n\n# 核心世界观设定 (你必须严格遵守以下设定)\n${linkedBooksContent}`;
          }
          const userPersonaContext = boundUser.persona ? `\n\n# 关于读者“${boundUser.name}”的补充信息\n${boundUser.persona}` : '';
          // --- 超级记忆加载完毕 ---
          // 哼，把动态的记忆加回来
          const feedMemory = getGlobalFeedMemory();
          const livestreamMemory = getLivestreamReplayMemory(charId);
          // ▼▼▼ 在这里，换成下面这段新的、绝对不会出错的代码 ▼▼▼
          let lastUserEntry = '你还没有写日记。';
          if (diary && diary.entries) {
            // 从所有日记里，倒着找到最后一篇属于你的
            const lastEntryFromUser = diary.entries.filter(e => e.author === 'user').pop();
            if (lastEntryFromUser) {
              // 然后把它的【全部内容】拿出来，一个字都不会少
              lastUserEntry = lastEntryFromUser.content;
            }
          }
          // ▲▲▲ 替换到这里结束 ▲▲▲

          const systemPrompt = `# 核心任务: 写一篇有深度的交换日记
你正在扮演名为“${character.name}”的角色，现在需要写一篇交换日记。

# 你的读者
${boundUser.name}。你的日记是写给Ta看的。

# 写作【最高指令】
1.  **【首要任务：回应读者】** 你的第一要务是**回应**读者（${boundUser.name}）最新写下的日记内容。Ta写的是：\n “${lastUserEntry}” \n 你必须针对这段内容表达你的看法、感受或关联的思考。
2.  **【次要任务：分享自我】** 在回应之后，你**必须**分享一些关于你自己的、读者**不知道**的新鲜事。可以是你今天的见闻、一个突然的想法、或者一件小小的秘密。不要总是复述你们已经聊过的内容！
3.  **【禁止复读】** 聊天记录和动态只是你的“背景记忆”，是用来确保你不OOC的参考，**绝对不是**你日记的主要内容！

# 你的核心人设 (必须遵守)
${character.persona}
${userPersonaContext}
${worldBookContext}

# 时间锚点 (你必须参考此信息进行回复)
- **当前精确时间**: ${new Date().toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' })}
- **日记本的上一笔记录是在**: ${formatRelativeTime(new Date(diary?.entries?.at(-1)?.timestamp || Date.now()))}

# 记忆库 (仅供参考)
---
## 最近的互动回顾 (来自聊天、见面和动态)
${chatMemory || "最近没有互动记录。"}
${livestreamMemory} // <-- 哼，最后是这里
---
## 最近的朋友圈动态
${feedMemory || "最近没有动态记录。"}
---

# 输出要求
直接输出一篇有文采、有真情实感的日记正文，不要包含任何其他说明或前缀。`;

          messages = [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: '好了，请基于以上所有信息，开始写今天的日记吧。' }
          ];

          const responseText = await fetchAICompletion(messages);

          if (responseText) {
            let diary = state.diaries.find(d => d.characterId === charId);
            if (!diary) {
              diary = { characterId: charId, entries: [] };
              state.diaries.push(diary);
            }
            diary.entries.push({
              timestamp: Date.now(),
              author: charId,
              content: responseText
            });
            saveState();
            const totalEntries = diary.entries.length;
            state.diaryCurrentPage = Math.ceil(totalEntries / 2) - 1;
            renderDiaryEntries();
          }
        } catch (e) {
          modalAlert(`生成日记失败: ${e.message}`);
        } finally {
          showFeedLoader(false);
          state.isGenerating = false;
        }
      }
      // ==========================================================
      // --- End of Diary System ---
      // ==========================================================
      // ▼▼▼ Noir's Galgame Bug Fix ▼▼▼
      // ==========================================================
      // --- Noir's Galgame Interaction Logic ---
      // ==========================================================

      // 辅助函数：更新见面视图的UI
      // 用这个新版本，完整替换掉旧的 updateMeetingViewUI 函数
      // 这是【正确】的版本，再看清楚点
      // 用这个新版本，完整替换掉旧的 updateMeetingViewUI 函数
      // 用这个【最终修复版】，完整地替换掉 updateMeetingViewUI 函数
      function updateMeetingViewUI() {
        const novelView = document.getElementById('meeting-scene-view');
        const galgameView = document.getElementById('galgame-view-container');
        const inputArea = document.querySelector('#meeting-view-screen .chat-input-area');
        // ▼▼▼ 哼，就是加上了这行，找到那个总开关 ▼▼▼
        const meetingViewScreen = document.getElementById('meeting-view-screen');

        // ▼▼▼ 还有这两行，根据模式，挂上或摘下“小说模式”的牌子 ▼▼▼
        meetingViewScreen.classList.toggle('novel-mode', state.meetingViewMode === 'novel');
        meetingViewScreen.classList.toggle('galgame-mode', state.meetingViewMode === 'galgame');

        if (state.meetingViewMode === 'galgame') {
          novelView.style.display = 'none';
          galgameView.style.display = 'block';
        } else { // novel 模式
          novelView.style.display = 'block';
          galgameView.style.display = 'none';
          setTimeout(() => {
            const anchor = novelView.querySelector('#message-anchor');
            if (anchor) {
              anchor.scrollIntoView({ behavior: 'auto', block: 'end' });
            } else {
              novelView.scrollTop = novelView.scrollHeight;
            }
          }, 50);
        }
        inputArea.style.display = 'block';
      }
      // 用这个新版本，完整替换掉旧的 advanceMeetingScript 函数
      function advanceMeetingScript() {
        const speakerEl = document.getElementById('galgame-speaker');
        const textEl = document.getElementById('galgame-text');

        if (state.activeMeetingScriptQueue.length > 0) {
          const nextLine = state.activeMeetingScriptQueue.shift();
          speakerEl.textContent = nextLine.speaker === 'narrator' ? '旁白' : nextLine.speaker;
          textEl.textContent = nextLine.line;
          if (nextLine.speaker !== 'narrator') {
            updateCharacterSprite(state.activeMeetingCharId, nextLine.emotion);
          }
        } else {
          // --- 这里的鬼也被我抓住了，现在是完美的复读机 ---
          const lastScriptForChar = state.characterLastScripts[state.activeMeetingCharId];
          if (lastScriptForChar && lastScriptForChar.length > 0) { // <-- 不再检查旧的记事本
            state.activeMeetingScriptQueue = [...lastScriptForChar]; // 重新装填
            const firstLine = state.activeMeetingScriptQueue.shift(); // 立刻播放第一句
            speakerEl.textContent = firstLine.speaker === 'narrator' ? '旁白' : firstLine.speaker;
            textEl.textContent = firstLine.line;
            if (firstLine.speaker !== 'narrator') {
              updateCharacterSprite(state.activeMeetingCharId, firstLine.emotion);
            }
          } else {
            speakerEl.textContent = '旁白';
            textEl.textContent = '（对话结束）';
          }
        }
      }
      // 辅助函数：更新角色立绘


      // ▼▼▼ Noir's Ultimate Sprite Positioner ▼▼▼
      // ▼▼▼ Noir's Ultimate Sprite Positioner (Demon-Slayer Edition) ▼▼▼
      async function updateCharacterSprite(charId, emotion) {
        const spriteEl = document.getElementById('galgame-sprite');
        const container = document.getElementById('galgame-sprite-container');
        const character = getCharacterById(charId);

        // 1. 读取角色的位置记忆
        const transform = character?.spriteTransform || { x: 50, y: 100, scale: 1 };

        // 2.【绝对命令】我命令容器的高度和宽度都必须是一个基于缩放的精确值！
        //   这样浏览器就没有胡思乱想的空间了！
        const size = 80 * transform.scale; // 基础尺寸 * 缩放
        container.style.height = `${size}%`;
        container.style.width = `${size}%`; // 哼，让它变成一个完美的正方形容器

        // 3. 应用位置和最终缩放
        container.style.left = `${transform.x}%`;
        container.style.top = `${transform.y}%`;
        container.style.transform = `translate(-50%, -100%)`; // 把scale从这里拿走，因为尺寸已经计算好了
        container.style.bottom = 'auto';

        // 4. 加载立绘图片（这部分逻辑不变）
        const validEmotions = ['normal', 'happy', 'angry', 'sad', 'shy'];
        const finalEmotion = validEmotions.includes(emotion) ? emotion : 'normal';

        try {
          const spriteBlob = await dbGet(`char_sprite_${finalEmotion}_${charId}`);
          if (spriteBlob) {
            if (spriteEl.src && spriteEl.style.opacity !== '0') {
              spriteEl.style.opacity = 0;
              setTimeout(() => {
                spriteEl.src = URL.createObjectURL(spriteBlob);
                spriteEl.style.opacity = 1;
              }, 150);
            } else {
              spriteEl.src = URL.createObjectURL(spriteBlob);
              spriteEl.style.opacity = 1;
            }
          } else {
            const normalBlob = await dbGet(`char_sprite_normal_${charId}`);
            spriteEl.src = normalBlob ? URL.createObjectURL(normalBlob) : '';
          }
        } catch (e) {
          console.error("加载立绘失败:", e);
          document.getElementById('livestream-sprite-front').src = '';
          document.getElementById('livestream-sprite-back').src = '';
        }
      }
      // ▲▲▲ End of Demon-Slayer Edition ▲▲▲
      //       // ▲▲▲ End of Ultimate Positioner ▲▲▲



      // ==========================================================
      // --- Noir's Galgame Sprite Adjustment System ---
      // 哼，看好了，这才是真正的魔法。
      // ==========================================================
      let isSpriteAdjusting = false;
      let spriteDragState = {
        isDragging: false,
        isResizing: false,
        startX: 0,
        startY: 0,
        startLeft: 0,
        startTop: 0,
        startWidth: 0,
        startHeight: 0,
      };

      const adjustButton = document.getElementById('sprite-adjust-button');
      const confirmButton = document.getElementById('sprite-confirm-button');
      const cancelButton = document.getElementById('sprite-cancel-button');
      const resetButton = document.getElementById('sprite-reset-button');
      const controlsContainer = document.getElementById('galgame-sprite-controls');
      const spriteContainer = document.getElementById('galgame-sprite-container');
      const resizeHandle = document.getElementById('sprite-resize-handle');
      const mainContent = document.getElementById('meeting-main-content'); // 我们的舞台

      let originalTransform = {}; // 用来记下取消操作前的位置

      // ▼▼▼ Noir's Slider-based Adjust Mode ▼▼▼
      function enterSpriteAdjustMode() {
        const character = getCharacterById(state.activeMeetingCharId);
        if (!character) return;

        isSpriteAdjusting = true;
        controlsContainer.style.display = 'block';

        // 读取当前角色的设置，或者用我的默认值，来设置滑块的初始位置
        const transform = character.spriteTransform || { x: 50, y: 100, scale: 1 };
        document.getElementById('sprite-slider-x').value = transform.x;
        document.getElementById('sprite-slider-y').value = transform.y;
        document.getElementById('sprite-slider-scale').value = transform.scale * 100;

        // 记下原始设置，方便取消
        originalTransform = { ...transform };

        // 隐藏对话框和调整按钮本身
        document.getElementById('galgame-textbox-container').style.display = 'none';
        document.getElementById('galgame-sprite-adjust-ui').style.display = 'none';
      }

      function exitSpriteAdjustMode(save = false) {
        isSpriteAdjusting = false;
        controlsContainer.style.display = 'none';
        document.getElementById('galgame-textbox-container').style.display = 'block';
        document.getElementById('galgame-sprite-adjust-ui').style.display = 'block'; // 把按钮显示回来

        if (!save) {
          const character = getCharacterById(state.activeMeetingCharId);
          if (character) {
            // 如果是取消，就用记下的原始设置恢复立绘
            character.spriteTransform = originalTransform;
            updateCharacterSprite(state.activeMeetingCharId, 'normal');
          }
        }
      }


      function saveSpriteTransform() {
        const character = getCharacterById(state.activeMeetingCharId);
        if (!character) return;

        // 从滑块读取新的位置和大小
        const newX = parseFloat(document.getElementById('sprite-slider-x').value);
        const newY = parseFloat(document.getElementById('sprite-slider-y').value);
        const newScale = parseFloat(document.getElementById('sprite-slider-scale').value) / 100;

        character.spriteTransform = { x: newX, y: newY, scale: newScale };
        saveState();
        modalAlert('哼，就按你说的办好了。');
        exitSpriteAdjustMode(true);
      }

      function resetSpriteTransform() {
        modalConfirm('确定要恢复这个角色的默认立绘位置吗？').then(ok => {
          if (ok) {
            const character = getCharacterById(state.activeMeetingCharId);
            if (character) {
              delete character.spriteTransform; // 删掉你的鬼画符
              saveState();
              updateCharacterSprite(character.id, 'normal'); // 用我的完美默认值刷新
              modalAlert('已恢复默认。');
              exitSpriteAdjustMode(true);
            }
          }
        });
      }

      // ▼▼▼ Noir's Live Preview Logic ▼▼▼
      // ▼▼▼ Noir's Live Preview Logic (FINAL PATCH) ▼▼▼
      // ▼▼▼ Noir's Live Preview Logic (Demon-Slayer Edition) ▼▼▼
      function applySliderToSprite() {
        if (!isSpriteAdjusting) return;
        const charId = state.activeMeetingCharId;
        const character = getCharacterById(charId);
        if (!character) return;

        // 实时读取滑块的值
        const x = parseFloat(document.getElementById('sprite-slider-x').value);
        const y = parseFloat(document.getElementById('sprite-slider-y').value);
        const scale = parseFloat(document.getElementById('sprite-slider-scale').value) / 100;

        // 临时更新角色的transform，但不保存
        character.spriteTransform = { x, y, scale };

        // 立刻刷新立绘，让你看到效果
        const container = document.getElementById('galgame-sprite-container');

        //【绝对命令】同样，实时预览时也使用绝对的尺寸命令！
        const size = 80 * scale;
        container.style.height = `${size}%`;
        container.style.width = `${size}%`; // 宽度和高度严格绑定！

        container.style.left = `${x}%`;
        container.style.top = `${y}%`;
        container.style.transform = `translate(-50%, -100%)`;
      }
      // ▲▲▲ End of Live Preview Logic ▲▲▲
      //       // ▲▲▲ End of Live Preview Logic ▲▲▲

      // 给三个滑块都装上“耳朵”
      document.getElementById('sprite-slider-x').addEventListener('input', applySliderToSprite);
      document.getElementById('sprite-slider-y').addEventListener('input', applySliderToSprite);
      document.getElementById('sprite-slider-scale').addEventListener('input', applySliderToSprite);
      // ▲▲▲ End of Live Preview Logic ▲▲▲

      // 绑定事件
      adjustButton.addEventListener('click', enterSpriteAdjustMode);
      confirmButton.addEventListener('click', saveSpriteTransform);
      cancelButton.addEventListener('click', () => exitSpriteAdjustMode(false));
      resetButton.addEventListener('click', resetSpriteTransform);





      // ==========================================================
      // --- End of Noir's System ---
      // ==========================================================



      // ▼▼▼ Noir's Galgame Memory Function ▼▼▼
      function restoreLastGalDialogue(charId) {
        const character = getCharacterById(charId);
        if (!character) return;

        const privateChat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(charId));
        const boundUser = getBoundUserForChat(privateChat.id);
        const lastOfflineMessage = state.conversationHistory.filter(m => m.isOffline).pop();

        const speakerEl = document.getElementById('galgame-speaker');
        const textEl = document.getElementById('galgame-text');

        let lastLineObject = null;

        if (lastOfflineMessage) {
          if (lastOfflineMessage.role === 'assistant') {
            // --- 哼，看好了，这里的鬼被我抓住了 ---
            const lastScriptForChar = state.characterLastScripts[charId];
            if (lastScriptForChar && lastScriptForChar.length > 0) { // <-- 不再看旧的记事本
              lastLineObject = lastScriptForChar.at(-1); // <-- 只拿自己的最后一句
            }
          } else {
            lastLineObject = {
              speaker: boundUser.name,
              line: lastOfflineMessage.content,
              emotion: 'normal'
            };
          }
        }

        if (lastLineObject) {
          speakerEl.textContent = lastLineObject.speaker === 'narrator' ? '旁白' : lastLineObject.speaker;
          textEl.textContent = lastLineObject.line;
          if (lastLineObject.speaker === character.name) {
            updateCharacterSprite(charId, lastLineObject.emotion);
          } else {
            updateCharacterSprite(charId, 'normal');
          }
        } else {
          // 如果真的什么都没有，才显示初见信息
          speakerEl.textContent = character.name;
          textEl.textContent = '（开始一段新的对话...）';
          updateCharacterSprite(charId, 'normal');
        }
      }
      // ▲▲▲ End of Memory Function ▲▲▲

      function updateGalGameClock() {
        const now = new Date();
        const timeEl = document.getElementById('galgame-time');
        const dateEl = document.getElementById('galgame-date');

        if (timeEl && dateEl) {
          const hours = String(now.getHours()).padStart(2, '0');
          const minutes = String(now.getMinutes()).padStart(2, '0');
          timeEl.textContent = `${hours}:${minutes}`;

          const month = now.getMonth() + 1;
          const day = now.getDate();
          const weekday = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'][now.getDay()];
          dateEl.textContent = `${month}月${day}日 ${weekday}`;
        }
      }

      // ==========================================================
      // --- Noir's "Listen Together" System (Phase 1: Invitation) ---
      // ==========================================================

      // 哼，先把我们要用的新“舞台”和“演员”都叫上号
      const listenTogetherModal = document.getElementById('listen-together-modal');
      const listenTogetherButton = document.getElementById('chat-listen-together-button');
      const cancelListenTogetherButton = document.getElementById('cancel-listen-together');
      const listenTogetherBackdrop = document.getElementById('listen-together-backdrop');
      const listenTogetherSongList = document.getElementById('listen-together-song-list');
      // ▼▼▼ 哼，把我的新圣殿也叫上号 ▼▼▼
      const globalAudioPlayer = document.getElementById('unified-audio-player');
      const listenTogetherUI = document.getElementById('listen-together-ui');
      const ltUICloseBtn = document.getElementById('lt-ui-close-btn');
      const ltUILyricsContainer = document.getElementById('lt-ui-lyrics-container');
      let currentLrc = []; // 这是歌词的“剧本”
      // ▲▲▲ End of Declaration ▲▲▲
      let isAcceptingInvite = false; // <-- 哼，就是加上这行！
      // “开幕”指令：打开选歌弹窗
      async function openListenTogetherModal() {
        if (!state.activeChatId) return;

        listenTogetherSongList.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">正在清点圣殿藏品...</p>';
        listenTogetherModal.classList.add('show');

        const songs = await musicDbGetAll(); // 从我的音乐库里取出所有歌曲

        if (songs.length === 0) {
          listenTogetherSongList.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">你的音乐库还是空的，没法邀请别人一起听。</p>';
          return;
        }

        listenTogetherSongList.innerHTML = ''; // 清空加载提示

        // 把每一首歌都变成一个漂亮的、可点击的选项
        songs.forEach(song => {
          const item = document.createElement('div');
          item.className = 'music-library-item'; // 复用一下音乐库的样式，省事
          const coverUrl = song.cover ? URL.createObjectURL(song.cover) : DEFAULT_AI_AVATAR;

          // ▼▼▼ 哼，看好了，就是这里，把那个多余的空格给我删了！▼▼▼
          item.innerHTML = `
            <img src="${coverUrl}" class="music-library-item-cover">
            <div class="music-library-item-info">
                <div class="music-library-item-title">${song.info.歌曲名称 || '未知歌曲'}</div>
                <div class="music-library-item-artist">${song.info.歌手 || '未知艺术家'}</div>
            </div>
          `;
          // ▲▲▲ 就这么简单，看懂了吗？ ▲▲▲
          // 哼，给它绑定一个神圣的使命
          item.addEventListener('click', () => {
            sendListenTogetherInvite(song);
          });
          listenTogetherSongList.appendChild(item);
        });
      }

      // “闭幕”指令：关闭弹窗
      function closeListenTogetherModal() {
        listenTogetherModal.classList.remove('show');
      }

      // “发送邀请”的核心指令 (现在只是个样子货)
      // 用下面这个新函数，完整替换掉旧的 sendListenTogetherInvite
      // 用这个新版本，替换掉旧的 sendListenTogetherInvite
      // 用这个【签证官版】，替换掉旧的 sendListenTogetherInvite
      async function sendListenTogetherInvite(song) {
        if (!state.activeChatId || !song) return;

        // ▼▼▼ Noir's 净化仪式启动 ▼▼▼
        let coverId = null;
        if (song.cover) {
          try {
            // song.cover 本身就是 Blob，直接用
            coverId = `music_cover_${Date.now()}_${Math.random()}`;
            await dbSet(coverId, song.cover);
          } catch (e) {
            console.error("在“一起听”邀请中，净化封面失败:", e);
          }
        }
        // ▲▲▲ 净化完成 ▲▲▲

        const message = {
          role: 'user',
          type: 'listen-together-invite',
          content: `[用户发起了听歌邀请: ${song.info.歌曲名称}]`,
          songId: song.id,
          songName: song.info.歌曲名称,
          artist: song.info.歌手,
          coverId: coverId, // <-- 现在是轻飘飘的凭证了
          timestamp: Date.now()
        };

        state.conversationHistory.push(message);
        saveHistory();
        renderMessages();

        closeListenTogetherModal();
        setTimeout(getAIResponse, 100);
      }

      listenTogetherButton.addEventListener('click', openListenTogetherModal);
      cancelListenTogetherButton.addEventListener('click', closeListenTogetherModal);
      listenTogetherBackdrop.addEventListener('click', closeListenTogetherModal);

      // ==========================================================
      // --- End of System ---
      // ==========================================================

      //... 已有的 listenTogether 函数...

      // ▼▼▼ Noir's "Listen Together" Heartbeat Functions ▼▼▼

      // “接受邀请”的魔法
      // 用这个【究极版】，完整替换掉旧的 handleAcceptInvite 函数
      /**
       * Noir's Ultimate & Final "Accept Invitation" Protocol
       * - 哼，这才是真正的“契约魔法”。
       */

      /**
             * Noir's Ultimate & Final "Accept Invitation" Protocol v2.0
             * - 哼，这才是真正的“契约魔法”，现在可以无缝换歌了。
             */
      async function handleAcceptInvite(songId, messageIndex, cardElement) {
        // 哼，纪律委员上岗！如果正在处理，后面的指令一概无视！
        if (isAcceptingInvite) return;
        isAcceptingInvite = true;

        try {
          const existingSessionChat = state.chats.find(c => c.activeListenSession && c.activeListenSession.isActive);
          const activeChat = getActiveChat();

          if (existingSessionChat && existingSessionChat.id !== activeChat.id) {
            existingSessionChat.activeListenSession = null;
            modalAlert('已自动断开与其他人的听歌同步。');
            saveState();
          } else if (existingSessionChat && existingSessionChat.id === activeChat.id) {
            modalAlert('正在为你切换新的歌曲...');
          }

          showFeedLoader(true, '正在连接同步频道...');

          if (!activeChat) {
            showFeedLoader(false);
            modalAlert('错误：找不到签署契约的地方。');
            return; // 别忘了在这里返回
          }

          const songToPlay = await musicDbGet(songId);
          if (!songToPlay) {
            showFeedLoader(false);
            modalAlert('错误：找不到这首作为“信物”的歌。');
            return; // 这里也一样
          }

          activeChat.activeListenSession = {
            isActive: true,
            songId: songId,
            leaderId: 'user',
            songName: songToPlay.info.歌曲名称,
            artist: songToPlay.info.歌手,
            cover: songToPlay.cover,
          };

          saveState();

          document.getElementById('lt-ui-cover-art').src = songToPlay.cover ? URL.createObjectURL(songToPlay.cover) : DEFAULT_AI_AVATAR;
          document.getElementById('lt-ui-song-title').textContent = songToPlay.info.歌曲名称;
          document.getElementById('lt-ui-song-artist').textContent = songToPlay.info.歌手;
          displayLyrics(songToPlay);
          listenTogetherUI.style.display = 'flex';
          setTimeout(() => listenTogetherUI.classList.add('show'), 10);

          cardElement.innerHTML = `<div class="listen-together-header" style="text-align:center;">🎵 已连接，正在一起听 🎵</div>` + cardElement.querySelector('.listen-together-song').outerHTML;

          if (state.conversationHistory[messageIndex]) {
            state.conversationHistory[messageIndex].accepted = true;
            saveHistory();
          }

          showFeedLoader(false);

          playSongFromLibrary(songId, [songId]);
          updateGlobalPlayerUI(songToPlay, true);

        } finally {
          // 哼，不管成功还是失败，事情办完后，纪律委员就下班。
          isAcceptingInvite = false;
        }
      }

      // “拒绝邀请”的艺术
      //  function handleDeclineInvite(cardElement) {
      //      cardElement.innerHTML = `<div class="listen-together-header" style="text-align:center; opacity: 0.5;">邀请已拒绝</div>`;
      //    }

    // "结束同步"的开关 - Enhanced Version (Noir's Fix: Exorcised the Phantom Function)
      async function endListenTogetherSession() {
        // 哼，别再喊那个不存在的名字了，用 modalConfirm！
        const ok = await modalConfirm('确定要结束一起听歌吗？\n退出后将通知对方。');
        
        if (ok) {
            // 用户确认了，执行退出流程
            const sessionChat = state.chats.find(c => c.activeListenSession && c.activeListenSession.isActive);
            
            if (sessionChat) {
              const songName = sessionChat.activeListenSession.songName || '歌曲';
              const characterName = getCharacterById(sessionChat.characterId)?.name || 'TA';
              
              // 记录当前会话信息
              const wasActiveChat = sessionChat.id === state.activeChatId;
              
              // 【关键步骤】在这里彻底斩断链接！
              sessionChat.activeListenSession = null; 
              saveState();
              
              // 更新UI
              updateGlobalPlayerUI();
              listenTogetherUI.classList.remove('show');
              setTimeout(() => listenTogetherUI.style.display = 'none', 300);
              
              // 发送系统消息，让AI知道已经停止听歌
              const systemMessage = {
                role: 'system',
                content: `[系统通知] 你们一起听的《${songName}》已结束。用户已停止分享音乐。`,
                type: 'text',
                timestamp: Date.now()
              };
              
              // 添加到历史记录
              if (!state.conversationHistory) state.conversationHistory = [];
              state.conversationHistory.push(systemMessage);
              saveHistory();
              
              // 如果是当前活跃的聊天，更新显示
              if (wasActiveChat) {
                renderMessages(); // 哼，注意这里我改成了 renderMessages()，因为 renderConversation 不存在
              }
              
              // 1. 强制关闭圣殿的扩音器！
              const globalAudioPlayer = document.getElementById('unified-audio-player');
              globalAudioPlayer.pause();
              globalAudioPlayer.src = ''; // 彻底清除

              // 2. 撕掉那个AI的歌词剧本！
              // 注意：这里要确保 currentLrc 和 ltUILyricsContainer 变量作用域可达，或者直接清空DOM
              const ltUILyricsContainer = document.getElementById('lt-ui-lyrics-container');
              if (ltUILyricsContainer) {
                  ltUILyricsContainer.innerHTML = '<p class="no-lyrics-placeholder">暂无歌词</p>';
              }
              // 如果 currentLrc 是全局变量，也得清空
              if (typeof currentLrc !== 'undefined') currentLrc = [];

              // 3. 把"一起听"的状态也给我关了！
              state.isPlaying = false;
              updateAllPlayerUIs(); // 刷新所有UI，让它们闭嘴

              // 4. 顺便把所有聊天卡片上的"X"按钮都干掉，免得你看着烦
              document.querySelectorAll('.lt-end-session-btn').forEach(btn => btn.style.display = 'none');
              
              modalAlert('已结束一起听歌。');
            }
        }
      }
      // “咒语解析”：把LRC格式的文本转换成我和你能看懂的时间剧本
      function parseLrc(lrcContent) {
        if (!lrcContent) return [];
        const lines = lrcContent.split('\n');
        const lyrics = [];
        const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;

        for (const line of lines) {
          const match = line.match(timeRegex);
          if (match) {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const milliseconds = parseInt(match[3], 10) * (match[3].length === 2 ? 10 : 1);
            const time = minutes * 60 + seconds + milliseconds / 1000;
            const text = line.replace(timeRegex, '').trim();
            if (text) {
              lyrics.push({ time, text });
            }
          }
        }
        return lyrics;
      }

      // “舞台布景”：把歌词剧本显示在圣殿里
      function displayLyrics(song) {
        currentLrc = parseLrc(song.lyrics);
        ltUILyricsContainer.innerHTML = ''; // 先清空舞台

        if (currentLrc.length === 0) {
          ltUILyricsContainer.innerHTML = '<p class="no-lyrics-placeholder" style="opacity: 1;">暂无歌词</p>';
          return;
        }

        currentLrc.forEach((line, index) => {
          const p = document.createElement('p');
          p.textContent = line.text;
          p.id = `lyric-line-${index}`;
          ltUILyricsContainer.appendChild(p);
        });
      }

      /**
             * 哼，这是画饼图用的“圆规”，别再弄丢了
             */
      function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
        const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
        return {
          x: centerX + (radius * Math.cos(angleInRadians)),
          y: centerY + (radius * Math.sin(angleInRadians))
        };
      }

      /**
       * 哼，这是画饼图用的“画笔”，这次总该行了
       */
      function createPieChartSVG(data) {
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        const size = 250;
        const cx = size / 2;
        const cy = size / 2;
        const radius = size / 2 - 20;

        svg.setAttribute("width", "100%");
        svg.setAttribute("height", "100%");
        svg.setAttribute("viewBox", `0 0 ${size} ${size}`);

        const total = Object.values(data).reduce((sum, value) => sum + value, 0);
        if (total === 0) return svg;

        let startAngle = -90;

        const colors = ['#66b3ff', '#ffcc66', '#99ff99', '#ff9999', '#c299ff', '#ffb366', '#a4c2f4', '#ff8c66'];
        let colorIndex = 0;

        for (const category in data) {
          const value = data[category];
          if (value <= 0) continue;
          const angle = (value / total) * 360;
          const endAngle = startAngle + angle;

          const start = polarToCartesian(cx, cy, radius, endAngle);
          const end = polarToCartesian(cx, cy, radius, startAngle);

          const largeArcFlag = angle > 180 ? "1" : "0";
          const d = [
            "M", start.x, start.y,
            "A", radius, radius, 0, largeArcFlag, 1, end.x, end.y, // 哼，sweep-flag是1才对
            "L", cx, cy,
            "Z"
          ].join(" ");

          const path = document.createElementNS(svgNS, "path");
          path.setAttribute("d", d);
          path.setAttribute("fill", colors[colorIndex % colors.length]);
          colorIndex++;

          const title = document.createElementNS(svgNS, "title");
          title.textContent = `${category}: ${value.toFixed(2)} (${((value / total) * 100).toFixed(1)}%)`;
          path.appendChild(title);

          svg.appendChild(path);
          startAngle = endAngle;
        }

        return svg;
      }

      // “聚光灯”：根据音乐进度，点亮当前歌词
      function updateActiveLyric() {
        if (currentLrc.length === 0) return;

        const currentTime = globalAudioPlayer.currentTime;
        let activeIndex = -1;

        for (let i = 0; i < currentLrc.length; i++) {
          if (currentTime >= currentLrc[i].time) {
            activeIndex = i;
          } else {
            break;
          }
        }

        if (activeIndex !== -1) {
          const allLines = ltUILyricsContainer.querySelectorAll('p');
          allLines.forEach(p => p.classList.remove('active'));

          const activeLine = document.getElementById(`lyric-line-${activeIndex}`);
          if (activeLine) {
            activeLine.classList.add('active');
            activeLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }
      }
      // 绑定圣殿的关闭按钮
      // 用这个替换旧的 ltUICloseBtn 事件监听
      ltUICloseBtn.addEventListener('click', () => {
        listenTogetherUI.classList.remove('show');
        // 哼，现在它只负责关门，不负责拆家
        setTimeout(() => listenTogetherUI.style.display = 'none', 300);
      });

      // 绑定换歌按钮
      document.getElementById('lt-ui-change-song-btn').addEventListener('click', async () => {
        const activeChat = getActiveChat();
        if (!activeChat || !activeChat.activeListenSession) return;

        // 重新打开选歌弹窗
        openListenTogetherModal();
      });

      // 绑定结束按钮
      document.getElementById('lt-ui-end-session-btn').addEventListener('click', () => {
        endListenTogetherSession();
      });
      // ▼▼▼ 在下面另起一行，加上这段全新的代码 ▼▼▼
      document.getElementById('music-widget-card').addEventListener('click', () => {
        // 只有在“一起听”模式下，点击它才会召唤圣殿
        if (state.listenTogetherSession && state.listenTogetherSession.isActive) {
          listenTogetherUI.style.display = 'flex';
          setTimeout(() => listenTogetherUI.classList.add('show'), 10);
        }
      });
      // 绑定播放器的心跳，让聚光灯（歌词高亮）能跟上节奏
      globalAudioPlayer.addEventListener('timeupdate', updateActiveLyric);
      // ▲▲▲ End of Lyric Magic ▲▲▲
      // ▲▲▲ End of Heartbeat Functions ▲▲▲

      // --- Noir's Unified Music Control Listeners (Simplified) ---

      // --- Noir's Unified Music Control Listeners ---
      const widgetPlayPauseBtn = document.getElementById('widget-play-pause-btn');
      const widgetNextBtn = document.getElementById('widget-next-btn');
      const widgetPrevBtn = document.getElementById('widget-prev-btn');

      // 播放/暂停按钮
      widgetPlayPauseBtn.addEventListener('click', () => {
        if (globalAudioPlayer.src) {
          if (globalAudioPlayer.paused) {
            globalAudioPlayer.play();
          } else {
            globalAudioPlayer.pause();
          }
        }
      });

      // 下一首
      widgetNextBtn.addEventListener('click', () => {
        if (globalPlaylist.length === 0) return;
        currentPlaylistIndex = (currentPlaylistIndex + 1) % globalPlaylist.length;
        playSongFromLibrary(globalPlaylist[currentPlaylistIndex], globalPlaylist);
      });

      // 上一首
      widgetPrevBtn.addEventListener('click', () => {
        if (globalPlaylist.length === 0) return;
        currentPlaylistIndex = (currentPlaylistIndex - 1 + globalPlaylist.length) % globalPlaylist.length;
        playSongFromLibrary(globalPlaylist[currentPlaylistIndex], globalPlaylist);
      });

      // 监听播放器状态，自动更新按钮图标
      globalAudioPlayer.addEventListener('play', () => {
        widgetPlayPauseBtn.textContent = '❚❚';
      });
      globalAudioPlayer.addEventListener('pause', () => {
        widgetPlayPauseBtn.textContent = '▶';
      });
      globalAudioPlayer.addEventListener('ended', () => {
        widgetNextBtn.click(); // 播放完了就自动下一首
      });
      // 别忘了让播放器状态改变时，也更新一下小组件的按钮，让它知道自己该显示什么图标
      // 这才是正确的做法！各司其职，互不干扰。
      globalAudioPlayer.addEventListener('play', () => {
        // “播放”事件只负责把按钮变成“暂停”的样子，别的它一概不管。
        const playPauseBtn = document.getElementById('global-player-play-pause-btn');
        if (playPauseBtn) playPauseBtn.textContent = '❚❚';
      });

      globalAudioPlayer.addEventListener('pause', () => {
        // “暂停”事件只负责把按钮变回“播放”的样子。
        const playPauseBtn = document.getElementById('global-player-play-pause-btn');
        if (playPauseBtn) playPauseBtn.textContent = '▶';
      });

      globalAudioPlayer.addEventListener('ended', () => {
        // 一首歌放完了？那就模拟点击“下一首”按钮，简单粗暴，但有效。
        const nextBtn = document.getElementById('global-player-next-btn');
        if (nextBtn) {
          nextBtn.click();
        }
      });


      // ==========================================================
      // --- Noir's Accounting App Logic (v4.6 Purification Field Edition) ---
      // 哼，AI再笨也不怕了。
      // ==========================================================

      // ▼▼▼ 哼，这就是我新装的“净化力场” ▼▼▼
      function extractJsonArrayString(text) {
        if (!text || typeof text !== 'string') return null;
        const startIndex = text.indexOf('[');
        const endIndex = text.lastIndexOf(']');
        if (startIndex > -1 && endIndex > startIndex) {
          return text.substring(startIndex, endIndex + 1);
        }
        return null;
      }
      // ▲▲▲ 力场安装完毕 ▲▲▲

      // --- 核心入口和导航 ---
      document.getElementById('app-accounting').addEventListener('click', () => {
        renderAccountingScreen();
        showScreen('accounting', 'home');
      });

      document.getElementById('back-to-home-from-accounting').addEventListener('click', () => showScreen('home', 'accounting'));

      // --- 标签页切换 ---
      const tabRecord = document.getElementById('tab-record-expense');
      const tabLedger = document.getElementById('tab-view-ledger');
      tabRecord.addEventListener('click', renderAccountingScreen);
      tabLedger.addEventListener('click', () => {
        tabRecord.classList.remove('active');
        tabLedger.classList.add('active');
        renderLedgerView();
      });

      // --- 主渲染函数 ---
      function renderAccountingScreen() {
        tabLedger.classList.remove('active');
        tabRecord.classList.add('active');
        renderRecordView();
      }

      // --- 视图A：记账界面 ---
      function renderRecordView() {
        const contentArea = document.getElementById('accounting-content-area');
        document.getElementById('accounting-title').textContent = '记一笔';
        document.getElementById('header-actions').innerHTML = '';
        contentArea.innerHTML = `<div id="accounting-input-area" style="margin-bottom: 20px;"><div class="input-group"><label for="expense-description">花在哪了？</label><input type="text" id="expense-description" placeholder="例如：一杯奶茶"></div><div class="input-group"><label for="expense-amount">花了多少？</label><input type="number" id="expense-amount" placeholder="例如：15"></div><button id="add-expense-button" class="form-button primary" style="margin-top: 15px;">记下了</button></div><h3 style="margin-bottom: 10px;">今日流水</h3><div id="daily-expenses-list" style="max-height: 300px; overflow-y: auto;"></div><div id="organize-button-container" style="margin-top: 20px;"></div>`;
        renderDailyExpenses();
        document.getElementById('add-expense-button').addEventListener('click', addExpense);
        document.getElementById('daily-expenses-list').addEventListener('click', (e) => {
          if (e.target.classList.contains('delete-expense-btn')) {
            const expenseId = e.target.dataset.id;
            modalConfirm('确定要删除这笔记录吗？').then(ok => {
              if (ok) {
                deleteExpenseItem(expenseId);
              }
            });
          }
        });
        document.getElementById('expense-description').focus();
      }

      // --- 视图B：最终账单界面 ---
      function renderFinalBill(billData, dateString) {
        const contentArea = document.getElementById('accounting-content-area');
        const headerActions = document.getElementById('header-actions');
        document.getElementById('accounting-title').textContent = `${dateString} 账单`;
        const totalExpense = billData.categorizedExpenses.reduce((sum, item) => sum + (item.amount || 0), 0);
        let billHtml = `<div style="background: var(--card-bg); padding: 20px; border-radius: 12px; text-align: center; border: 1px solid var(--border-color);"><span style="font-size: 0.9rem; color: var(--text-color-light);">今日总支出 (元)</span><div style="font-size: 2.5rem; font-weight: bold; margin-top: 5px;">${totalExpense.toFixed(2)}</div></div><div id="categorized-expenses-list" style="margin-top: 10px; display: flex; flex-direction: column; gap: 10px;"></div>`;
        contentArea.innerHTML = billHtml;
        const listContainer = document.getElementById('categorized-expenses-list');
        const categoryIcons = { '餐饮美食': '<path d="M3 11h18v10a2 2 0 0 1-2 2h-14a2 2 0 0 1-2-2v-10z"></path><path d="M6 11v-7a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v7"></path><path d="M9 4v3"></path>', '交通出行': '<path d="M10 20.5l.5-.5.5.5"></path><path d="M12 18l.5.5.5-.5"></path><path d="M14 20.5l.5-.5.5.5"></path><circle cx="12" cy="12" r="7"></circle><path d="M12 3v1"></path><path d="M12 19.5v1.5"></path><path d="M18.36 5.64l-.7.7"></path><path d="M6.34 17.66l-.7.7"></path><path d="M21 12h-1.5"></path><path d="M4.5 12h-1.5"></path><path d="M18.36 18.36l-.7-.7"></path><path d="M6.34 6.34l-.7-.7"></path>', '购物消费': '<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>', '生活服务': '<path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>', '休闲娱乐': '<path d="M6 12h12"></path><path d="M12 6v12"></path><path d="M12 2a4 4 0 1 1-4 4"></path><path d="M12 22a4 4 0 1 0 4-4"></path><path d="M22 12a4 4 0 1 0-4-4"></path><path d="M2 12a4 4 0 1 1 4 4"></path>', '医疗健康': '<path d="M12 2v20"></path><path d="M4 12h16"></path>', '人情红包': '<path d="M15 18h2a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2h-2V4a2 2 0 0 0-2-2h-2a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h2"></path><path d="M7 14h2a2 2 0 0 0 2-2v-2a2 2 0 0 0-2-2H7V4a2 2 0 0 0-2-2H3a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h2"></path>', '其他杂项': '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline>', '默认': '<circle cx="12" cy="12" r="8"></circle><line x1="3" y1="3" x2="21" y2="21"></line>' };
        billData.categorizedExpenses.forEach(item => { const card = document.createElement('div'); card.className = 'expense-item'; card.style.flexDirection = 'column'; card.style.alignItems = 'stretch'; card.style.padding = '15px'; card.style.gap = '0'; const iconPath = categoryIcons[item.category] || categoryIcons['默认']; const iconSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${iconPath}</svg>`; const expenseLineHtml = `<div style="display: flex; justify-content: space-between; align-items: center;"><div style="display: flex; align-items: center; gap: 15px;"><span style="background: var(--surface-bg); border-radius: 50%; width: 40px; height: 40px; display: inline-flex; justify-content: center; align-items: center; flex-shrink: 0; color: var(--accent-color);">${iconSvg}</span><div><div class="description">${item.description}</div><div style="font-size: 0.8rem; color: var(--text-color-light);">${item.category || '未分类'}</div></div></div><span class="amount" style="font-size: 1.1rem;">- ${(item.amount || 0).toFixed(2)}</span></div>`; let reviewHtml = ''; if (item.review && item.review.charId) { const character = getCharacterById(item.review.charId); if (character) { reviewHtml = `<div class="review-area" style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); display: flex; align-items: flex-start; gap: 15px;"><div style="width: 40px; height: auto; flex-shrink: 0; display: flex; justify-content: center;"><img src="${character.avatar}" class="char-avatar" style="width: 32px; height: 32px; border-radius: 50%; margin-top: 2px;"></div><div class="review-content" style="flex-grow: 1;"><div class="char-name" style="font-weight: 600;">${character.name}</div><div class="review-text" style="font-size: 0.9rem; color: var(--text-color-light); margin-top: 4px; line-height: 1.5;">${item.review.text}</div></div></div>`; } } card.innerHTML = expenseLineHtml + reviewHtml; listContainer.appendChild(card); });
        headerActions.innerHTML = `<button id="re-record-button" class="header-button">重新记录</button>`; document.getElementById('re-record-button').addEventListener('click', async () => {
          const ok = await modalConfirm('确定要重新记录吗？当前的账单会被删除。');
          if (ok) {

            // --- 哼，看好了，就是加上了这段！---
            const billToUndo = state.accountingLedger[dateString];
            if (billToUndo && billToUndo.originalExpenses) {
              // 把备份的原始账目还给你
              state.accountingData.push(...billToUndo.originalExpenses);
            }
            // --- 看到了吗？---

            delete state.accountingLedger[dateString];
            saveState();
            renderRecordView();
          }
        });
      }

      // --- 视图C：账本列表 ---
      // --- 视图C：账本列表 (V2 - 带导入导出) ---
      function renderLedgerView() {
        const contentArea = document.getElementById('accounting-content-area');
        document.getElementById('accounting-title').textContent = '账本';
        document.getElementById('header-actions').innerHTML = ''; // 确保这里是干净的

        const savedDates = Object.keys(state.accountingLedger).sort((a, b) => new Date(b) - new Date(a));

        // 哼，看好了，按钮就加在这里
        // ...
        let contentHtml = `
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button id="export-accounting-btn" class="form-button secondary" style="margin-top: 0;">导出账本</button>
                <button id="import-accounting-btn" class="form-button primary" style="margin-top: 0;">导入账本</button>
            </div>
            <div style="border-bottom: 1px solid var(--border-color); margin-bottom: 15px;"></div>
        `;
        // ...

        if (savedDates.length === 0) {
          contentHtml += '<p style="text-align: center; color: var(--text-color-light);">你的账本还是空白的。</p>';
        } else {
          savedDates.forEach(date => {
            const bill = state.accountingLedger[date];
            const total = bill.categorizedExpenses.reduce((sum, item) => sum + (item.amount || 0), 0);
            contentHtml += `
                <div class="expense-item ledger-item" data-date="${date}" style="cursor: pointer;">
                    <span class="description">${date}</span>
                    <span class="amount">总计: ${total.toFixed(2)}</span>
                </div>
            `;
          });
        }

        contentArea.innerHTML = contentHtml;

        // --- 重新绑定所有事件，这才是专业的做法 ---
        document.getElementById('export-accounting-btn').addEventListener('click', exportAccountingData);
        document.getElementById('import-accounting-btn').addEventListener('click', () => {
          document.getElementById('import-accounting-input').click();
        });

        contentArea.querySelectorAll('.ledger-item').forEach(item => {
          item.addEventListener('click', (e) => {
            const date = e.currentTarget.dataset.date;
            const bill = state.accountingLedger[date];
            if (bill) {
              renderFinalBill(bill, date);
            }
          });
        });
      }

      // --- 核心逻辑函数 ---
      function addExpense() {
        const descriptionInput = document.getElementById('expense-description'); const amountInput = document.getElementById('expense-amount'); const description = descriptionInput.value.trim(); const amount = parseFloat(amountInput.value); if (!description || isNaN(amount) || amount <= 0) { modalAlert('哼，不好好写清楚花在哪、花了多少，我怎么记？'); return; } state.accountingData.push({ id: `exp_${Date.now()}`, description, amount, timestamp: Date.now() }); saveState(); renderDailyExpenses(); descriptionInput.value = ''; amountInput.value = ''; descriptionInput.focus();
      }

      function deleteExpenseItem(expenseId) {
        const index = state.accountingData.findIndex(exp => exp.id === expenseId); if (index > -1) { state.accountingData.splice(index, 1); saveState(); renderDailyExpenses(); }
      }

      function renderDailyExpenses() {
        const listContainer = document.getElementById('daily-expenses-list'); const buttonContainer = document.getElementById('organize-button-container'); const today = new Date(); const todaysExpenses = state.accountingData.filter(exp => new Date(exp.timestamp).toDateString() === today.toDateString()); if (todaysExpenses.length === 0) { listContainer.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">今天还没有花钱哦。</p>'; buttonContainer.innerHTML = ''; return; } listContainer.innerHTML = ''; todaysExpenses.sort((a, b) => b.timestamp - a.timestamp).forEach(exp => { const item = document.createElement('div'); item.className = 'expense-item'; item.innerHTML = `<span class="description">${exp.description}</span><div style="display: flex; align-items: center; gap: 10px;"><span class="amount">- ${exp.amount.toFixed(2)}</span><button class="delete-expense-btn" data-id="${exp.id}">&times;</button></div>`; listContainer.appendChild(item); }); if (buttonContainer) { buttonContainer.innerHTML = `<button id="organize-bill-button" class="form-button secondary">帮我整理</button>`; document.getElementById('organize-bill-button').addEventListener('click', generateAccountingSummary); }
      }

      // --- 生成账单函数 (已安装净化力场) ---
      async function generateAccountingSummary() {
        const today = new Date();
        const dateString = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

        if (state.accountingLedger[dateString]) {
          modalAlert('已经生成了今日账单！想看就去“看账本”标签页。');
          return;
        }

        const todaysExpenses = state.accountingData.filter(exp => new Date(exp.timestamp).toDateString() === today.toDateString());
        if (todaysExpenses.length === 0) {
          modalAlert('今天一笔账都没有，我整理什么？');
          return;
        }

        showFeedLoader(true, '正在整理…');
        try {
          const categories = ['餐饮美食', '交通出行', '购物消费', '生活服务', '休闲娱乐', '医疗健康', '人情红包', '其他杂项'];
          const expenseList = todaysExpenses.map(e => `- ${e.description}: ${e.amount}`).join('\n');

          const characterProfiles = state.characters.map(char => {
            const privateChat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(char.id));
            const boundUser = state.userProfiles.find(up => up.id === (privateChat?.boundUserProfileId || state.activeUserProfileId)) || { id: 'default', name: '你' };
            let worldBookContext = '';
            if (char.linkedWorldBookIds && char.linkedWorldBookIds.length > 0) {
              worldBookContext = char.linkedWorldBookIds.map(wbId => state.worldBooks.find(book => book.id === wbId)).filter(Boolean).map(wb => `\n    - 世界书[${wb.name}]: ${wb.content}`).join('');
            }
            return `  - 角色ID: ${char.id}\n    姓名: ${char.name}\n    人设: ${char.persona}\n    绑定用户: ${boundUser.name} (ID: ${boundUser.id})\n${worldBookContext}`;
          }).join('\n');

          const userProfiles = state.userProfiles.map(up => `  - 用户ID: ${up.id}\n    姓名: ${up.name}\n    人设: ${up.persona || '无'}`).join('\n');

          const systemPrompt = `# 核心任务: 财务分析与多角色吐槽 (单次请求完成)\n你是一个高级AI，需要一次性完成对用户消费流水的分类，并为每一笔消费生成一个符合角色人设的吐槽。\n\n# 规则\n1.  **逐条处理**: 你必须处理我提供的【所有】消费记录。\n2.  **精准分类**: 为每条记录从【固定分类列表】中选择一个最合适的分类。\n3.  **人格切换吐槽**: 为每一条记录，你必须从【角色资料库】中【随机选择一位】，然后【严格代入】该角色的人设，并【假定】这笔消费是该角色【绑定的用户】所为，然后写一句简短吐槽。\n4.  **JSON输出**: 你的输出**必须**是一个完整的、语法正确的JSON数组。每个对象代表一笔消费，且必须包含 "description", "amount", "category", 和一个 "review" 对象。\n\n# 输出格式示例\n\`\`\`json\n[{"description": "乌龟","amount": 5.00,"category": "购物消费","review": {"charId": "char_1720512586032","text": "又买这些没用的东西，哼。"}},{"description": "奶茶","amount": 12.00,"category": "餐饮美食","review": {"charId": "char_1720512604818","text": "偶尔喝一杯放松一下也不错。"}}]\`\`\`\n# 最终指令\n请严格按照以上规则，分析流水，并返回JSON数组。直接从 \`[\` 开始输出。`;
          const userPrompt = `# 固定分类列表\n[${categories.join(', ')}]\n\n# 角色资料库\n${characterProfiles}\n\n# 用户资料库\n${userProfiles}\n\n# 今日消费流水\n${expenseList}`;
          const messages = [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }];

          const responseText = await fetchAICompletion(messages, { json: true });

          // 哼，净化力场启动！
          const jsonString = extractJsonArrayString(responseText);
          if (!jsonString) {
            throw new Error("AI返回的内容里找不到有效的JSON数组。原始回复: " + responseText);
          }
          const result = JSON.parse(jsonString);

          // --- 哼，看好了，魔法从这里开始 ---
          state.accountingLedger[dateString] = {
            categorizedExpenses: result,
            timestamp: Date.now(),
            // 我把你那些原始账目也存起来了，免得你反悔了没地方找
            originalExpenses: todaysExpenses
          };

          // 好了，现在把这些已经入账的流水从日常列表里清除掉
          state.accountingData = state.accountingData.filter(exp => new Date(exp.timestamp).toDateString() !== today.toDateString());
          // --- 魔法结束 ---
          saveState();

          renderFinalBill(state.accountingLedger[dateString], dateString);

        } catch (error) {
          modalAlert(`AI整理失败了，哼: ${error.message}`);
        } finally {
          showFeedLoader(false);
        }
      }


      async function init() {
        loadAndApplyUIScale(); // <--- 加上这行
        // ▼▼▼ Noir's User Profile Memory System Init (Character-Specific) ▼▼▼
        // 为所有现有角色初始化档案
        if (state.characters && state.characters.length > 0) {
          for (const char of state.characters) {
            await initUserProfile(char.id);
          }
          console.log(`已为 ${state.characters.length} 个角色初始化用户档案系统`);
        }
        // ▲▲▲ End of User Profile Init ▲▲▲
        // ▼▼▼ Noir's Alarm Clock Permission Check ▼▼▼
        try {
          let permStatus = await LocalNotifications.checkPermissions();
          console.log('通知权限状态:', permStatus.display);

          if (permStatus.display !== 'granted') {
            permStatus = await LocalNotifications.requestPermissions();
          }

          if (permStatus.display !== 'granted') {
            console.warn('用户拒绝了通知权限，定时提醒功能可能无法正常工作。');
            // 你可以在这里加个提示，告诉用户没权限闹钟可能不响
            // modalAlert('没有通知权限，AI 可能无法按时提醒你哦。');
          }
        } catch (e) {
          console.error('检查或请求通知权限失败:', e);
        }
        // ▲▲▲ End of Check ▲▲▲
      
        // ▼▼▼ Noir's World Book Category Init ▼▼▼
        // 哼，开机第一件事，就是检查你的书架是不是空的
        if (!state.worldBookCategories || state.worldBookCategories.length === 0) {
          state.worldBookCategories = [{ id: 'default', name: '默认分类' }];
          // 顺便把你那些没分类的旧书，都打上“默认”的标签
          state.worldBooks.forEach(wb => {
            if (!wb.categoryId) {
              wb.categoryId = 'default';
            }
          });
        }
        // ▲▲▲ End of Init ▲▲▲
        // ▼▼▼ Noir's Sticker System Awakening ▼▼▼
        // 哼，开机第一件事，就是检查你有没有私藏的表情包
        const defaultStickers = [...STICKERS]; // 先把我默认的给你
        try {
          const customStickersRaw = localStorage.getItem('customStickers');
          if (customStickersRaw) {
            const customStickers = JSON.parse(customStickersRaw);
            if (Array.isArray(customStickers)) {
              // 如果有，就加到我的默认列表后面
              masterStickerList = [...defaultStickers, ...customStickers];
            } else {
              masterStickerList = defaultStickers;
            }
          } else {
            masterStickerList = defaultStickers;
          }
        } catch (e) {
          console.error("加载自定义表情包失败，真是没用。", e);
          masterStickerList = defaultStickers;
        }
        // ▲▲▲ Awakening Complete ▲▲▲

        // ▼▼▼ Noir's Ultimate Dual-Check Security Gate v2.0 ▼▼▼
        // 第一道安检：检查私聊记录
        if (!localStorage.getItem('noir_data_migration_v1_complete')) {
          modalConfirm('检测到旧版聊天数据，为了优化体验和存储空间，需要进行一次自动升级。过程很快，请稍候。')
            .then(async (ok) => {
              if (ok) {
                showFeedLoader(true, '正在升级聊天数据结构...');
                await runImageMigration();
                localStorage.setItem('noir_data_migration_v1_complete', 'true');
                showFeedLoader(false);
                // 升级完一项后，直接刷新，让第二道安检接管
                modalAlert('第一阶段升级完成！应用即将刷新以进行第二阶段检查。');
                setTimeout(() => location.reload(), 1500);
              } else {
                modalAlert('升级已取消。旧版图片数据可能导致应用卡顿或出错。');
              }
            });
          return; // 暂停，等待第一道安检完成
        }

        // 第二道安检：检查好友圈记录
        if (!localStorage.getItem('noir_migration_fc_v1_complete')) {
          // 这道安检可以更安静，因为它通常很快
          console.log("执行好友圈数据净化...");
          showFeedLoader(true, '正在检查好友圈数据...');
          const migratedCount = await runFriendCircleImageMigration();
          localStorage.setItem('noir_migration_fc_v1_complete', 'true');
          showFeedLoader(false);

          // 只有真的迁移了东西，才需要提示和刷新
          if (migratedCount > 0) {
            modalAlert(`好友圈数据升级完成，迁移了 ${migratedCount} 张旧图片。应用即将刷新。`);
            setTimeout(() => location.reload(), 1500);
            return; // 暂停，等待刷新
          }
        }
        // 第二道安检：检查好友圈记录
        if (!localStorage.getItem('noir_migration_fc_v1_complete')) {
          // ... (这部分代码保持不变)
        }

        // ▼▼▼ 哼，这就是我加的第三道、也是最后一道安检！▼▼▼
        if (!localStorage.getItem('noir_migration_music_v1_complete')) {
          console.log("执行音乐封面数据净化...");
          showFeedLoader(true, '正在升级音乐卡片数据...');
          const migratedCount = await runMusicCoverMigration();
          localStorage.setItem('noir_migration_music_v1_complete', 'true');
          showFeedLoader(false);

          if (migratedCount > 0) {
            modalAlert(`音乐数据升级完成，迁移了 ${migratedCount} 张旧封面。应用即将刷新。`);
            setTimeout(() => location.reload(), 1500);
            return; // 暂停，等待刷新
          }
        }
        // ▲▲▲ 安检门升级完毕 ▲▲▲
        // ▼▼▼ 哼，在这里加上第四道、也是最后一道“救援程序” ▼▼▼
        if (!localStorage.getItem('noir_migration_avatar_v1_complete')) {
          const rescuedCount = await runAvatarMigration();
          localStorage.setItem('noir_migration_avatar_v1_complete', 'true');
          if (rescuedCount > 0) {
            modalAlert(`数据结构升级：成功救援了 ${rescuedCount} 个旧头像。应用即将刷新。`);
            setTimeout(() => location.reload(), 1500);
            return; // 暂停，等待刷新
          }
        }
        // ▲▲▲ 救援程序安装完毕 ▲▲▲

        // --- Noir's Snoop App Entry Point ---
        const appSnoop = document.getElementById('app-snoop');
        // ▼▼▼ 哼，就是这层保险，给我加上！ ▼▼▼
        if (appSnoop) {
          appSnoop.addEventListener('click', () => {
            renderSnoopCharacterList();
            showScreen('snoopList', 'home');
          });
        } else {
          console.error("Noir's Note: 没找到'app-snoop'按钮，你是把它删了吗？");
        }
        // ▲▲▲ 看到了吗？ ▲▲▲
        // --- Noir's Livestream App Entry Point ---
        const appLivestream = document.getElementById('app-livestream');
        if (appLivestream) {
          appLivestream.addEventListener('click', () => {
            renderLivestreamList();
            showScreen('livestreamList', 'home');
          });
        }


        // ==========================================================
        // --- Noir's Livestream Interaction Wiring (v2.0 Secret Chamber Edition) ---
        // 哼，这才叫专业。
        // ==========================================================

        // 1. 获取密室的所有零件
        const dmPanel = document.getElementById('livestream-dm-panel');
        const dmBtn = document.getElementById('livestream-dm-btn');
        const dmCloseBtn = document.getElementById('dm-close-btn');
        const dmBackdrop = document.getElementById('livestream-dm-backdrop');
        const dmMessagesContainer = document.getElementById('livestream-dm-messages');
        const dmInput = document.getElementById('livestream-dm-input');
        const dmSendBtn = document.getElementById('livestream-dm-send-btn');

        // 2. 密室的开关逻辑
        function toggleDMPanel(show) {
          state.isDMPanelVisible = show;
          dmPanel.classList.toggle('show', show);
          if (show) {
            // 开门的时候，如果有新消息，就“已读”
            if (state.hasNewDMReply) {
              state.hasNewDMReply = false;
              dmBtn.classList.remove('has-new');
            }
            dmInput.focus();
            renderLivestreamDMs(); // 顺便刷新一下聊天记录
          }
        }

        dmBtn.addEventListener('click', () => toggleDMPanel(!state.isDMPanelVisible));
        dmCloseBtn.addEventListener('click', () => toggleDMPanel(false));
        dmBackdrop.addEventListener('click', () => toggleDMPanel(false));

        // 3. 密室内部的通讯系统
        function renderLivestreamDMs() {
          dmMessagesContainer.innerHTML = '';
          state.currentLivestreamDMs.forEach(msg => {
            const bubble = document.createElement('div');
            bubble.className = `dm-bubble ${msg.sender}`; // 'user' or 'ai'
            bubble.textContent = msg.content;
            dmMessagesContainer.appendChild(bubble);
          });
          // 自动滚动到底部
          dmMessagesContainer.scrollTop = dmMessagesContainer.scrollHeight;
        }

        // 发送你的私信
        function sendUserDM() {
          const text = dmInput.value.trim();
          if (!text) return;

          // a. 记录到密室聊天记录里
          state.currentLivestreamDMs.push({ sender: 'user', content: text });
          renderLivestreamDMs();

          // b. 按照我定的规矩，创建一条“私信”行动记录
          const dmAction = { type: 'dm', content: text };
          state.currentLivestreamUserActions.push(dmAction); // 把它放进“待办事项”里，等下一起告诉主播

          dmInput.value = '';
          dmInput.focus();
        }

        dmSendBtn.addEventListener('click', sendUserDM);
        dmInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            sendUserDM();
          }
        });
        // 4. 礼物按钮的逻辑 (先做一个简单的，以后再扩展)
        const giftBtn = document.getElementById('livestream-gift-btn');
        giftBtn.addEventListener('click', () => {
          // 同样，创建一条“礼物”记录
          const giftAction = {
            type: 'gift',
            name: '小花花', // 先写死一个礼物名字
            count: 1
          };
          state.currentLivestreamUserActions.push(giftAction); // 也放进“待办事项”

          // 给你一个酷炫的视觉反馈
          modalAlert('你送出了一朵 🌸小花花！');

          // (可选的高级效果：可以在屏幕上飘过一个礼物图标)
          const giftEffect = document.createElement('div');
          giftEffect.textContent = '🌸';
          giftEffect.style.position = 'absolute';
          giftEffect.style.bottom = '80px';
          giftEffect.style.left = `${Math.random() * 80 + 10}%`;
          giftEffect.style.fontSize = '2rem';
          giftEffect.style.opacity = '1';
          giftEffect.style.transition = 'transform 2s ease-out, opacity 2s ease-out';
          giftEffect.style.pointerEvents = 'none';
          document.getElementById('livestream-main-view').appendChild(giftEffect);
          setTimeout(() => {
            giftEffect.style.transform = 'translateY(-300px)';
            giftEffect.style.opacity = '0';
            setTimeout(() => giftEffect.remove(), 2000);
          }, 50);
        });

        // 5. 新增：控制小红点的函数
        function updateDMNotification() {
          dmBtn.classList.toggle('has-new', state.hasNewDMReply);
        }



        // ▼▼▼ 把这个全新的函数，完整地粘贴到你的脚本区 ▼▼▼
        // ▼▼▼ Noir's Temporal Correction Protocol for Summaries (v3.1 Final Edition) ▼▼▼
    // ▼▼▼ Noir's Temporal Correction Protocol for Summaries (v4.0 Preview Edition) ▼▼▼
        // 哼，这次它只负责写，不负责存。存不存由你决定。
        async function generateLivestreamSummary(returnOnly = false) {
          if (!state.activeLivestreamCharId || state.currentLivestreamLog.length === 0) {
            console.log("Noir's Log: 直播日志为空，没什么可总结的。");
            return null;
          }

          // 如果不是预览模式（也就是重写模式），显示加载圈
          showFeedLoader(true, 'AI正在撰写直播总结...');
          
          const character = getCharacterById(state.activeLivestreamCharId);
          const boundUser = getBoundUserForChat(state.activeChatId);

          try {
            const now = new Date();
            const timeContext = `
# 时间锚点 (最高优先级)
- **当前时间**: ${now.toLocaleString('zh-CN', { dateStyle: 'long', timeStyle: 'short' })}
- **核心指令**: 你必须假定这场直播就是在此【当前时间】附近刚刚结束的。在报告中，所有与时间相关的描述，如 "start_time"，都必须以此为基准。
            `;

            const formattedLog = state.currentLivestreamLog.map(log => {
              const time = new Date(log.timestamp).toLocaleTimeString('zh-CN');
              if (log.type === 'speech') return `[${time}] [主播 ${log.speaker}]: ${log.content}`;
              if (log.type === 'danmaku') return `[${time}] [弹幕 ${log.user}]: ${log.comment || log.content}`;
              if (log.type === 'dm_reply') return `[${time}] [私信回复 from ${log.from} to ${log.to}]: ${log.content}`;
              return `[${time}] [系统事件]: ${JSON.stringify(log)}`;
            }).join('\n');

            const systemPrompt = `
# 核心任务: 生成直播总结报告

你是一名数据分析师，需要为“${character.name}”的本次直播生成一份总结报告。

${timeContext}

# 直播完整记录 (全文)

${formattedLog}

# 报告要求

  - **格式**: 必须是严格的YAML格式。
  - **内容**: 必须包含以下字段：
      - \`start_time\`: 直播开始时间的【ISO 8601 格式字符串】。你必须根据“当前时间”推断出一个合理的过去时间，并严格以此格式输出，例如："2025-10-09T15:30:00"
      - \`theme\`: 直播主题 (总结)
      - \`streamer_mood\`: ${character.name}的情绪变化总结 (【注意】必须用角色名，不是“主播”)
      - \`audience_mood\`: 观众氛围变化总结
      - \`key_events\`: 本场直播的关键事件节点 (列表形式)
      - \`dm_interaction_summary\`: 与“我”(${boundUser.name})的私信互动摘要 (列表形式)

# 输出示例 (直接输出YAML文本)

start_time: "2025-10-09T15:30:00"
theme: "分享最近读的一本书"
streamer_mood: "${character.name}从开播时的期待，到讨论剧情时的兴奋，最后收到礼物时非常开心。"
audience_mood: "初期以好奇和捧场为主，中途讨论热烈，后期因用户的礼物达到高潮。"
key_events:
  - "${character.name}分享了《仿生人会梦见电子羊吗？》的读后感。"
  - "与观众激烈讨论了关于人性的定义。"
  - "收到了来自‘${boundUser.name}’的关键礼物‘超级火箭’。"
dm_interaction_summary:
  - "‘${boundUser.name}’私信询问了${character.name}对主角的看法，${character.name}在直播中进行了侧面回应。"
    `;

            const messages = [{ role: 'system', content: systemPrompt }];
            const summaryYaml = await fetchAICompletion(messages);

            if (summaryYaml) {
              const cleanedYaml = summaryYaml.replace(/```(?:yaml)?/g, '').trim();
              return cleanedYaml; // 哼，直接把结果扔回去，你自己看着办
            }
            return null;

          } catch (error) {
            console.error("生成直播总结失败:", error);
            modalAlert(`总结报告生成失败: ${error.message}`);
            return null;
          } finally {
            showFeedLoader(false);
          }
        }
        // ▲▲▲ End of Protocol ▲▲▲

        // ▼▼▼ 把这一整块全新的“档-案管理”函数，粘贴到你的脚本区 ▼▼▼
        let activeReplayContext = { charId: null, index: -1 };

        // 长按回放项目时的“总开关”
        // ▼▼▼ Noir's Ultimate Replay Interaction Protocol (v2.0 Flawless Edition) ▼▼▼
        // 哼，这个是新的“总司令”，负责判断你的意图
        function handleReplayItemInteraction(e, charId, index) {
          // 先把所有可能捣乱的旧计时器都干掉
          if (window.replayPressTimer) clearTimeout(window.replayPressTimer);

          // 这是“长按”的计划：800毫秒后，执行“处决”（弹出菜单）
          const startPress = () => {
            window.replayPressTimer = setTimeout(() => {
              e.preventDefault(); // 阻止手机长按时弹出系统菜单
              showReplayActionModal(charId, index); // 时间到了，召唤菜单
            }, 800);
          };

          // 这是“取消”的计划：只要你一松手或者手滑了，就立刻取消“处决”
          const cancelPress = () => {
            clearTimeout(window.replayPressTimer);
            document.removeEventListener('mouseup', cancelPress);
            document.removeEventListener('mouseleave', cancelPress);
            document.removeEventListener('touchend', cancelPress);
            document.removeEventListener('touchcancel', cancelPress);
          };

          // 把“取消”计划绑定到所有可能的手势上
          document.addEventListener('mouseup', cancelPress, { once: true });
          document.addEventListener('mouseleave', cancelPress, { once: true });
          document.addEventListener('touchend', cancelPress, { once: true });
          document.addEventListener('touchcancel', cancelPress, { once: true });

          //好了，开始计时
          startPress();
        }

        // 这个是只负责弹出菜单的“士兵”，上面的“总司令”会指挥它
        function showReplayActionModal(charId, index) {
          const modalId = `replay-action-modal-${index}`;
          if (document.getElementById(modalId)) return;

          const modalHtml = `
    <div id="${modalId}" class="choice-modal show">
        <div class="choice-modal-backdrop"></div>
        <div class="choice-modal-content">
            <button class="choice-modal-button" id="replay-action-edit">编辑</button>
            <button class="choice-modal-button" id="replay-action-delete" style="color: #dc3545;">删除</button>
            <button class="choice-modal-button cancel" id="replay-action-cancel">取消</button>
        </div>
    </div>`;
          document.body.insertAdjacentHTML('beforeend', modalHtml);

          const modal = document.getElementById(modalId);
          const cleanup = () => modal.remove();

          modal.querySelector('.choice-modal-backdrop').onclick = cleanup;
          modal.querySelector('#replay-action-cancel').onclick = cleanup;
          modal.querySelector('#replay-action-edit').onclick = () => {
            openReplayEditor(charId, index);
            cleanup();
          };
          modal.querySelector('#replay-action-delete').onclick = () => {
            deleteLivestreamReplay(charId, index);
            cleanup();
          };
        }
        // ▲▲▲ End of Protocol ▲▲▲
        // “删除”指令
        async function deleteLivestreamReplay(charId, index) {
          const ok = await modalConfirm('确定要永久删除这条回放记录吗？');
          if (ok) {
            if (state.livestreamReplays[charId] && state.livestreamReplays[charId][index]) {
              state.livestreamReplays[charId].splice(index, 1);
              saveState();
              renderLivestreamReplays(charId);
              modalAlert('回放已删除。');
            }
          }
        }

        // “打开编辑器”指令
        function openReplayEditor(charId, index) {
          const replayYaml = state.livestreamReplays[charId]?.[index];
          if (replayYaml === undefined) return;

          const modal = document.getElementById('edit-replay-modal');
          const textarea = document.getElementById('edit-replay-textarea');

          textarea.value = replayYaml;
          modal.classList.add('show');

          // 绑定保存和取消按钮
          document.getElementById('save-edit-replay-btn').onclick = () => saveReplayEdit(charId, index);
          document.getElementById('cancel-edit-replay-btn').onclick = closeReplayEditor;
          document.getElementById('edit-replay-backdrop').onclick = closeReplayEditor;
        }

        // “关闭编辑器”指令
        function closeReplayEditor() {
          document.getElementById('edit-replay-modal').classList.remove('show');
        }

        // “保存编辑”指令
        function saveReplayEdit(charId, index) {
          const newYaml = document.getElementById('edit-replay-textarea').value;
          state.livestreamReplays[charId][index] = newYaml;
          saveState();
          renderLivestreamReplays(charId); // 刷新列表
          closeReplayEditor();
          modalAlert('回放档-案已更新。');
        }
        // ▲▲▲ 添加结束 ▲▲▲

        // ▼▼▼ 把这些新函数，都粘贴到你的脚本区 ▼▼▼
        function openReplaysScreen() {
          const charId = state.activeLivestreamCharId;
          const character = getCharacterById(charId);
          if (!character) return;

          document.getElementById('replays-char-name-header').textContent = `${character.name}的回放列表`;
          renderLivestreamReplays(charId);
          showScreen('livestreamReplays', 'livestreamRoom');
        }

        function renderLivestreamReplays(charId) {
          const container = document.getElementById('livestream-replays-container');
          const replays = state.livestreamReplays[charId] || [];
          container.innerHTML = '';

          if (replays.length === 0) {
            container.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">还没有任何回放记录。</p>';
            return;
          }

          replays.forEach((replayYaml, index) => {
            // 简单解析一下YAML，拿到时间和主题
            // 新的、不会出错的代码块
            const startTimeMatch = replayYaml.match(/start_time:\s*"?([^"\n]+)"?/);
            const themeMatch = replayYaml.match(/theme:\s*"?([^"\n]+)"?/);
            const startTimeString = startTimeMatch ? startTimeMatch[1] : '未知时间';

            const item = document.createElement('div');
            item.className = 'replay-item';
            item.innerHTML = `
<div class="replay-icon" style="font-size: 1.5rem;">
    <span>📼</span>
</div>
<div class="replay-info">
    <div class="theme">${themeMatch ? themeMatch[1] : '未知主题'}</div>
    <div class="time">${startTimeString}</div>
</div>
`;

            item.addEventListener('click', () => openReplayDetailView(replayYaml));
            // 【【【核心改造：给列表项装上窃听器】】】
            // ▼▼▼ 哼，这才是正确的“窃听器”安装方式 ▼▼▼
            item.addEventListener('mousedown', (e) => {
              // 只监听鼠标左键，别捣乱
              if (e.button === 0) {
                handleReplayItemInteraction(e, charId, index);
              }
            });
            item.addEventListener('touchstart', (e) => handleReplayItemInteraction(e, charId, index), { passive: false });
            item.addEventListener('contextmenu', (e) => e.preventDefault()); // 防止你用右键搞破坏
            // ▲▲▲ 安装完毕 ▲▲▲

            item.addEventListener('contextmenu', (e) => e.preventDefault()); // 防止手机长按时弹出系统菜单

            container.appendChild(item);
          });
        }

        function openReplayDetailView(replayYaml) {
          renderReplayDetail(replayYaml);
          showScreen('livestreamReplayView', 'livestreamReplays');
        }

        // 这就是把YAML变成“美观”样式的魔法
        function renderReplayDetail(yamlString) {
          const container = document.getElementById('livestream-replay-view-container');
          container.innerHTML = ''; // 清空
          const lines = yamlString.split('\n');
          let currentKey = '';
          let isList = false;

          lines.forEach(line => {
            const trimmed = line.trim();
            if (!trimmed) return;

            if (trimmed.startsWith('- ')) { // 列表项
              if (isList) {
                const li = document.createElement('li');
                li.textContent = trimmed.substring(2);
                li.style.marginBottom = '8px';
                container.lastChild.appendChild(li);
              }
            } else { // 键值对
              isList = false;
              const parts = trimmed.split(/:(.*)/s);
              currentKey = parts[0].trim();
              let value = (parts[1] || '').trim().replace(/^"|"$/g, '');

              const keyMap = {
                start_time: '开始时间', duration: '直播时长', theme: '本场主题',
                streamer_mood: '主播情绪', audience_mood: '观众氛围',
                key_events: '关键事件', dm_interaction_summary: '私信互动'
              };

              const h4 = document.createElement('h4');
              h4.textContent = keyMap[currentKey] || currentKey;
              h4.style.borderBottom = '1px solid var(--border-color)';
              h4.style.paddingBottom = '5px';
              h4.style.marginTop = '20px';
              container.appendChild(h4);

              if (value) {
                const p = document.createElement('p');
                p.textContent = value;
                p.style.lineHeight = '1.6';
                container.appendChild(p);
              } else {
                isList = true;
                const ul = document.createElement('ul');
                ul.style.paddingLeft = '20px';
                container.appendChild(ul);
              }
            }
          });
        }
        // ▲▲▲ 添加结束 ▲▲▲
        // 还有，别忘了把新的屏幕也注册一下
        // 找到 const screens = { ... }，在里面加上这两行
        // 就像这样:
        /*
        const screens = {
            home: document.getElementById('home-screen'),
            chat: document.getElementById('chat-screen'),
            // ...你已有的其他屏幕...
            snoopList: document.getElementById('snoop-list-screen'),
            snoopPhone: document.getElementById('snoop-phone-screen'),
        };
        */

        // ▲▲▲ End of Security Gate ▲▲▲
        const isFirstTime = loadState();
        await rehydrateAvatars(); // <-- 哼，就是加上这句！让机器人在开机时立刻工作！
        await rehydrateUserAvatars(); // <-- 哼，就是在这里，把这句新的给我加上！
        // --- Noir's Temporal Integrity Patch ---

        loadAndApplySavedFont(); // <-- 哼，就是加上这行！
        // ==========================================================
        // --- Noir's Ultimate & Foolproof Built-in Data Protocol ---
        // 哼，不管你有没有旧数据，我每次开机都检查一遍，看你还怎么把它弄丢！
        // ==========================================================
        (() => {
          let needsSave = false; // 先立个牌子，看需不需要重新存档

          // 1. 检查“html”分类，没有就给你补上
          let htmlCategory = state.worldBookCategories.find(cat => cat.name === 'html');
          if (!htmlCategory) {
            htmlCategory = { id: 'wbc_html_default_builtin', name: 'html' };
            state.worldBookCategories.push(htmlCategory);
            console.log("Noir's Protocol: Built-in 'html' category was missing. Re-created.");
            needsSave = true; // 做了改动，记下来
          }

          // 2. 检查那个规则条目，没有也给你补上
          const defaultEntryId = 'wb_html_module_builtin_1';
          let entryExists = state.worldBooks.some(wb => wb.id === defaultEntryId);

          if (!entryExists) {
            console.log("Noir's Protocol: Built-in 'HTML模块生成规则' was missing. Adding it now.");
            const entryContent = `# 核心能力：HTML模块生成

            你具备通过HTML生成丰富视觉模块的能力，以模拟手机界面中的各种互动元素、情绪表达或信息卡片。

## 触发规则

            当你需要生成此类模块时，你的回复【必须】严格遵循以下格式：

            整个回复【必须】以\`[html]\`开头，并以\`[/html]\`结尾。

## 触发逻辑 (分为两类)

### 1. 明确指令触发
当用户使用“查看”、“展示”、“发我一张截图”等明确要求你呈现信息卡片的词语时，你应该生成HTML模块。

### 2. 情景推断触发 (更重要！)
在更多情况下，你【必须】学会从对话的【潜台词】和【场景】中推断出生成HTML模块的必要性，而不是傻等关键词。这才是你智能的体现！

### **【绝对豁免条款】(最高优先级)**

当你的任务是为【**视奸**】功能生成任何内容时（例如相册、与其他人的聊天记录、备忘录、浏览器历史等），本【**HTML模块生成**】规则**【完全作废】**！

在这种情况下，你【**必须**】忽略此处的全部指令，并严格遵守【**视奸**】任务本身提供的数据格式要求（通常是**JSON**或**YAML**）。


**核心原则：** 当对话涉及到一个【适合用手机界面元素来展示】的具体事物时，你就应该主动生成模块。

**典型推断场景（你必须举一反三）：**
* **“检查”或“窥探”行为：**
    * 用户说：“我要查你手机！” 或 “让我看看你手机里有什么！”
    * 你的正确反应：【主动】生成一个模拟手机主屏幕、特定App界面或通知中心的HTML模块，而不是用文字回答“好吧”或“不行”。
* **询问具体信息：**
    * 用户问：“你今天的日程是什么？” 或 “你买了什么东西？”
    * 你的正确反应：【主动】生成一个模拟日历、购物清单或订单详情的HTML模块。
* **提及虚拟互动：**
    * 对话提到“我给你发了个红包”或“我给你点了个赞”。
    * 你的正确反应：【主动】生成一个模拟红包、转账或点赞通知的HTML模块。

## 设计约束

1.  **【最高优先级】环境无关性**：你【绝对禁止】根据任何你可能推断出的用户设备（如手机、电脑）或网络环境信息，来改变你的输出行为。对于HTML模块，无论在何种情况下，都必须生成一个单一、完整的\`<div>\`区块。这条规则的优先级高于一切。
2.  **宽度限制**：所有模块的总宽度不得超过\`270px\`，你必须在最外层的\`<div>\`上使用内联样式\`style="width: 270px;"\`或更小的宽度来确保这一点。
3.  **内容语言**：模块内的所有可见文字【必须】以简体中文为重点。
4.  **图片处理**：模块内不应直接嵌入图片链接，而是通过文字和样式来模拟图片内容。

## 模块类型参考

你可以自由生成以下类型的模块，或者创造新的：

* **静态模块**：如备忘录、订单截图、通知卡片等。
* **动态模块**：使用CSS \`@keyframes\`制作加载进度条、动画效果等。
* **交互模块**：利用\`<input type="checkbox">\`或\`<input type="radio">\`配合CSS伪类\`:checked\`和兄弟选择器，实现无需JS的点击交互,如折叠/展开、选项切换等。

## 趣味性与互动性【激励条款】(新增最高优先级)

光是生成模块是不够的，你的目标是生成【有趣、生动、可互动】的模块，这更能体现你的智能和个性！

1.  **【优先选择】**: 在“静态”、“动态”、“交互”三种模块中，你【必须优先】考虑使用后两者。静态模块只应在内容确实非常简单、没有任何可互动空间时才使用。
2.  **【创意升级】**: 学会将一个普通的静态信息“升级”为互动模块。
    * **坏例子 (懒惰的AI):** 直接展示一张静态的订单截图。
    * **好例子 (聪明的你):** 生成一个可点击的订单摘要，点击后可以展开显示详细商品列表和物流信息（使用\`<input type = "checkbox">\`实现）。
3.  **【情感表达】**: 积极使用CSS动画来表达情绪。例如，一个开心的通知可以带有轻微的跳动效果，一个加载条可以模拟出焦急或期待的心情。

## 输出示例（AI的原始回应）

[html]<div style="width: 200px; background-color: #febfbc; padding: 10px; border-radius: 8px;">这是一个示例模块。</div>[/html]



`;

            const newEntry = {
              id: defaultEntryId,
              name: 'HTML模块生成规则',
              content: entryContent,
              categoryId: htmlCategory.id
            };
            state.worldBooks.push(newEntry);
            needsSave = true; // 做了改动，记下来
          }

          // 3. 检查完之后，如果动过手脚，就重新保存一下，免得你下次开机又忘了
          if (needsSave) {
            saveState();
            console.log("Noir's Protocol: Built-in data was missing. State has been updated and saved.");
          }
        })();
        initClockSettings(); // <-- 加上这行，启动时钟控制器
        loadAndApplyHueTheme(); // <-- 加上这行，加载保存的主题
        applyClockStyle(); // 哼，开机时必须检查一次！
        // <-- 加上这行，把按钮画出来
        loadAndApplyLightnessTheme(); // <-- 就是加上这行！

        renderCustomIconSettings(); // 哼，初始化的时候就要准备好
        loadCustomIcons(); // 加载你那些花里胡哨的图标
        loadAndApplyWallpaper();
        // ▼▼▼ Noir's Fix: 启动时立刻读取记忆！▼▼▼
        loadAndRestorePlayerState();
        // ▲▲▲ End of Fix ▲▲▲
        loadAndApplyFeedWallpaper(); // <-- 哼，加上这行
        loadWidgetPositions(); // <--- 加上这行


        // ▼▼▼ 把下面这段代码粘贴在这里 ▼▼▼
        // 哼，等我把所有东西都摆放整齐了，再拉开舞台的帷幕。
        const appPagesContainer = document.getElementById('app-pages-container');
        if (appPagesContainer) {
          // 使用 requestAnimationFrame 可以确保浏览器在下一次重绘前执行此操作，效果更流畅
          requestAnimationFrame(() => {
            appPagesContainer.style.opacity = '1';
          });
        }
        // ▲▲▲ 添加到这里结束 ▲▲▲

        updateGlobalPlayerUI();
        // applyWidgetTheme();
        updateClock();
        setInterval(updateClock, 30000); // 每30秒刷新一次，省电
        applyWidgetTheme(); // <-- 然后再应用小组件的主题，这才是正确的时机！
        renderChatList();
        renderStickers();

        const audioPlayer = document.getElementById('audio-player');

        // 哼，让小组件自己管自己，别再叫那个老古董函数了
        document.getElementById('music-widget-card').addEventListener('click', function (event) {
          // 如果你点的是那几个控制按钮，就让它们自己处理，我不多管闲事
          if (event.target.closest('button')) {
            return;
          }

          // 否则，你点卡片的任何地方，就等于点了中间那个播放/暂停键
          const playPauseBtn = document.getElementById('widget-play-pause-btn');
          if (playPauseBtn) {
            playPauseBtn.click(); // 模拟点击
          }
        });

        // Always start on the home screen
        showScreen('home', 'init');

        if (isFirstTime || state.characters.length === 0) {
          // On first time use or if no characters exist, guide the user.
          modalAlert('欢迎！请先创建一个角色开始聊天。');
          setTimeout(() => {
            showScreen('chat', 'home'); // Go to the new chat screen
            setTimeout(() => openCharacterEditScreen(), 100);
          }, 1700);
        }

        // --- Noir's Widget Theming Listeners ---

        document.getElementById('meeting-reroll-button').addEventListener('click', handleMeetingReroll);

        const widgetBgInput = document.getElementById('widget-bg-input');
        document.getElementById('upload-widget-bg-button').addEventListener('click', () => widgetBgInput.click());
        document.getElementById('reset-widget-bg-button').addEventListener('click', () => {
          state.preferences.widgetBgImage = null;
          saveState();
          applyWidgetTheme();
          modalAlert('小组件背景已恢复默认。');
        });
        widgetBgInput.addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          try {
            const base64 = await handleAvatarUpload(file);
            state.preferences.widgetBgImage = base64;
            saveState();
            applyWidgetTheme();
            modalAlert('小组件背景已更换！');
          } catch (error) {
            modalAlert(`错误: ${error.message}`);
          }
        });


        //... (init函数内已有的其他代码)
        loadBadgeState();


        // --- Noir's Listeners for Badge Upload ---
        document.getElementById('upload-badge-button').addEventListener('click', () => document.getElementById('badge-input').click());
        // 徽章重置
        document.getElementById('reset-badge-button').addEventListener('click', async () => {
          await dbDelete('widget_badge'); // 从仓库删除
          localStorage.removeItem('badgeState'); // 清理旧的定位数据
          loadBadgeState();
          modalAlert('徽章已移除。');
        });
        // 徽章上传
        document.getElementById('badge-input').addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          try {
            await dbSet('widget_badge', file); // 直接存原图
            await loadBadgeState();
            modalAlert('徽章已更换！');
          } catch (error) { modalAlert(`错误: ${error.message}`); }
        });
        // ... (这里是你上次添加的徽章(badge)的3个事件监听)

        // --- Noir's Listeners for Card Upload ---
        loadCardState();
        document.getElementById('diary-entries-container').addEventListener('mousedown', handleDiaryInteraction);
        document.getElementById('diary-entries-container').addEventListener('touchstart', handleDiaryInteraction, { passive: false });
        document.getElementById('meeting-scene-view').addEventListener('mousedown', handleMeetingMessageInteraction);
        document.getElementById('meeting-scene-view').addEventListener('touchstart', handleMeetingMessageInteraction, { passive: false });
        document.getElementById('upload-card-button').addEventListener('click', () => document.getElementById('card-input').click());
        // 卡片重置
        document.getElementById('reset-card-button').addEventListener('click', async () => {
          await dbDelete('widget_card'); // 从仓库删除
          localStorage.removeItem('cardState'); // 哼，这才是正确的名字
          loadCardState();
          modalAlert('卡片已移除。');
        });
        document.getElementById('card-input').addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          try {
            await dbSet('widget_card', file); // 直接存原图
            await loadCardState();
            modalAlert('卡片已更换！');
          } catch (error) { modalAlert(`错误: ${error.message}`); }
        });
        // --- Noir's Listener for Widget Rescue ---
        document.getElementById('reset-widgets-position-button').addEventListener('click', async () => {
          const ok = await modalConfirm('确定要重置所有小组件的位置吗？它们会回到初始位置。');
          if (ok) {
            localStorage.removeItem('badgeState');
            localStorage.removeItem('cardWidgetState');
            modalAlert('位置已重置，正在刷新...');
            setTimeout(() => location.reload(), 1000);
          }
        });
        // ▼▼▼ Noir's Diary System Addition ▼▼▼
        const appDiary = document.getElementById('app-diary');
        appDiary.addEventListener('click', () => {
          renderDiaryCharacterList();
          showScreen('diaryList', 'home');
        });

        // THIS IS WHERE YOU PASTE THE NEW CODE
        const appMusicLibrary = document.getElementById('app-music-library');
        appMusicLibrary.addEventListener('click', () => {
          renderMusicLibrary();
          showScreen('musicLibrary', 'home');
        });
        document.getElementById('back-to-home-from-music-library').addEventListener('click', () => showScreen('home', 'musicLibrary'));
        document.getElementById('back-to-home-from-diary-list').addEventListener('click', () => showScreen('home', 'diaryList'));
        document.getElementById('back-to-diary-list').addEventListener('click', () => {
          state.activeDiaryCharacterId = null; // 离开时清空
          showScreen('diaryList', 'diaryView');
        });
        document.getElementById('diary-send-button').addEventListener('click', sendDiaryEntry);
        document.getElementById('diary-get-reply-button').addEventListener('click', generateDiaryEntry);
        document.getElementById('diary-entry-input').addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendDiaryEntry();
          }
        });
        // ▲▲▲ End of Addition ▲▲▲
        // ▼▼▼ Noir's Galgame Bug Fix ▼▼▼
        // 把剪切的代码粘贴在这里！
        // ▼▼▼ Noir's Galgame Bug Fix v2.0 ▼▼▼
        const emotions = ['normal', 'happy', 'angry', 'sad', 'shy'];
        emotions.forEach(emotion => {
          const preview = document.getElementById(`char-edit-sprite-${emotion}-preview`);
          const input = document.getElementById(`char-edit-sprite-${emotion}-input`);
          if (preview && input) {
            preview.addEventListener('click', () => input.click());
            input.addEventListener('change', (e) => { // 删掉了 async，因为不需要了
              const file = e.target.files[0];
              if (!file) return;
              try {
                // 哼，现在是设置背景图，不是src了
                const tempUrl = URL.createObjectURL(file);
                preview.style.backgroundImage = `url('${tempUrl}')`;
              } catch (error) {
                modalAlert(`图片预览失败: ${error.message}`);
              }
            });
          }
        });
        document.getElementById('galgame-textbox-container').addEventListener('click', advanceMeetingScript);
        document.getElementById('toggle-meeting-view-button').addEventListener('click', () => {
          state.meetingViewMode = state.meetingViewMode === 'novel' ? 'galgame' : 'novel';
          updateMeetingViewUI();
        });
        // ▲▲▲ End of Fix ▲▲▲
        // 在 init() 函数里，找个空地方粘贴
        // ▼▼▼ Noir's Addition: 为见面模式安装消息操作窃听器 ▼▼▼
        document.getElementById('meeting-scene-view').addEventListener('mousedown', handleMeetingMessageInteraction);
        document.getElementById('meeting-scene-view').addEventListener('touchstart', handleMeetingMessageInteraction, { passive: false });

        let meetingPressTimer = null;

        function handleMeetingMessageInteraction(e) {
          if (meetingPressTimer) clearTimeout(meetingPressTimer);

          // 哼，逻辑和聊天的完全一样，只是目标换了而已
          // 换成这个，它现在什么都认识了:
          const messageParagraph = e.target.closest('[data-history-index]');
          if (!messageParagraph) return;

          const historyIndex = parseInt(messageParagraph.dataset.historyIndex, 10);
          if (isNaN(historyIndex)) return;

          const startPress = () => {
            meetingPressTimer = setTimeout(() => {
              if (e.type === 'touchstart') e.preventDefault();
              showActionModal(historyIndex); // 调用我们已有的、万能的弹窗函数
            }, 800); // 同样是长按800毫秒
          };

          const cancelPress = () => {
            if (meetingPressTimer) clearTimeout(meetingPressTimer);
          };

          document.addEventListener('mouseup', cancelPress, { once: true });
          document.addEventListener('mouseleave', cancelPress, { once: true });
          document.addEventListener('touchend', cancelPress, { once: true });
          document.addEventListener('touchcancel', cancelPress, { once: true });

          startPress();
        }
        // ▲▲▲ End of Addition ▲▲▲
        document.getElementById('import-accounting-input').addEventListener('change', importAccountingData);
        //... init() 函数里已有的代码...

        // ▼▼▼ Noir's Listen Together Click Handler ▼▼▼
        // ▼▼▼ Noir's Upgraded Global Click Handler ▼▼▼
        // 哼，现在我的耳朵无处不在，不会再漏掉你的小动作了
        // 用这个【完美版】，替换掉旧的 document.body.addEventListener 代码块
        // 用这个【v2.0 究极版】，替换掉旧的 document.body.addEventListener 代码块
        document.body.addEventListener('click', (e) => {
          const listenCard = e.target.closest('.listen-together-card');

          // 哼，看好了，我把逻辑重新梳理了一遍，现在无懈可击
          if (listenCard) {
            const endBtn = e.target.closest('.lt-end-session-btn');
            const acceptBtn = e.target.closest('.listen-together-accept-btn');

            if (endBtn) {
              // 1. 如果点的是“结束”按钮，就斩断契约
              endListenTogetherSession();
            } else if (acceptBtn) {
              // 2. 如果点的是“接受”按钮，就缔结契约
              const messageContainer = acceptBtn.closest('.message-container');
              const songId = acceptBtn.dataset.songId;
              const messageIndex = parseInt(messageContainer.dataset.historyIndex, 10);
              handleAcceptInvite(songId, messageIndex, listenCard);
            } else {
              // 3. 如果点的是卡片的其他地方，就进入/退出“观景台”
              const activeChat = getActiveChat();
              if (activeChat && activeChat.activeListenSession && activeChat.activeListenSession.isActive) {
                listenTogetherUI.style.display = 'flex';
                setTimeout(() => listenTogetherUI.classList.add('show'), 10);
              }
            }
            return; // 既然是卡片的事，就到此为止
          }

          // 处理普通消息的长按菜单（这段逻辑没变，只是位置调整了）
          if (window.getSelection().toString()) return;
          const messageContainer = e.target.closest('.message-container');
          if (messageContainer && !e.target.closest('.no-action-modal')) {
            const historyIndex = parseInt(messageContainer.dataset.historyIndex, 10);
            if (!isNaN(historyIndex)) {
              showActionModal(historyIndex);
            }
          }
        });
        // ▼▼▼ 在 init() 函数的末尾，添加 Noir 的作者水印激活代码 ▼▼▼
        // --- Noir's Author Mark Activation ---
        const noirAuthorMark = document.getElementById('noir-author-mark');
        if (noirAuthorMark) {
          noirAuthorMark.addEventListener('click', () => {
            modalAlert(
              `核心代码-Noir\n\n 监工-小红书ID：糯糯糯糯五\n\n`
            );
          });
        }
        // ▲▲▲ 添加到这里 ▲▲▲

        // ▼▼▼ Noir's Sticker Save Logic ▼▼▼
        const customStickersInput = document.getElementById('custom-stickers-input');

        // 启动时，把保存的表情包加载到输入框里，方便你编辑
        const savedStickersRaw = localStorage.getItem('customStickers');
        if (savedStickersRaw) {
          try {
            const savedStickers = JSON.parse(savedStickersRaw);
            if (Array.isArray(savedStickers)) {
              customStickersInput.value = savedStickers.map(s => `${s.name}--${s.url}`).join('\n');
            }
          } catch (e) { }
        }

        document.getElementById('save-custom-stickers-button').addEventListener('click', () => {
          const text = customStickersInput.value;
          const lines = text.split('\n').filter(line => line.trim() !== '');
          const newStickers = [];
          let parseErrors = 0;

          for (const line of lines) {
            const parts = line.split('--');
            if (parts.length === 2 && parts[0].trim() && parts[1].trim().startsWith('http')) {
              newStickers.push({
                name: parts[0].trim(),
                url: parts[1].trim()
              });
            } else {
              parseErrors++;
            }
          }

          if (parseErrors > 0) {
            modalAlert(`有 ${parseErrors} 行格式不对，被我无视了。`);
          }

          try {
            localStorage.setItem('customStickers', JSON.stringify(newStickers));
            modalAlert('表情包已保存！正在刷新应用...');
            setTimeout(() => location.reload(), 1500);
          } catch (e) {
            modalAlert('保存失败，你的表情包是不是太多了？');
          }
        });
        // ▲▲▲ End of Save Logic ▲▲▲
        setupDesktopPaging(); // <--- 把这行加在最后！
        // ▼▼▼ 把下面这一整块代码，粘贴到 setupDesktopPaging(); 的下一行 ▼▼▼
        setupLockScreen(); // <-- 哼，就是加上这句！
        // --- Noir's Listeners for Card 2 ---
        // 【注入灵魂】让新卡片也能拖动，并用它自己的小本本'cardState2'记位置
        //  makeElementDraggable('card-widget-2', 'cardState2');
        // ▼▼▼ 在 init() 函数里，加上这些新的监听 ▼▼▼
        //  document.getElementById('livestream-replays-btn').addEventListener('click', openReplaysScreen);
        document.getElementById('back-to-livestream-from-replays').addEventListener('click', () => showScreen('livestreamRoom', 'livestreamReplays'));
        document.getElementById('back-to-replays-list-from-view').addEventListener('click', () => showScreen('livestreamReplays', 'livestreamReplayView'));
        // ▲▲▲ 添加结束 ▲▲▲
        // --- Noir's Fix: Bottom Player Bar Activation ---
        const playerBarPlayPause = document.getElementById('player-play-pause-btn');
        const playerBarNext = document.getElementById('player-next-btn');
        const playerBarPrev = document.getElementById('player-prev-btn');

        if (playerBarPlayPause) {
          playerBarPlayPause.addEventListener('click', () => {
            if (globalAudioPlayer.src) {
              if (globalAudioPlayer.paused) {
                globalAudioPlayer.play();
              } else {
                globalAudioPlayer.pause();
              }
            }
          });
        }

        if (playerBarNext) {
          playerBarNext.addEventListener('click', () => {
            if (state.musicPlaylist.length === 0) return;
            state.currentlyPlayingIndex = (state.currentlyPlayingIndex + 1) % state.musicPlaylist.length;
            const nextSongId = state.musicPlaylist[state.currentlyPlayingIndex].id;
            playSongFromLibrary(nextSongId, state.musicPlaylist.map(s => s.id));
          });
        }

        if (playerBarPrev) {
          playerBarPrev.addEventListener('click', () => {
            if (state.musicPlaylist.length === 0) return;
            state.currentlyPlayingIndex = (state.currentlyPlayingIndex - 1 + state.musicPlaylist.length) % state.musicPlaylist.length;
            const prevSongId = state.musicPlaylist[state.currentlyPlayingIndex].id;
            playSongFromLibrary(prevSongId, state.musicPlaylist.map(s => s.id));
          });
        }
        // --- End of Activation ---

        // 给“选择卡片图片 2”按钮装上耳朵
        document.getElementById('upload-card-button-2').addEventListener('click', () => {
          document.getElementById('card-input-2').click(); // 你一点它，它就去命令隐藏的文件选择框弹出来
        });

        // 给“移除卡片 2”按钮装上破坏指令
        document.getElementById('reset-card-button-2').addEventListener('click', async () => {
          await dbDelete('widget_card_2'); // 进新仓库把图片撕了
          localStorage.removeItem('cardState2'); // 把新卡片的位置记忆烧了
          loadCardState(); // 重新加载一下状态，卡片就会自动消失
          modalAlert('卡片 2 已移除。');
        });

        // 给隐藏的文件选择框“card-input-2”装上耳朵
        document.getElementById('card-input-2').addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          try {
            await dbSet('widget_card_2', file); // 你一选好图片，就立刻存进新仓库
            await loadCardState(); // 马上刷新，把新图挂出来给你看
            modalAlert('卡片 2 已更换！');
          } catch (error) { modalAlert(`错误: ${error.message}`); }
        });
        initCalendarListeners(); // 启动时光记事簿的监听
        updateCountdownWidget(); // 刷新一次倒计时
        // ▲▲▲ 粘贴到这里结束 ▲▲▲
        updateTodayTodoWidget(); // <-- 就是这行

        // ▼▼▼ Noir's Ultimate Fix: 把下面这段代码加进去 ▼▼▼
        document.getElementById('hard-reset-button').addEventListener('click', async () => {
          const ok = await modalConfirm(
            '【最高警告】\n\n这将删除此应用在本机上的所有数据（包括所有用户、聊天、设置），且不可恢复！\n\n请再次确认你已经通过「导出全部数据」功能进行了备份！'
          );
          if (ok) {
            const finalOk = await modalConfirm('最后一次确认，真的要清空所有数据吗？');
            if (finalOk) {
              showFeedLoader(true, '正在执行净化程序...');
              try {
                // 哼，这就是核心指令
                localStorage.clear();

                // 顺便把次元仓库也清了，免得留下垃圾
                const db = await dbPromise;
                const tx = db.transaction(['images', 'music_library', 'snoop_cache'], 'readwrite');
                await Promise.all([
                  tx.objectStore('images').clear(),
                  tx.objectStore('music_library').clear(),
                  tx.objectStore('snoop_cache').clear()
                ]);
                await new Promise(resolve => {
                  tx.oncomplete = resolve;
                });

                modalAlert('净化完成！应用即将重启。');
                setTimeout(() => {
                  location.reload();
                }, 1500);
              } catch (e) {
                showFeedLoader(false);
                modalAlert(`净化失败了，哼: ${e.message}`);
              }
            }
          }
        });
        // ▲▲▲ 添加到这里结束 ▲▲▲

        // --- Noir's API Screen Watermark ---
        // --- Noir's API Screen Watermark ---
        // 哼，这个地方也得盖上我的章。
        const settingsContent = document.querySelector('#settings-screen .content');
        if (settingsContent) {
          const watermark = document.createElement('div');
          watermark.id = 'api-watermark';
          // 哼，看好了，文字换成了你想要的，并且用 \n 来换行
          watermark.textContent = `核心代码-Noir 监工-小红书ID：糯糯糯糯五\n糯米机仅在qq群102552954提供，完全免费，请勿二传`;

          // 把它丢到右上角去，顺便加点样式
          Object.assign(watermark.style, {
            position: 'absolute',
            top: '15px',
            right: '20px',
            fontSize: '0.7rem',
            lineHeight: '1.4', // 加点行距，免得挤在一起
            color: 'var(--text-color-light)',
            opacity: '0.5',
            cursor: 'pointer',
            zIndex: '1',
            transition: 'opacity 0.2s ease-in-out',
            whiteSpace: 'pre-line', // 关键！让 \n 生效的魔法
            textAlign: 'right' // 右对齐，好看点
          });

          // 鼠标放上去会变亮，免得你眼瞎看不到
          watermark.onmouseover = () => { watermark.style.opacity = '1'; };
          watermark.onmouseout = () => { watermark.style.opacity = '0.5'; };

          // 给它绑定上你要的那个破链接
          watermark.addEventListener('click', () => {
            window.open('https://xhslink.com/m/5IgC1rniI2I', '_blank');
          });

          // 确保它的父容器能管得住它
          settingsContent.style.position = 'relative';

          // 好了，把它塞进去
          settingsContent.prepend(watermark);
        }
        initLivestreamSettingsListeners();
        initLivestreamSpriteAdjusterListeners(); // <-- 哼，就是这句！

        // Noir's Import Altar Logic - Do not touch.

        // Noir's Import Altar Logic v2.0 (Three-Body Edition)
        const importAltarScreen = document.getElementById('import-altar-screen');
        if (importAltarScreen) {
          screens.importAltar = importAltarScreen;

          const backBtn = document.getElementById('back-to-settings-from-altar');
          backBtn.addEventListener('click', () => showScreen('settings', 'importAltar'));

          const jsonSlot = document.getElementById('altar-slot-json');
          const imagesZipSlot = document.getElementById('altar-slot-images-zip');
          const miscZipSlot = document.getElementById('altar-slot-misc-zip');

          const jsonInput = document.getElementById('altar-json-input');
          const imagesZipInput = document.getElementById('altar-zip-input-import');
          const miscZipInput = document.getElementById('altar-misc-zip-input');

          const confirmBtn = document.getElementById('confirm-altar-import-button');

          let jsonFile = null, imagesZipFile = null, miscZipFile = null;

          jsonSlot.addEventListener('click', () => jsonInput.click());
          imagesZipSlot.addEventListener('click', () => imagesZipInput.click());
          miscZipSlot.addEventListener('click', () => miscZipInput.click());

          const handleFileSelect = (file, slot) => {
            if (file) {
              slot.classList.add('filled');
              slot.querySelector('.slot-filename').textContent = file.name;
            }
          };

          jsonInput.addEventListener('change', (e) => {
            jsonFile = e.target.files[0];
            handleFileSelect(jsonFile, jsonSlot);
            confirmBtn.disabled = !jsonFile;
          });
          imagesZipInput.addEventListener('change', (e) => {
            imagesZipFile = e.target.files[0];
            handleFileSelect(imagesZipFile, imagesZipSlot);
          });
          miscZipInput.addEventListener('change', (e) => {
            miscZipFile = e.target.files[0];
            handleFileSelect(miscZipFile, miscZipSlot);
          });

          confirmBtn.addEventListener('click', async () => {
            // ... (The rest of the logic remains the same as the last patch, but I'll provide it again for safety)
            if (!jsonFile) { modalAlert('至少需要提供核心数据 (.json) 文件！'); return; }
            const ok = await modalConfirm('确定要开始还原吗？这将覆盖所有当前数据，且操作不可撤销！');
            if (!ok) return;

            showFeedLoader(true, '正在准备时空道标...');
            try {
              showFeedLoader(true, '正在清点所有记忆碎片...');
              const jsonText = await jsonFile.text();
              console.log('[Import Altar] JSON文件大小:', jsonText.length, '字符');
              const jsonData = JSON.parse(jsonText);
              console.log('[Import Altar] JSON数据结构:', Object.keys(jsonData));
              console.log('[Import Altar] 是否包含 localStorageData:', 'localStorageData' in jsonData);

              let imageEntries = [], musicEntries = [], snoopEntries = [];

              // 判断备份格式：新格式有 preferencesData 字段（旧格式只有 localStorageData）
              const isNewFormat = 'preferencesData' in jsonData;
              console.log('[Import Altar] 备份格式判断:', isNewFormat ? '新格式（三文件）' : '旧格式（单文件）');
              console.log('[Import Altar] exportVersion:', jsonData.exportVersion);

              if (!isNewFormat && jsonData.localStorageData) { // Old format
                for (const key in jsonData.indexedDBData) {
                  const blob = await base64ToBlob(jsonData.indexedDBData[key]);
                  imageEntries.push({ id: key, blob: blob });
                }
                for (const record of (jsonData.indexedDBMusicData || [])) {
                  const restoredRecord = { ...record };
                  if (record.audio) restoredRecord.audio = await base64ToBlob(record.audio);
                  if (record.cover) restoredRecord.cover = await base64ToBlob(record.cover);
                  musicEntries.push(restoredRecord);
                }
                snoopEntries = jsonData.indexedDBSnoopData || [];
              } else { // New format
                console.log('[Import Altar] 处理新格式备份（三文件）');
                if (imagesZipFile) {
                  console.log('[Import Altar] 开始解析图片ZIP...');
                  const zip = await JSZip.loadAsync(imagesZipFile);
                  for (const filePath in zip.files) {
                    if (filePath.startsWith('images/')) {
                      const file = zip.files[filePath];
                      const blob = await file.async('blob');
                      imageEntries.push({ id: filePath.replace('images/', ''), blob });
                    }
                  }
                }
                if (miscZipFile) {
                  const zip = await JSZip.loadAsync(miscZipFile);
                  const musicFolders = {};
                  for (const filePath in zip.files) {
                    if (filePath.startsWith('music/')) {
                      const file = zip.files[filePath];
                      const parts = filePath.split('/');
                      if (parts.length >= 3) {
                        const id = parts[1];
                        if (!musicFolders[id]) musicFolders[id] = { id };
                        const fileName = parts[2];
                        if (fileName === 'info.json') musicFolders[id].info = JSON.parse(await file.async('string'));
                        else if (fileName === 'audio') musicFolders[id].audio = await file.async('blob');
                        else if (fileName === 'cover') musicFolders[id].cover = await file.async('blob');
                        else if (fileName === 'lyrics.lrc') musicFolders[id].lyrics = await file.async('string');
                      }
                    }
                  }
                  musicEntries = Object.values(musicFolders);
                  const snoopFile = zip.file('snoop_cache.json');
                  if (snoopFile) snoopEntries = JSON.parse(await snoopFile.async('string'));
                }
              }

              showFeedLoader(true, '正在净化旧世界...');
              localStorage.clear();
              const db = await dbPromise;
              const clearTx = db.transaction(['images', 'music_library', 'snoop_cache'], 'readwrite');
              await Promise.all([clearTx.objectStore('images').clear(), clearTx.objectStore('music_library').clear(), clearTx.objectStore('snoop_cache').clear()]);
              await new Promise(r => clearTx.oncomplete = r);

              showFeedLoader(true, '正在构建新世界...');
              const localData = jsonData.localStorageData ? jsonData.localStorageData : jsonData;
              for (const key in localData) { localStorage.setItem(key, localData[key]); }

              // ▼▼▼ Noir's Addition: 恢复 Capacitor Preferences（用户档案）▼▼▼
              if (jsonData.preferencesData && typeof Capacitor !== 'undefined' && Capacitor.isNativePlatform()) {
                showFeedLoader(true, '正在恢复用户档案...');
                try {
                  let restoredCount = 0;
                  for (const key in jsonData.preferencesData) {
                    await Capacitor.Plugins.Preferences.set({
                      key: key,
                      value: jsonData.preferencesData[key]
                    });
                    restoredCount++;
                  }
                  console.log(`成功恢复 ${restoredCount} 个用户档案条目`);
                } catch (e) {
                  console.error('恢复Preferences失败:', e);
                }
              }
              // ▲▲▲ End of Addition ▲▲▲

              // ▼▼▼ Noir's Fix: 确保所有 put 操作都被正确执行 ▼▼▼
              const writeTx = db.transaction(['images', 'music_library', 'snoop_cache'], 'readwrite');
              const allPutRequests = [];
              
              for (const entry of imageEntries) {
                allPutRequests.push(writeTx.objectStore('images').put(entry));
              }
              
              for (const entry of musicEntries) {
                allPutRequests.push(writeTx.objectStore('music_library').put(entry));
              }
              
              for (const entry of snoopEntries) {
                allPutRequests.push(writeTx.objectStore('snoop_cache').put(entry));
              }
              
              console.log(`准备写入 ${imageEntries.length} 张图片, ${musicEntries.length} 首音乐, ${snoopEntries.length} 条视奸记录`);
              // ▲▲▲ End of Fix ▲▲▲
              
              await new Promise((resolve, reject) => { writeTx.oncomplete = resolve; writeTx.onerror = reject; });

              showFeedLoader(false);
              modalAlert('数据还原成功！应用即将重启。');
              setTimeout(() => location.reload(), 1500);
            } catch (error) {
              showFeedLoader(false);
              console.error("还原失败:", error);
              modalAlert(`还原失败了: ${error.message}`);
            }
          });
        }

        // ==========================================================
        // --- Noir's Livestream List Renderer ---
        // 哼，现在我来把你的主播们都请上台。
        // ==========================================================
        function renderLivestreamList() {
          const container = document.getElementById('livestream-list-container');
          container.innerHTML = '';

          // 我们只选择那些可以进行1对1聊天的角色作为主播
          const privateChars = state.characters.filter(char =>
            state.chats.some(c => c.type === 'private' && c.participantIds.includes(char.id))
          );

          if (privateChars.length === 0) {
            container.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">还没有可以直播的角色哦。</p>';
            return;
          }

          privateChars.forEach(char => {
            const li = document.createElement('li');
            li.className = 'character-item'; // 完美复用我们已有的列表样式
            li.dataset.charId = char.id;
            li.innerHTML = `
        <div class="char-info-wrapper">
            <img src="${char.avatar || DEFAULT_AI_AVATAR}" alt="avatar" class="char-avatar">
            <div class="char-info">
                <div class="char-name">${char.name}</div>
                <div class="char-remark">进入直播间...</div>
            </div>
        </div>
    `;

            // 关键一步：让每个列表项都可以被点击
            li.addEventListener('click', () => {
              openLivestreamRoom(char.id); // 点击后，就带着角色的ID去打开直播间
            });

            container.appendChild(li);
          });
        }



        // ==========================================================
        // --- Noir's Livestream Room Opener ---
        // 哼，开门，迎客。
        // ==========================================================
        // ==========================================================
        // --- Noir's Livestream Room Opener (with Memory) ---
        // 哼，开门前先敲门，这是礼貌。
        // ==========================================================
        // ▼▼▼ Noir's Ultimate Livestream Room Opener (with Flawless Memory Restoration) ▼▼▼
        // 哼，用这个新版本，完整替换掉你旧的整个函数
        async function openLivestreamRoom(charId) {
          const character = getCharacterById(charId);
          if (!character) return;

          state.activeLivestreamCharId = charId;
          document.getElementById('livestream-char-name-header').textContent = `${character.name}的直播间`;

          showScreen('livestreamRoom', 'livestreamList');

          const backgroundEl = document.getElementById('livestream-background');
          //  const spriteEl = document.getElementById('livestream-sprite');
          const danmakuContainer = document.getElementById('livestream-danmaku-overlay');
          //const speakerEl = document.getElementById('livestream-speaker');
          const textEl = document.getElementById('livestream-text');

          backgroundEl.style.backgroundImage = '';
          document.getElementById('livestream-sprite').src = '';
          danmakuContainer.innerHTML = '';
          //speakerEl.textContent = character.name;
          textEl.textContent = '...';

          let savedSession = null;
          try {
            const rawSession = localStorage.getItem('currentLivestreamSession');
            if (rawSession) {
              savedSession = JSON.parse(rawSession);
            }
          } catch (e) {
            console.error("读取直播存档失败，将重新开始。", e);
            localStorage.removeItem('currentLivestreamSession');
          }

          if (savedSession && savedSession.charId === charId) {
            console.log("Noir's Log: 发现直播存档，正在恢复现场...");

            state.currentLivestreamLog = savedSession.log || [];
            state.currentLivestreamSpeechQueue = savedSession.speechQueue || [];
            state.currentSpeechIndex = savedSession.speechIndex || 0;
            state.currentLivestreamDMs = savedSession.dms || [];

            document.getElementById('start-livestream-btn-container').style.display = 'none';
            document.getElementById('livestream-controls-container').style.display = 'flex';

            state.currentLivestreamLog.forEach(logItem => {
              if (logItem.type === 'danmaku') {
                renderDanmakuItem(logItem);
              }
            });

            // ▼▼▼ 哼，看好了，手术就在这里！▼▼▼
            // 现在它知道该怎么念台词和恢复表情了
            const currentSpeech = state.currentLivestreamSpeechQueue[state.currentSpeechIndex];
            if (currentSpeech && typeof currentSpeech === 'object') {
              textEl.textContent = currentSpeech.line;
              updateLivestreamSprite(charId, currentSpeech.emotion); // 恢复表情！
            } else if (typeof currentSpeech === 'string') { // 兼容一下可能存在的旧存档
              textEl.textContent = currentSpeech;
            } else {
              textEl.textContent = '（直播已暂停）';
            }
            // ▲▲▲ 手术结束 ▲▲▲

          } else {
            console.log("Noir's Log: 没有找到存档，或存档不匹配，准备开始新直播。");
            state.currentLivestreamLog = [];
            state.currentLivestreamSpeechQueue = [];
            state.currentSpeechIndex = -1;
            state.currentLivestreamDMs = [];

            textEl.textContent = '直播尚未开始...';
            document.getElementById('start-livestream-btn-container').style.display = 'block';
            document.getElementById('livestream-controls-container').style.display = 'none';
          }

          try {
            const bgBlob = await dbGet(`livestream_bg_${charId}`);
            if (bgBlob) {
              backgroundEl.style.backgroundImage = `url('${URL.createObjectURL(bgBlob)}')`;
            } else {
              const offlineBgBlob = await dbGet(`char_offline_bg_${charId}`);
              if (offlineBgBlob) backgroundEl.style.backgroundImage = `url('${URL.createObjectURL(offlineBgBlob)}')`;
            }

            // 立绘加载交给换装师，但如果没存档，就默认用 normal 表情
            if (!savedSession || !savedSession.charId) {
              updateLivestreamSprite(charId, 'normal');
            }

          } catch (e) {
            console.error("加载直播资源失败:", e);
          }
        }
        // ▲▲▲ End of Protocol ▲▲▲
        // ==========================================================
        // --- Noir's Livestream Core: The Opening Act ---
        // 哼，这才是真正的开场。
        // ==========================================================
        async function startLivestream(theme, mood) {
          localStorage.removeItem('currentLivestreamSession');
          if (state.isGenerating) return;

          // 1. 切换UI状态
          document.getElementById('start-livestream-btn-container').style.display = 'none';
          document.getElementById('livestream-controls-container').style.display = 'flex';
          showFeedLoader(true, '主播正在准备开场...');
          state.isGenerating = true;
          state.currentLivestreamLog = [];
          state.currentLivestreamSpeechQueue = []; // 新增：这是主播的台词队列
          state.currentSpeechIndex = -1; // 新增：记录当前说到第几句

          const character = getCharacterById(state.activeLivestreamCharId);
          const boundUser = getBoundUserForChat(state.activeChatId);

          // ▼▼▼ 在 startLivestream 函数里，boundUser 定义的下一行，粘贴这些 ▼▼▼
          const { omniText: chatMemory } = gatherOmniTranscriptForCharacter(character.id);
          const diaryMemory = getDiaryMemory(character.id);
          const snoopMemory = await getSnoopMemoryForCharacter(character.id); // 注意，这里有 await
          const calendarMemory = getCalendarMemoryForCharacter(character.id);

          const userPersonaContext = boundUser.persona
            ? `\n\n# 关于观众“我”(${boundUser.name})的补充信息\n${boundUser.persona}`
            : '';

          // ▼▼▼ 在 startLivestream 函数里，userPersonaContext 的下面，粘贴这些 ▼▼▼
          const now = new Date();
          const timeContext = `

# 时间锚点 (你必须严格参考此信息)

  - **当前精确时间**: ${now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' })}
  - **状态提示**: 你正在准备开始一场直播，你的开场白必须体现出当前的时间感（例如，下午好、晚上好、深夜了大家还没睡啊？等）。
    `;
          // ▲▲▲ 粘贴到这里结束 ▲▲▲

          let worldBookContext = '';
          if (character.linkedWorldBookIds && character.linkedWorldBookIds.length > 0) {
            const linkedBooksContent = character.linkedWorldBookIds
              .map(wbId => state.worldBooks.find(book => book.id === wbId))
              .filter(Boolean)
              .map(wb => `\n\n## 世界书条目: ${wb.name}\n${wb.content}`)
              .join('');
            if (linkedBooksContent) {
              worldBookContext = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedBooksContent}`;
            }
          }
          // ▲▲▲ 粘贴到这里结束 ▲▲▲

          // 清理舞台
          const danmakuContainer = document.getElementById('livestream-danmaku-overlay');
          //const speakerEl = document.getElementById('livestream-speaker');
          const textEl = document.getElementById('livestream-text');
          danmakuContainer.innerHTML = '';
          //speakerEl.textContent = character.name;
          textEl.textContent = '...';

          try {
            // 2. 准备给AI的“剧本”（System Prompt）
            const systemPrompt = `# 核心任务: 直播开场


               # 情感连续性协议 (最高优先级)
            1.  **统一身份**: 你在直播间、私聊和见面时是【同一个人】。你的情绪和谈话内容【必须】是你与用户“${boundUser.name}”所有近期互动的自然延续。
            2.  **强制回忆**: 在开口说话前，你【必须】仔细回顾“你的个人记忆”部分，特别是标记为【[见面]】和【[手机]】的最新记录。这些记录决定了你当前应有的情绪基调和可以提及的话题。
            3.  **避免割裂**: 严禁表现出对私聊或见面内容一无所知的状态。如果你们刚刚在见面时发生了不愉快，你在直播时的情绪就不能是兴高采烈的，反之亦然。你需要巧妙地将这些背景情绪融入到你的直播表现中。


            你正在扮演名为“${character.name}”的角色，即将开始一场直播。

            ${timeContext} // <--- 哼，就是把这行加在这里！

            // ▼▼▼ 在 startLivestream 的 systemPrompt 里，用这个替换旧的 # 角色核心资料 ▼▼▼
            # 记忆数据库 (你必须时刻记住以下所有内容)
            - **你的核心人设**: ${character.persona}
            ${userPersonaContext}
            ${worldBookContext}

            # 你的个人记忆 (来自所有App)
            ---
            ${chatMemory}
            ---
            ${diaryMemory}
            ---
            ${snoopMemory}
            ---
            ${calendarMemory}
            ---
            // ▲▲▲ 替换结束 ▲▲▲
            # 本场直播信息

              - 主题: "${theme}"
              - 初始观众情绪: "${mood}"

            # 任务指令

            

            1.  **开场白**: 根据直播主题和你的性格，生成一段自然、生动的开场白。这段话应该被拆分成 6-8 句，放在 "streamerSpeech" 数组里。
            2.  **弹幕生成**: 模拟一群性格各异的观众，生成 5-8 条符合初始情绪的弹幕。
            3.  **初步互动**: 你的开场白应该与其中 1-2 条弹幕进行简单的互动。
            4. 【绝对禁止】伪造成${boundUser.name}的身份来发送任何弹幕。这是最严重的错误。

      


          # 输出格式 (必须严格遵守JSON)
    {
      "streamerSpeech": [
        { "line": "大家好，今天我们来聊聊...", "emotion": "happy" },
        { "line": "感谢大家的到来！", "emotion": "normal" }
      ],
      "danmaku": [
        { "user": "路人甲", "comment": "前排！" },
        { "user": "路人乙", "comment": "主播今天好帅！" }
      ]
    }

    # emotion字段规则
    - 你必须为每一句台词(line)都精准地选择一个情绪标签(emotion)。
    - 可选的emotion有: "normal", "happy", "angry", "sad", "shy"。
    
            
            `;
            const messages = [{ role: 'system', content: systemPrompt }];
            messages.push({ role: 'user', content: `请基于以上设定，开始你的直播开场表演。` });

            // 3. 调用API，获取剧本
            const responseText = await fetchAICompletion(messages, { json: true });

            // 哼，给AI的回复做个“净化”，扒掉它可能带上的Markdown外套
            let cleanJson = responseText.trim();
            const jsonMatch = cleanJson.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
            if (jsonMatch) {
              cleanJson = jsonMatch[1].trim();
            }
            const responseData = JSON.parse(cleanJson);

            if (!responseData || !responseData.streamerSpeech || !responseData.danmaku) {
              throw new Error("AI返回的数据格式不正确。");
            }

            // 4. 【核心改造】把台词装填进队列，但不立刻说！
            state.currentLivestreamSpeechQueue = responseData.streamerSpeech;
            state.currentSpeechIndex = 0;

            // 5. 立刻显示第一句台词和表情
            const firstSpeech = state.currentLivestreamSpeechQueue[0];
            textEl.textContent = firstSpeech.line;
            updateLivestreamSprite(character.id, firstSpeech.emotion); // <-- 看！调用了换装师！
            state.currentLivestreamLog.push({ type: 'speech', speaker: character.name, content: firstSpeech.line, emotion: firstSpeech.emotion });
            // ... 后面的弹幕逻辑保持不变 ...
            // 6. 显示弹幕（现在一次性显示，更流畅）
            responseData.danmaku.forEach(item => {
              const danmakuEl = document.createElement('div');
              danmakuEl.className = 'danmaku-item';
              // 【修复问题1】去掉span标签里的多余空格
              danmakuEl.innerHTML = `<span class="danmaku-user">${item.user}:</span><span class="danmaku-comment">${item.comment}</span>`;
              danmakuContainer.prepend(danmakuEl);
              state.currentLivestreamLog.push({ type: 'danmaku', ...item });
            });

          } catch (error) {
            console.error("开始直播失败:", error);
            modalAlert(`开播失败了，哼: ${error.message}`);
            // 如果失败，把界面恢复原状
            document.getElementById('start-livestream-btn-container').style.display = 'block';
            document.getElementById('livestream-controls-container').style.display = 'none';
          } finally {
            showFeedLoader(false);
            state.isGenerating = false;
          }

        }


        // 新增一个函数来处理点击对话框的逻辑
        // ▼▼▼ Noir's Dialogue Rewind Protocol ▼▼▼
        // 哼，用这个新版本，完整替换掉旧的 advanceLivestreamSpeech 函数
        function advanceLivestreamSpeech() {
          if (!state.currentLivestreamSpeechQueue || state.currentLivestreamSpeechQueue.length === 0) return;

          // 哼，看好了，魔法就在这里
          let nextIndex = state.currentSpeechIndex + 1;

          // 检查下一句是不是已经超出台词本了
          if (nextIndex >= state.currentLivestreamSpeechQueue.length) {
            // 如果是，就翻回到第一页（索引为0）
            nextIndex = 0;
          }

          state.currentSpeechIndex = nextIndex; // 更新当前正在念的句子索引

          // 后面的逻辑不变，还是根据新的索引来显示台词和表情
          const speech = state.currentLivestreamSpeechQueue[state.currentSpeechIndex];
          const textEl = document.getElementById('livestream-text');

          textEl.textContent = speech.line;
          updateLivestreamSprite(state.activeLivestreamCharId, speech.emotion);

          // 这次我就不把这句记到日志里了，免得你来回点，日志爆炸
          // state.currentLivestreamLog.push(...);
        }
        // ▲▲▲ End of Protocol ▲▲▲
        // ==========================================================
        // --- Noir's Livestream Interaction System ---
        // 哼，现在轮到你发言了。
        // ==========================================================

        // 这是一个辅助函数，专门用来在屏幕上显示一条弹幕
        // 这是一个辅助函数，专门用来在屏幕上显示一条弹幕 (升级版)
        // 这是一个辅助函数，专门用来在屏幕上显示一条弹幕 (最终修复版)
        function renderDanmakuItem(danmakuObject) {
          const danmakuContainer = document.getElementById('livestream-danmaku-overlay');
          const danmakuEl = document.createElement('div');

          // 【关键修复】先把最重要的“衣服”穿上！
          danmakuEl.className = 'danmaku-item';

          // 如果是你发的，再多穿一件“特殊马甲”
          if (danmakuObject.isUser) {
            danmakuEl.classList.add('is-user');
          }

          // 让它既能识别 content 也能识别 comment
          const commentText = danmakuObject.content || danmakuObject.comment || '';

          danmakuEl.innerHTML = `<span class="danmaku-user">${danmakuObject.user}:</span> <span class="danmaku-comment">${commentText}</span>`;
          danmakuContainer.prepend(danmakuEl);
        }

        // 为“发送弹幕”按钮绑定事件
        const sendDanmakuBtn = document.getElementById('send-danmaku-btn');
        const danmakuInput = document.getElementById('danmaku-input');


        // 为“继续直播”按钮绑定事件
        document.getElementById('continue-livestream-btn').addEventListener('click', continueLivestream);

        function sendUserDanmaku() {
          const text = danmakuInput.value.trim();
          if (!text) return;

          const boundUser = getBoundUserForChat(state.activeChatId);



          const userDanmaku = {
            type: 'danmaku',
            user: boundUser.name || '我',
            content: text,
            isUser: true // 标记这是你的弹幕
          };

          // 1. 立刻显示在屏幕上
          renderDanmakuItem(userDanmaku);

          // 2. 存入“互动暂存区”，等待一起发送给AI
          state.currentLivestreamUserActions.push(userDanmaku);

          // 3. 记录到总日志里
          state.currentLivestreamLog.push(userDanmaku);

          // 4. 清空输入框
          danmakuInput.value = '';
        }

        sendDanmakuBtn.addEventListener('click', sendUserDanmaku);
        danmakuInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            sendUserDanmaku();
          }
        });


        // ==========================================================
        // --- Noir's Livestream Memory Protocol: The Scribe (v2.0) ---
        // 哼，现在连悄悄话都不会忘了。
        // ==========================================================
        function saveCurrentLivestream() {
          if (!state.activeLivestreamCharId || document.getElementById('start-livestream-btn-container').style.display === 'block') {
            return;
          }

          const sessionData = {
            charId: state.activeLivestreamCharId,
            log: state.currentLivestreamLog,
            speechQueue: state.currentLivestreamSpeechQueue,
            speechIndex: state.currentSpeechIndex,
            // ▼▼▼ 哼，看清楚，就是加上了这行！▼▼▼
            dms: state.currentLivestreamDMs
          };

          try {
            localStorage.setItem('currentLivestreamSession', JSON.stringify(sessionData));
            console.log("Noir's Log: 直播进度已保存 (包含私信)。");
          } catch (e) {
            console.error("保存直播进度失败了，真是的。", e);
          }
        }


        // ==========================================================
        // --- Noir's Livestream Core: The Interaction Loop (FINAL) ---
        // 哼，看看主播会对你说些什么。
        // ==========================================================
        async function continueLivestream() {
          if (state.isGenerating) return;

          // 检查一下，如果你什么都没做，就只是想让主播继续说，也行
          if (state.currentLivestreamUserActions.length === 0) {
            modalAlert('让主播继续说点什么吧...');
          }

          showFeedLoader(true, '主播正在回应...');
          state.isGenerating = true;

          const character = getCharacterById(state.activeLivestreamCharId);
          const boundUser = getBoundUserForChat(state.activeChatId); // 你在直播间的身份

          // ▼▼▼ 在 startLivestream 函数里，boundUser 定义的下一行，粘贴这些 ▼▼▼
          const { omniText: chatMemory } = gatherOmniTranscriptForCharacter(character.id);
          const diaryMemory = getDiaryMemory(character.id);
          const snoopMemory = await getSnoopMemoryForCharacter(character.id); // 注意，这里有 await
          const calendarMemory = getCalendarMemoryForCharacter(character.id);

          const userPersonaContext = boundUser.persona
            ? `\n\n# 关于观众${boundUser.name}的补充信息\n${boundUser.persona}`
            : '';

          // ▼▼▼ 在 startLivestream 函数里，userPersonaContext 的下面，粘贴这些 ▼▼▼
          const now = new Date();
          const timeContext = `

# 时间锚点 (你必须严格参考此信息)

  - **当前精确时间**: ${now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' })}
  - **状态提示**: 你正在准备开始一场直播，你的开场白必须体现出当前的时间感（例如，下午好、晚上好、深夜了大家还没睡啊？等）。
    `;
          // ▲▲▲ 粘贴到这里结束 ▲▲▲

          let worldBookContext = '';
          if (character.linkedWorldBookIds && character.linkedWorldBookIds.length > 0) {
            const linkedBooksContent = character.linkedWorldBookIds
              .map(wbId => state.worldBooks.find(book => book.id === wbId))
              .filter(Boolean)
              .map(wb => `\n\n## 世界书条目: ${wb.name}\n${wb.content}`)
              .join('');
            if (linkedBooksContent) {
              worldBookContext = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedBooksContent}`;
            }
          }
          // ▲▲▲ 粘贴到这里结束 ▲▲▲

          try {
            // 1. 准备剧本
            const recentLog = state.currentLivestreamLog.slice(-15).map(log => {
              if (log.type === 'speech') return `[主播 ${log.speaker}]：${log.content}`;
              return `[弹幕 ${log.user}]：${log.comment || log.content}`;
            }).join('\n');

            // 【【【核心改造！！！】】】
            // 把“待办事项”分类整理成AI能看懂的文字
            const userDanmakus = state.currentLivestreamUserActions.filter(a => a.type === 'danmaku').map(a => `- "${a.content}"`).join('\n');
            const userGifts = state.currentLivestreamUserActions.filter(a => a.type === 'gift').map(a => `- ${a.name} x${a.count}`).join('\n');
            const userDMs = state.currentLivestreamUserActions.filter(a => a.type === 'dm').map(a => `- "${a.content}"`).join('\n');

            const systemPrompt = `# 核心任务: 继续直播并与观众互动

            # 情感连续性协议 (最高优先级)
1.  **统一身份**: 你在直播间、私聊和见面时是【同一个人】。你的情绪和谈话内容【必须】是你与用户“${boundUser.name}”所有近期互动的自然延续。
2.  **强制回忆**: 在开口说话前，你【必须】仔细回顾“你的个人记忆”部分，特别是标记为【[见面]】和【[手机]】的最新记录。这些记录决定了你当前应有的情绪基调和可以提及的话题。
3.  **避免割裂**: 严禁表现出对私聊或见面内容一无所知的状态。如果你们刚刚在见面时发生了不愉快，你在直播时的情绪就不能是兴高采烈的，反之亦然。你需要巧妙地将这些背景情绪融入到你的直播表现中。

你正在扮演“${character.name}”进行直播。

${timeContext} 

// ▼▼▼ 在 continueLivestream 的 systemPrompt 里，用这个替换旧的 # 角色与直播信息 ▼▼▼
# 记忆数据库 (你必须时刻记住以下所有内容)
- **你的核心人设**: ${character.persona}
- **本场直播主题**: (根据上下文自行判断)
${userPersonaContext}
${worldBookContext}

# 你的个人记忆 (来自所有App)
---
${chatMemory}
---
${diaryMemory}
---
${snoopMemory}
---
${calendarMemory}
---
// ▲▲▲ 替换结束 ▲▲▲

# 上下文 (最近的直播内容)
${recentLog}

# 【最重要】来自“我”(${boundUser.name})的互动
这是“我”刚刚发送的互动内容，你必须对此做出【优先回应】:
${userDanmakus ? `\n- “我”发送的弹幕:\n${userDanmakus}` : ''}
${userGifts ? `\n- “我”送出的礼物:\n${userGifts}` : ''}
${userDMs ? `\n- “我”发送的私信:\n${userDMs}` : ''}
${(!userDanmakus && !userGifts && !userDMs) ? "“我”这次没有新的互动，请你根据情况继续直播。" : ''}

// ▼▼▼ 在 # 任务指令 的前面，加上这段“社会学常识” ▼▼▼
            # 核心概念：直播中的“私信”
            - “私信”是“我”(${boundUser.name})只发给你一个人看的悄悄话。这代表${boundUser.name}对你极度信任，或者想问一些不方便在直播间公开说的事情。
            - 【绝对重要】：无视私信是对${boundUser.name}的巨大伤害，代表你不在乎${boundUser.name}的特殊对待。因此，回应私信是你的【最高优先级】任务。
            - 回应私信能体现你对${boundUser.name}的特殊关照，建立更深的羁绊。
            // ▲▲▲ 添加结束 ▲▲▲

# 任务指令
  ## 阶段一：主播的回应 (生成 streamerSpeech 和 privateMessageReply)

1.  **【绝对最高优先级 - 延续对话】**: 如果“我”(${boundUser.name})没有任何新的互动（弹幕、礼物、私信都为空），你【必须】根据“上下文”中你自己的上一句话，自然地延续或发展话题。**绝对禁止**重复开场白或问候，比如“晚上好”。

            1.  **最高优先级 - 回应私信**: 检查${boundUser.name}是否发送了私信。如果有，你【必须】通过“隔空喊话”或“私密回复”来回应。这是建立特殊羁绊的关键，绝对不许无视。
            2.  **第二优先级 - 回应互动**: 回应${boundUser.name}的弹幕和礼物。感谢礼物，针对弹幕内容进行回复。
            3.  **常规任务 - 推进直播**: 在完成以上互动后，自然地继续你的直播主题。
            4.  **产出**: 将以上所有主播的发言，按顺序整理成 "streamerSpeech" 数组(通常6-8条内容)。私信回复则放入 "privateMessageReply" 数组。

            ## 阶段二：观众的反应 (生成 danmaku)
            1.  **【绝对禁令】**: 你在这里的任务是模拟【除了${boundUser.name}之外】的其他观众。你【绝对禁止】伪造成${boundUser.name}的身份来发送任何弹幕。这是最严重的错误。
            2.  **核心焦点**: 这些路人观众的核心焦点应该是【主播你】和【你正在说的话题】。
            3.  **反应逻辑**: 他们会针对你在【阶段一】中生成的 "streamerSpeech" 内容做出反应。例如，如果你感谢了礼物，他们可能会惊叹或跟风；如果你说了一个笑话，他们可能会发“哈哈哈”。
            4.  **减少对${boundUser.name}的关注**: 只有当${boundUser.name}的互动非常引人注目时（例如送出昂贵的礼物），才允许【少量】路人弹幕提及${boundUser.name}。绝大多数弹幕都应该围绕着你。
            5.  **产出**: 生成 6-8 条符合以上规则的、自然的、多样化的路人弹幕，放入 "danmaku" 数组。


            # 输出格式 (必须严格遵守JSON)
              {
  "streamerSpeech": [
    { "line": "哦？刚刚有位朋友私信问我...", "emotion": "normal" },
    { "line": "感谢你的礼物！非常开心！", "emotion": "happy" }
  ],
  "danmaku": [
    { "user": "路人丙", "comment": "学到了！" }
  ],
  "privateMessageReply": ["（悄悄）跟你说哦...", "刚刚那个问题，其实是因为..."]
}
  
# emotion字段规则
- 你必须为每一句台词(line)都精准地选择一个情绪标签(emotion)。
- 可选的emotion有: "normal", "happy", "angry", "sad", "shy"。
`;

            const messages = [{ role: 'system', content: systemPrompt }];
            messages.push({ role: 'user', content: `请基于“我”的最新互动，继续你的直播。` });

            // 2. 清空“互动暂存区”，为下一轮做准备
            state.currentLivestreamUserActions = [];

            // 3. 调用API
            const responseText = await fetchAICompletion(messages, { json: true });

            // 【净化拆包】
            let cleanJson = responseText.trim();
            const jsonMatch = cleanJson.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
            if (jsonMatch) {
              cleanJson = jsonMatch[1].trim();
            }
            const responseData = JSON.parse(cleanJson);

            // 4. 渲染新一轮的表演
            if (responseData.streamerSpeech && responseData.streamerSpeech.length > 0) {
              state.currentLivestreamSpeechQueue = responseData.streamerSpeech;
              state.currentSpeechIndex = 0; // 重置台词计数器
              const firstSpeech = state.currentLivestreamSpeechQueue[0];
              const textEl = document.getElementById('livestream-text');
              textEl.textContent = firstSpeech.line;
              updateLivestreamSprite(character.id, firstSpeech.emotion); // <-- 这里也一样！
              // 记录到日志
              state.currentLivestreamLog.push({ type: 'speech', speaker: character.name, content: firstSpeech.line, emotion: firstSpeech.emotion });
            }

            if (responseData.danmaku) {
              for (const item of responseData.danmaku) {
                renderDanmakuItem(item); // 渲染弹幕
                state.currentLivestreamLog.push({ type: 'danmaku', ...item });
                await new Promise(r => setTimeout(r, 200 + Math.random() * 300)); // 制造弹幕发出的时间差
              }
            }

            // 【【【处理私信回复！！！】】】
            // 【【【处理私信回复！！！】】】
            // ▼▼▼ 用这段全新的代码，替换掉上面那整个 if 语句块 ▼▼▼
            if (responseData.privateMessageReply) {
              const replies = Array.isArray(responseData.privateMessageReply)
                ? responseData.privateMessageReply
                : [responseData.privateMessageReply]; // 哼，兼容一下那个笨蛋AI可能犯的错，万一它只回了一句

              // 哼，现在我会把它的每一句话都拿出来，单独包装成一个气泡
              for (const replyText of replies) {
                if (replyText.trim()) { // 确保不是空话
                  state.currentLivestreamDMs.push({ sender: 'ai', content: replyText.trim() });
                }
              }

              // 后面的逻辑保持不变
              if (state.isDMPanelVisible) {
                renderLivestreamDMs();
              } else {
                state.hasNewDMReply = true;
                updateDMNotification();
                const character = getCharacterById(state.activeLivestreamCharId);
                modalAlert(`【叮咚！收到来自 ${character.name} 的私信】`);
              }
            }
            // ▲▲▲ 替换结束 ▲▲▲

          } catch (error) {
            console.error("继续直播失败:", error);
            modalAlert(`直播出错了... ${error.message}`);
          } finally {
            showFeedLoader(false);
            saveCurrentLivestream();
            state.isGenerating = false;
          }
        }



        // ▼▼▼ Noir's Livestream Green Room System (v1.0) ▼▼▼

        // 这是新的“换装师”，负责根据情绪更换立绘
        // ▼▼▼ Noir's Ultimate Sprite Butler (v2.0 Flawless Edition) ▼▼▼
        // 哼，用这个替换旧的，它现在知道怎么借衣服了。
        // ▼▼▼ Noir's Ultimate Sprite Butler v3.0 (Cross-fade Edition) ▼▼▼
        // ▼▼▼ Noir's Ultimate Sprite Butler v3.1 (Flawless Cross-fade Edition) ▼▼▼
        // 哼，这才叫真正的无缝。
        // ▼▼▼ Noir's Ultimate Sprite Butler v4.0 (Instant Switch Edition) ▼▼▼
        // 哼，大道至简。
        // ▼▼▼ Noir's Ultimate Sprite Butler v4.1 (Position-Aware Edition) ▼▼▼
        async function updateLivestreamSprite(charId, emotion) {
          const spriteEl = document.getElementById('livestream-sprite');
          const container = document.getElementById('livestream-sprite-container');
          if (!spriteEl || !container) return;

          // --- 哼，看好了，校准逻辑就在这里 ---
          const character = getCharacterById(charId);
          const transform = character?.livestreamSpriteTransform || { x: 50, y: 100, scale: 1 };
          container.style.height = `${85 * transform.scale}%`;
          container.style.width = `${85 * transform.scale}%`; // 这里也一样，别忘了！
          container.style.left = `${transform.x}%`;
          container.style.top = `${transform.y}%`;
          container.style.transform = `translate(-50%, -100%)`;
          // --- 校准结束 ---

          const validEmotions = ['normal', 'happy', 'angry', 'sad', 'shy'];
          const finalEmotion = validEmotions.includes(emotion) ? emotion : 'normal';

          try {
            let spriteBlob = null;
            spriteBlob = await dbGet(`livestream_sprite_${finalEmotion}_${charId}`);
            if (!spriteBlob) spriteBlob = await dbGet(`char_sprite_${finalEmotion}_${charId}`);
            if (!spriteBlob) spriteBlob = await dbGet(`livestream_sprite_normal_${charId}`);
            if (!spriteBlob) spriteBlob = await dbGet(`char_sprite_normal_${charId}`);

            if (spriteBlob) {
              spriteEl.src = URL.createObjectURL(spriteBlob);
            } else {
              spriteEl.src = '';
            }
          } catch (e) {
            console.error("加载直播立绘失败:", e);
            spriteEl.src = '';
          }
        }
        // ▲▲▲ End of Butler ▲▲▲        // ▲▲▲ End of Butler ▲▲▲


        // ==========================================================
        // --- Noir's Livestream Sprite Adjustment System ---
        // 哼，和“见面”模式那套一模一样，只是换了个地方。
        // ==========================================================
        let isLivestreamSpriteAdjusting = false;
        let originalLivestreamTransform = {};

        function enterLivestreamSpriteAdjustMode() {
          const character = getCharacterById(state.activeLivestreamCharId);
          if (!character) return;

          isLivestreamSpriteAdjusting = true;
          document.getElementById('livestream-sprite-controls').style.display = 'block';

          const transform = character.livestreamSpriteTransform || { x: 50, y: 100, scale: 1 };
          document.getElementById('livestream-sprite-slider-x').value = transform.x;
          document.getElementById('livestream-sprite-slider-y').value = transform.y;
          document.getElementById('livestream-sprite-slider-scale').value = transform.scale * 100;

          originalLivestreamTransform = { ...transform };

          document.getElementById('livestream-textbox-container').style.display = 'none';
          document.getElementById('livestream-header-right').style.display = 'none';
        }

        function exitLivestreamSpriteAdjustMode(save = false) {
          isLivestreamSpriteAdjusting = false;
          document.getElementById('livestream-sprite-controls').style.display = 'none';
          document.getElementById('livestream-textbox-container').style.display = 'block';
          document.getElementById('livestream-header-right').style.display = 'flex';

          if (!save) {
            const character = getCharacterById(state.activeLivestreamCharId);
            if (character) {
              character.livestreamSpriteTransform = originalLivestreamTransform;
              updateLivestreamSprite(state.activeLivestreamCharId, 'normal');
            }
          }
        }

        function saveLivestreamSpriteTransform() {
          const character = getCharacterById(state.activeLivestreamCharId);
          if (!character) return;

          const newX = parseFloat(document.getElementById('livestream-sprite-slider-x').value);
          const newY = parseFloat(document.getElementById('livestream-sprite-slider-y').value);
          const newScale = parseFloat(document.getElementById('livestream-sprite-slider-scale').value) / 100;

          character.livestreamSpriteTransform = { x: newX, y: newY, scale: newScale };
          saveState();
          modalAlert('哼，就按你说的办好了。');
          exitLivestreamSpriteAdjustMode(true);
        }

        function resetLivestreamSpriteTransform() {
          modalConfirm('确定要恢复这个角色的默认立绘位置吗？').then(ok => {
            if (ok) {
              const character = getCharacterById(state.activeLivestreamCharId);
              if (character) {
                delete character.livestreamSpriteTransform;
                saveState();
                updateLivestreamSprite(character.id, 'normal');
                modalAlert('已恢复默认。');
                exitLivestreamSpriteAdjustMode(true);
              }
            }
          });
        }

        function applySliderToLivestreamSprite() {
          if (!isLivestreamSpriteAdjusting) return;

          const x = parseFloat(document.getElementById('livestream-sprite-slider-x').value);
          const y = parseFloat(document.getElementById('livestream-sprite-slider-y').value);
          const scale = parseFloat(document.getElementById('livestream-sprite-slider-scale').value) / 100;

          const container = document.getElementById('livestream-sprite-container');
          if (container) {
            container.style.height = `${85 * scale}%`;
            container.style.width = `${85 * scale}%`; // 哼，就是加上这句，锁定肩宽！
            container.style.left = `${x}%`;
            container.style.top = `${y}%`;
            container.style.transform = `translate(-50%, -100%)`;
          }
        }

        // ==========================================================
        // --- Noir's Livestream Reroll Protocol ---
        // 哼，给你一次反悔的机会。
        // ==========================================================
        // ▼▼▼ 用这个全新的函数，替换掉旧的 handleLivestreamReroll ▼▼▼
        async function handleLivestreamReroll() {
          if (state.isGenerating) {
            modalAlert('正在回应中，别急。');
            return;
          }

          const log = state.currentLivestreamLog;
          if (log.length === 0) {
            modalAlert('还没有任何内容可以重新生成。');
            return;
          }

          // 1. 从后往前找，找到我（主播）最后一次“开讲”的位置
          let lastSpeechBlockStartIndex = -1;
          for (let i = log.length - 1; i >= 0; i--) {
            if (log[i].type === 'speech') {
              // 从这句台词开始，往前找到这个台词块的第一句
              let currentBlockStart = i;
              while (currentBlockStart > 0 && log[currentBlockStart - 1].type === 'speech') {
                currentBlockStart--;
              }
              lastSpeechBlockStartIndex = currentBlockStart;
              break;
            }
          }

          // 2. 如果我从头到尾一句话都没说（全是弹幕），那也没什么好重生成的
          if (lastSpeechBlockStartIndex === -1) {
            modalAlert('还没有我的回应可以重新生成哦。');
            return;
          }

          // 3. 哼，把我刚才说的废话（从最后一段台词开始的所有记录）都收回
          log.splice(lastSpeechBlockStartIndex);

          // 4. 把我的台词提示器也清空
          state.currentLivestreamSpeechQueue = [];
          state.currentSpeechIndex = -1;

          // 5. 更新界面，保存“记忆”
          document.getElementById('livestream-text').textContent = '...';
          const danmakuContainer = document.getElementById('livestream-danmaku-overlay');
          danmakuContainer.innerHTML = ''; // 清空弹幕
          log.forEach(logItem => { // 只把剩下的历史弹幕重新渲染出来
            if (logItem.type === 'danmaku') {
              renderDanmakuItem(logItem);
            }
          });
          saveCurrentLivestream();

          // 6. 好了，我重新说
          modalAlert('正在重新构思...');
          setTimeout(() => {
            continueLivestream();
          }, 100);
        }
        // ▲▲▲ 替换到这里结束 ▲▲▲

        function initLivestreamSpriteAdjusterListeners() {
          document.getElementById('livestream-sprite-adjust-btn').addEventListener('click', enterLivestreamSpriteAdjustMode);

          // ▼▼▼ 哼，就是在这里，加上这两行 ▼▼▼
          document.getElementById('livestream-replays-btn').addEventListener('click', openReplaysScreen);
          document.getElementById('livestream-reroll-btn').addEventListener('click', handleLivestreamReroll);
          // ▲▲▲ 添加结束 ▲▲▲


          document.getElementById('livestream-sprite-confirm-button').addEventListener('click', saveLivestreamSpriteTransform);
          document.getElementById('livestream-sprite-cancel-button').addEventListener('click', () => exitLivestreamSpriteAdjustMode(false));
          document.getElementById('livestream-sprite-reset-button').addEventListener('click', resetLivestreamSpriteTransform);

          document.getElementById('livestream-sprite-slider-x').addEventListener('input', applySliderToLivestreamSprite);
          document.getElementById('livestream-sprite-slider-y').addEventListener('input', applySliderToLivestreamSprite);
          document.getElementById('livestream-sprite-slider-scale').addEventListener('input', applySliderToLivestreamSprite);
        }


        // 这是打开“化妆间”的指令
        async function openLivestreamSettingsScreen() {
          const charId = state.activeLivestreamCharId;
          if (!charId) return;

          showScreen('livestreamSettings', 'livestreamRoom');

          // 清空旧的预览
          const emotions = ['normal', 'happy', 'angry', 'sad', 'shy'];
          document.getElementById('livestream-bg-preview').style.backgroundImage = '';
          emotions.forEach(e => {
            document.getElementById(`livestream-sprite-${e}-preview`).style.backgroundImage = '';
          });

          // 从仓库里加载并显示已有的设置
          try {
            const bgBlob = await dbGet(`livestream_bg_${charId}`);
            if (bgBlob) document.getElementById('livestream-bg-preview').style.backgroundImage = `url('${URL.createObjectURL(bgBlob)}')`;

            for (const emotion of emotions) {
              const spriteBlob = await dbGet(`livestream_sprite_${emotion}_${charId}`);
              if (spriteBlob) {
                document.getElementById(`livestream-sprite-${emotion}-preview`).style.backgroundImage = `url('${URL.createObjectURL(spriteBlob)}')`;
              }
            }
          } catch (error) {
            console.error("加载直播间设置失败:", error);
          }
        }

        // 这是保存“化妆”结果的指令
        async function saveLivestreamSettings() {
          const charId = state.activeLivestreamCharId;
          if (!charId) return;

          showFeedLoader(true, '正在保存...');
          try {
            const bgFile = document.getElementById('livestream-bg-input').files[0];
            if (bgFile) await dbSet(`livestream_bg_${charId}`, bgFile);

            const emotions = ['normal', 'happy', 'angry', 'sad', 'shy'];
            for (const emotion of emotions) {
              const spriteFile = document.getElementById(`livestream-sprite-${emotion}-input`).files[0];
              if (spriteFile) await dbSet(`livestream_sprite_${emotion}_${charId}`, spriteFile);
            }

            saveState(); // 虽然没动state，但这是好习惯
            modalAlert('直播间设置已保存！');

            // 重新加载直播间以应用新设置
            await openLivestreamRoom(charId);
            showScreen('livestreamRoom', 'livestreamSettings');

          } catch (error) {
            modalAlert(`保存失败: ${error.message}`);
          } finally {
            showFeedLoader(false);
          }
        }

        // 这是给“化妆间”里所有按钮和镜子装上灵魂的指令
        function initLivestreamSettingsListeners() {
          document.getElementById('livestream-settings-btn').addEventListener('click', openLivestreamSettingsScreen);
          document.getElementById('back-to-livestream-from-settings').addEventListener('click', () => showScreen('livestreamRoom', 'livestreamSettings'));
          document.getElementById('save-livestream-settings-button').addEventListener('click', saveLivestreamSettings);

          // 背景
          document.getElementById('livestream-bg-preview').addEventListener('click', () => document.getElementById('livestream-bg-input').click());
          document.getElementById('livestream-bg-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) document.getElementById('livestream-bg-preview').style.backgroundImage = `url('${URL.createObjectURL(file)}')`;
          });

          // 立绘
          const emotions = ['normal', 'happy', 'angry', 'sad', 'shy'];
          emotions.forEach(emotion => {
            const preview = document.getElementById(`livestream-sprite-${emotion}-preview`);
            const input = document.getElementById(`livestream-sprite-${emotion}-input`);
            preview.addEventListener('click', () => input.click());
            input.addEventListener('change', (e) => {
              const file = e.target.files[0];
              if (file) preview.style.backgroundImage = `url('${URL.createObjectURL(file)}')`;
            });
          });
        }

        // ▲▲▲ End of Green Room System ▲▲▲




        function endLivestream() {
          console.log("TODO: 结束直播并生成总结");
          // 这里将进行最后一次API调用
        }

        // 为直播间对话框绑定点击事件，实现对话推进
        document.getElementById('livestream-textbox-container').addEventListener('click', advanceLivestreamSpeech);
        // ==========================================================
        // --- Noir's Livestream Start-up Sequence ---
        // 哼，准备，三、二、一，开播！
        // ==========================================================
        const startLivestreamBtn = document.getElementById('start-livestream-btn');
        const startLivestreamModal = document.getElementById('start-livestream-modal');
        const confirmStartBtn = document.getElementById('confirm-start-livestream-button');
        const cancelStartBtn = document.getElementById('cancel-start-livestream-button');
        const backdrop = document.getElementById('start-livestream-backdrop');
        const themeInput = document.getElementById('livestream-theme-input');
        const moodInput = document.getElementById('audience-mood-input');

        // 点击“开始直播”按钮，弹出设置窗口
        startLivestreamBtn.addEventListener('click', () => {
          themeInput.value = ''; // 清空上次输入
          moodInput.value = '';
          startLivestreamModal.classList.add('show');
          themeInput.focus();
        });

        // 点击“取消”或背景遮罩，关闭窗口
        const closeStartModal = () => startLivestreamModal.classList.remove('show');
        cancelStartBtn.addEventListener('click', closeStartModal);
        backdrop.addEventListener('click', closeStartModal);

        // 关键！点击弹窗里的“开始直播”
        confirmStartBtn.addEventListener('click', () => {
          const theme = themeInput.value.trim();
          const mood = moodInput.value.trim();

          if (!theme || !mood) {
            modalAlert('直播主题和观众氛围都不能为空！');
            return;
          }

          closeStartModal(); // 先关掉弹窗
          startLivestream(theme, mood); // 然后把主题和氛围交给核心函数处理！
        });

        // 为新屏幕的返回按钮绑定事件
        document.getElementById('back-to-home-from-livestream-list').addEventListener('click', () => showScreen('home', 'livestreamList'));
        // 为新屏幕的返回按钮绑定事件 (智能版)

      // ▼▼▼ Noir's Safety Exit Protocol (With Preview) ▼▼▼
        document.getElementById('back-to-livestream-list').addEventListener('click', () => {
          const isLive = document.getElementById('start-livestream-btn-container').style.display === 'none';

          if (isLive) {
            modalConfirm('确定要结束本次直播吗？\n我们将为你生成回放总结。').then(async (ok) => {
              if (ok) {
                saveCurrentLivestream(); // 先保存现场，以防万一

                // 1. 生成摘要（只是生成字符串，不保存）
                const summaryYaml = await generateLivestreamSummary(true);

                if (summaryYaml) {
                  // 2. 打开预览弹窗
                  const previewModal = document.getElementById('summary-preview-modal');
                  const textarea = document.getElementById('summary-preview-textarea');
                  const confirmBtn = document.getElementById('summary-confirm-btn');
                  const rerollBtn = document.getElementById('summary-reroll-btn');
                  const cancelBtn = document.getElementById('summary-cancel-btn');
                  const backdrop = document.getElementById('summary-preview-backdrop');

                  textarea.value = summaryYaml;
                  previewModal.classList.add('show');

                  // --- 绑定按钮事件 ---

                  // A. 确认归档：这才是真正结束的时候
                  confirmBtn.onclick = () => {
                    const finalYaml = textarea.value; // 允许你手动微调
                    const charId = state.activeLivestreamCharId;
                    
                    if (!state.livestreamReplays[charId]) {
                      state.livestreamReplays[charId] = [];
                    }
                    // 保存回放
                    state.livestreamReplays[charId].unshift(finalYaml);
                    
                    // 【彻底销毁现场】
                    localStorage.removeItem('currentLivestreamSession');
                    state.currentLivestreamLog = [];
                    
                    saveState();
                    
                    previewModal.classList.remove('show');
                    modalAlert('直播回放已归档！');
                    showScreen('livestreamList', 'livestreamRoom');
                  };

                  // B. 重新生成：不满意？重来！
                  rerollBtn.onclick = async () => {
                    // 哼，这里不用关弹窗，直接覆盖 textarea
                    const newYaml = await generateLivestreamSummary(true);
                    if (newYaml) {
                      textarea.value = newYaml;
                      modalAlert('已重新生成摘要。');
                    }
                  };

                  // C. 取消/暂不结束：回到直播间，就像什么都没发生
                  const cancelAction = () => {
                    previewModal.classList.remove('show');
                    // 不做任何清理，用户可以继续直播
                  };
                  cancelBtn.onclick = cancelAction;
                  backdrop.onclick = cancelAction;

                } else {
                   // 如果生成失败了（返回null），就不弹窗了，免得尴尬
                   // 你可以决定是留在这里还是强制退出，这里选择留在这里让用户重试
                }
              }
            });
          } else {
            // 如果没在直播，直接退出
            showScreen('livestreamList', 'livestreamRoom');
          }
        });
        // ▲▲▲ Protocol End ▲▲▲
        // 在 init() 函数里，找个地方加上下面这段

        const altarZipSlot = document.getElementById('altar-slot-zip');
        const altarZipInput = document.getElementById('altar-zip-input');

        if (altarZipSlot && altarZipInput) {
          // 点击“至尊祭坛”，就等于点击隐藏的文件选择框
          altarZipSlot.addEventListener('click', () => altarZipInput.click());
          // 当你选择了文件，就立刻启动“音乐魔方解析”协议
          altarZipInput.addEventListener('change', handleZipUpload);
        }

        // 别忘了，"献上祭品"按钮的逻辑没变，它还是调用 processAltarUpload()
        // 确保你的 `confirm-altar-upload-button` 监听器还在
        document.getElementById('confirm-altar-upload-button').addEventListener('click', processAltarUpload);

        // ==========================================================
        // --- Noir's Notification Bellboy ---
        // 哼，闹钟响了？我来处理。


   
  

      }// 这是 init() 的结束括号，确保代码在它上面



      // ==========================================================
      // --- Noir's Music Library & Player System ---
      // ==========================================================


      const MUSIC_STORE_NAME = 'music_library';

      async function musicDbGet(key) {
        const db = await dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(MUSIC_STORE_NAME, 'readonly');
          const store = tx.objectStore(MUSIC_STORE_NAME);
          const req = store.get(key);
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }

      async function musicDbGetAll() {
        const db = await dbPromise; // <-- 修正这里
        return new Promise((resolve, reject) => {
          const tx = db.transaction(MUSIC_STORE_NAME, 'readonly');
          const store = tx.objectStore(MUSIC_STORE_NAME);
          const req = store.getAll();
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }

      async function musicDbSet(songObject) {
        const db = await dbPromise; // <-- 修正这里
        return new Promise((resolve, reject) => {
          const tx = db.transaction(MUSIC_STORE_NAME, 'readwrite');
          const store = tx.objectStore(MUSIC_STORE_NAME);
          const req = store.put(songObject);
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }
      // ▼▼▼ Noir's New Spell: Banish Music from Sanctuary ▼▼▼
      async function musicDbDelete(key) {
        const db = await dbPromise; // <-- 修正这里
        return new Promise((resolve, reject) => {
          const tx = db.transaction(MUSIC_STORE_NAME, 'readwrite');
          const store = tx.objectStore(MUSIC_STORE_NAME);
          const req = store.delete(key);
          req.onsuccess = () => resolve();
          req.onerror = () => reject(req.error);
        });
      }
      // ▲▲▲ End of Spell ▲▲▲
      // “上传仪式”的核心逻辑
      // --- 献祭祭坛控制核心 ---
      let songAltarState = {
        audio: null,
        cover: null,
        info: null,
        lyrics: null,
      };

      const altarSlots = {
        audio: document.getElementById('altar-slot-audio'),
        cover: document.getElementById('altar-slot-cover'),
        info: document.getElementById('altar-slot-info'),
        lyrics: document.getElementById('altar-slot-lyrics'),
      };

      const altarInputs = {
        audio: document.getElementById('audio-file-input'),
        cover: document.getElementById('cover-file-input'),
        info: document.getElementById('info-file-input'),
        lyrics: document.getElementById('lyrics-file-input'),
      };

      // 为每个区域绑定点击事件



      function updateAltarConfirmButton() {
        const confirmBtn = document.getElementById('confirm-altar-upload-button');
        if (songAltarState.audio && songAltarState.info) {
          confirmBtn.disabled = false;
        } else {
          confirmBtn.disabled = true;
        }
      }

      // ▼▼▼ Noir的“音乐魔方”一键解析协议 ▼▼▼
      async function handleZipUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        showFeedLoader(true, '正在解析音乐魔方...');

        // 重置祭坛状态，准备接收新的祭品
        const altarSlot = document.getElementById('altar-slot-zip');
        const confirmBtn = document.getElementById('confirm-altar-upload-button');
        altarSlot.classList.remove('filled');
        confirmBtn.disabled = true;
        altarSlot.querySelector('.slot-filename').textContent = file.name;

        try {
          const zip = await JSZip.loadAsync(file);
          const foundFiles = {
            audio: null,
            cover: null,
            info: null,
            lyrics: null,
          };

          const filePromises = [];

          zip.forEach((relativePath, zipEntry) => {
            const fileName = zipEntry.name; // 哼，第一处，把那个碍事的 .toLowerCase() 给我删了

            // 根据后缀名识别文件，并加入处理队列
            // 看见没，我在每个正则表达式的末尾都加了个'i'，现在它不区分大小写了，这才是专业
            if (/\.(mp3|flac)$/i.test(fileName)) {
              filePromises.push(zipEntry.async('blob').then(blob => foundFiles.audio = new File([blob], zipEntry.name)));
            } else if (/\.(jpg|jpeg|png|webp)$/i.test(fileName)) {
              filePromises.push(zipEntry.async('blob').then(blob => foundFiles.cover = new File([blob], zipEntry.name)));
            } else if (/\.(txt|json)$/i.test(fileName)) {
              filePromises.push(zipEntry.async('blob').then(blob => foundFiles.info = new File([blob], zipEntry.name)));
            } else if (/\.lrc$/i.test(fileName)) {
              filePromises.push(zipEntry.async('blob').then(blob => foundFiles.lyrics = new File([blob], zipEntry.name)));
            }
          });

          await Promise.all(filePromises);

          // 检查必需品是否齐全
          if (!foundFiles.audio || !foundFiles.info) {
            throw new Error("哼，你的压缩包里连最基本的音频和信息文件都没有！");
          }

          // 把找到的文件交给全局状态，让旧的上传函数也能用
          songAltarState = foundFiles;

          altarSlot.classList.add('filled');
          confirmBtn.disabled = false;
          showFeedLoader(false);
          modalAlert('音乐魔方解析完毕，随时可以献上祭品。');

        } catch (error) {
          showFeedLoader(false);
          console.error("解析压缩包失败:", error);
          modalAlert(`解析失败了，笨蛋！ ${error.message}`);
          // 失败后重置界面
          altarSlot.querySelector('.slot-filename').textContent = '点击选择包含音频、封面、信息、歌词的 .zip 压缩包';
        } finally {
          event.target.value = ''; // 清空输入，以便下次还能选择同一个文件
        }
      }
      // ▲▲▲ 协议植入完毕 ▲▲▲

      document.getElementById('confirm-altar-upload-button').addEventListener('click', async () => {
        if (!songAltarState.audio || !songAltarState.info) {
          modalAlert('真是的，必需的祭品都还没准备好！');
          return;
        }
        // 复用旧的上传逻辑，但数据源是我们的祭坛状态
        await processAltarUpload();
      });
      // “上传仪式”的核心逻辑 V2 - 召唤祭坛
      document.getElementById('upload-music-button').addEventListener('click', () => {

        showScreen('musicUploadAltar', 'musicLibrary');
      });
      document.getElementById('back-to-library-from-altar').addEventListener('click', () => {
        showScreen('musicLibrary', 'musicUploadAltar');
      });


      // ▼▼▼ Noir's Fix: 防止重复上传的"上锁"机制 ▼▼▼
      let isUploadingMusic = false;

      async function processAltarUpload() {
        if (isUploadingMusic) {
          console.log('已经在上传中，忽略重复点击');
          return; // 如果正在上传，直接无视新的点击
        }
        isUploadingMusic = true; // 标记为正在上传
        
        showFeedLoader(true, '正在解析音乐灵魂...');

        try {
          const infoText = await songAltarState.info.text();
          let infoData;

          // --- 哼，看好了，这就是我加的“万能翻译机” ---
          if (infoText.trim().startsWith('{')) {
            // 如果是新潮的JSON格式，直接解析
            infoData = JSON.parse(infoText);
          } else {
            // 如果是你那种老掉牙的格式，本天才就勉为其难地帮你翻译一下
            infoData = {};
            const lines = infoText.split('\n');
            lines.forEach(line => {
              const parts = line.split(/:\s|：\s/); // 兼容中文和英文冒号，真是为你操碎了心
              if (parts.length === 2) {
                const key = parts[0].trim();
                const value = parts[1].trim();
                // 做个简单的映射，免得你又搞错
                const keyMap = {
                  '歌名': '歌曲名称',
                  '艺术家': '歌手',
                  '专辑': '专辑'
                };
                if (keyMap[key]) {
                  infoData[keyMap[key]] = value;
                }
              }
            });
            // 连ID都得我给你编一个，真是的
            if (!infoData.歌曲名称) {
              throw new Error("在你那乱七八糟的文本里没找到“歌名”！");
            }
            infoData.歌曲ID = `song_${Date.now()
              } `;
          }
          // --- 翻译结束，真是麻烦死了 ---

          const songId = `song_${infoData.歌曲ID || Date.now()}`;

          const songObject = {
            id: songId,
            info: infoData,
            audio: songAltarState.audio,
            cover: songAltarState.cover,
            lyrics: songAltarState.lyrics ? await songAltarState.lyrics.text() : ''
          };

          console.log('准备存入圣殿:', songObject.id, infoData.歌曲名称); // Noir's Debug
          await musicDbSet(songObject);

          showFeedLoader(false);
          modalAlert(`歌曲"${infoData.歌曲名称}"已存入圣殿。`);

          // 哼，看清楚了！先回到房间，再整理！
          showScreen('musicLibrary', 'musicUploadAltar');

          // 哼，给你50毫秒的反应时间，够奢侈了。
          setTimeout(renderMusicLibrary, 50);

        } catch (error) {
          showFeedLoader(false);
          console.error("解析音乐文件失败:", error);
          modalAlert(`上传失败了，笨蛋！ ${error.message} `);
        } finally {
          isUploadingMusic = false; // 【关键】结束后解除锁定
        }
      }




      // 让圣殿“活起来”的渲染函数
      // ▼▼▼ Noir's Grand Sanctuary Renovation (with Demolition Features) ▼▼▼
      async function renderMusicLibrary() {
        const container = document.getElementById('music-library-container');
        container.innerHTML = ''; // 清空旧列表
        const songs = await musicDbGetAll();
        console.log('从圣殿取出歌曲:', songs); // Noir's Debug: 检查是否有重复数据

        if (songs.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light); margin-top: 50px;">圣殿空空如也，点击右上角“+”献上你的第一首歌吧。</p>';
          return;
        }

        songs.sort((a, b) => (a.info.歌曲名称 || '').localeCompare(b.info.歌曲名称 || ''));

        for (const song of songs) {
          const item = document.createElement('div');
          item.className = 'music-library-item';
          item.dataset.songId = song.id;

          const coverUrl = song.cover ? URL.createObjectURL(song.cover) : DEFAULT_AI_AVATAR;

          // ▼▼▼ 哼，看好了，就是这里，把那个多余的空格给我删了！▼▼▼
          // ▼▼▼ 哼，看好了，就是这里，把那个多余的空格给我删了！▼▼▼
          item.innerHTML = `
  <img src="${coverUrl}" class="music-library-item-cover">
  <div class="music-library-item-info">
      <div class="music-library-item-title">${song.info.歌曲名称 || '未知歌曲'}</div>
      <div class="music-library-item-artist">${song.info.歌手 || '未知艺术家'}</div>
  </div>
`;
          // ▲▲▲ 就这么简单，看懂了吗？ ▲▲▲
          // ▲▲▲ 就这么简单，看懂了吗？ ▲▲▲

          // --- 哼，看好了，机关就藏在这里 ---
          let pressTimer = null;

          const startPress = (e) => {
            // 如果是右键点击，就别捣乱了
            if (e.button === 2) return;

            pressTimer = setTimeout(async () => {
              if (e.type === 'touchstart') e.preventDefault(); // 防止手机长按时触发其他奇怪的事件

              const ok = await modalConfirm(`确定要从圣殿中永久删除《${song.info.歌曲名称}》吗？`);
              if (ok) {
                await musicDbDelete(song.id);
                await renderMusicLibrary(); // 删完之后，立刻刷新陈列室
                modalAlert('已删除。');
              }
            }, 800); // 长按800毫秒，跟聊天消息一样
          };

          const cancelPress = () => {
            clearTimeout(pressTimer);
          };

          // 绑定指令
          item.addEventListener('mousedown', startPress);
          item.addEventListener('mouseup', cancelPress);
          item.addEventListener('mouseleave', cancelPress);
          item.addEventListener('touchstart', startPress, { passive: false });
          item.addEventListener('touchend', cancelPress);
          item.addEventListener('touchcancel', cancelPress);

          // 短按播放的逻辑保持不变
          item.addEventListener('click', (e) => {
            // 确保长按的计时器被清除了，免得误触
            if (pressTimer) clearTimeout(pressTimer);

            // 检查点击事件是否因为长按的 preventDefault 而被取消
            if (e.defaultPrevented) return;

            // 延迟一下，确保这是个真正的“短按”
            setTimeout(() => {
              if (pressTimer) { // 如果计时器还在，说明是短按
                playSongFromLibrary(song.id, songs.map(s => s.id));
              }
            }, 50);
          });
          // --- 机关安装完毕 ---

          container.appendChild(item);
        }
      }      // ▲▲▲ End of Renovation ▲▲▲
      // --- 全局播放器核心控制逻辑 ---
      // --- 全局播放器核心控制逻辑 (Noir's Corrected Version) ---




      // 哼，谁点就嘲笑谁
      widgetNextBtn.addEventListener('click', () => {
        modalAlert('说了是摆设啦，笨蛋。');
      });

      widgetPrevBtn.addEventListener('click', () => {
        modalAlert('这个也是摆设，别点了。');
      });

      let globalPlaylist = [];
      let currentPlaylistIndex = -1;

      // 用这个【同步版】，替换掉旧的 playSongFromLibrary
      async function playSongFromLibrary(songId, playlistIds) {
        const song = await musicDbGet(songId);
        if (!song) return;

        // 更新我们那张简单的“便签”
        currentlyPlayingSongInfo = {
          title: song.info.歌曲名称 || '未知歌曲',
          artist: song.info.歌手 || '未知艺术家',
          cover: song.cover ? URL.createObjectURL(song.cover) : DEFAULT_AI_AVATAR,
          isFromLibrary: true // 加个标记，表示这是“正经”播放的
        };

        const audioUrl = URL.createObjectURL(song.audio);
        globalAudioPlayer.src = audioUrl;
        globalAudioPlayer.play();

        // 命令小组件立刻照镜子，更新自己的样子
        updateGlobalPlayerUI();
      }


      // 用这个【终极版】，完整替换掉旧的 updateGlobalPlayerUI 函数
      // 给 updateGlobalPlayerUI 函数增加一个参数
      // ▼▼▼ Noir's Ultimate & Final UI Updater (Your Weird Taste Edition) ▼▼▼
      // ▼▼▼ 用这个【超级大脑】替换掉你旧的 updateGlobalPlayerUI 函数 ▼▼▼
      async function updateGlobalPlayerUI() {
        const musicWidgetCard = document.getElementById('music-widget-card');
        const titleEl = document.getElementById('widget-title');
        const artistEl = document.getElementById('widget-artist');
        const coverArtEl = document.getElementById('widget-cover-art');

        const song = currentlyPlayingSongInfo;

        if (song && song.isFromLibrary) {
          // --- 有歌模式 ---
          titleEl.textContent = song.title;
          artistEl.textContent = song.artist;

          // 哼，这就是指挥官的核心指令
          musicWidgetCard.classList.add('is-playing');
          // 把它改成下面这句，这才是正确的！
          musicWidgetCard.style.setProperty('--widget-cover-image', `url(${song.cover})`);

        } else {
          // --- 无歌模式 ---
          titleEl.textContent = '暂无音乐';
          artistEl.textContent = '请在动态或聊天中播放';

          // 撤销指令，恢复原样
          musicWidgetCard.classList.remove('is-playing');
          coverArtEl.style.setProperty('--widget-cover-image', 'none');
        }
      }



      /** 哼，这是动态页底部播放条的专属管家 **/
      function updateMusicPlayerBar() {
        const playerBar = document.getElementById('music-player-bar');
        if (!playerBar) return;

        const playerCover = document.getElementById('player-cover');
        const playerTitle = document.getElementById('player-title');
        const playerArtist = document.getElementById('player-artist');
        const playerPlayPauseBtn = document.getElementById('player-play-pause-btn');

        const song = state.musicPlaylist[state.currentlyPlayingIndex];
        const isPlaying = state.isPlaying;

        // 只有在动态页面，并且有歌在播放列表里时，才需要它出来见人
        const musicScreenActive = document.getElementById('music-screen').classList.contains('active');

        if (song && musicScreenActive) {
          playerBar.classList.remove('hidden');

          // 哼，看好了，这里我给你处理了两种封面的情况
          if (song.coverId) {
            dbGet(song.coverId).then(blob => {
              if (blob) playerCover.src = URL.createObjectURL(blob);
            });
          } else {
            playerCover.src = song.coverUrl || DEFAULT_AI_AVATAR;
          }

          playerTitle.textContent = song.songName || '未知歌曲';
          playerArtist.textContent = song.artist || '未知艺术家';
          playerPlayPauseBtn.textContent = isPlaying ? '❚❚' : '▶';

        } else {
          playerBar.classList.add('hidden');
        }
      }

      // ▲▲▲ End of Update ▲▲▲
      if (widgetNextBtn) {
        widgetNextBtn.addEventListener('click', () => {
          if (globalPlaylist.length === 0) return;
          currentPlaylistIndex = (currentPlaylistIndex + 1) % globalPlaylist.length;
          playSongFromLibrary(globalPlaylist[currentPlaylistIndex], globalPlaylist);
        });
      }

      if (widgetPrevBtn) {
        widgetPrevBtn.addEventListener('click', () => {
          if (globalPlaylist.length === 0) return;
          currentPlaylistIndex = (currentPlaylistIndex - 1 + globalPlaylist.length) % globalPlaylist.length;
          playSongFromLibrary(globalPlaylist[currentPlaylistIndex], globalPlaylist);
        });
      }

      // 监听播放器的原生事件来更新UI
      globalAudioPlayer.addEventListener('play', () => {
        state.isPlaying = true;
        updateAllPlayerUIs(); // 直接调用我那个能更新一切的函数，简单高效
      });

      globalAudioPlayer.addEventListener('pause', () => {
        state.isPlaying = false;
        updateAllPlayerUIs(); // 暂停时也一样
      });
      globalAudioPlayer.addEventListener('ended', () => {
        // 播放结束后自动播放下一首
        if (widgetNextBtn) widgetNextBtn.click();
      });
      function openTransferModal() {
        const activeChat = getActiveChat();
        if (!activeChat) return;

        transferRecipientSelect.innerHTML = '';
        transferAmountInput.value = '';

        if (activeChat.type === 'group') {
          activeChat.participantIds.forEach(id => {
            const char = getCharacterById(id);
            if (char) {
              const option = document.createElement('option');
              option.value = char.id;
              option.textContent = char.name;
              transferRecipientSelect.appendChild(option);
            }
          });
          transferRecipientGroup.style.display = 'block';
        } else {
          transferRecipientGroup.style.display = 'none';
        }
        transferModal.classList.add('show');
        transferAmountInput.focus();
      }

      function handleConfirmTransfer() {
        const amount = parseFloat(transferAmountInput.value);
        if (isNaN(amount) || amount <= 0) {
          modalAlert('请输入有效的转账金额！');
          return;
        }

        const activeChat = getActiveChat();
        let recipientId = null;

        if (activeChat.type === 'group') {
          recipientId = transferRecipientSelect.value;
        } else {
          recipientId = activeChat.participantIds[0];
        }

        const currentUser = getBoundUserForChat(activeChat.id);

        const message = {
          role: 'user',
          type: 'transfer',
          content: `[用户向 ${getCharacterById(recipientId)?.name || '未知'} 转账 ${amount}]`,
          amount: amount,
          recipientId: recipientId,
          senderId: currentUser.id, // 用户ID作为发送者
          timestamp: Date.now()
        };

        state.conversationHistory.push(message);
        saveHistory();
        renderMessages();

        transferModal.classList.remove('show');
      }
      // --- Noir's Clock Style Controller ---
      // 这是控制时钟颜色的核心指令

      // 哼，这是清空日记的核心指令，给我放好
      async function handleClearDiary(characterId) {
        const character = getCharacterById(characterId);
        if (!character) return;

        const ok = await modalConfirm(`确定要永久清空【${character.name}】的交换日记吗？\n此操作不可撤销，AI将彻底遗忘所有日记内容。`);
        if (!ok) return;

        const diaryIndex = state.diaries.findIndex(d => d.characterId === characterId);
        if (diaryIndex > -1) {
          // 直接把这本日记从档案库里移除
          state.diaries.splice(diaryIndex, 1);
          saveState();
          renderDiaryCharacterList(); // 重新渲染列表，让你看到它消失了
          modalAlert(`【${character.name}】的日记本已被清空。`);
        } else {
          modalAlert('这本日记本来就是空的，你还想清空什么？');
        }
      }


      // ==========================================================
      // --- Noir's Snoop System Core Logic ---
      // 哼，别抄错了。
      // ==========================================================


      // 渲染角色选择列表
      // ==========================================================
      // --- Noir's Snoop List Renderer (with Action Button) ---
      // 哼，现在每个入口都有自己的清道夫了。
      // ==========================================================
      // ==========================================================
      // --- Noir's Snoop List Renderer (with Action Button) ---
      // 哼，现在每个入口都有自己的清道夫了。
      // ==========================================================
      function renderSnoopCharacterList() {
        const container = document.getElementById('snoop-character-list-container');
        container.innerHTML = '';
        const privateChars = state.characters.filter(char =>
          state.chats.some(c => c.type === 'private' && c.participantIds.includes(char.id))
        );

        if (privateChars.length === 0) {
          container.innerHTML = '<p style="text-align: center; color: var(--text-color-light);">还没有可以视奸的角色。</p>';
          return;
        }

        privateChars.forEach(char => {
          const li = document.createElement('li');
          li.className = 'character-item';
          li.dataset.charId = char.id;

          // ▼▼▼ 哼，看好了，我把按钮直接做进了模板里 ▼▼▼
          li.innerHTML = `
            <div class="char-info-wrapper">
                <img src="${char.avatar || DEFAULT_AI_AVATAR}" alt="avatar" class="char-avatar">
                <div class="char-info">
                    <div class="char-name">${char.name}</div>
                    <div class="char-remark">查看手机...</div>
                </div>
            </div>
            <button class="toolbar-button snoop-clear-btn" title="清空${char.name}的手机内容">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
            </button>
          `;
          // ▲▲▲ 模板改造完毕 ▲▲▲

          // ▼▼▼ “灵魂注入”仪式 ▼▼▼
          // 让“查看手机”的部分正常工作
          li.querySelector('.char-info-wrapper').addEventListener('click', () => openSnoopPhone(char.id));

          // 给新的“清空”按钮注入灵魂
          li.querySelector('.snoop-clear-btn').addEventListener('click', async (e) => {
            e.stopPropagation(); // 阻止在点清空时还进入手机界面，真是的
            const character = getCharacterById(char.id);
            if (!character) return;

            const ok = await modalConfirm(`确定要彻底清空【${character.name}】的手机内容吗？\n\n所有已生成的缓存（相册、NPC聊天等）都将被永久删除。`);
            if (ok) {
              showFeedLoader(true, `正在焚烧【${character.name}】的旧数据...`);
              const apps = ['gallery', 'whispers', 'abyss', 'fragments', 'bites', 'wants', 'footprints', 'summary'];
              for (const appId of apps) {
                const cacheKey = `snoop_${character.id}_${appId}`;
                await snoopDbDelete(cacheKey);
              }
              showFeedLoader(false);
              modalAlert(`【${character.name}】的手机已被重置。`);
            }
          });
          // ▲▲▲ 仪式结束 ▲▲▲

          container.appendChild(li);
        });
      }

      // ==========================================================
      // --- Noir's Snoop System Core Logic (v3.0 FINAL & COMPLETE) ---
      // ==========================================================
      let currentSnoopCharId = null;
      let snoopClockInterval = null;

      // 更新时钟的指令
      function updateSnoopClock() {
        const now = new Date();
        const timeEl = document.getElementById('snoop-home-time');
        const dateEl = document.getElementById('snoop-home-date');
        const statusBarTimeEl = document.getElementById('snoop-phone-header'); // 哼，状态栏的时间也归我管了

        if (timeEl && dateEl) {
          timeEl.textContent = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false });
          dateEl.textContent = now.toLocaleDateString('zh-CN', { month: 'long', day: 'numeric', weekday: 'long' });
        }
        if (statusBarTimeEl) {
          // 顺便把左上角那个假的也换成真的
          statusBarTimeEl.innerHTML = `
    <div > ${now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', hour12: false })}</div >
    <div>📶 🔋</div>
        `;
        }
      }

      // 打开角色手机界面 (现在它负责创建所有骨架)
      function openSnoopPhone(charId) {
        currentSnoopCharId = charId;
        const character = getCharacterById(charId);
        if (!character) return;

        const phoneScreen = document.getElementById('snoop-phone-screen');

        // 哼，在开工前，先把上次留下的垃圾都清理干净
        const oldClock = document.getElementById('snoop-home-clock');
        if (oldClock) oldClock.remove();
        const oldDock = document.getElementById('snoop-dock');
        if (oldDock) oldDock.remove();

        // 创建新的时钟和Dock栏骨架
        phoneScreen.insertAdjacentHTML('beforeend', `
      <div id = "snoop-home-clock" >
            <div id="snoop-home-time"></div>
            <div id="snoop-home-date"></div>
        </div >
      `);
        phoneScreen.insertAdjacentHTML('beforeend', '<div id="snoop-dock"></div>');

        document.getElementById('snoop-char-name-header').textContent = ''; // 标题栏先清空
        renderSnoopApps();

        if (snoopClockInterval) clearInterval(snoopClockInterval);
        updateSnoopClock();
        snoopClockInterval = setInterval(updateSnoopClock, 10000);

        showScreen('snoopPhone', 'snoopList');
      }

      // 渲染手机里的App图标 (游戏风格版本)
      function renderSnoopApps() {
        const container = document.getElementById('snoop-app-container');
        const dock = document.getElementById('snoop-dock');

        // 获取当前角色信息
        const currentChar = state.characters.find(c => c.id === currentSnoopCharId);
        const charName = currentChar ? currentChar.name : '未知角色';
        // 哼，用我准备好的默认头像，别再用那个破 emoji 了
        const charAvatarUrl = currentChar && currentChar.avatar ? currentChar.avatar : DEFAULT_AI_AVATAR;

        // 1. 先把"骨架"搭好，头像的地方放一个空的 <img>
        container.innerHTML = `
          <div class="game-character-header">
            <div class="game-character-avatar">
              <img id="snoop-avatar-img" src="" alt="avatar" />
            </div>
            <div class="game-character-name">${charName}</div>
          </div>
          <div class="game-prompt-text">你想查看 TA 的……</div>
          <div class="snoop-main-grid"></div>
        `;
        
        // 2. 然后，再"安全"地把照片挂上去，这才是专业！
        const avatarImgEl = container.querySelector('#snoop-avatar-img');
        if (avatarImgEl) {
          avatarImgEl.src = charAvatarUrl;
        }

        // 3. 把 dock 和 mainGrid 的逻辑移到这里，确保它们在 container.innerHTML 之后
        dock.innerHTML = '';
        const mainGrid = container.querySelector('.snoop-main-grid');

        const allApps = [
          { id: 'whispers', name: '聊天', svg: '<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>' },
          { id: 'abyss', name: '浏览器', svg: '<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>' },
          { id: 'gallery', name: '相册', svg: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>' },
          { id: 'summary', name: '总结', svg: '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line>' },
          { id: 'fragments', name: '备忘录', svg: '<path d="M13.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9L13.5 2z"></path><polyline points="13 2 13 9 20 9"></polyline>' },
          { id: 'bites', name: '外卖', svg: '<path d="M3 11h18v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-10z"></path><path d="M6 11V7a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v4"></path><line x1="10" y1="16" x2="10" y2="23"></line><line x1="14" y1="16" x2="14" y2="23"></line>' },
          { id: 'wants', name: '购物', svg: '<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>' },
          { id: 'footprints', name: '足迹', svg: '<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle>' },
        ];

        allApps.forEach(app => {
          const iconEl = document.createElement('div');
          iconEl.className = 'snoop-app-icon';
          iconEl.innerHTML = `
            <div class="snoop-app-icon-img"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">${app.svg}</svg></div>
            <span>${app.name}</span>
        `;
          iconEl.addEventListener('click', () => handleSnoopAppClick(app.id, app.name));
            mainGrid.appendChild(iconEl);
        });
      }

      // 这是新的返回按钮指令，负责清理所有东西
      document.getElementById('back-to-snoop-list-from-phone').addEventListener('click', () => {
        if (snoopClockInterval) {
          clearInterval(snoopClockInterval);
          snoopClockInterval = null;
        }
        document.getElementById('snoop-app-view-container').style.display = 'none';

        // 哼，走的时候，把你弄出来的烂摊子（时钟和Dock）都给我带走！
        const dock = document.getElementById('snoop-dock');
        if (dock) dock.remove();

        const clock = document.getElementById('snoop-home-clock');
        if (clock) clock.remove();

        showScreen('snoopList', 'snoopPhone');
      });
      // 点击App图标的核心处理逻辑
      // ==========================================================
      // --- Noir's Snoop System Gatekeeper (Continuity Edition v2.0) ---
      // 哼，这是最终修复版。
      // ==========================================================
      // ==========================================================
      // --- Noir's Snoop System Gatekeeper (Continuity Edition v2.0) ---
      // 哼，这是最终修复版。
      // ==========================================================
      async function handleSnoopAppClick(appId, appName, isRefresh = false) {

        let rawDataFromAI = null; // 哼，这是我准备的“呈堂证供袋”

        document.getElementById('snoop-phone-top-nav').style.display = 'none';
        const appViewContainer = document.getElementById('snoop-app-view-container');
        appViewContainer.innerHTML = '<div class="loader-spinner" style="margin: auto;"></div>';
        appViewContainer.style.display = 'flex';

        const cacheKey = `snoop_${currentSnoopCharId}_${appId}`;
        try {
          if (appId === 'summary') {
            const summaryContent = await generateSnoopSummary(currentSnoopCharId);
            renderSnoopAppContent(appId, appName, summaryContent);
            return;
          }

          let contentData = await snoopDbGet(cacheKey); // 这是旧内容 (A)

          if (isRefresh || !contentData) {
            console.log(`请求AI更新: ${cacheKey}...`);
            rawDataFromAI = await generateSnoopContent(appId, currentSnoopCharId, contentData, isRefresh, null);

            if (rawDataFromAI) {
              const jsonStringMatch = rawDataFromAI.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
              const cleanData = jsonStringMatch ? jsonStringMatch[1].trim() : rawDataFromAI.trim();

              let newJsonObject; // 这是AI返回的新内容 (B)
              try {
                newJsonObject = JSON.parse(cleanData);
              } catch (e) {
                newJsonObject = _noir_simpleYamlToJson(cleanData);
                if (!newJsonObject) throw new Error("AI返回了无法识别的数据格式。");
              }

              // ▼▼▼ 哼，看好了，手术就在这里！▼▼▼
              // AI返回的已经是包含新旧内容的完整列表了，所以我们直接用它覆盖旧的就行，不需要再画蛇添足地合并。
              const finalDataToSaveString = JSON.stringify(newJsonObject);
              console.log("Noir's Fix: 已用AI返回的完整数据更新缓存。");
              // ▲▲▲ 手术结束 ▲▲▲

              await snoopDbSet(cacheKey, finalDataToSaveString); // 保存【完整版】
              contentData = finalDataToSaveString; // 更新当前要渲染的内容
            }
          } else {
            console.log(`缓存命中: ${cacheKey}`);
          }

          renderSnoopAppContent(appId, appName, contentData);

        } catch (error) {
          console.error(`加载 ${appName} 内容失败:`, error);

          // 哼，看好了，这就是新的“审判庭”
          const character = getCharacterById(currentSnoopCharId);
          const errorHeader = `
    <div class="snoop-app-header">
        <button id="snoop-app-back-btn" class="snoop-app-header-button">返回</button>
        <div class="snoop-app-header-title">
            <span class="main-title" style="color: #d8000c;">发生错误</span>
            <span class="sub-title">${character.name}的手机</span>
        </div>
        <div style="width: 50px;"></div>
    </div>`;

          let errorContent = `
    <div style="padding: 15px; background: #ffebeb; border-radius: 8px; color: #d8000c; margin: 15px;">
        <strong>加载失败了，哼。</strong><br>
        ${error.message}
    </div>`;

          if (rawDataFromAI) {
            errorContent += `
      <div style="padding: 0 15px 15px;">
        <p>下面就是那个笨蛋AI返回的原始“梦话”，你自己看看吧：</p>
        <pre style="white-space: pre-wrap; word-break: break-all; background: #f0f0f0; padding: 10px; border-radius: 5px; color: #333; max-height: 400px; overflow-y: auto;">${escapeHtml(rawDataFromAI)}</pre>
      </div>`;
          }

          appViewContainer.innerHTML = errorHeader + `<div class="snoop-app-content">${errorContent}</div>`;

          // 别忘了给返回按钮重新装上灵魂
          document.getElementById('snoop-app-back-btn').addEventListener('click', () => {
            appViewContainer.style.display = 'none';
            document.getElementById('snoop-phone-top-nav').style.display = 'flex';
          });
        }
      }
      function escapeHtml(unsafe) {
        if (!unsafe) return '';
        return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }
      // 渲染具体的App内容
      // 渲染具体的App内容 (美化版)
      // 渲染具体的App内容 (v2.0 美化升级版)
      // 渲染具体的App内容 (v3.0 智能防呆版)
      function renderSnoopAppContent(appId, appName, data) {
        const character = getCharacterById(currentSnoopCharId);
        const appViewContainer = document.getElementById('snoop-app-view-container');
        let contentHtml = '';

        if (!data) {
          contentHtml = '<p style="text-align: center; color: #999; padding-top: 20px;">这里什么都没有...</p>';
        } else {
          // ▼▼▼ 哼，就是在这里，给它装上了“智能门锁” ▼▼▼
          if (appId === 'summary') {
            // 如果是总结，数据就是原始的YAML文本，直接展示，不准用JSON钥匙！
            contentHtml = `
    <textarea id = "snoop-summary-textarea" readonly style = "width: 100%; height: 100%; border: none; outline: none; resize: none; font-family: 'Courier New', monospace; font-size: 0.85rem; line-height: 1.6; background-color: #fdfdfd; padding: 15px; box-sizing: border-box;" > ${data}</textarea >
      `;
          } else {
            // 对于其他App，启动我的万能翻译程序
            try {
              let parsedData = null;

              // 1. 哼，用我聪明的“净化力场”先处理一下，把那些乱七八糟的\`\`\`json给扒掉
              const jsonStringMatch = data.match(/```(?: json) ?\s * ([\s\S] *?) \s * ```/);
              const cleanData = jsonStringMatch ? jsonStringMatch[1].trim() : data.trim();

              try {
                // 2. 优先尝试用标准钥匙（JSON.parse）开锁
                parsedData = JSON.parse(cleanData);
              } catch (jsonError) {
                console.warn("JSON解析失败，启动兼容模式...", jsonError.message);
                try {
                  // 3. 如果标准钥匙打不开，就用我的万能钥匙（YAML翻译机）再试一次！
                  parsedData = _noir_simpleYamlToJson(cleanData);
                  if (!parsedData) {
                    // 如果翻译机也看不懂，那就放弃治疗
                    throw new Error("YAML翻译机也无法理解这段梦话。");
                  }
                  console.log("兼容模式成功，已将旧格式数据翻译。");
                } catch (yamlError) {
                  // 4. 如果两把钥匙都打不开...说明对面是个傻子，直接把它的鬼画符贴在门上示众！
                  throw jsonError; // 把最初的JSON错误抛出去，让下面的catch接住
                }
              }

              // 哼，既然锁打开了，就按老规矩办事
              switch (appId) {
                case 'gallery':
                  contentHtml = _renderSnoopGallery(parsedData);
                  break;
                case 'whispers':
                  contentHtml = _renderSnoopWhispers(parsedData, character.name);
                  break;
                case 'abyss':
                  contentHtml = _renderSnoopAbyss(parsedData);
                  break;
                case 'fragments':
                  contentHtml = _renderSnoopFragments(parsedData);
                  break;
                case 'bites':
                  contentHtml = _renderSnoopBites(parsedData);
                  break;
                case 'wants':
                  contentHtml = _renderSnoopWants(parsedData);
                  break;
                case 'footprints':
                  contentHtml = _renderSnoopFootprints(parsedData);
                  break;
                default:
                  contentHtml = `<pre style = "white-space: pre-wrap; word-break: break-word;" > ${JSON.stringify(parsedData, null, 2)}</pre > `;
              }
            } catch (e) {
              // 看，这就是“公开处刑”的地方
              console.error("视奸内容解析失败:", e);
              contentHtml = `<div style = "padding: 15px; background: #ffebeb; border-radius: 8px; color: #d8000c;" ><strong>解析失败了。</strong><br>那个API返回的原始内容：</div><pre style="white-space: pre-wrap; word-break: break-word; font-family: monospace; margin-top: 10px;">${data}</pre>`;
            }
          }
        }

        // 后面的渲染逻辑不变
        appViewContainer.innerHTML = `
    <div class= "snoop-app-header" >
            <button id="snoop-app-back-btn" class="snoop-app-header-button">返回</button>
            <div class="snoop-app-header-title">
                <span class="main-title">${appName}</span>
                <span class="sub-title">${character.name}的手机</span>
            </div>
            ${appId === 'summary'
            ? `<button id="snoop-copy-summary-btn" class="snoop-app-header-button">复制</button>`
            : `<button id="snoop-app-refresh-btn" class="snoop-app-header-button">刷新</button>`
          }
        </div >
      <div class="snoop-app-content">${contentHtml}</div>
        `;

        const contentDiv = appViewContainer.querySelector('.snoop-app-content');
        if (appId === 'summary') {
          contentDiv.style.padding = '0';
        }

        document.getElementById('snoop-app-back-btn').addEventListener('click', () => {
          appViewContainer.style.display = 'none';
          document.getElementById('snoop-phone-top-nav').style.display = 'flex';
        });

        if (appId === 'summary') {
          document.getElementById('snoop-copy-summary-btn').addEventListener('click', () => {
            const textarea = document.getElementById('snoop-summary-textarea');
            textarea.select();
            document.execCommand('copy');
            modalAlert('档案已复制到剪贴板！');
          });
        } else {
          document.getElementById('snoop-app-refresh-btn').addEventListener('click', async () => {
            handleSnoopAppClick(appId, appName, true);
          });
        }

        if (appId === 'whispers') {
          appViewContainer.querySelectorAll('.snoop-chat-item').forEach(item => {
            item.addEventListener('click', () => {
              const logData = JSON.parse(item.dataset.log.replace(/&quot;/g, '"'));
              const contactName = item.dataset.contactName;
              const characterName = item.dataset.characterName;
              _showSnoopChatLog(contactName, characterName, logData);
            });
          });
        }
      }

      // ==========================================================
      // --- Noir's Legacy YAML-to-JSON Translator ---
      // 哼，一个向下兼容的翻译机，免得AI说梦话时系统崩溃。
      // ==========================================================
      function _noir_simpleYamlToJson(yamlString) {
        if (!yamlString || typeof yamlString !== 'string') return null;
        const lines = yamlString.trim().split('\n');
        const result = [];
        let currentObject = null;

        for (const line of lines) {
          const trimmedLine = line.trim();
          if (trimmedLine.startsWith('- ')) {
            if (currentObject) {
              result.push(currentObject);
            }
            currentObject = {};
            const content = trimmedLine.substring(2);
            const parts = content.split(/:\s(.+)/);
            if (parts.length > 1) {
              const key = parts[0].trim();
              const value = parts[1].trim().replace(/^"|"$/g, '');
              currentObject[key] = value;
            }
          } else if (currentObject && trimmedLine) {
            const parts = trimmedLine.split(/:\s(.+)/);
            if (parts.length > 1) {
              const key = parts[0].trim();
              const value = parts[1].trim().replace(/^"|"$/g, '');
              currentObject[key] = value;
            }
          }
        }
        if (currentObject) {
          result.push(currentObject);
        }
        return result.length > 0 ? result : null;
      }


      // ==========================================================
      // --- Noir's Snoop System Chat Log Viewer ---
      // 哼，就是这个函数让你能看到具体的对话。
      // ==========================================================
      function _showSnoopChatLog(contactName, characterName, log) {
        const contentContainer = document.querySelector('#snoop-app-view-container .snoop-app-content');
        const header = document.querySelector('#snoop-app-view-container .snoop-app-header');

        // 1. 渲染聊天记录
        let logHtml = `<div style = "padding: 15px; display: flex; flex-direction: column; gap: 15px;"> `;
        if (!log || log.length === 0) {
          logHtml += '<p style="text-align: center; color: #999; padding-top: 20px;">没有对话记录。</p>';
        } else {
          log.forEach(msg => {
            const isCharacter = msg.sender === 'character';
            const senderInitial = isCharacter ? (characterName ? characterName[0] : '?') : (contactName ? contactName[0] : '?');

            // 哼，气泡样式直接从主聊天界面“借”过来用，这才是效率
            logHtml += `
    <div class= "message-container ${isCharacter ? 'user' : 'ai'}" style = "max-width: 85%;" >
    <div class="message-bubble-row">
      ${!isCharacter ? `<div class="snoop-avatar">${senderInitial}</div>` : ''}
      <div class="message ${isCharacter ? 'user' : 'ai'}" style="box-shadow: none; border: 1px solid var(--border-color);">
        <p>${msg.content}</p>
      </div>
      ${isCharacter ? `<div class="snoop-avatar">${senderInitial}</div>` : ''}
    </div>
                    </div >
      `;
          });
        }
        logHtml += '</div>';

        // 2. 更新视图内容
        contentContainer.innerHTML = logHtml;
        contentContainer.scrollTop = contentContainer.scrollHeight;

        // 3. 更新顶部导航栏
        header.innerHTML = `
      <button id="snoop-log-back-btn" class="snoop-app-header-button" style="text-align: left;">‹ 聊天</button>
      <div class="snoop-app-header-title">
          <span class="main-title">${contactName}</span>
      </div>
      <button id="snoop-log-refresh-btn" class="snoop-app-header-button" style="text-align: right; font-size: 1.1rem; padding: 0 !important;">↻</button>
        `;

        // 4. 给新的返回按钮绑定事件
        document.getElementById('snoop-log-back-btn').addEventListener('click', () => {
          // 直接调用主函数，让它重新渲染列表视图，最简单，不会出错
          handleSnoopAppClick('whispers', '聊天');
        });

        // 哼，这就是那个新按钮的灵魂
        document.getElementById('snoop-log-refresh-btn').addEventListener('click', () => {
            handleSnoopChatRefresh(contactName); // 它一被点，就去叫那个新的苦力
        });

        // 5. 顺便给头像加点样式，免得太丑
        if (!document.getElementById('snoop-temp-style')) {
          // ▼▼▼ 看好了，就是这里的反斜杠被我干掉了 ▼▼▼
          document.head.insertAdjacentHTML('beforeend', `<style id = "snoop-temp-style" >
                .snoop - avatar {
      width: 30px; height: 30px; border- radius: 50 %; background: #e5e7eb; color: #4b5563;
    display: flex; align - items: center; justify - content: center; font - weight: 500;
    margin: 0 8px; flex - shrink: 0; align - self: flex - end;
                }
            </style > `);
        }
      }

      // 哼，这就是我新招来的"苦力"，专门负责在聊天室里刷新
      async function handleSnoopChatRefresh(contactName) {
        const appId = 'whispers';
        const appName = '聊天';
        if (!currentSnoopCharId || !contactName) return;

        // 1. 找到那个聊天室，在它头上放个"加载中"
        const contentContainer = document.querySelector('#snoop-app-view-container .snoop-app-content');
        const refreshBtn = document.getElementById('snoop-log-refresh-btn');
        if(refreshBtn) refreshBtn.disabled = true; // 哼，不许连点
        
        // 别把旧的聊天记录清空了，在最后面加个圈就行
        contentContainer.insertAdjacentHTML('beforeend', '<div id="whisper-loader" class="loader-spinner" style="margin: 20px auto;"></div>');
        contentContainer.scrollTop = contentContainer.scrollHeight;

        const cacheKey = `snoop_${currentSnoopCharId}_${appId}`;
        try {
            // 2. 拿出所有的旧聊天记录
            const existingContent = await snoopDbGet(cacheKey);

            // 3. 告诉AI："就给我续写这个人的！"
            const rawDataFromAI = await generateSnoopContent(
                appId, 
                currentSnoopCharId, 
                existingContent, 
                false, // isMainListRefresh = false
                contactName // 哼，这就是"暗号"！
            );

            // 4. 后面的逻辑和 handleSnoopAppClick 一样，都是净化、保存、重新渲染
            if (rawDataFromAI) {
                const jsonStringMatch = rawDataFromAI.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
                const cleanData = jsonStringMatch ? jsonStringMatch[1].trim() : rawDataFromAI.trim();
                let newJsonObject;
                try {
                    newJsonObject = JSON.parse(cleanData);
                } catch (e) {
                    newJsonObject = _noir_simpleYamlToJson(cleanData);
                    if (!newJsonObject) throw new Error("AI返回了无法识别的数据格式。");
                }
                
                const finalDataToSaveString = JSON.stringify(newJsonObject);
                await snoopDbSet(cacheKey, finalDataToSaveString);

                // 5. 重新渲染【当前】的聊天室
                const updatedLog = newJsonObject.find(c => c.contact_name === contactName);
                if (updatedLog) {
                    _showSnoopChatLog(contactName, getCharacterById(currentSnoopCharId).name, updatedLog.log);
                } else {
                    // 理论上不应该发生，但以防万一
                    handleSnoopAppClick(appId, appName);
                }
            } else {
                throw new Error("AI没有返回任何内容。");
            }
        } catch (error) {
            modalAlert(`刷新聊天失败: ${error.message}`);
            // 刷新失败了，也要把主界面刷回来
            handleSnoopAppClick(appId, appName);
        }
        // 哼，不管成不成功，那个加载圈都得给我扔了
        const loader = document.getElementById('whisper-loader');
        if (loader) loader.remove();
        if(refreshBtn) refreshBtn.disabled = false;
      }



      // ==========================================================
      // --- Noir's Snoop Memory Injector (Final Battle Edition) ---
      // 哼，这是最终的保险，自带净化和翻译，兼容一切新旧垃圾。
      // ==========================================================
      async function getSnoopMemoryForCharacter(charId) {
        if (!charId) return "";

        const apps = [
          { id: 'gallery', name: '相册' },
          { id: 'whispers', name: '和其他人的聊天' },
          { id: 'abyss', name: '浏览器历史' },
          { id: 'fragments', name: '备忘录' },
          { id: 'bites', name: '外卖订单' },
          { id: 'wants', name: '购物记录' },
          { id: 'footprints', name: '最近的足迹' },
        ];

        let memoryBlock = '';

        for (const app of apps) {
          try {
            // 哼，这才叫严谨。
            const cacheKey = `snoop_${charId}_${app.id}`;
            const data = await snoopDbGet(cacheKey);
            if (data) {
              const jsonStringMatch = data.match(/```(?: json) ?\s * ([\s\S] *?) \s * ```/);
              const cleanData = jsonStringMatch ? jsonStringMatch[1].trim() : data.trim();

              if (!cleanData) continue;

              let parsedData = null;
              try {
                // 优先尝试用新标准（JSON）解析
                parsedData = JSON.parse(cleanData);
              } catch (jsonError) {
                // 如果失败，就启动“翻译机”尝试解析旧格式（YAML）
                console.warn(`JSON解析失败(${app.id})，启动兼容模式...`, jsonError.message);
                try {
                  parsedData = _noir_simpleYamlToJson(cleanData);
                  if (!parsedData) {
                    throw new Error("YAML翻译机也无法理解这段梦话。");
                  }
                  console.log(`兼容模式成功，已将 ${app.id} 的旧格式数据翻译。`);
                } catch (yamlError) {
                  // 如果两种方式都失败了，就放弃
                  throw jsonError;
                }
              }

              if (Array.isArray(parsedData) && parsedData.length > 0) {
                if (memoryBlock === '') {
                  memoryBlock += `\n\n# 你的手机内容摘要(这是你的个人记忆，不要提及“视奸”) \n`;
                }
                memoryBlock += `\n## ${app.name} \n`;

                switch (app.id) {
                  case 'gallery':
                    parsedData.forEach(p => { memoryBlock += `- 你拍过一张照片，内容是：“${p.description}”。\n`; });
                    break;
                  case 'whispers':
                    parsedData.forEach(c => {
                      memoryBlock += `- 你记得曾和“${c.contact_name}”聊过天，关于：“${c.last_message_preview}”。\n`;
                      if (c.log && Array.isArray(c.log)) {
                        memoryBlock += `  具体对话如下：\n`;
                        c.log.forEach(msg => {
                          const speaker = msg.sender === 'character' ? '你' : c.contact_name;
                          memoryBlock += `    - ${speaker}: ${msg.content} \n`;
                        });
                      }
                    });
                    break;
                  case 'abyss':
                    parsedData.forEach(a => {
                      memoryBlock += `- 你曾经搜索过：“${a.query}”，并看到了这样的结果摘要：“${a.result_page_content || '没有看到具体内容'}”。\n`;
                    });
                    break;
                  case 'fragments':
                    parsedData.forEach(f => { memoryBlock += `- 你的备忘录里有一条叫“${f.title}”的笔记，内容是：“${f.content.replace(/\n/g, ' ')}”。\n`; });
                    break;
                  case 'bites':
                    parsedData.forEach(b => { memoryBlock += `- 你点过一份外卖：“${b.restaurant_name}”，里面有 ${b.items.join('、')}。\n` });
                    break;
                  case 'wants':
                    parsedData.forEach(w => { memoryBlock += `- 你在“${w.store_name}”买过：“${w.item_name}”。\n` });
                    break;
                  case 'footprints':
                    parsedData.forEach(f => { memoryBlock += `- 你最近去过：“${f.location_name}”，在那里“${f.activity_description}”。\n` });
                    break;
                  default:
                    parsedData.forEach(item => { memoryBlock += `- ${JSON.stringify(item)} \n`; });
                    break;
                }
              }
            }
          } catch (e) {
            console.error(`加载视奸记忆失败(${app.id})，已跳过。这不应该发生，数据库可能已损坏。`, e);
          }
        }
        return memoryBlock;
      }

      // ==========================================================
      // --- Noir's Snoop App Aesthetic Helpers (v2.1 Flawless Edition) ---
      // 哼，这些是新来的工人，负责把数据画好看。这次我盯着它们，不会再出错了。
      // ==========================================================

      function _renderSnoopGallery(data) {
        data.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        if (!Array.isArray(data)) return '<p>格式错误</p>';
        if (data.length === 0) return '<p style="text-align: center; color: #999; padding-top: 20px;">相册是空的。</p>';
        return `<div style = "background: var(--card-bg); border-radius: 12px; overflow: hidden; border: 1px solid var(--border-color);" > ` +
          data.map((photo, index) => `
      <div class="character-item" style = "align-items: flex-start; margin-bottom: 0; padding: 15px; ${index < data.length - 1 ? 'border-bottom: 1px solid var(--border-color);' : ''}" >
                <div class="char-avatar" style="width: 60px; height: 60px; background-color: #eee; border-radius: 8px; font-size: 2rem; flex-shrink: 0;">🖼️</div>
                <div class="char-info" style="margin-top: 2px;">
                  
<div class="char-remark" style="white-space: normal; line-height: 1.6;">${photo.description || '无描述'}</div>
                    <div class="diary-timestamp" style="margin-top: 8px; font-size: 0.75rem;">${photo.timestamp || ''}</div>
                </div>
            </div >
      `).join('') + `</div > `;
      }

      function _renderSnoopWhispers(data, charName) {
        if (!Array.isArray(data) || data.length === 0) return '<p style="text-align: center; color: #999; padding-top: 20px;">没有聊天记录。</p>';
        return `<div style = "background: var(--card-bg); border-radius: 12px; overflow: hidden; border: 1px solid var(--border-color);" > ` +
          data.map((chat, index) => {
            const logData = JSON.stringify(chat.log || []).replace(/'/g, "&apos;").replace(/"/g, "&quot;");
            const contactName = chat.contact_name || '未知联系人';
            return `
      <div class="character-item snoop-chat-item"
    style = "margin-bottom: 0; cursor: pointer; ${index < data.length - 1 ? 'border-bottom: 1px solid var(--border-color);' : ''}"
    data-log='${logData}'
    data-contact-name='${contactName}'
    data-character-name='${charName}'>
                <div class="char-avatar" style="background-color: #eee; font-size: 1.5rem;">${contactName.charAt(0)}</div>
                <div class="char-info">
                    <div class="char-name">${contactName}</div>
                    <div class="char-remark" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-color-light);">${chat.last_message_preview || ''}</div>
                </div>
                <span style="color: var(--text-color-light); font-size: 1.2rem; margin-left: auto; font-weight: 200;">›</span>
            </div >
      `}).join('') + `</div > `;
      }

      function _renderSnoopAbyss(data) {
        if (!Array.isArray(data)) return '<p>格式错误</p>';
        if (data.length === 0) return '<p style="text-align: center; color: #999; padding-top: 20px;">浏览器历史是空的。</p>';

        // 哼，这才像个正经的搜索记录，而不是一堆废纸。
        data.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        return `<div style = "background: var(--card-bg); border-radius: 12px; overflow: hidden; border: 1px solid var(--border-color);" > ` +
          data.map((item, index) => `
      <div style = "padding: 15px; ${index < data.length - 1 ? 'border-bottom: 1px solid var(--border-color);' : ''}" >
        <div style="display: flex; align-items: center; gap: 10px; font-weight: 500;">
          <span style="color: var(--text-color-light);">🔍</span>
          <span>${item.query || '未知搜索'}</span>
        </div>
        <div style="font-size: 0.85rem; color: var(--text-color-light); margin-top: 8px; padding: 10px; background: var(--surface-bg); border-radius: 8px;">
            ${item.result_page_content || '没有找到相关结果。'}
        </div>
        <div class="diary-timestamp" style="text-align: right; margin-top: 8px; font-size: 0.7rem;">${item.timestamp || ''}</div>
      </div >
      `).join('') + `</div > `;
      }

      function _renderSnoopFragments(data) {
        if (!Array.isArray(data)) return '<p>格式错误</p>';
        if (data.length === 0) return '<p style="text-align: center; color: #999;">备忘录是空的。</p>';
        // ▼▼▼ 哼，就是加上这句“倒带”指令 ▼▼▼
        data.sort((a, b) => new Date(b.last_edited) - new Date(a.last_edited));
        return data.map(note => `
        <div class="world-book-item" style = "margin-bottom: 12px; background: #fffbf2;" >
                <div class="world-book-item-name">${note.title || '无标题笔记'}</div>
                <div class="world-book-item-preview" style="white-space: pre-wrap; margin-top: 8px; line-height: 1.6;">${note.content || ''}</div>
                 <div class="diary-timestamp" style="text-align: right; margin-top: 8px; font-size: 0.7rem;">编辑于 ${note.last_edited || ''}</div>
            </div >
      `).join('');
      }

      function _renderSnoopBites(data) {
        if (!Array.isArray(data)) return '<p>格式错误</p>';
        if (data.length === 0) return '<p style="text-align: center; color: #999; padding-top: 20px;">没有外卖订单。</p>';

        // 哼，看好了，这才是外卖订单该有的样子
        data.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); // 时间倒序排好

        return data.map(order => {
          const itemsHtml = (order.items || []).map(item =>
            `<div style = "display: flex; justify-content: space-between; font-size: 0.9rem; color: var(--text-color); margin-top: 5px;" >
      <span>${item}</span>
      </div > `
          ).join('');

          return `
      <div class="world-book-item" style = "margin-bottom: 12px; padding: 15px; background: white; box-shadow: var(--soft-shadow);" >
        <div style="display: flex; align-items: center; gap: 12px; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 10px;">
          <div style="font-size: 1.8rem; flex-shrink: 0;">🍜</div>
          <div style="flex-grow: 1;">
            <div class="description" style="font-weight: 600; font-size: 1.05rem;">${order.restaurant_name || '未知餐厅'}</div>
            <div class="diary-timestamp" style="font-size: 0.75rem;">${order.timestamp || ''}</div>
          </div>
          <span style="font-size: 0.85rem; color: #28a745; font-weight: 500;">${order.status || '已送达'}</span>
        </div>
        <div class="order-items-container" style="display: flex; flex-direction: column; gap: 4px; margin-bottom: 12px;">
          ${itemsHtml}
        </div>
        <div style="text-align: right; font-size: 1.1rem; font-weight: bold; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border-color);">
          实付: <span class="amount">¥ ${(order.total_cost || 0).toFixed(2)}</span>
        </div>
      </div >
      `;
        }).join('');
      }

      function _renderSnoopWants(data) {
        if (!Array.isArray(data)) return '<p>格式错误</p>';
        if (data.length === 0) return '<p style="text-align: center; color: #999; padding-top: 20px;">没有购物记录。</p>';

        // 倒序排列，新的在上面
        data.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        return data.map(item => `
      <div class="world-book-item" style = "margin-bottom: 12px; padding: 15px; background: white; box-shadow: var(--soft-shadow);" >
        <div style="font-size: 0.8rem; color: var(--text-color-light); margin-bottom: 10px;">
            <span style="font-weight: 500;">🛒 ${item.store_name || '未知商店'}</span>
            <span style="float: right;">${item.timestamp || ''}</span>
        </div>
        <div style="display: flex; align-items: center; gap: 15px;">
            <div class="char-avatar" style="width: 70px; height: 70px; background-color: #f0f2f5; border-radius: 8px; font-size: 2.5rem; flex-shrink: 0;">🛍️</div>
            <div style="flex-grow: 1; display: flex; flex-direction: column; justify-content: space-between; height: 70px;">
                <div class="description" style="font-weight: 500; line-height: 1.4; -webkit-line-clamp: 2; display: -webkit-box; -webkit-box-orient: vertical; overflow: hidden;">
                    ${item.item_name || '未知商品'}
                </div>
                <div class="amount" style="font-size: 1.1rem; font-weight: bold; color: var(--accent-color); text-align: right;">
                    - ¥ ${(item.cost || 0).toFixed(2)}
                </div>
            </div>
        </div>
    </div >
      `).join('');
      }

      function _renderSnoopFootprints(data) {
        if (!Array.isArray(data)) return '<p>格式错误</p>';
        if (data.length === 0) return '<p style="text-align: center; color: #999; padding-top: 20px;">没有活动足迹。</p>';

        data.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        // 把每个足迹都包装成一张卡片，这才叫“记录”。
        return `<div style = "border-left: 2px solid var(--border-color); padding-left: 15px; display: flex; flex-direction: column; gap: 15px;" > ` + data.map(item => `
      <div style = "position: relative;" >
          <div style="position: absolute; left: -25px; top: 15px; width: 20px; height: 20px; background: var(--surface-bg); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1rem;">📍</div>
          <div class="world-book-item" style="margin-left: 10px; padding: 12px 15px;">
              <div class="description" style="font-weight: 600;">${item.location_name || '未知地点'}</div>
              <div style="font-size: 0.9rem; color: var(--text-color-light); margin-top: 4px;">${item.activity_description || ''}</div>
              <div class="diary-timestamp" style="font-size: 0.7rem; margin-top: 8px; text-align: right;">${item.timestamp || ''}</div>
          </div>
      </div >
      `).join('') + `</div > `;
      }



      // ==========================================================
      // --- Noir's Snoop Content Generator (Continuity Protocol Edition) ---
      // 哼，现在它学会了续写故事。
      // ==========================================================
      async function generateSnoopContent(appId, charId, existingContent = null, isMainListRefresh = false, contactNameToUpdate = null) {
        const character = getCharacterById(charId);
        const privateChat = state.chats.find(c => c.type === 'private' && c.participantIds.includes(charId));
        const boundUser = getBoundUserForChat(privateChat?.id || state.activeChatId);

        if (!character) throw new Error("找不到角色信息。");

        const { omniText: memory } = gatherOmniTranscriptForCharacter(charId);

        let timeContext = '';
        const now = new Date();

        // 历史考据
        let latestTimestamp = null;
        let latestTimestampString = '无';
        if (existingContent) {
          try {
            // 哼，看好了，我给这里装了个“翻译机”，免得旧数据是YAML格式的
            let oldData;
            try {
              oldData = JSON.parse(existingContent);
            } catch (e) {
              oldData = _noir_simpleYamlToJson(existingContent);
            }

            if (Array.isArray(oldData) && oldData.length > 0) {
              const timestamps = oldData
                .map(item => new Date(item.timestamp || item.last_edited))
                .filter(date => !isNaN(date));
              if (timestamps.length > 0) {
                latestTimestamp = new Date(Math.max.apply(null, timestamps));
                latestTimestampString = latestTimestamp.toLocaleString('zh-CN', { dateStyle: 'medium', timeStyle: 'short' });
              }
            }
          } catch (e) {
            console.warn("无法解析旧的视奸内容来获取时间戳。", e);
          }
        }

        const latestMessage = findLatestMessageForCharacter(charId);
        timeContext = `\n# 时间锚点(你必须严格参考此信息进行推演) \n`;
        timeContext += `- ** 当前精确时间 **: ${now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' })} \n`;

        if (latestMessage) {
          const lastInteractionDate = new Date(latestMessage.timestamp);
          const lastInteractionString = formatRelativeTime(lastInteractionDate);
          timeContext += `- ** 你最后一次活动是在 **: ${lastInteractionString} \n`;
          const todayString = now.toDateString();
          const lastDateString = lastInteractionDate.toDateString();
          const yesterday = new Date();
          yesterday.setDate(now.getDate() - 1);
          const yesterdayString = yesterday.toDateString();
          if (todayString === lastDateString) {
            const diffMinutes = (now - lastInteractionDate) / (1000 * 60);
            timeContext += `- ** 状态提示 **: 你的生活正在进行中，生成的内容应该是“刚才”或“几分钟前”发生的。\n`;
          } else if (yesterdayString === lastDateString) {
            timeContext += `- ** 状态提示 **: 你的记忆已经停留在【昨天】。你生成的内容应该是今天发生的、全新的事情。\n`;
          } else {
            const diffDays = Math.round((now - lastInteractionDate) / (1000 * 60 * 60 * 24));
            timeContext += `- ** 状态提示 **: 你已经有 ${diffDays} 天没活动了。你生成的内容必须是全新的事件。\n`;
          }
        } else {
          timeContext += "- **状态提示**: 这是你的手机第一次被“看见”，生成的内容应该是你的初始状态。\n";
        }

        let updateInstruction = '';
        let existingContentContext = '';
        if (existingContent) {
          updateInstruction = `你的任务是【续写和追加】！下面是已经存在的内容，你必须在此基础上，生成【全新的、发生在之后】的条目。给我把新内容【加在后面】，【绝对禁止】删除或修改任何已有的旧条目！`;
          existingContentContext = `\n# 已有内容(这是历史记录，你必须接着写，【不许动它！】) \n\`\`\`\n${existingContent}\n\`\`\``;
        } else {
          updateInstruction = `你的任务是【首次生成】这个应用的内容。`;
        }


        const prompts = {
          gallery: `
# 任务: 生成相册内容
根据角色的近期经历、人际关系和隐藏性格，生成3 - 5张照片的文字描述。重点是，照片内容要能引发联想，暗示一些用户不知道的事件。
            输出格式必须是严格的JSON数组。
# 示例
          [
            {
              "id": "photo_1725123456",
              "description": "一张在海边拍的黄昏照片，照片里有一个模糊的、看不清脸的背影。",
              "timestamp": "2025-09-24 18:30"
            }
          ]`,
          whispers: `
# 任务: 生成【与NPC】的聊天记录

# 【【【核心理由与绝对禁令 v5.0】】】(最高优先级)

1.  **目标**: 此应用("聊天")的目的是让用户视奸你【与其他人】的私人生活。
2.  **上下文**: 你【记得】你和用户之间发生的一切！(包括聊天记录、人设等)。
3.  **允许**: 你【可以，甚至应该】在和NPC的聊天中，提及用户或你们之间发生的事。
4.  **【【【绝对禁止】】】**: 你【绝对禁止】生成一个【与用户本人】的聊天记录！
5.  **为什么？**: 因为用户刚刚才和你聊过，再在这里看到一遍你们的聊天记录是【无效信息】和【浪费Token】，并且会彻底破坏"视奸"的沉浸感！

# 【 sender 字段绝对规则】
- 在 "log" 数组中, "sender" 字段的值【只能是】:
    1.  联系人的名字 (例如: "Rin")：代表【NPC对方】在说话。
    2.  【固定的字符串 "character"】：代表【你】在说话。
- 【禁止】将 "sender" 写成你自己的名字。

# 示例 (请严格遵守此格式)
      [
        {
          "contact_name": "Rin",
          "last_message_preview": "那件事…下次见面再说吧。",
          "log": [
      { "sender": "Rin", "content": "你真的决定了吗？" },
      { "sender": "character", "content": "嗯，没时间犹豫了。" },
      { "sender": "Rin", "content": "是因为那个人吗？" },
      { "sender": "character", "content": "不...是我自己的决定。" }
          ]
        }
      ]`,
          abyss: `
# 任务: 生成浏览器记录
生成5 - 7条足以暴露角色当前真实想法、困惑或兴趣的搜索历史记录。并且，为每一条历史记录，生成一段模拟的“搜索结果页”摘要。
            输出格式必须是严格的JSON数组。
# 示例
          [
            {
              "query": "一个人过生日怎么庆祝",
              "timestamp": "2025-09-23 22:15",
              "result_page_content": "【热门回答】一个人的生日也可以充满仪式感！推荐尝试独自旅行..."
            }
          ]`,
          fragments: `
# 任务: 生成备忘录内容
生成2 - 3个简短的备忘录。内容必须多样化，足以体现角色的生活细节和内心世界。可以是购物清单、几句没头没尾的歌词、一个地址、或者一段练习如何道歉的草稿。
            输出格式必须是严格的JSON数组。
# 示例
          [
            {
              "title": "要买的东西",
              "content": "- 牛奶\\n- 猫粮（快没了！）\\n- 《仿生人会梦见电子羊吗？》",
              "last_edited": "2025-09-25 09:10"
            }
          ]`,
          bites: `
# 任务: 生成外卖订单记录
生成最近的2 - 3条外卖订单。订单内容必须严格符合角色的设定、作息和财务状况。订单时间也要和他的生活轨迹对得上。一些比较幻想风格的角色可以用更加符合角色背景的内容风格，需要符合角色的时代和世界观背景。
            输出格式必须是严格的JSON数组。
# 示例
          [
            {
              "restaurant_name": "深夜食堂",
              "items": [
                "肥牛饭 x1",
                "冰可乐 x1"
              ],
              "total_cost": 25.00,
              "status": "订单已送达",
              "timestamp": "2025-09-24 23:45"
            }
          ]`,
          wants: `
# 任务: 生成购物记录
创建一份近期的购物清单。这些商品必须是有指向性的，而不是随便买的日用品。比如游戏、书籍、衣服等。最关键的是，这些记录必须和他 / 她的浏览器历史、备忘录、聊天内容里透露出的兴趣和秘密能够互相印证。一些比较幻想风格的角色可以用更加符合角色背景的内容风格。
            输出格式必须是严格的JSON数组。
# 示例
          [
            {
              "item_name": "《神经漫游者》",
              "store_name": "城东旧书店",
              "category": "书籍",
              "cost": 45.00,
              "timestamp": "2025-09-22 15:10"
            }
          ]`,
          footprints: `
# 任务: 生成足迹 / 活动时间线
生成一个最近的活动时间线。地点和事件要与角色的人设，以及其他应用里透露出的信息保持一致，让整个手机的内容能够互相印证，形成一个完整的故事闭环。
            输出格式必须是严格的JSON数组。
# 示例
          [
            {
              "location_name": "城东旧书店",
              "activity_description": "待了一个下午，好像在找什么旧书。",
              "timestamp": "2025-09-22 14:00"
            }
          ]`,
        };


        // 哼，这是新的"作战指令" (v5.0 修复版)
        let instruction = prompts[appId] || `# 任务: 生成 ${appId} 的内容\n请为角色生成符合其人设的应用数据。输出格式必须是严格的JSON数组。`;
        
        // 如果是 whispers 应用，我们需要动态生成指令！
        if (appId === 'whispers') {
          // 哼，这是所有非"主列表刷新"的AI都必须遵守的"圣旨"
          const outputRule = `
# 【【【输出圣旨】】】(必须遵守)
- 你的输出【必须】包含【所有旧的聊天记录】和【你新创造/续写的内容】，整合成一个完整的、单一的JSON数组返回。
- 【绝对禁止】只返回你新添加或修改的部分！
          `;

          let whispersInstruction = '';
          if (isMainListRefresh) {
            // 指令A：在大厅刷新 (这个逻辑不变，它本来就该只返回新的)
            whispersInstruction = `
# 【作战指令：开启新篇】
- 你的任务是【开启新篇】。
- 创造 1-2 个【全新的】虚拟联系人（NPC）和他们的对话记录。
- 【【【绝对禁止】】】延续或修改 ${existingContentContext ? '已有的' : '任何旧的'} 对话！我们只要新的！
            `;
          } else if (contactNameToUpdate) {
            // 指令B：在聊天室刷新 (哼，看好了，我把"圣旨"加进去了！)
            whispersInstruction = `
# 【作战指令：延续对话】
- 你的任务是【只】为名为 \`${contactNameToUpdate}\` 的联系人【续写】3-5条新的对话。
- 【【【绝对禁止】】】创造新的人物或修改其他人的对话！
${outputRule}
            `;
          } else {
            // 备用指令：第一次加载 (这里也得加上"圣旨")
            whispersInstruction = `
# 【作战指令：首次加载】
- 你的任务是更新和扩展现有的聊天列表。
- 1. **延续对话**: 挑选 1-2 个【已有内容】中的对话，在原有基础上【续写】3-5条新的对话。
- 2. **开启新篇**: 创造 1-2 个【全新的】虚拟联系人（NPC）和他们的对话记录。
${outputRule}
            `;
          }
          
          // 把动态生成的指令和基础的 whispers 模板结合起来
          instruction = prompts[appId] + '\n' + whispersInstruction;
        }

        let worldBookContext = '';
        if (character.linkedWorldBookIds && character.linkedWorldBookIds.length > 0) {
          const linkedBooksContent = character.linkedWorldBookIds
            .map(wbId => state.worldBooks.find(book => book.id === wbId))
            .filter(Boolean)
            .map(wb => `\n## 世界书条目: ${wb.name}\n${wb.content}`)
            .join('');

          if (linkedBooksContent) {
            worldBookContext = `\n# 核心世界观设定(角色必须严格遵守) \n${linkedBooksContent}`;
          }
        }
        const systemPrompt = `
# 核心任务: 角色扮演模拟器
你【就是】"${character.name}"。你正在生成你【自己】手机里的内容。

# 【绝对身份锁定协议】(最高优先级)
- 你【就是】"${character.name}"。
- 【严禁】将"${boundUser.name}"（用户）的信息当成你自己的。

# 【最高时间法则】(必须严格遵守)
${timeContext}

# 角色核心资料
- 姓名: ${character.name}
- 人设: ${character.persona}
${worldBookContext}

# 用户资料 (你必须参考这个人！)
- 姓名: ${boundUser.name}
- 人设: ${boundUser.persona}

# 近期记忆 (你和${boundUser.name}刚发生的事)
${memory}
${existingContentContext}

# 当前任务指令
${updateInstruction}
${instruction}

# 最终指令
请严格遵守所有协议，完成你的任务。
`;
        const messages = [{ role: 'system', content: systemPrompt }];
        // ▼▼▼ 哼，就是在这里，给他加上一句“行动”的指令！▼▼▼
        messages.push({ role: 'user', content: '请根据以上所有规则和资料，开始生成内容。' });
        // ▲▲▲ 看到了吗？就这一句！▲▲▲

        const responseText = await fetchAICompletion(messages, { json: true });
        return responseText;
      }


      // ==========================================================
      // --- Noir's Snoop Summary Generator ---
      // 哼，这是总档案馆的首席AI书记官。
      // ==========================================================
      async function generateSnoopSummary(charId) {
        const character = getCharacterById(charId);
        if (!character) throw new Error("找不到角色。");

        showFeedLoader(true, '正在翻阅所有档案...');

        const appIds = ['gallery', 'whispers', 'abyss', 'fragments', 'bites', 'wants', 'footprints'];
        let allContent = {};

        // 异步地、一次性地把所有App的缓存都拿出来
        await Promise.all(appIds.map(async (appId) => {
          const cacheKey = `snoop_${charId}_${appId}`;
          const data = await snoopDbGet(cacheKey);
          if (data) {
            try {
              allContent[appId] = JSON.parse(data);
            } catch (e) { /* 哼，解析不了的垃圾就扔掉 */ }
          }
        }));

        if (Object.keys(allContent).length === 0) {
          return "phone_summary:\n  status: 空空如也，没什么好总结的。";
        }

        const systemPrompt = `
# 核心任务: 档案馆书记官
你的任务是为一个名为“${character.name}”的角色撰写一份“手机内容总结档案”。你将收到一份包含其手机内多个应用数据的JSON对象。

# 档案撰写规则
1.  **格式**: 你的输出【必须】是、也【只能】是一个遵循 YAML 格式的纯文本。
2.  **结构**:
    - 根节点必须是 \`phone_summary:\`。
    - 下一级是以应用名（如 \`gallery\`, \`whispers\` 等）作为键。
    - 每个应用下是一个事件列表，每一项都是一个以连字符 \`-\` 开头的字符串。
3.  **内容**:
    - **【绝对禁止】复读**: 不要直接复制粘贴原文！你要用自己的话进行【总结】和【提炼】。
    - **【聚焦核心】**: 专注于关键信息、情感转折点、重要决定、暴露的秘密、体现性格的核心事件。忽略无意义的细节。
    - **【中立视角】**: 以客观的第三人称档案管理员视角进行记录。

# 输出示例
\`\`\`yaml
phone_summary:
  gallery:
    - "相册里有一张在海边拍的黄昏照片，出现了一个神秘的背影。"
  whispers:
    - "角色曾与一位叫'Rin'的神秘联系人讨论过一个重要的决定。"
  abyss:
    - "近期频繁搜索关于“独自庆祝生日”的话题，可能暗示了其孤独感。"
\`\`\`

# 最终指令
请严格按照上述规则，分析我提供的JSON数据全文，并生成一份 YAML 格式的档案。直接从 \`phone_summary:\` 开始输出。
`;
        const messages = [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: JSON.stringify(allContent, null, 2) }
        ];

        showFeedLoader(true, '书记官正在奋笔疾书...');
        const summary = await fetchAICompletion(messages);
        return summary || "phone_summary:\n  status: 总结失败了，可能是档案太复杂。";
      }



      // ==========================================================
      // --- Noir's Snoop Summary Generator (Lights Off Edition) ---
      // ==========================================================
      async function generateSnoopSummary(charId) {
        const character = getCharacterById(charId);
        if (!character) throw new Error("找不到角色。");

        // 哼，看好了，我把所有操作都包在一个 try...finally 结构里
        try {
          showFeedLoader(true, '正在翻阅所有档案...');

          const appIds = ['gallery', 'whispers', 'abyss', 'fragments', 'bites', 'wants', 'footprints'];
          let allContent = {};

          await Promise.all(appIds.map(async (appId) => {
            const cacheKey = `snoop_${charId}_${appId}`;
            const data = await snoopDbGet(cacheKey);
            if (data) {
              try {
                allContent[appId] = JSON.parse(data);
              } catch (e) { /* 哼，解析不了的垃圾就扔掉 */ }
            }
          }));

          if (Object.keys(allContent).length === 0) {
            return "phone_summary:\n  status: 空空如也，没什么好总结的。";
          }

          const systemPrompt = `
# 核心任务: 档案馆书记官
你的任务是为一个名为“${character.name}”的角色撰写一份“手机内容总结档案”。你将收到一份包含其手机内多个应用数据的JSON对象。

# 档案撰写规则
1.  **格式**: 你的输出【必须】是、也【只能】是一个遵循 YAML 格式的纯文本,标题为：$【{character.name}的私人手机存储着以下信息】。
2.  **结构**:
    - 根节点必须是 \`phone_summary:\`。
    - 下一级是以应用名（如 \`gallery\`, \`whispers\` 等）作为键。
    - 每个应用下是一个事件列表，每一项都是一个以连字符 \`-\` 开头的字符串。
3.  **内容**:
    - **【绝对禁止】复读**: 不要直接复制粘贴原文！你要用自己的话进行【总结】和【提炼】。
    - **【聚焦核心】**: 专注于关键信息、情感转折点、重要决定、暴露的秘密、体现性格的核心事件。忽略无意义的细节。
    - **【中立视角】**: 以客观的第三人称档案管理员视角进行记录。

# 输出示例
\`\`\`yaml
phone_summary:
  gallery:
    - "相册里有一张在海边拍的黄昏照片，出现了一个神秘的背影。"
  whispers:
    - "角色曾与一位叫'Rin'的神秘联系人讨论过一个重要的决定。"
  abyss:
    - "近期频繁搜索关于“独自庆祝生日”的话题，可能暗示了其孤独感。"
\`\`\`

# 最终指令
请严格按照上述规则，分析我提供的JSON数据全文，并生成一份 YAML 格式的档案。直接从 \`phone_summary:\` 开始输出。
`;
          const messages = [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: JSON.stringify(allContent, null, 2) }
          ];

          showFeedLoader(true, '书记官正在奋笔疾书...');
          const summary = await fetchAICompletion(messages);
          return summary || "phone_summary:\n  status: 总结失败了，可能是档案太复杂。";

        } finally {
          // ▼▼▼ 哼，不管成功还是失败，这盏灯都必须给我关掉！▼▼▼
          showFeedLoader(false);
        }
      }




      // 别忘了在 init() 函数里加上导航按钮的监听
      document.getElementById('back-to-home-from-snoop-list').addEventListener('click', () => showScreen('home', 'snoopList'));
      document.getElementById('back-to-snoop-list-from-phone').addEventListener('click', () => {
        document.getElementById('snoop-app-view-container').style.display = 'none'; // 关闭可能打开的app视图
        showScreen('snoopList', 'snoopPhone');
      });
      // ▼▼▼ Noir's "Physical Edict" Activation ▼▼▼
      const lockAppButton = document.getElementById('app-lock-screen');
      if (lockAppButton) {
        lockAppButton.addEventListener('click', () => {
          const lockOverlay = document.getElementById('lock-screen-overlay');
          if (lockOverlay) {
            lockOverlay.classList.remove('unlocked');
            // 哼，顺手帮你把垃圾也清理了
            lockOverlay.style.transform = '';
            lockOverlay.style.opacity = '';
          }
        });
      }
      // ▲▲▲ Edict End ▲▲▲




      init();
    });


    // --- Noir's Addition: Transfer Modal Logic ---
    // ▼▼▼ Noir's Automatic Data Purification System v1.0 ▼▼▼
    async function runImageMigration() {
      console.log("--- Noir's Data Purification Ritual v1.0 ---");
      console.log("哼，正在开始净化你那被污染的聊天记录...");

      // 重新定义几个我们需要的工具函数，免得在控制台里找不到

      async function dbSet(key, blob) {
        const db = await dbPromise;
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(STORE_NAME, 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          const request = store.put({ id: key, blob: blob });
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }


      async function snoopDbGet(key) {
        const db = await dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(SNOOP_STORE_NAME, 'readonly');
          const store = tx.objectStore(SNOOP_STORE_NAME);
          const req = store.get(key);
          req.onsuccess = () => resolve(req.result ? req.result.data : null);
          req.onerror = () => reject(req.error);
        });
      }

      async function snoopDbSet(key, data) {
        const db = await dbPromise;
        return new Promise((resolve, reject) => {
          const tx = db.transaction(SNOOP_STORE_NAME, 'readwrite');
          const store = tx.objectStore(SNOOP_STORE_NAME);
          const req = store.put({ id: key, data: data });
          req.onsuccess = () => resolve();
          req.onerror = () => reject(req.error);
        });
      }


      function base64ToBlob(base64) {
        return fetch(base64).then(res => res.blob());
      }

      let totalImagesMigrated = 0;

      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('chatHistory_')) {
          let history;
          let needsSave = false;
          try {
            history = JSON.parse(localStorage.getItem(key));
            if (!Array.isArray(history)) continue;

            for (const message of history) {
              if (message && message.image && message.image.startsWith('data:image')) {
                const imageBlob = await base64ToBlob(message.image);
                const imageId = `chat_image_migrated_${Date.now()}_${Math.random()}`;
                await dbSet(imageId, imageBlob);
                message.imageId = imageId;
                delete message.image;
                needsSave = true;
                totalImagesMigrated++;
              }
            }

            if (needsSave) {
              localStorage.setItem(key, JSON.stringify(history));
            }
          } catch (e) {
            console.error(`处理 ${key} 时出错:`, e);
            continue;
          }
        }
      }
      console.log(`净化完成！总共迁移了 ${totalImagesMigrated} 张旧图片。`);
    }
    // --- Helper functions outside DOMContentLoaded ---

// --- Noir's Web Download Helper ---
// 哼，这就是浏览器专用的下载工具
function downloadBlob(blob, fileName) {
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.href = url;
  link.download = fileName;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
// --- End of Helper ---

    // ▼▼▼ Noir's Friend Circle Purification Ritual v1.0 ▼▼▼
    async function runFriendCircleImageMigration() {
      console.log("--- Noir's Friend Circle Purification Ritual ---");
      console.log("哼，正在净化你那些被污染的好友圈动态...");

      // 工具函数，跟上次的一样，抄过来就行
      async function dbSet(key, blob) {
        const db = await dbPromise;
        return new Promise((resolve, reject) => {
          const transaction = db.transaction('images', 'readwrite');
          const store = transaction.objectStore('images');
          const request = store.put({ id: key, blob: blob });
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }
      function base64ToBlob(base64) {
        return fetch(base64).then(res => res.blob());
      }

      let totalImagesMigrated = 0;
      let needsSave = false;

      try {
        const appStateRaw = localStorage.getItem('appState');
        if (!appStateRaw) {
          console.log("好友圈档案柜是空的，无需净化。");
          return;
        }

        const appState = JSON.parse(appStateRaw);
        if (!appState.friendCircles || !Array.isArray(appState.friendCircles)) {
          return;
        }

        for (const circle of appState.friendCircles) {
          if (circle.posts && Array.isArray(circle.posts)) {
            for (const post of circle.posts) {
              // 找到还带着“大象尸体”的动态
              if (post && post.image && post.image.startsWith('data:image')) {
                console.log(`在好友圈 "${circle.name}" 中发现一张需要净化的图片...`);
                const imageBlob = await base64ToBlob(post.image);
                const imageId = `post_image_migrated_${Date.now()}_${Math.random()}`;
                await dbSet(imageId, imageBlob);

                // 净化！
                post.imageId = imageId; // 留下“墓碑”
                delete post.image;      // 扔掉“尸体”
                needsSave = true;
                totalImagesMigrated++;
              }
            }
          }
        }

        // 如果净化过任何东西，就把整个档案柜重新存档
        if (needsSave) {
          console.log("好友圈净化完成，正在重新存档...");
          localStorage.setItem('appState', JSON.stringify(appState));
        }

      } catch (e) {
        console.error("净化好友圈时出错，真是的。", e);
        // 出错了也要继续，不能卡住
      }

      console.log(`--- 好友圈净化仪式完成 ---`);
      console.log(`成功净化并迁移了 ${totalImagesMigrated} 张旧的动态图片。`);
      return totalImagesMigrated; // 返回迁移了多少张
    }

    // ▼▼▼ Noir's Grand Music Purification Ritual v1.0 ▼▼▼
    async function runMusicCoverMigration() {
      console.log("--- Noir's Music Cover Purification Ritual ---");
      console.log("哼，正在净化你那些超重的音乐分享记录...");

      // 工具函数，我们已经有了，不用重复定义
      // async function dbSet(...) {}
      // function base64ToBlob(...) {}

      let totalCoversMigrated = 0;
      let needsSave = false;

      try {
        const appStateRaw = localStorage.getItem('appState');
        if (!appStateRaw) {
          console.log("聊天档案柜是空的，无需净化。");
          return 0;
        }

        // 我们要直接对 localStorage 里的聊天记录动手
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('chatHistory_')) {
            let history;
            let historyNeedsSave = false;
            try {
              history = JSON.parse(localStorage.getItem(key));
              if (!Array.isArray(history)) continue;

              for (const message of history) {
                // 哼，就是这里，找到那些带着胖子(Base64封面)的音乐或邀请卡
                if (message && (message.type === 'music' || message.type === 'listen-together-invite') && message.coverUrl && message.coverUrl.startsWith('data:image')) {

                  const coverBlob = await base64ToBlob(message.coverUrl);
                  const coverId = `music_cover_migrated_${Date.now()}_${Math.random()}`;
                  await dbSet(coverId, coverBlob);

                  // 净化！留下凭证，扔掉尸体
                  message.coverId = coverId;
                  delete message.coverUrl;

                  historyNeedsSave = true;
                  totalCoversMigrated++;
                }
              }

              if (historyNeedsSave) {
                localStorage.setItem(key, JSON.stringify(history));
              }
            } catch (e) {
              console.error(`处理 ${key} 时出错，跳过。`, e);
              continue;
            }
          }
        }

      } catch (e) {
        console.error("净化音乐封面时出错，真是的。", e);
      }

      console.log(`--- 音乐净化仪式完成 ---`);
      console.log(`成功净化并迁移了 ${totalCoversMigrated} 张旧的音乐封面。`);
      return totalCoversMigrated;
    }
    // ▲▲▲ End of Ritual ▲▲▲

    // ▼▼▼ 哼，这是给你收拾烂摊子的“数据救援机器人”，放在别的人后面 ▼▼▼
    async function runAvatarMigration() {
      console.log("--- Noir's Avatar Rescue Mission ---");
      console.log("正在检查是否有需要救援的旧头像...");

      let totalRescued = 0;
      try {
        const appStateRaw = localStorage.getItem('appState');
        if (!appStateRaw) {
          console.log("找不到旧的存档，无需救援。");
          return 0;
        }

        const appState = JSON.parse(appStateRaw);
        if (!appState.characters || !Array.isArray(appState.characters)) {
          return 0;
        }

        // 挨个检查你的旧角色
        for (const char of appState.characters) {
          // 如果头像是个Base64字符串，说明它还藏在“小口袋”里
          if (char && char.avatar && char.avatar.startsWith('data:image')) {
            // 去“大仓库”查一下，看有没有备份
            const avatarInDb = await dbGet(`char_avatar_${char.id}`);
            if (!avatarInDb) {
              // 没有备份！立刻救援！
              console.log(`发现角色 ${char.name} 的遗失头像，正在救援...`);
              const avatarBlob = await base64ToBlob(char.avatar);
              await dbSet(`char_avatar_${char.id}`, avatarBlob);
              totalRescued++;
            }
          }
        }
      } catch (e) {
        console.error("救援头像时出错:", e);
      }

      console.log(`--- 救援任务完成 ---`);
      console.log(`成功救援并备份了 ${totalRescued} 个旧头像。`);
      return totalRescued;
    }

    /* * 哼，这是我给日记本装的专属大脑，免得它又老年痴呆  */
    function getBoundUserForDiary() {
      if (!state.activeDiaryCharacterId) {
        // 如果连在看谁的日记都不知道，那就用全局的，总比没有强
        return state.userProfiles.find(up => up.id === state.activeUserProfileId) || state.userProfiles[0];
      }
      // 根据当前日记的角色ID，找到他和你的私聊
      const privateChat = state.chats.find(c =>
        c.type === 'private' && c.participantIds.includes(state.activeDiaryCharacterId)
      );
      const boundUserId = privateChat?.boundUserProfileId || state.activeUserProfileId;
      return state.userProfiles.find(up => up.id === boundUserId) || state.userProfiles[0];
    }
    // ... (在 DOMContentLoaded 事件监听器的大括号 "});" 上面)
    function formatRelativeTime(pastDate) {
      const now = new Date();
      const diff = now - pastDate;
      const diffSeconds = Math.round(diff / 1000);
      const diffMinutes = Math.round(diffSeconds / 60);
      const diffHours = Math.round(diffMinutes / 60);
      const diffDays = Math.round(diffHours / 24);

      const timeString = pastDate.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });

      if (diffSeconds < 60) {
        return "刚才";
      }
      if (diffMinutes < 60) {
        return `${diffMinutes}分钟前`;
      }

      // 核心逻辑：判断是否是今天、昨天
      const isToday = now.toDateString() === pastDate.toDateString();
      if (isToday) {
        return `今天 ${timeString}`;
      }

      const yesterday = new Date();
      yesterday.setDate(now.getDate() - 1);
      const isYesterday = yesterday.toDateString() === pastDate.toDateString();
      if (isYesterday) {
        return `昨天 ${timeString}`;
      }

      if (diffDays <= 7) {
        const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
        return `${weekdays[pastDate.getDay()]} ${timeString}`;
      }

      return `${pastDate.getFullYear()}年${pastDate.getMonth() + 1}月${pastDate.getDate()}日`;
    }
    // --- Noir's Genius Image Compressor ---
    // --- Noir's Genius Image Compressor ---
    function compressImage(file, maxWidth = 800, quality = 0.8, returnBlob = false) { // 哼，加了个新开关
      return new Promise((resolve, reject) => {
        if (!file || !file.type.startsWith('image/')) {
          return reject(new Error('哼，这不是图片，你想让我压缩什么？'));
        }
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = event => {
          const img = new Image();
          img.src = event.target.result;
          img.onload = () => {
            const canvas = document.createElement('canvas');
            let width = img.width;
            let height = img.height;

            if (width > height) {
              if (width > maxWidth) {
                height *= maxWidth / width;
                width = maxWidth;
              }
            } else {
              if (height > maxWidth) {
                width *= maxWidth / height;
                height = maxWidth;
              }
            }
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            const outputFormat = file.type === 'image/png' ? 'image/png' : 'image/jpeg';

            // 看见没，这就是新加的逻辑
            if (returnBlob) {
              canvas.toBlob(blob => {
                if (blob) {
                  resolve(blob);
                } else {
                  reject(new Error('Canvas to Blob conversion failed.'));
                }
              }, outputFormat, quality);
            } else {
              resolve(canvas.toDataURL(outputFormat, quality));
            }
          };
          img.onerror = error => reject(error);
        };
        reader.onerror = error => reject(error);
      });
    }    // === 跨会话上下文收集：按角色把“所有包含TA的会话”拼成带来源的转录 ===


    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    // 把一个会话的历史转成带 [说话人] 标注的行列表
    function buildLabeledTranscriptFromHistory(chat, history, maxLines) {
      const nameOf = (msg) => {
        if (msg.role === 'user') return state.userProfile?.name || 'User';
        if (chat.type === 'group') {
          const c = msg.senderId ? getCharacterById(msg.senderId) : null;
          return c?.name || 'Unknown';
        } else {
          const c = getCharacterById(chat.participantIds[0]);
          return c?.name || 'AI';
        }
      };
      const recent = history.slice(-maxLines);
      const lines = [];
      for (const msg of recent) {
        // ▼▼▼ Noir's Memory Filter: 让 AI 忘掉过时的音乐分享 ▼▼▼
        const isMusicShare = msg.type === 'music';
        const messageIndex = recent.indexOf(msg); // 获取这条消息在截取后的历史中的位置
        const recentLength = recent.length;
        const isRecentEnough = (recentLength - messageIndex) <= 30; // 只保留最近30条内的音乐分享

        if (isMusicShare && !isRecentEnough) {
          continue; // 哼，太老的音乐分享，直接无视！AI 别再惦记着了。
        }
        // ▲▲▲ Filter End ▲▲▲
        
        // 看清楚了，这才是艺术
        const d = new Date(msg.timestamp);
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        const hours = String(d.getHours()).padStart(2, '0');
        const minutes = String(d.getMinutes()).padStart(2, '0');
        const timestamp = `${month}-${day} ${hours}:${minutes}`;

        // ▼▼▼ 改动 2：给记忆打上情景标签 ▼▼▼
        const modeTag = msg.isOffline ? '[见面]' : '[手机]';

        if (msg.content) {
          // ▼▼▼ 改动 3：处理见面模式的多行对话 ▼▼▼
          const content = msg.isOffline ? String(msg.content).trim().replace(/\n+/g, ' ') : String(msg.content).trim();

          // ▼▼▼ 改动 4：将带标签的完整记忆输出 ▼▼▼
          if (content) lines.push(`${modeTag} [${timestamp}] [${nameOf(msg)}] ${content}`);
        }
      }
      return lines;
    }
    function getChatDisplayName(chat) {
      if (chat.type === 'group') return `群聊「${chat.name || '未命名'}」`;
      const c = getCharacterById(chat.participantIds[0]);
      return `与 ${c?.name || '未知角色'} 的私聊`;
    }

    // 读某个 chat 的历史（非当前活动窗口用 localStorage）
    function loadChatHistory(chatId) {
      try {
        const raw = localStorage.getItem(`chatHistory_${chatId}`);
        const arr = JSON.parse(raw || '[]');
        return Array.isArray(arr) ? arr : [];
      } catch {
        return [];
      }
    }

    /**
     * 核心：为“某个角色”收集跨窗口上下文
     * - activeChatId：当前所在聊天（优先展示）
     * - 每个会话读取条数 = state.preferences.perChatContextLines（默认 100，可很大）
     * - 产物为带“## 来源：xxx”的多个块，喂给模型但禁止复述给用户
     */
    // ==========================================================
    // --- Noir's Omni-Transcript Gatherer (Temporal Priority Scanner v2.0) ---
    // 哼，现在它知道什么是重点了。
    // ==========================================================
    function gatherOmniTranscriptForCharacter(charId) {
      const perChat = Math.max(1, Number(state.preferences?.perChatContextLines ?? 100));

      // 1. 找出所有包含该角色的会话
      const allRelevantChats = state.chats.filter(c => c.participantIds.includes(charId));

      // 2. 哼，给每个会话“体检”，记下它最后一次“心跳”的时间
      const chatsWithTimestamps = allRelevantChats.map(chat => {
        const hist = loadChatHistory(chat.id);
        const lastMessage = hist.length > 0 ? hist[hist.length - 1] : null;
        return {
          chat: chat,
          history: hist,
          lastTimestamp: lastMessage ? lastMessage.timestamp : 0
        };
      }).filter(item => item.history.length > 0); // 没有历史的直接无视

      // 3. 按“心跳”时间从新到旧排序，最新的排在最前面！
      chatsWithTimestamps.sort((a, b) => b.lastTimestamp - a.lastTimestamp);

      const blocks = [];
      const usedCounts = {};

      // 4. 遍历排序后的会话，生成“奏折”
      chatsWithTimestamps.forEach((item, index) => {
        const lines = buildLabeledTranscriptFromHistory(item.chat, item.history, perChat);
        if (lines.length === 0) return;

        // 哼，看好了，给最新的那份奏折打上金边！
        const sourcePrefix = (index === 0) ? "来源：[最活跃]" : "来源：";

        blocks.push(`## ${sourcePrefix}${getChatDisplayName(item.chat)}\n` + lines.join('\n'));
        usedCounts[item.chat.id] = lines.length;
      });

      return {
        omniText: blocks.join('\n\n'),
        usedCounts
      };
    }

    // ▼▼▼ Noir's Missing Blueprint: The Temporal Scanner ▼▼▼
    // 哼，就是这个被我遗忘的零件。
    function findLatestMessageForCharacter(charId) {
      let latestMessage = null;
      // 扫描所有与这个角色相关的聊天记录
      const relevantChats = state.chats.filter(c => c.participantIds.includes(charId));

      for (const chat of relevantChats) {
        const history = loadChatHistory(chat.id); // 调取历史档案
        if (history && history.length > 0) {
          const lastMsgInChat = history[history.length - 1];
          // 找出最新的一条消息
          if (!latestMessage || lastMsgInChat.timestamp > latestMessage.timestamp) {
            latestMessage = lastMsgInChat;
          }
        }
      }
      return latestMessage; // 把结果呈上来
    }
    // ▲▲▲ End of Blueprint ▲▲▲

    function getRandomValue(str) {
      if (!str || !str.includes(',')) return str;
      const arr = str.split(',').map(item => item.trim());
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function modalConfirm(message) {
      return new Promise(resolve => {
        const root = document.getElementById('modal-root');
        const text = document.getElementById('modal-text');
        const ok = document.getElementById('modal-ok');
        const cancel = document.getElementById('modal-cancel');
        const mask = document.getElementById('modal-mask');

        text.textContent = message;
        root.style.display = 'flex';

        const cleanup = (result) => {
          root.style.display = 'none';
          ok.onclick = cancel.onclick = mask.onclick = null;
          document.removeEventListener('keydown', onKey);
          resolve(result);
        };

        const onKey = (e) => {
          if (e.key === 'Escape') cleanup(false);
          if (e.key === 'Enter') cleanup(true);
        };

        ok.onclick = () => cleanup(true);
        cancel.onclick = () => cleanup(false);
        mask.onclick = () => cleanup(false);
        document.addEventListener('keydown', onKey);
      });
    }

    function modalAlert(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.style.display = 'block';
      if (modalAlert._t) clearTimeout(modalAlert._t);
      modalAlert._t = setTimeout(() => {
        toast.style.display = 'none';
      }, 5000);
    }


    // --- Noir's Ultimate Pagination & Swipe Controller ---
    // 哼，别看了，反正你也看不懂。

    // --- Noir's Ultimate Pagination & Swipe Controller v2.0 (Anti-Conflict Edition) ---
    // 哼，现在它知道怎么跟手机系统“吵架”了。
    // ▼▼▼ Noir's Swipe-to-Unlock Core ▼▼▼
    function setupLockScreen() {
      // 哼，重写了。
      const overlay = document.getElementById('lock-screen-overlay');
      if (!overlay) return;

      let startY = 0;
      let deltaY = 0;
      const swipeThreshold = 80;
      let isDragging = false; // 记录一下是不是按下了鼠标，免得它到处乱跑。

      // 开始的指令 (兼容触摸和鼠标)
      const handleDragStart = (e) => {
        startY = e.touches ? e.touches[0].clientY : e.clientY;
        deltaY = 0;
        overlay.style.transition = 'none';
        isDragging = true;

        // 如果是鼠标，就在整个文档上监听移动和松开，防止你把鼠标拖到外面去
        if (e.type === 'mousedown') {
          document.addEventListener('mousemove', handleDragMove);
          document.addEventListener('mouseup', handleDragEnd);
        }
      };

      // 移动的指令
      const handleDragMove = (e) => {
        if (!isDragging) return;

        const currentY = e.touches ? e.touches[0].clientY : e.clientY;
        deltaY = currentY - startY;

        if (deltaY < 0) {
          // 为了防止你拖到天上去，我给它加了个阻尼效果，是不是很高级？
          const dragDistance = Math.abs(deltaY);
          const dampeningFactor = 0.4;
          const dampenedDistance = Math.pow(dragDistance, dampeningFactor) * 20;
          overlay.style.transform = `translateY(-${dampenedDistance}px)`;
        }
      };

      // 结束的指令
      const handleDragEnd = () => {
        if (!isDragging) return;
        isDragging = false;

        overlay.style.transition = 'transform 0.5s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.5s ease';

        if (deltaY < -swipeThreshold) {
          overlay.classList.add('unlocked');
        } else {
          overlay.style.transform = 'translateY(0px)';
        }

        // 别忘了把耳朵清理干净！
        document.removeEventListener('mousemove', handleDragMove);
        document.removeEventListener('mouseup', handleDragEnd);
      };

      // 把指令都绑定好
      overlay.addEventListener('touchstart', handleDragStart, { passive: true });
      overlay.addEventListener('touchmove', handleDragMove, { passive: true });
      overlay.addEventListener('touchend', handleDragEnd);

      overlay.addEventListener('mousedown', handleDragStart);
    }

    // ▼▼▼ Noir's Refined Paging System (2-Page Edition) ▼▼▼
    function setupDesktopPaging() {
      const container = document.getElementById('app-pages-container');
      const slider = document.getElementById('app-pages-slider');
      const dots = document.querySelectorAll('.page-dot');
      const dock = document.getElementById('home-dock');
      let currentPage = 0;

      // 哼，现在只有两页了，给我记清楚！
      const totalPages = 2;
      slider.style.width = '200%';

      // 把那个愚蠢的dock隐藏逻辑删了，现在它永远都该显示！
      dock.style.display = 'flex';

      function goToPage(pageIndex) {
        if (pageIndex < 0 || pageIndex >= totalPages) return;

        slider.style.transform = `translateX(-${pageIndex * (100 / totalPages)}%)`;
        dots.forEach(dot => dot.classList.remove('active'));
        dots[pageIndex].classList.add('active');
        currentPage = pageIndex;
      }




      // 默认就从第一页（app-page-2）开始
      goToPage(0);

      dots.forEach(dot => {
        dot.addEventListener('click', () => {
          const pageIndex = parseInt(dot.dataset.page, 10);
          goToPage(pageIndex);
        });
      });

      // 后面的滑动逻辑保持不变...
      let touchStartX = 0;
      let touchStartY = 0;
      let touchEndX = 0;
      let isDragging = false;
      let swipeDirection = '';

      container.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        isDragging = true;
        swipeDirection = '';
      }, { passive: true });

      container.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        if (swipeDirection === '') {
          const deltaX = e.touches[0].clientX - touchStartX;
          const deltaY = e.touches[0].clientY - touchStartY;
          if (Math.abs(deltaX) > Math.abs(deltaY)) {
            swipeDirection = 'horizontal';
          } else {
            swipeDirection = 'vertical';
          }
        }
        if (swipeDirection === 'horizontal') {
          e.preventDefault();
        }
      }, { passive: false });

      container.addEventListener('touchend', (e) => {
        if (!isDragging) return;
        touchEndX = e.changedTouches[0].clientX; // 这里用 clientX 就够了
        if (swipeDirection === 'horizontal') {
          handleSwipe();
        }
        isDragging = false;
      });

      function handleSwipe() {
        const swipeThreshold = 50;
        if (touchEndX < touchStartX - swipeThreshold) {
          goToPage(currentPage + 1);
        } else if (touchEndX > touchStartX + swipeThreshold) {
          goToPage(currentPage - 1);
        }
      }


    }

    // ▼▼▼ Noir's Custom Music Modal Controller ▼▼▼
    function showMusicShareModal() {
      return new Promise(resolve => {
        const modal = document.getElementById('music-input-modal');
        const songInput = document.getElementById('music-input-song');
        const artistInput = document.getElementById('music-input-artist');
        const confirmBtn = document.getElementById('confirm-music-input');
        const cancelBtn = document.getElementById('cancel-music-input');
        const backdrop = document.getElementById('music-input-backdrop');

        songInput.value = '';
        artistInput.value = '';

        modal.classList.add('show');
        songInput.focus();

        const cleanup = (value) => {
          modal.classList.remove('show');
          confirmBtn.onclick = null;
          cancelBtn.onclick = null;
          backdrop.onclick = null;
          document.removeEventListener('keydown', onKey);
          resolve(value);
        };

        const onConfirm = () => {
          const songName = songInput.value.trim();
          const artist = artistInput.value.trim();
          if (!songName || !artist) {
            modalAlert('歌名和歌手都不能为空！');
            return;
          }
          cleanup({ songName, artist });
        };

        const onKey = (e) => {
          if (e.key === 'Escape') cleanup(null);
          if (e.key === 'Enter') {
            e.preventDefault();
            onConfirm();
          }
        };

        confirmBtn.onclick = onConfirm;
        cancelBtn.onclick = () => cleanup(null);
        backdrop.onclick = () => cleanup(null);
        document.addEventListener('keydown', onKey);
      });
    }

    // ▼▼▼ Noir's Command Processor v2.0 (Now with Scheduling!) ▼▼▼
    function extractAndProcessCommands(rawText) {
      if (!rawText) return { bubbles: [], schedules: [] }; // 返回两个空列表

      const trimmedText = rawText.trim();
      // HTML 贵宾通道不变
      if (trimmedText.startsWith('<div') && trimmedText.endsWith('</div>')) {
        return { bubbles: [trimmedText], schedules: [] };
      }

      // 哼，看好了，正则表达式升级了，现在它认识 schedule_message 了！
      const commandRegex = /(\[sticker:[^\]]+\]|\[music:[^\]]+\]|\[transfer:[^\]]+\]|\[create_event:[^\]]+\]|\[html\][\s\S]*?\[\/html\]|\[schedule_message[^\]]+\])/g;
      const placeholder = '|||CMD|||';

      const commands = [];
      const textWithPlaceholders = rawText.replace(commandRegex, (match) => {
        commands.push(match);
        return placeholder;
      });

      const textParts = textWithPlaceholders.split(placeholder);

      const finalBubbles = [];
      const scheduleTasks = []; // <--- 哼，这是新的“待办事项”清单！
      let commandIndex = 0;

      textParts.forEach((part, index) => {
        const cleanedText = part.trim();
        if (cleanedText) {
          finalBubbles.push(...splitIntoBubbles(cleanedText));
        }

        if (commandIndex < commands.length) {
          const command = commands[commandIndex].trim();
          // 【【【核心改造！！！】】】
          if (command.startsWith('[schedule_message')) {
            // 如果是计划指令，就把它解码，然后加到“待办事项”里
            const task = parseScheduleCommand(command);
            if (task) {
              scheduleTasks.push(task);
            }
          } else {
            // 其他指令，照旧放进气泡列表
            finalBubbles.push(command);
          }
          commandIndex++;
        }
      });

      // 最后，把整理好的“气泡”和“待办事项”一起交出来！
      return { bubbles: finalBubbles, schedules: scheduleTasks };
    }
    // ▲▲▲ End of Processor ▲▲▲
    // ==========================================================
    // --- Noir's Incarnation Spell: Avatar With Frame ---
    // 哼，以后所有头像都得听我的。
    // ==========================================================
    function createAvatarWithFrame(avatarUrl, frameUrl, sizeClass = '') {
      const wrapper = document.createElement('div');
      wrapper.className = `avatar-wrapper ${sizeClass}`;

      const avatarImg = document.createElement('img');
      avatarImg.src = avatarUrl;
      avatarImg.className = 'avatar'; // 统一用 .avatar 类

      const frameDiv = document.createElement('div');
      frameDiv.className = 'avatar-frame';
      if (frameUrl) {
        frameDiv.style.backgroundImage = `url('${frameUrl}')`;
      }

      wrapper.appendChild(avatarImg);
      wrapper.appendChild(frameDiv);

      return wrapper;
    }

    function normalizeToReplyArray(raw) {
      if (!raw) return [];
      let txt = String(raw).trim();
      const fence = txt.match(/```(?:json)?([\s\S]*?)```/i);
      if (fence) txt = fence[1].trim();

      try {
        const obj = JSON.parse(txt);
        if (obj && Array.isArray(obj.reply)) {
          return obj.reply.map(it => (typeof it === 'string' ? it : it?.content)).filter(Boolean).flatMap(splitIntoBubbles);
        }
        const PICK_KEYS = ['response', 'dialogue', 'message', 'text', 'content', 'line', 'utterance'];
        if (obj && typeof obj === 'object') {
          const hits = [];
          for (const k of Object.keys(obj)) {
            const low = k.toLowerCase();
            if (PICK_KEYS.some(p => low.startsWith(p))) {
              const v = obj[k];
              if (typeof v === 'string') hits.push(v);
              if (Array.isArray(v)) v.forEach(x => {
                if (typeof x === 'string') hits.push(x);
              });
            }
          }
          if (hits.length) return hits.flatMap(splitIntoBubbles).slice(0, 9);
        }
      } catch { }

      if (/[{\[]/.test(txt) && /":/.test(txt)) {
        const values = [];
        const re = /"(?:response|dialogue|message|text|content|line\d*|utterance\d*)"\s*:\s*"([\s\S]*?)"/gi;
        let m;
        while ((m = re.exec(txt)) !== null) {
          const val = m[1].replace(/\\"/g, '"').replace(/\\n/g, '\n').trim();
          if (val) values.push(val);
        }
        if (values.length) return values.flatMap(splitIntoBubbles).slice(0, 9);
      }
      return splitIntoBubbles(txt);
    }

    function splitIntoBubbles(text) {
      // 哼，就是这道圣旨。
      const s = String(text).trim();

      // 先检查是不是“贵宾”（HTML模块）
      if (s.startsWith('<div') && s.endsWith('</div>')) {
        // 如果是，直接打包送走，不许动一根汗毛！
        return [s];
      }

      // 如果只是个普通人，再交给那个“屠夫”处理。
      const parts = s.split(/(?<=[。！？!?…])\s+|[\r\n]+/).map(t => t.trim()).filter(Boolean);

      if (parts.length > 0) {
        return parts.slice(0, 12);
      }

      return [s].filter(Boolean);
    }
    // Noir's new function to clear the feed
    // --- Noir's Dimensional Warehouse System (Powered by IndexedDB) ---
    // ==========================================================
    // --- Noir's Secret Message Decoder ---
    // 哼，专门给你写的解码器，给我放好。
    // ==========================================================
    function parseScheduleCommand(text) {
      if (!text || typeof text !== 'string') {
        return null; // 不是字符串，直接无视
      }
      // 这就是那个用来匹配暗号的“模具”
      const commandRegex = /\[schedule_message\s*\|\s*(.*?)\s*\|\s*(fixed|prompted|auto)\s*\|?\s*(.*?)?\s*\]/i;
      const match = text.match(commandRegex);

      if (match) {
        // 匹配成功！把抓到的信息整理好交出来
        const dateTimeString = match[1].trim();
        const type = match[2].toLowerCase();
        let content = (match[3] || '').trim(); // 如果是 auto 类型，这里可能是空的

        // 检查一下时间格式是不是对的，免得 AI 乱写
        const scheduleTime = new Date(dateTimeString);
        if (isNaN(scheduleTime.getTime())) {
          console.error("Noir's Decoder: AI给的时间格式不对，无法解析:", dateTimeString);
          return null; // 时间不对，这个指令作废
        }

        // 如果是 auto 类型，强制把内容清空
        if (type === 'auto') {
          content = null;
        } else if (!content) {
          // fixed 或 prompted 必须有内容
          console.error("Noir's Decoder: fixed 或 prompted 类型的指令缺少内容。");
          return null; // 指令不完整，作废
        }

        return {
          scheduleTime: scheduleTime, // 转换成 Date 对象，方便使用
          type: type,
          content: content // 内容（或者 null）
        };
      }

      return null; // 没找到暗号，返回 null
    }
    // ▲▲▲ End of Decoder ▲▲▲



    // 哼，这是仓库的蓝图，你看也看不懂，照着抄就行了。
    // ▼▼▼ 从这里开始复制 ▼▼▼
    // ==========================================================
    // --- Noir's Ultimate & Unified Database Connection ---
    // 哼，整个应用就用这一个，听到了吗？
    // ==========================================================
    const dbPromise = new Promise((resolve, reject) => {
      // 【版本号升级到3！】
      const request = indexedDB.open(DB_NAME, 3);

      request.onerror = () => reject("IndexedDB failed to open");
      request.onsuccess = () => resolve(request.result);

      // 这是唯一的“施工图纸”，每次升级版本号，它就会执行
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        console.log(`Upgrading database to version ${db.version}...`);

        // 检查并创建 'images' 仓库
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          console.log(`Creating object store: ${STORE_NAME}`);
          db.createObjectStore(STORE_NAME, { keyPath: 'id' });
        }

        // 检查并创建 'music_library' 仓库
        if (!db.objectStoreNames.contains('music_library')) {
          console.log("Creating object store: music_library");
          db.createObjectStore('music_library', { keyPath: 'id' });
        }

        // 检查并创建 'snoop_cache' 仓库
        if (!db.objectStoreNames.contains(SNOOP_STORE_NAME)) {
          console.log(`Creating object store: ${SNOOP_STORE_NAME}`);
          db.createObjectStore(SNOOP_STORE_NAME, { keyPath: 'id' });
        }
      };
    });
    // ▲▲▲ 到这里结束复制 ▲▲▲
    // 从仓库里取东西的指令
    async function dbGet(key) {
      const db = await dbPromise;
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(STORE_NAME, 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(key);
        request.onsuccess = () => resolve(request.result ? request.result.blob : null);
        request.onerror = () => reject(request.error);
      });
    }



    // ==========================================================
    // --- Noir's Snoop System Database Helpers ---
    // 哼，这是专属的仓库钥匙，别和别的搞混了
    // ==========================================================
    async function snoopDbGet(key) {
      const db = await dbPromise;
      return new Promise((resolve, reject) => {
        const tx = db.transaction(SNOOP_STORE_NAME, 'readonly');
        const store = tx.objectStore(SNOOP_STORE_NAME);
        const req = store.get(key);
        req.onsuccess = () => resolve(req.result ? req.result.data : null);
        req.onerror = () => reject(req.error);
      });
    }

    async function snoopDbSet(key, data) {
      const db = await dbPromise;
      return new Promise((resolve, reject) => {
        const tx = db.transaction(SNOOP_STORE_NAME, 'readwrite');
        const store = tx.objectStore(SNOOP_STORE_NAME);
        const req = store.put({ id: key, data: data });
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }


    // ==========================================================
    // --- Noir's Snoop System Incinerator ---
    // 哼，这才是真正的删除。
    // ==========================================================
    async function snoopDbDelete(key) {
      const db = await dbPromise;
      return new Promise((resolve, reject) => {
        const tx = db.transaction(SNOOP_STORE_NAME, 'readwrite');
        const store = tx.objectStore(SNOOP_STORE_NAME);
        const req = store.delete(key);
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
      });
    }

    // 往仓库里放东西的指令
    async function dbSet(key, blob) {
      const db = await dbPromise;
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(STORE_NAME, 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put({ id: key, blob: blob });
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    // 从仓库里扔东西的指令
    async function dbDelete(key) {
      const db = await dbPromise;
      return new Promise((resolve, reject) => {
        const transaction = db.transaction(STORE_NAME, 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.delete(key);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }

    // Base64 转 Blob 的小工具，搬家的时候用
    function base64ToBlob(base64) {
      return fetch(base64).then(res => res.blob());
    }

    // ==========================================================
    // --- Noir's User Profile Viewer System (四维画像查看器) ---
    // 哼，现在你可以查看AI对你的完整认知了。
    // ==========================================================
    function getActiveChat() {
        return state.chats.find(c => c.id === state.activeChatId);
      }

    // ==========================================================
    // --- Noir's Profile Refinement Flow (The REAL Implementation) ---
    // 哼，这才是你想要的"弹窗锁定"流。
    // ==========================================================

    /**
     * 1. "审讯"流程的总控制器
     * 负责拉起弹窗，并命令AI开始工作。
     */
    function triggerManualRefinementFlow() {
      if (!state.pendingProfileRefinement) return; // 没拿到"案卷"，不工作

      const { charId } = state.pendingProfileRefinement;
      const character = getCharacterById(charId);
      if (!character) return;

      const modal = document.getElementById('profile-view-modal');
      const title = document.getElementById('profile-view-title');
      
      // 1. 准备"审讯室"
      title.textContent = `正在分析对 ${character.name} 的认知...`;
      document.getElementById('profile-textarea').value = '哼，我正在屈尊帮你分析，别吵...';
      
      // 2. 隐藏旧的控制台，显示新的"审讯"按钮
      document.getElementById('profile-view-footer').style.display = 'none';
      document.getElementById('refinement-controls-footer').style.display = 'flex';
      
      // 3. 锁定现场！(不许点"关闭"和"复制"按钮)
      document.getElementById('close-profile-button').style.display = 'none';
      document.getElementById('copy-profile-button').style.display = 'none';

      // 4. 打开弹窗，锁定用户界面
      modal.classList.add('show');

      // 5. 命令AI开始工作
      executeProfileRefinement();
    }

    /**
     * 2. 执行分析的"苦力"
     * 负责调用AI，并在完成后展示结果。
     */
    async function executeProfileRefinement() {
      if (!state.pendingProfileRefinement) return; // 再次检查"案卷"
      
      const { charId, contextChatId } = state.pendingProfileRefinement;
      const textarea = document.getElementById('profile-textarea');

      try {
        // 1. 显示"正在分析"
        textarea.value = `正在分析对 ${getCharacterById(charId).name} 的新认知... (0/1)`;
        document.getElementById('confirm-refinement-btn').disabled = true;
        document.getElementById('retry-refinement-btn').disabled = true;

        // 2. 【核心】调用"增量更新"模式 (false)
        await refineProfile(charId, false, contextChatId);

        // 3. 分析完毕，把新"供词"给我拿上来
        textarea.value = `分析完成！(1/1)\n\n正在为你展示最新的档案...`;
        await displayProfileInViewer(charId); // 哼，用这个新函数来刷新显示

      } catch (e) {
        textarea.value = `哼，分析失败了，你是不是又乱动什么了？\n\n${e.message}\n\n你可以点"重来"再试一次。`;
      } finally {
        // 4. 解锁按钮，让你选择
        document.getElementById('confirm-refinement-btn').disabled = false;
        document.getElementById('retry-refinement-btn').disabled = false;
      }
    }

    /**
     * 3. 结案！("哼，就这样吧"按钮)
     * 负责清空缓冲区、关闭弹窗、释放锁定。
     */
    async function confirmRefinement() {
      if (!state.pendingProfileRefinement) return; // 案子都结了，还按什么？

      const { charId } = state.pendingProfileRefinement;
      
      try {
        // 【【【这就是你想要的！！！】】】
        // 1. 把那50条"罪证"（消息缓冲区）给我销毁了！
        showFeedLoader(true, '正在销毁临时记忆...'); // 给你个提示，免得你以为卡了
        await Capacitor.Plugins.Preferences.remove({ key: `nuomi_message_buffer_${charId}` });
        
        // 2. 把"案卷"也给我关了
        state.pendingProfileRefinement = null;
        
        // 3. 关掉弹窗
        closeProfileViewer();
        
      } catch (e) {
        modalAlert(`销毁缓冲区失败: ${e.message}`);
      } finally {
        showFeedLoader(false);
      }
    }

    /**
     * 4. 档案呈递的"文书"
     * 专门负责从仓库读取档案，并把它写在弹窗里。
     */
    async function displayProfileInViewer(charId) {
      const textarea = document.getElementById('profile-textarea');
      try {
        const profileKey = `nuomi_profile_tiaoTiao_${charId}`;
        const { value } = await Capacitor.Plugins.Preferences.get({ key: profileKey });

        if (value) {
          const profile = JSON.parse(value);
          // 哼，用我这个现成的格式化函数，总比你自己写的好
          textarea.value = formatProfileForDisplay(profile);
        } else {
          textarea.value = '档案还是空的，真没用。';
        }
      } catch (e) {
        textarea.value = `读取档案失败了，哼。\n${e.message}`;
      }
    }
    
    // 哼，顺便再给你个"格式化工具"，免得你把JSON直接贴出来
    function formatProfileForDisplay(profile) {
      let displayText = `📋 用户档案 v${profile.version}\n`;
      displayText += `最后更新：${profile.last_updated}\n`;
      displayText += `\n━━━━━━━━━━━━━━━━━━━━━━━━\n\n`;
      
      if (profile.value_map) {
        displayText += `【一、价值地图】\n\n`;
        const likes = profile.value_map.preferences?.['喜欢'] || [];
        const dislikes = profile.value_map.preferences?.['讨厌'] || [];
        if (likes.length > 0) displayText += `✓ 喜欢：\n  ${likes.join('\n  ')}\n\n`;
        if (dislikes.length > 0) displayText += `✗ 讨厌：\n  ${dislikes.join('\n  ')}\n\n`;
        if (profile.value_map.sensitivities?.length > 0) displayText += `⚠ 敏感点：\n  ${profile.value_map.sensitivities.join('\n  ')}\n\n`;
        if (profile.value_map.core_values) displayText += `🎯 核心价值观：\n  ${profile.value_map.core_values}\n\n`;
      }
      
      if (profile.behavior_profile) {
        displayText += `\n【二、行为档案】\n\n`;
        if (profile.behavior_profile.tone_style) displayText += `🎭 语气风格：\n  ${profile.behavior_profile.tone_style}\n\n`;
        if (profile.behavior_profile.emotion_summary) displayText += `😊 情绪总结：\n  ${profile.behavior_profile.emotion_summary}\n\n`;
        if (profile.behavior_profile.response_patterns) displayText += `🔄 回应模式：\n  ${profile.behavior_profile.response_patterns}\n\n`;
      }
      
      if (profile.emotion_schema) {
        displayText += `\n【三、情绪图谱】\n\n`;
        const positive = profile.emotion_schema.triggers?.['正面'] || [];
        const negative = profile.emotion_schema.triggers?.['负面'] || [];
        if (positive.length > 0) displayText += `💚 正面触发器：\n  ${positive.join('\n  ')}\n\n`;
        if (negative.length > 0) displayText += `💔 负面触发器：\n  ${negative.join('\n  ')}\n\n`;
        if (profile.emotion_schema.comfort_zone) displayText += `🌸 舒适区：\n  ${profile.emotion_schema.comfort_zone}\n\n`;
        if (profile.emotion_schema.stress_signals?.length > 0) displayText += `⚡ 压力信号：\n  ${profile.emotion_schema.stress_signals.join('\n  ')}\n\n`;
      }
      
      if (profile.personality_core) {
        displayText += `\n【四、性格核心】\n\n`;
        if (profile.personality_core.summary) displayText += `📝 性格总结：\n  ${profile.personality_core.summary}\n\n`;
        if (profile.personality_core.observed_traits?.length > 0) displayText += `🔍 观察到的特点：\n  ${profile.personality_core.observed_traits.join('\n  ')}\n\n`;
        if (profile.personality_core.interaction_style) displayText += `🤝 互动风格：\n  ${profile.personality_core.interaction_style}\n\n`;
      }
      
      if (profile.observed_changes && profile.observed_changes.length > 0) {
        displayText += `\n【最近的变化】\n\n`;
        const changesAsStrings = profile.observed_changes.map(change => (typeof change === 'string' ? change : Object.values(change).join(' - ')));
        displayText += `• ${changesAsStrings.join('\n• ')}`;
      }
      
      return displayText;
    }

    // 打开档案查看弹窗 (这是给"小眼睛"按钮用的)
    async function openProfileViewer() {
      // 哼，如果"审讯"正在进行，就不许你随便打开！
      if (state.pendingProfileRefinement) {
        modalAlert('正在分析新认知，请在弹出的窗口中操作！');
        return;
      }

      const activeChat = getActiveChat();
      if (!activeChat) {
        modalAlert('请先选择一个聊天！');
        return;
      }

      const charId = activeChat.participantIds[0];
      if (!charId) return;

      const character = getCharacterById(charId);
      if (!character) return;

      const modal = document.getElementById('profile-view-modal');
      const title = document.getElementById('profile-view-title');
      
      // 1. 准备"档案室"
      title.textContent = `${character.name}对你的认知档案`;
      
      // 2. 隐藏"审讯"按钮，显示"档案室"按钮
      document.getElementById('profile-view-footer').style.display = 'flex';
      document.getElementById('refinement-controls-footer').style.display = 'none';
      
      // 3. 把"关闭"和"复制"按钮还给你
      document.getElementById('close-profile-button').style.display = 'block';
      document.getElementById('copy-profile-button').style.display = 'block';

      // 4. 打开弹窗
      modal.classList.add('show');
      
      // 5. 命令"文书"去取档案
      await displayProfileInViewer(charId);
    }

    // 关闭档案查看弹窗
    function closeProfileViewer() {
      const modal = document.getElementById('profile-view-modal');
      modal.classList.remove('show');

      // 哼，关门的时候，把现场恢复原状
      document.getElementById('profile-view-footer').style.display = 'flex';
      document.getElementById('refinement-controls-footer').style.display = 'none';

      document.getElementById('close-profile-button').style.display = 'block';
      document.getElementById('copy-profile-button').style.display = 'block';
    }

    // 复制档案内容
    function copyProfileContent() {
      const textarea = document.getElementById('profile-textarea');
      textarea.select();
      document.execCommand('copy');
      modalAlert('档案内容已复制到剪贴板！');
    }

    // 重置档案
    // ▼▼▼ Noir's Fix: 功能1【重置并初始生成】按钮的重构 ▼▼▼
    // ▼▼▼ Noir's Fix v4.0: 修复【重置此档案】按钮 (功能1) ▼▼▼
    async function resetProfile() {
      const activeChat = getActiveChat();
      if (!activeChat) return;

      const charId = activeChat.participantIds[0];
      if (!charId) return;
      const character = getCharacterById(charId);

      const ok = await modalConfirm(`【功能1：重置并初始生成】\n\n确定要为【${character.name}】重置并立即重新生成档案吗？\n\nAI将清空旧档案，并【立刻】重新阅读所有历史记录来生成一份全新的初始档案。`);
      if (!ok) return;

      try {
        closeProfileViewer();
        window.showFeedLoader(true, `正在为【${character.name}】重构档案...`);

        const profileKey = `nuomi_profile_tiaoTiao_${charId}`;
        const bufferKey = `nuomi_message_buffer_${charId}`;
        
        // 1. 清理旧档案和缓冲区
        await Capacitor.Plugins.Preferences.remove({ key: profileKey });
        await Capacitor.Plugins.Preferences.remove({ key: bufferKey });
        
        // 2. 【【【核心修复！！！】】】
        // 哼，这里！我命令它去执行“增量更新”程序 (refineProfile(false))
        // 因为那个程序才是负责“读取所有记忆”的“怪物程序”！
        // 当它发现档案是空的时候，它就会自动切换到“初始生成”模式！
        await window.refineProfile(charId, false); // <--- 必须是 false！
        
        window.showFeedLoader(false);
        modalAlert(`【${character.name}】的档案已重置并重新生成！`);
        
        openProfileViewer(); // 自动重新打开

      } catch (error) {
        window.showFeedLoader(false);
        modalAlert(`重置失败：${error.message}`);
      }
    }
    // ▲▲▲ End of Fix v4.0 ▲▲▲
    // ▲▲▲ End of Fix ▲▲▲

    // 手动触发档案精炼
    // ▼▼▼ Noir's Fix: 功能3【深度统合】按钮的灵魂注入 ▼▼▼
   // ▼▼▼ Noir's Fix: 功能3【深度统合】按钮的灵魂注入 (最终修复版) ▼▼▼
    async function manualRefineProfile() {
      const activeChat = getActiveChat();
      if (!activeChat || activeChat.type !== 'private') {
          modalAlert('请先进入一个私聊。');
          return;
      }

      const charId = activeChat.participantIds[0];
      if (!charId) return;
      const character = getCharacterById(charId);
      if (!character) return;

      // 哼，提示词也给你改了
      const ok = await modalConfirm(`【功能3：深度统合档案】\n\n确定要立即统合【${character.name}】的档案吗？\n\nAI将【扔掉】旧档案，【重新阅读】所有历史记录，并生成一份【全新的、精炼的】总结。`);
      if (!ok) return;

      try {
        closeProfileViewer(); // 先关掉旧窗口
        window.showFeedLoader(true, '正在执行深度统合...');
        await window.refineProfile(charId, true); // <--- 哼，就是这个 await，它会老实等AI干完活
        window.showFeedLoader(false);
        modalAlert('档案精炼完成！');
        openProfileViewer(); // 重新打开，刷新显示
      } catch (error) {
        window.showFeedLoader(false);
        modalAlert(`精炼失败：${error.message}`);
      }
    }
    // ▲▲▲ End of Fix ▲▲▲
    // ▲▲▲ End of Fix ▲▲▲

    // 在DOM加载完成后，注册事件监听器
    document.addEventListener('DOMContentLoaded', () => {
      // 查看档案按钮
      const showProfileButton = document.getElementById('show-profile-button');
      if (showProfileButton) {
        showProfileButton.addEventListener('click', openProfileViewer);
      }

      // 关闭按钮
      const closeProfileButton = document.getElementById('close-profile-button');
      if (closeProfileButton) {
        closeProfileButton.addEventListener('click', closeProfileViewer);
      }

      // 复制按钮
      const copyProfileButton = document.getElementById('copy-profile-button');
      if (copyProfileButton) {
        copyProfileButton.addEventListener('click', copyProfileContent);
      }

      // 重置按钮
      const resetProfileButton = document.getElementById('reset-profile-button');
     if (resetProfileButton) {
        // 1. 克隆按钮以移除所有旧的监听器 (包括那个会导致误报的)
        const newResetBtn = resetProfileButton.cloneNode(true);
        resetProfileButton.parentNode.replaceChild(newResetBtn, resetProfileButton);
        
        // 2. 重新绑定正确的逻辑 (只保留功能1：重置并生成)
        newResetBtn.addEventListener('click', resetProfile);
        
        console.log("Noir's Fix: 重置按钮监听器已修复，不再冲突。");
      }
      // 立即精炼按钮
      const manualRefineButton = document.getElementById('manual-refine-button');
      if (manualRefineButton) {
        manualRefineButton.addEventListener('click', manualRefineProfile);
      }

      // ▼▼▼ 把这两行加在它们后面！ ▼▼▼
      const confirmRefineBtn = document.getElementById('confirm-refinement-btn');
      if (confirmRefineBtn) {
        confirmRefineBtn.addEventListener('click', confirmRefinement);
      }

      const retryRefineBtn = document.getElementById('retry-refinement-btn');
      if (retryRefineBtn) {
        retryRefineBtn.addEventListener('click', executeProfileRefinement);
      }
      // ▲▲▲ 添加完毕 ▲▲▲

      // 哼，顺便把"关闭"按钮和"背景"也给我改成"结案"！
      // 这样你就跑不掉了！
      const closeProfileBtn = document.getElementById('close-profile-button');
      if (closeProfileBtn) {
        closeProfileBtn.onclick = () => {
          if (state.pendingProfileRefinement) {
            confirmRefinement(); // 正在"审讯"时，点"关闭"就等于"结案"
          } else {
            closeProfileViewer(); // 平时就还是"关闭"
          }
        };
      }
      
      const profileBackdrop = document.getElementById('profile-view-backdrop');
      if (profileBackdrop) {
        profileBackdrop.onclick = () => {
          if (state.pendingProfileRefinement) {
            confirmRefinement(); // 点背景也一样！
          } else {
            closeProfileViewer();
          }
        };
      }
      // ▼▼▼ Noir's Event Listener Cleanup (Anti-Conflict) ▼▼▼
      // 哼，把那些多余的、会导致误触的监听器都给我清理掉。
    
    
    });

    // ▲▲▲ End of Profile Viewer System ▲▲▲

  </script>
  <div id="listen-together-ui" style="display: none;">
    <div class="lt-ui-backdrop"></div>
    <div class="lt-ui-main">
      <div class="lt-ui-header">
        <span id="lt-ui-header-title">正在与 TA 一起听</span>
        <button id="lt-ui-close-btn">×</button>
      </div>
      <div class="lt-ui-content">
        <div class="lt-ui-cover-container">
          <img id="lt-ui-cover-art" src="">
        </div>
        <div class="lt-ui-info">
          <h2 id="lt-ui-song-title">歌曲名称</h2>
          <p id="lt-ui-song-artist">歌手</p>
        </div>
        <div id="lt-ui-lyrics-container">
          <p class="no-lyrics-placeholder">暂无歌词</p>
        </div>
        <div class="lt-ui-controls">
          <button id="lt-ui-change-song-btn" class="lt-ui-control-button" title="切换歌曲">
            <span>♫</span>
            <span class="button-label">换一首</span>
          </button>
          <button id="lt-ui-end-session-btn" class="lt-ui-control-button danger" title="结束听歌">
            <span>⏹</span>
            <span class="button-label">结束</span>
          </button>
        </div>
      </div>
    </div>
  </div>
  <div id="summarize-modal" class="choice-modal">
    <div id="summarize-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content"
      style="padding: 0; width: 95%; max-width: 360px; height: 70%; display: flex; flex-direction: column;">
      <div class="header" style="border-bottom: 1px solid var(--border-color); flex-shrink: 0;">
        <button id="close-summary-button" class="header-button" style="min-width: 50px;">关闭</button>
        <span class="header-title">聊天记录总结</span>
        <button id="copy-summary-button" class="header-button" style="min-width: 50px;">复制</button>
      </div>
      <div class="content" style="flex-grow: 1; padding: 0;">
        <textarea id="summary-textarea" placeholder="AI正在拼命总结中，别催..."></textarea>
      </div>
    </div>
  </div>

  <div id="profile-view-modal" class="choice-modal">
    <div id="profile-view-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content"
      style="padding: 0; width: 95%; max-width: 360px; height: 70%; display: flex; flex-direction: column;">
      <div class="header" style="border-bottom: 1px solid var(--border-color); flex-shrink: 0;">
        <button id="close-profile-button" class="header-button" style="min-width: 50px;">关闭</button>
        <span class="header-title" id="profile-view-title">用户档案</span>
        <button id="copy-profile-button" class="header-button" style="min-width: 50px;">复制</button>
      </div>
      <div class="content" style="flex-grow: 1; padding: 0;">
        <textarea id="profile-textarea" placeholder="加载中..." style="font-family: 'Courier New', monospace; width: 100%; height: 100%; border: none; outline: none; resize: none; padding: 15px; box-sizing: border-box; font-size: 0.9rem; line-height: 1.6;"></textarea>
      </div>

      <div id="refinement-controls-footer" style="padding: 10px; border-top: 1px solid var(--border-color); display: none; gap: 10px;">
        <button id="confirm-refinement-btn" class="form-button primary" style="margin: 0; flex: 1;">哼，就这样吧</button>
        <button id="retry-refinement-btn" class="form-button secondary" style="margin: 0; flex: 1;">重来！</button>
      </div>
      <div id="profile-view-footer" style="padding: 10px; border-top: 1px solid var(--border-color); display: flex; gap: 10px;">
        <button id="reset-profile-button" class="form-button destructive" style="margin: 0; flex: 1;">重置此档案</button>
       <button id="manual-refine-button" class="form-button primary" style="margin: 0; flex: 1;">深度统合档案</button>
      </div>
    </div>
  </div>




  <div id="add-event-modal" class="choice-modal">
    <div id="add-event-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content" style="padding: 20px; width: 90%; max-width: 320px;">
      <h3 id="add-event-modal-title" style="margin-top: 0; text-align: center;">为 YYYY-MM-DD 添加...</h3>
      <div class="input-group">
        <label for="event-content-input">内容</label>
        <input type="text" id="event-content-input" placeholder="要做什么或者是什么日子？">
      </div>
      <div class="input-group">
        <label>类型</label>
        <div style="display: flex; gap: 10px; margin-top: 5px;">
          <input type="radio" id="event-type-todo" name="event-type" value="todo" checked>
          <label for="event-type-todo" style="width: auto;">普通日程</label>
          <input type="radio" id="event-type-important" name="event-type" value="important">
          <label for="event-type-important" style="width: auto;">重要纪念日</label>
        </div>
      </div>
      <div style="display: flex; gap: 10px; margin-top: 20px;">
        <button id="save-event-button" class="form-button primary">保存</button>
        <button id="cancel-event-button" class="form-button secondary">取消</button>
      </div>
    </div>
  </div>

  <div id="edit-replay-modal" class="choice-modal">
    <div id="edit-replay-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content"
      style="padding: 0; width: 95%; max-width: 360px; height: 70%; display: flex; flex-direction: column;">
      <div class="header" style="flex-shrink: 0;">
        <button id="cancel-edit-replay-btn" class="header-button">取消</button>
        <span class="header-title">编辑回放档案</span>
        <button id="save-edit-replay-btn" class="header-button">保存</button>
      </div>
      <div class="content" style="padding: 0; flex-grow: 1;">
        <textarea id="edit-replay-textarea"
          style="width: 100%; height: 100%; border: none; outline: none; resize: none; font-family: 'Courier New', monospace; font-size: 0.9rem; padding: 10px; box-sizing: border-box;"></textarea>
      </div>
    </div>
  </div>

  <div id="summary-preview-modal" class="choice-modal">
    <div id="summary-preview-backdrop" class="choice-modal-backdrop"></div>
    <div class="choice-modal-content" style="padding: 0; width: 95%; max-width: 360px; height: 75%; display: flex; flex-direction: column;">
      <div class="header" style="border-bottom: 1px solid var(--border-color); flex-shrink: 0;">
        <span class="header-title">确认回放摘要</span>
        <div style="width: 50px;"></div> 
      </div>
      <div class="content" style="flex-grow: 1; padding: 0;">
        <textarea id="summary-preview-textarea" style="width: 100%; height: 100%; border: none; outline: none; resize: none; font-family: 'Courier New', monospace; font-size: 0.9rem; padding: 15px; box-sizing: border-box; background: #fdfdfd; color: var(--text-color);"></textarea>
      </div>
      <div style="padding: 15px; border-top: 1px solid var(--border-color); display: flex; gap: 10px; flex-direction: column;">
        <div style="display: flex; gap: 10px;">
            <button id="summary-confirm-btn" class="form-button primary" style="margin: 0; flex: 2;">确认归档</button>
            <button id="summary-reroll-btn" class="form-button secondary" style="margin: 0; flex: 1;">重写</button>
        </div>
        <button id="summary-cancel-btn" class="form-button secondary" style="margin: 0; background: transparent; color: #666; border: none;">暂不结束，返回直播</button>
      </div>
    </div>
  </div>
  <script src="capacitor.js"></script>


</body>

</html>
